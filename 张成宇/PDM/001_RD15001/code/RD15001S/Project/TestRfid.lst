C51 COMPILER V9.52.0.0   TESTRFID                                                          08/18/2015 14:52:37 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TESTRFID
OBJECT MODULE PLACED IN .\TestRfid.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\TestRfid.c LARGE BROWSE INCDIR(..\code) DEBUG OBJECTEXTEND PRINT
                    -(.\TestRfid.lst) OBJECT(.\TestRfid.obj)

line level    source

   1          #include "app_rfid.h"
   2          #include "uart.h"
   3          #include "Init.h"
   4          #include "stdlib.h"
   5          #define TIMELENGTH  11
   6          #define TAGLENGTH  4
   7          #define ENWIRONMENTLENGTH 35
   8          extern uchar const code g_szGetCurrentProgram[5];
   9          extern uchar const code g_szBootFirmware[5];
  10          extern uchar const code g_szSetFrequencyChannel[6];
  11          extern uchar const code g_szSetProtocol[7];
  12          extern uchar const code g_szSetAntenna[8];
  13          extern uchar const code g_szClearBuffer[5];
  14          extern uchar const code g_szSearchTag[10];
  15          extern uchar const code g_szGetTagdata[8];
  16          
  17          extern uchar const code g_szGetTagIddata[8];
  18          extern uchar const code g_szPrimeContinueReading[8];
  19          extern uchar const code g_szContinueReading[21];
  20          extern uchar const code g_szEnhanceDistance[7];
  21          extern uchar const code g_szEnhanceSpeed1[8];
  22          extern uchar const code g_szEnhanceSpeed2[8];
  23          extern uchar const code g_szEnhanceSpeed3[8];
  24          extern uchar const code g_szEnhanceSpeed4[8];
  25          extern uchar const code g_szEnhanceSpeed5[8];
  26          extern uchar const code g_szEnhanceSpeed6[9];
  27          extern uchar const code g_szContinueReadingEx[21];
  28          extern uchar const code g_szStopReading[8];
  29          extern uchar const code g_szOnceMode[8];
  30          
  31          extern unsigned char xdata Sensor_Data[5];
  32          STATIC BOOL AnalyzeCmd(P_U8 pBuf, U16 u16Count)
  33          {
  34   1          BOOL xdata bRet = FALSE;
  35   1          U8 xdata szResponse[3] = {0x00, 0x90, 0x00};
  36   1      
  37   1          if(u16Count == 3)
  38   1          {
  39   2              if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x01) && (*(pBuf + 2) == 0xAA))//关机指令
  40   2              {
  41   3                  bRet = TRUE;
  42   3                  RFID_SHUTDOWN();
  43   3                  szResponse[0] = 1;
  44   3                  Uart1_Tx(szResponse, 3);
  45   3                  
  46   3              }       
  47   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x02) && (*(pBuf + 2) == 0xAA))//开机指令
  48   2              {
  49   3                  bRet = TRUE;
  50   3                  RFID_UNSHUTDOWN();
  51   3                  szResponse[0] = 2;
  52   3                  Uart1_Tx(szResponse, 3);
  53   3                  
  54   3              }
C51 COMPILER V9.52.0.0   TESTRFID                                                          08/18/2015 14:52:37 PAGE 2   

  55   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x03) && (*(pBuf + 2) == 0xAA))//读取系统状态
  56   2              {
  57   3                  bRet = TRUE;
  58   3                  szResponse[0] = 3;
  59   3                  Uart1_Tx(szResponse, 3);
  60   3              }
  61   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x04) && (*(pBuf + 2) == 0xAA))//测试指令
  62   2              {
  63   3                  bRet = TRUE;
  64   3                  szResponse[0] = 4;
  65   3                  Uart1_Tx(szResponse, 3);
  66   3              }
  67   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x05) && (*(pBuf + 2) == 0xAA))//自动指令
  68   2              {
  69   3                  bRet = TRUE;
  70   3                  szResponse[0] = 5;
  71   3                  Uart1_Tx(szResponse, 3);
  72   3                             
  73   3                  while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
  74   3                  
  75   3                  while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
  76   3                  
  77   3              }
  78   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x06) && (*(pBuf + 2) == 0xAA))//自动唯一ID指令
  79   2              {
  80   3                  bRet = TRUE;
  81   3                  
  82   3                  szResponse[0] = 6;
  83   3                  
  84   3                  Uart1_Tx(szResponse, 3);
  85   3                  
  86   3                  while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
  87   3                  
  88   3                  while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
  89   3              }
  90   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x07) && (*(pBuf + 2) == 0xAA))//增强速度指令
  91   2              {
  92   3                  bRet = TRUE;
  93   3                  
  94   3                  szResponse[0] = 7;
  95   3                  
  96   3                  Uart1_Tx(szResponse, 3);
  97   3                  
  98   3                  while(SendAndWaitRfidDataProc(ENHANCESPEED1) == FALSE);
  99   3                  
 100   3                  while(SendAndWaitRfidDataProc(ENHANCESPEED2) == FALSE);
 101   3                  
 102   3                  while(SendAndWaitRfidDataProc(ENHANCESPEED3) == FALSE);
 103   3                  
 104   3                  while(SendAndWaitRfidDataProc(ENHANCESPEED4) == FALSE);
 105   3                  
 106   3                  while(SendAndWaitRfidDataProc(ENHANCESPEED5) == FALSE);
 107   3                  
 108   3                  while(SendAndWaitRfidDataProc(ENHANCESPEED6) == FALSE);
 109   3                  
 110   3                  while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
 111   3                  
 112   3                  while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
 113   3              }
 114   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x08) && (*(pBuf + 2) == 0xAA))//增强距离指令 
 115   2              {
 116   3                  bRet = TRUE;
C51 COMPILER V9.52.0.0   TESTRFID                                                          08/18/2015 14:52:37 PAGE 3   

 117   3                  
 118   3                  szResponse[0] = 8;
 119   3                  
 120   3                  Uart1_Tx(szResponse, 3);
 121   3                  
 122   3                  while(SendAndWaitRfidDataProc(ENHANCEDISTANCE) == FALSE);
 123   3                  
 124   3                  while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
 125   3                  
 126   3                  while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
 127   3              }
 128   2              else if((*pBuf == 0xAA) && (*(pBuf + 1) == 0x09) && (*(pBuf + 2) == 0xAA))//检索特定标签
 129   2              {
 130   3                  bRet = TRUE;
 131   3                  
 132   3                  szResponse[0] = 9;
 133   3                  
 134   3                  Uart1_Tx(szResponse, 3);
 135   3                  
 136   3                  while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
 137   3                  
 138   3                  while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
 139   3              }
 140   2              else if((*pBuf == 0xfe) && (*(pBuf + 1) == 0xfe) && (*(pBuf + 2)< 35))//开机指令
 141   2              {
 142   3                  bRet = TRUE;
 143   3      
 144   3                  
 145   3                  while(SendAndWaitRfidDataProc(STOPREADING) == FALSE);
 146   3                  
 147   3                  while(SendAndWaitRfidDataProc(ONCEMODE) == FALSE);
 148   3      
 149   3                      while(SendAndWaitRfidDataProcEnhance((*(pBuf + 2) * 100)) == FALSE);     //调整功率
 150   3      
 151   3                      while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
 152   3                      
 153   3                      while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
 154   3                  szResponse[0] = 0xef;
 155   3                  szResponse[1] = 0xfe;
 156   3                  szResponse[2] = *(pBuf + 2);
 157   3                  Uart1_Tx(szResponse, 3);
 158   3                  
 159   3              }
 160   2          }
 161   1          return bRet;
 162   1          
 163   1      }
 164          
 165          
 166          STATIC VOID GetCurrentTimeString(U8 *g_pData)
 167          {
 168   1          U32 xdata u32Tick;
 169   1          u32Tick = GetTickCount();
 170   1          *(g_pData) = '#';
 171   1          *(g_pData + 1) = (u32Tick/1000000000)+'0' ;
 172   1          *(g_pData + 2) = ((u32Tick/100000000)%10)+'0' ;
 173   1          *(g_pData + 3) = ((u32Tick/10000000)%10)+'0' ;
 174   1          *(g_pData + 4) = ((u32Tick/1000000)%10)+'0' ;
 175   1          *(g_pData + 5) = ((u32Tick/100000)%10)+'0' ;
 176   1          *(g_pData + 6) = ((u32Tick/10000)%10)+'0' ;
 177   1          *(g_pData + 7) = ((u32Tick/1000)%10)+'0' ;
 178   1          *(g_pData + 8) = ((u32Tick/100)%10)+'0' ;
C51 COMPILER V9.52.0.0   TESTRFID                                                          08/18/2015 14:52:37 PAGE 4   

 179   1          *(g_pData + 9) = ((u32Tick/10)%10)+'0' ;
 180   1          *(g_pData + 10) = (u32Tick%10)+'0' ;
 181   1      
 182   1      }
 183          
 184          STATIC VOID GetCurrentTagString(U8 *g_pData, U8 u8Value)
 185          {
 186   1          *(g_pData) = '#';
 187   1          *(g_pData + 1) = ((u8Value/100)%10)+'0' ;
 188   1          *(g_pData + 2) = ((u8Value/10)%10)+'0' ;
 189   1          *(g_pData + 3) = (u8Value%10)+'0' ;
 190   1      
 191   1      }
 192          
 193          STATIC VOID GetCurrentEnwironment(U8 *g_pData)
 194          {
 195   1              float xdata Temperature, xdata Humidity;
 196   1              U8 u8AM2305_Check;
 197   1              u8AM2305_Check = Sensor_Data[0] + Sensor_Data[1] + Sensor_Data[2] + Sensor_Data[3];
 198   1              if(u8AM2305_Check == Sensor_Data[4])
 199   1              {
 200   2                      Humidity = (Sensor_Data[0]*256 + Sensor_Data[1])/10.0;
 201   2                      Temperature = (Sensor_Data[2]*256 + Sensor_Data[3])/10.0;
 202   2              }
 203   1              else
 204   1              {
 205   2                      Humidity = 0;
 206   2                      Temperature = 0;
 207   2              }
 208   1              sprintf(g_pData, "#Humidity = %3.1f#Temperature = %3.1f",Humidity,Temperature);
 209   1      
 210   1      
 211   1      }
 212          
 213          STATIC VOID RunRfidProc(VOID)
 214          {
 215   1          while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
 216   1      
 217   1          while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
 218   1      }
 219          
 220          STATIC VOID StopRfidProc(VOID)
 221          {
 222   1          U8 xdata u8Cnt = 0;
 223   1          BOOL xdata bRet;
 224   1          do
 225   1          {
 226   2              bRet = SendAndWaitRfidDataProc(STOPREADING);
 227   2              u8Cnt++;
 228   2          }while((bRet == FALSE) && (u8Cnt < 10));
 229   1          if(u8Cnt == 10)
 230   1          {
 231   2              EnterException(ERR_RFID_STOP);
 232   2          }
 233   1      
 234   1      
 235   1      }
 236          
 237          VOID TestRFID(VOID)
 238          {
 239   1          U16 xdata u16Cnt, xdata u16Length;
 240   1          
C51 COMPILER V9.52.0.0   TESTRFID                                                          08/18/2015 14:52:37 PAGE 5   

 241   1          U8 xdata szData[RFIDDATACOUNT], xdata szTestTest[RFIDDATACOUNT], xdata szTimeBuf[TIMELENGTH], xdata sz
             -TagBuf[TAGLENGTH], xdata szOutputBuf[TIMELENGTH + TAGLENGTH + ENWIRONMENTLENGTH+ 2], xdata szEnwironmentBuf[ENWIRONMENTL
             -ENGTH];
 242   1              
 243   1          U32 u32Tick;
 244   1              RfidInitProc();
 245   1              
 246   1              while(SendAndWaitRfidDataProc(ONCEMODE) == FALSE);
 247   1      
 248   1              while(SendAndWaitRfidDataProcEnhance(2500) == FALSE);    //调整功率
 249   1      
 250   1              while(SendAndWaitRfidDataProc(PRIMECONTINUEREADING) == FALSE);
 251   1              
 252   1              while(SendAndWaitRfidDataProc(CONTINUEREADING) == FALSE);
 253   1      
 254   1          u32Tick = GetTickCount();
 255   1      
 256   1              while(1)
 257   1              {
 258   2              if((GetTickCount() - u32Tick) > 3000)
 259   2              {
 260   3                  u32Tick = GetTickCount();
 261   3                  Am2305_Read();
*** WARNING C206 IN LINE 261 OF ..\code\TestRfid.c: 'Am2305_Read': missing function-prototype
 262   3              }
 263   2              
 264   2                      ReceiveUsart1Data(szData, &u16Length);
 265   2                      if(u16Length)
 266   2                      {
 267   3                              memcpy(szTestTest, szData, u16Length);
 268   3                  if(AnalyzeCmd(szTestTest, u16Length) == FALSE)
 269   3                      Uart2_Tx(szTestTest, u16Length);
 270   3                      }
 271   2      
 272   2                      ReceiveUsart2Data(szData, &u16Length);
 273   2                      if(u16Length)
 274   2                      {
 275   3                              memcpy(szTestTest, szData, u16Length);
 276   3                  for(u16Cnt = 0; u16Cnt < u16Length; u16Cnt++)
 277   3                  {
 278   4                      if((szTestTest[u16Cnt] == 0xff) && (szTestTest[u16Cnt + 1] == 0x18) && (szTestTest[u16Cnt 
             -+ 2] == 0x22) )               
 279   4                      {
 280   5                          if(HandleTag(szTestTest + u16Cnt + 15) == TRUE)
 281   5                          {
 282   6                              GetCurrentTagString(szTagBuf, g_u8TagOffset);
 283   6                              GetCurrentTimeString(szTimeBuf);
 284   6                                                      GetCurrentEnwironment(szEnwironmentBuf);
 285   6                              memcpy(szOutputBuf, szTimeBuf, TIMELENGTH);
 286   6                              memcpy(szOutputBuf + TIMELENGTH, szTagBuf, TAGLENGTH);
 287   6                                                      memcpy(szOutputBuf + TIMELENGTH + TAGLENGTH, szEnwironmentBuf, ENWIRONMENTLENGTH);
 288   6                              szOutputBuf[TIMELENGTH + TAGLENGTH + ENWIRONMENTLENGTH] = '\r';
 289   6                              szOutputBuf[TIMELENGTH + TAGLENGTH + ENWIRONMENTLENGTH+ 1] = '\n';
 290   6                              Uart1_Tx(szOutputBuf, TIMELENGTH + TAGLENGTH + ENWIRONMENTLENGTH + 2);
 291   6                          }
 292   5                          
 293   5                      }
 294   4                      
 295   4                  }
 296   3                      }
 297   2      
 298   2      
C51 COMPILER V9.52.0.0   TESTRFID                                                          08/18/2015 14:52:37 PAGE 6   

 299   2              }
 300   1                   
 301   1      }
 302          
 303          VOID TestCalcuate(VOID)
 304          {
 305   1          U16 xdata u16Count, xdata u16Value;
 306   1          U8 xdata szData[RFIDDATACOUNT] = {0};
 307   1          Uart1_Tx_End("RFID CRC Please input :\r\n");
 308   1          while(1)
 309   1              {
 310   2                      ReceiveUsart1Data(szData, &u16Count);
 311   2                      if(u16Count)
 312   2                      {
 313   3                  u16Value = CalculateRfidCrc(szData, u16Count);
 314   3                              sprintf(szData, "CRC = %x\r\n", u16Value);
 315   3                  Uart1_Tx_End(szData);
 316   3                      }
 317   2          }        
 318   1                      
 319   1      }
 320          
 321          
 322          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2342    ----
   CONSTANT SIZE    =    128    ----
   XDATA SIZE       =   ----     292
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE APP_RFID
OBJECT MODULE PLACED IN .\app_rfid.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\app_rfid.c LARGE BROWSE INCDIR(..\code) DEBUG OBJECTEXTEND PRINT
                    -(.\app_rfid.lst) OBJECT(.\app_rfid.obj)

line level    source

   1          #include "app_rfid.h"
   2          #include "uart.h"
   3          #include "system.h"
   4          #include "Init.h"
   5          
   6          //uchar xdata g_szGetCurrentProgram[5] =      {0xFF, 0x00, 0x0C, 0x1D, 0x03};
   7          //uchar xdata g_szBootFirmware[5] =           {0xFF, 0x00, 0x04, 0x1D, 0x0B};
   8          //uchar xdata g_szSetFrequencyChannel[6] =    {0xFF, 0x01, 0x97, 0x06, 0x4B, 0xBB};//return FF 00 97 00 00
             - 77 9E
   9          //uchar xdata g_szSetProtocol[7] =            {0xFF, 0x02, 0x93, 0x00, 0x05, 0x51, 0x7D};
  10          //uchar xdata g_szSetAntenna[8] =             {0xFF, 0x03, 0x91, 0x02, 0x01, 0x01, 0x42, 0xC5};//return FF
             - 00 91 00 00 17 58
  11          //uchar xdata g_szClearBuffer[5] =            {0xFF, 0x00, 0x2A, 0x1D, 0x25};//return FF 00 2A 00 00 01 E8
  12          //uchar xdata g_szSearchTag[10] =              {0xFF, 0x05, 0x22, 0x00, 0x00, 0x13, 0x01, 0xF4, 0x2B, 0x19
             -};//FF 07 22 00 00 00 00 13 00 00 00 01 8B 58
  13          //uchar xdata g_szGetTagdata[8] =             {0xFF, 0x03, 0x29, 0x01, 0xFF, 0x00, 0x1B, 0x03};
  14          //uchar xdata g_szGetTagIddata[8] =           {0xFF, 0x03, 0x29, 0x00, 0x00, 0x00, 0xF4, 0x22};//»ñÈ¡Î¨Ò»I
             -D
  15          //uchar xdata g_szPrimeContinueReading[8] =   {0xFF, 0x03, 0x9A, 0x01, 0x0C, 0x00, 0xA3, 0x5D};//²»¶Ï»ñÈ¡Ê
             -ý¾Ý
  16          //uchar xdata g_szContinueReading[21] =        {0xFF, 0x10, 0x2F, 0x00, 0x00, 0x01, 0x22, 0x00, 0x00, 0x05
             -, 0x07, 0x22, 0x10, 0x00, 0x1B, 0x03, 0xE8, 0x00, 0x00, 0xDC, 0xD4};//²»¶Ï»ñÈ¡Êý¾Ý£¬ÇÒÎªÎ¨Ò»ID
  17          //uchar xdata g_szEnhanceDistance[7] =        {0xFF, 0x02, 0x92, 0x0b, 0xb8, 0x4a, 0xe1};//ÐèÒªÔ¶¾àÀëÊ±²ÉÓ
             -Ã¸ÃÖ¸Áî
  18          //uchar xdata g_szEnhanceSpeed1[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x02, 0x02, 0xde, 0xea};//Ôö¿ìËÙ¶ÈÖ
             -¸Áî1
  19          //uchar xdata g_szEnhanceSpeed2[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x12, 0x00, 0xce, 0xe8};//Ôö¿ìËÙ¶ÈÖ
             -¸Áî2
  20          //uchar xdata g_szEnhanceSpeed3[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x10, 0x00, 0xcc, 0xe8};//Ôö¿ìËÙ¶ÈÖ
             -¸Áî3
  21          //uchar xdata g_szEnhanceSpeed4[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x11, 0x00, 0xcd, 0xe8};//Ôö¿ìËÙ¶ÈÖ
             -¸Áî4
  22          //uchar xdata g_szEnhanceSpeed5[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x00, 0x00, 0xdc, 0xe8};//Ôö¿ìËÙ¶ÈÖ
             -¸Áî5
  23          //uchar xdata g_szEnhanceSpeed6[9] =          {0xFF, 0x04, 0x9b, 0x05, 0x01, 0x00, 0x00, 0xa3, 0xfd};//Ôö¿
             -ìËÙ¶ÈÖ¸Áî5
  24          //uchar xdata g_szContinueReadingEx[21] =      {0xFF, 0x10, 0x2F, 0x00, 0x00, 0x01, 0x22, 0x00, 0x00, 0x05
             -, 0x07, 0x22, 0x10, 0x00, 0x1B, 0x03, 0xE8, 0x01, 0xFF, 0xDD, 0x2B};//²»¶Ï»ñÈ¡Êý¾Ý£¬ÇÒ²»½ö½öÖ»ÓÐIDÊý¾Ý
  25          //uchar xdata g_szStopReading[8] =            {0xFF, 0x03, 0x2F, 0x00, 0x00, 0x02, 0x5E, 0x86};//FF 01 2F 
             -00 00 02 30 E6
  26          uchar const code g_szGetCurrentProgram[5] =      {0xFF, 0x00, 0x0C, 0x1D, 0x03};
  27          uchar const code g_szBootFirmware[5] =           {0xFF, 0x00, 0x04, 0x1D, 0x0B};
  28          uchar const code g_szSetFrequencyChannel[6] =    {0xFF, 0x01, 0x97, 0x06, 0x4B, 0xBB};//return FF 00 97 00
             - 00 77 9E
  29          uchar const code g_szSetProtocol[7] =            {0xFF, 0x02, 0x93, 0x00, 0x05, 0x51, 0x7D};
  30          uchar const code g_szSetAntenna[8] =             {0xFF, 0x03, 0x91, 0x02, 0x01, 0x01, 0x42, 0xC5};//return
             - FF 00 91 00 00 17 58
  31          uchar const code g_szClearBuffer[5] =            {0xFF, 0x00, 0x2A, 0x1D, 0x25};//return FF 00 2A 00 00 01
             - E8
  32          uchar const code g_szSearchTag[10] =              {0xFF, 0x05, 0x22, 0x00, 0x00, 0x13, 0x01, 0xF4, 0x2B, 0
             -x19};//FF 07 22 00 00 00 00 13 00 00 00 01 8B 58
  33          uchar const code g_szGetTagdata[8] =             {0xFF, 0x03, 0x29, 0x01, 0xFF, 0x00, 0x1B, 0x03};
  34          uchar const code g_szGetTagIddata[8] =           {0xFF, 0x03, 0x29, 0x00, 0x00, 0x00, 0xF4, 0x22};//»ñÈ¡Î¨
             -Ò»ID
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 2   

  35          uchar const code g_szPrimeContinueReading[8] =   {0xFF, 0x03, 0x9A, 0x01, 0x0C, 0x00, 0xA3, 0x5D};//²»¶Ï»ñ
             -È¡Êý¾Ý
  36          uchar const code g_szContinueReading[21] =        {0xFF, 0x10, 0x2F, 0x00, 0x00, 0x01, 0x22, 0x00, 0x00, 0
             -x05, 0x07, 0x22, 0x10, 0x00, 0x1B, 0x03, 0xE8, 0x00, 0x00, 0xDC, 0xD4};//²»¶Ï»ñÈ¡Êý¾Ý£¬ÇÒÎªÎ¨Ò»ID
  37          uchar const code g_szEnhanceDistance[7] =        {0xFF, 0x02, 0x92, 0x0b, 0xb8, 0x4a, 0xe1};//ÐèÒªÔ¶¾àÀëÊ±
             -²ÉÓÃ¸ÃÖ¸Áî
  38          uchar const code g_szEnhanceSpeed1[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x02, 0x02, 0xde, 0xea};//Ôö¿ìËÙ
             -¶ÈÖ¸Áî1
  39          uchar const code g_szEnhanceSpeed2[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x12, 0x00, 0xce, 0xe8};//Ôö¿ìËÙ
             -¶ÈÖ¸Áî2
  40          uchar const code g_szEnhanceSpeed3[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x10, 0x00, 0xcc, 0xe8};//Ôö¿ìËÙ
             -¶ÈÖ¸Áî3
  41          uchar const code g_szEnhanceSpeed4[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x11, 0x00, 0xcd, 0xe8};//Ôö¿ìËÙ
             -¶ÈÖ¸Áî4
  42          uchar const code g_szEnhanceSpeed5[8] =          {0xFF, 0x03, 0x9b, 0x05, 0x00, 0x00, 0xdc, 0xe8};//Ôö¿ìËÙ
             -¶ÈÖ¸Áî5
  43          uchar const code g_szEnhanceSpeed6[9] =          {0xFF, 0x04, 0x9b, 0x05, 0x01, 0x00, 0x00, 0xa3, 0xfd};//
             -Ôö¿ìËÙ¶ÈÖ¸Áî5
  44          uchar const code g_szContinueReadingEx[21] =      {0xFF, 0x10, 0x2F, 0x00, 0x00, 0x01, 0x22, 0x00, 0x00, 0
             -x05, 0x07, 0x22, 0x10, 0x00, 0x1B, 0x03, 0xE8, 0x01, 0xFF, 0xDD, 0x2B};//²»¶Ï»ñÈ¡Êý¾Ý£¬ÇÒ²»½ö½öÖ»ÓÐIDÊý¾Ý
  45          uchar const code g_szStopReading[8] =            {0xFF, 0x03, 0x2F, 0x00, 0x00, 0x02, 0x5E, 0x86};//FF 01 
             -2F 00 00 02 30 E6
  46          uchar const code g_szOnceMode[8] = {0xFF, 0x03, 0x9B, 0x05, 0x00, 0x01, 0xDC, 0xE9};
  47          //const U8 g_szTag[13][14] =
  48          //{
  49          //    {0x10 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x11 , 0x03 , 0x04 , 0x00 , 0x03 , 0x24 , 0x1E , 0xB9},
  50          //    {0xE2 , 0x00 , 0x20 , 0x75 , 0x58 , 0x11 , 0x02 , 0x53 , 0x23 , 0x90 , 0x1E , 0x43 , 0x51 , 0x68},
  51          //    {0x10 , 0x05 , 0x00 , 0x23 , 0x00 , 0x00 , 0x20 , 0x14 , 0x05 , 0x10 , 0x04 , 0x65 , 0x8E , 0xFE},
  52          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x27 , 0x43 , 0xAF , 0x37},
  53          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x29 , 0x51 , 0xBE , 0x4B},
  54          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x24 , 0x56 , 0xB8 , 0xF0},
  55          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x28 , 0x87 , 0x26 , 0xC1},
  56          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x15 , 0x14 , 0x11 , 0xB2 , 0x76},
  57          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x23 , 0x70 , 0x65 , 0xC3},
  58          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x25 , 0x77 , 0xBF , 0x82},
  59          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x25 , 0x11 , 0xB3 , 0xE2},
  60          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x26 , 0x22 , 0xE0 , 0x81},
  61          //    {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x23 , 0x78 , 0xE4 , 0xCB}
  62          // 
  63          //};
  64          
  65          uchar const g_szTag[17][14] =
  66          {
  67              {0x10 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x11 , 0x03 , 0x04 , 0x00 , 0x03 , 0x24 , 0x1E , 0xB9},
  68              {0xE2 , 0x00 , 0x20 , 0x75 , 0x58 , 0x11 , 0x02 , 0x53 , 0x23 , 0x90 , 0x1E , 0x43 , 0x51 , 0x68},
  69              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x28 , 0x12 , 0xF5 , 0xDD},
  70              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x25 , 0x42 , 0xD9 , 0x74},
  71              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x25 , 0x06 , 0xD1 , 0x34},
  72              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x26 , 0x35 , 0x82 , 0x57},
  73              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x24 , 0x57 , 0xA8 , 0xD1},
  74              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x25 , 0x21 , 0x85 , 0xB1},   
  75              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x25 , 0x66 , 0xBD , 0x92},   
  76              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x26 , 0x08 , 0x65 , 0xA9}, 
  77              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x25 , 0x14 , 0xE3 , 0x47}, 
  78              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x24 , 0x18 , 0x11 , 0xFA},
  79              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x31 , 0x57 , 0x54 , 0x57},  
  80              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x24 , 0x11 , 0x80 , 0xD3},   
  81              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x24 , 0x77 , 0x8C , 0xB3},
  82              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x24 , 0x31 , 0xA4 , 0xB1},
  83              {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 0x14 , 0x23 , 0x39 , 0xBC , 0x2E},
  84          };
  85          
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 3   

  86          
  87          
  88          //const U8 g_szTag1[] =                   {0x10 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x11 , 0x03 , 0x04 , 
             -0x00 , 0x03 , 0x24 , 0x1E , 0xB9};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 00 00 00 00 20 11 03 04 00 03 24 1E 
             -B9 63 94
  89          //const U8 g_szTag2[] =                   {0xE2 , 0x00 , 0x20 , 0x75 , 0x58 , 0x11 , 0x02 , 0x53 , 0x23 , 
             -0x90 , 0x1E , 0x43 , 0x51 , 0x68};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 E2 00 20 75 58 11 02 53 23 90 1E 43 51 
             -68 63 94
  90          //const U8 g_szTag3[] =                   {0x10 , 0x05 , 0x00 , 0x23 , 0x00 , 0x00 , 0x20 , 0x14 , 0x05 , 
             -0x10 , 0x04 , 0x65 , 0x8E , 0xFE};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 23 00 00 20 14 05 10 04 65 8E 
             -FE 63 94
  91          //const U8 g_szTag4[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 
             -0x14 , 0x27 , 0x43 , 0xAF , 0x37};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 27 43 AF 
             -37 63 94
  92          //const U8 g_szTag5[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 
             -0x14 , 0x29 , 0x51 , 0xBE , 0x4B};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 29 51 BE 
             -4B 63 94
  93          //const U8 g_szTag6[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 
             -0x14 , 0x24 , 0x56 , 0xB8 , 0xF0};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 24 56 B8 
             -F0 63 94
  94          //const U8 g_szTag7[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 
             -0x14 , 0x28 , 0x87 , 0x26 , 0xC1};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 28 87 26 
             -C1 63 94
  95          //const U8 g_szTag8[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 
             -0x15 , 0x14 , 0x11 , 0xB2 , 0x76};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 15 14 11 B2 
             -76 63 94
  96          //const U8 g_szTag9[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 , 
             -0x14 , 0x23 , 0x70 , 0x65 , 0xC3};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 23 70 65 
             -C3 63 94
  97          //const U8 g_szTag10[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 ,
             - 0x14 , 0x25 , 0x77 , 0xBF , 0x82};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 25 77 BF
             - 82 63 94
  98          //const U8 g_szTag11[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 ,
             - 0x14 , 0x25 , 0x11 , 0xB3 , 0xE2};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 25 11 B3
             - E2 63 94
  99          //const U8 g_szTag12[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 ,
             - 0x14 , 0x26 , 0x22 , 0xE0 , 0x81};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 26 22 E0
             - 81 63 94
 100          //const U8 g_szTag13[] =                   {0x10 , 0x05 , 0x00 , 0x00 , 0x00 , 0x00 , 0x20 , 0x15 , 0x01 ,
             - 0x14 , 0x23 , 0x78 , 0xE4 , 0xCB};//FF 18 22 00 00 10 00 1B 00 00 01 00 80 30 00 10 05 00 00 00 00 20 15 01 14 23 78 E4
             - CB 63 94
 101          
 102          #define TAG_NUMBER  40
 103          STATIC U32 xdata g_u32TagCrcData[TAG_NUMBER] = {0};
 104          STATIC U8 xdata g_u8TagCount = 0;
 105          U8 xdata g_u8TagOffset = 0;
 106          
 107          CRfidVar xdata g_cRfidVar = {0};
 108          
 109          STATIC U16 const crctable[] = 
 110          {
 111              0x0000, 0x1021, 0x2042, 0x3063,
 112              0x4084, 0x50a5, 0x60c6, 0x70e7,
 113              0x8108, 0x9129, 0xa14a, 0xb16b,
 114              0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
 115          };
 116          
 117          VOID GetCmdProc(U8 cCmdType, U8 *pData, U8 *pCount)
 118          {
 119   1          switch(cCmdType)
 120   1          {
 121   2              case GETCURRENTPROGRAM:
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 4   

 122   2                  *pCount = sizeof(g_szGetCurrentProgram);
 123   2                  memcpy(pData, g_szGetCurrentProgram, *pCount);
 124   2                  break;
 125   2              case BOOTFIRMWARE:
 126   2                  *pCount = sizeof(g_szBootFirmware);
 127   2                  memcpy(pData, g_szBootFirmware, *pCount);
 128   2                  break;
 129   2              case SETFREQUENCYCHANNEL:
 130   2                  *pCount = sizeof(g_szSetFrequencyChannel);
 131   2                  memcpy(pData, g_szSetFrequencyChannel, *pCount);
 132   2                  break;
 133   2              case SETPROTOCOL:
 134   2                  *pCount = sizeof(g_szSetProtocol);
 135   2                  memcpy(pData, g_szSetProtocol, *pCount);
 136   2                  break;
 137   2              case SETANTENNA:
 138   2                  *pCount = sizeof(g_szSetAntenna);
 139   2                  memcpy(pData, g_szSetAntenna, *pCount);
 140   2                  break;
 141   2              case CLEARBUFFER:
 142   2                  *pCount = sizeof(g_szClearBuffer);
 143   2                  memcpy(pData, g_szClearBuffer, *pCount);
 144   2                  break;
 145   2              case SEARCHTAG:
 146   2                  *pCount = sizeof(g_szSearchTag);
 147   2                  memcpy(pData, g_szSearchTag, *pCount);
 148   2                  break;
 149   2              case GETTAGDATA:
 150   2                  *pCount = sizeof(g_szGetTagdata);
 151   2                  memcpy(pData, g_szGetTagdata, *pCount);
 152   2                  break;
 153   2              case GETTAGDATAId:
 154   2                  *pCount = sizeof(g_szGetTagIddata);
 155   2                  memcpy(pData, g_szGetTagIddata, *pCount);
 156   2                  break;
 157   2              case PRIMECONTINUEREADING:
 158   2                  *pCount = sizeof(g_szPrimeContinueReading);
 159   2                  memcpy(pData, g_szPrimeContinueReading, *pCount);
 160   2                  break;
 161   2              case CONTINUEREADING:
 162   2                  *pCount = sizeof(g_szContinueReading);
 163   2                  memcpy(pData, g_szContinueReading, *pCount);
 164   2                  break;
 165   2              case ENHANCEDISTANCE:
 166   2                  *pCount = sizeof(g_szEnhanceDistance);
 167   2                  memcpy(pData, g_szEnhanceDistance, *pCount);
 168   2                  break;
 169   2              case ENHANCESPEED1:
 170   2                  *pCount = sizeof(g_szEnhanceSpeed1);
 171   2                  memcpy(pData, g_szEnhanceSpeed1, *pCount);
 172   2                  break;
 173   2              case ENHANCESPEED2:
 174   2                  *pCount = sizeof(g_szEnhanceSpeed2);
 175   2                  memcpy(pData, g_szEnhanceSpeed2, *pCount);
 176   2                  break;
 177   2              case ENHANCESPEED3:
 178   2                  *pCount = sizeof(g_szEnhanceSpeed3);
 179   2                  memcpy(pData, g_szEnhanceSpeed3, *pCount);
 180   2                  break;
 181   2              case ENHANCESPEED4:
 182   2                  *pCount = sizeof(g_szEnhanceSpeed4);
 183   2                  memcpy(pData, g_szEnhanceSpeed4, *pCount);
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 5   

 184   2                  break;
 185   2              case ENHANCESPEED5:
 186   2                  *pCount = sizeof(g_szEnhanceSpeed5);
 187   2                  memcpy(pData, g_szEnhanceSpeed5, *pCount);
 188   2                  break;
 189   2              case ENHANCESPEED6:
 190   2                  *pCount = sizeof(g_szEnhanceSpeed6);
 191   2                  memcpy(pData, g_szEnhanceSpeed6, *pCount);
 192   2                  break;
 193   2              case CONTINUEREADINGEX:
 194   2                  *pCount = sizeof(g_szContinueReadingEx);
 195   2                  memcpy(pData, g_szContinueReadingEx, *pCount);
 196   2                  break;
 197   2              case STOPREADING:
 198   2                  *pCount = sizeof(g_szStopReading);
 199   2                  memcpy(pData, g_szStopReading, *pCount);
 200   2                  break;             
 201   2                      case ONCEMODE:
 202   2                  *pCount = sizeof(g_szOnceMode);
 203   2                  memcpy(pData, g_szOnceMode, *pCount);
 204   2                  break;            
 205   2              default :
 206   2                  break;
 207   2          }
 208   1      }
 209          
 210          
 211          
 212          STATIC VOID ReadRfidStateProc(VOID)   
 213          {
 214   1          if(READ_RFID_RESET())
 215   1          {
 216   2              g_cRfidVar.u8RfidState = BOOTLOADER_RUNNING;        
 217   2          }
 218   1          else
 219   1          {
 220   2              g_cRfidVar.u8RfidState = APPLICTATION_RUNNING;
 221   2          }
 222   1      }    
 223          
 224          
 225          BOOL CompareTag(U8 *pBuf)
 226          {
 227   1          U8 xdata u8Count;
 228   1          BOOL xdata bRet = FALSE;
 229   1      
 230   1          for(u8Count = 0;u8Count < 17; u8Count++)
 231   1          {
 232   2              if(memcmp(g_szTag[u8Count], pBuf, 14) == 0)
 233   2              {
 234   3                  g_cRfidVar.u8Tag = u8Count + 1;
 235   3                  bRet = TRUE;
 236   3                  break;
 237   3              }
 238   2          }
 239   1          return bRet;
 240   1      }
 241          U16 CalculateRfidCrc(U8 *u8Buf, U16 len)
 242          {
 243   1      
 244   1          U16 xdata crc;
 245   1          int xdata i;
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 6   

 246   1      
 247   1          crc = 0xffff;
 248   1      
 249   1          for (i = 0; i < len ; i++)
 250   1          {
 251   2              crc = ((crc << 4) | (u8Buf[i] >> 4))  ^ crctable[crc >> 12];
 252   2              crc = ((crc << 4) | (u8Buf[i] & 0xf)) ^ crctable[crc >> 12];
 253   2          }
 254   1      
 255   1          return crc;
 256   1      }
 257          
 258          U8 CalcCheckSum(U8* pSrcData, U16 wDataLen)
 259          {
 260   1          U8 bCheckSum;
 261   1          int i;
 262   1          
 263   1          if(pSrcData == NULL)
 264   1              return 0;
 265   1          
 266   1          bCheckSum = pSrcData[0];
 267   1      
 268   1          if(wDataLen == 0xFFFF)
 269   1             return 0;
 270   1                 
 271   1          for(i = 1; i <= wDataLen - 1; i++)
 272   1          {
 273   2                      pSrcData[i] = pSrcData[i] << 1 + i;
 274   2              bCheckSum ^= pSrcData[i]; 
 275   2          }
 276   1          return bCheckSum;    
 277   1      }
 278          
 279          U32 SoftGenCrc32(U32* puData, U32 uSize) 
 280          { 
 281   1              U32 xdata crc = 0xFFFFFFFF;
 282   1              U32 xdata i = 0, xdata j = 0, xdata temp; 
 283   1              for(i=0;i<uSize;i++)
 284   1              { 
 285   2                      temp = puData[i]; 
 286   2                      for(j=0;j<32;j++)
 287   2                      { 
 288   3                              if( (crc ^ temp) & 0x80000000 )
 289   3                              { 
 290   4                                      crc = 0x04C11DB7 ^ (crc<<1); 
 291   4                              }
 292   3                              else
 293   3                              { 
 294   4                                      crc <<=1; 
 295   4                              } 
 296   3                              temp<<=1; 
 297   3                      } 
 298   2              }
 299   1              
 300   1              return crc; 
 301   1      } 
 302          
 303          //BOOL HandleTag(U8 *pBuf)
 304          //{
 305          //    BOOL bRet = FALSE;
 306          //    U8 xdata u8Count;
 307          ////    U8 xdata u8Length;
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 7   

 308          //      U8 xdata u8Value;
 309          //
 310          ////    u8Length = *(pBuf + 1);
 311          //      u8Value = CalcCheckSum(pBuf+25, 4);
 312          //    
 313          //    bRet = TRUE;
 314          //    for(u8Count = 0; u8Count < TAG_NUMBER; u8Count++)
 315          //    {
 316          //        if(u8Value == g_u8TagCrcData[u8Count])
 317          //        {
 318          //            g_u8TagOffset = u8Count;
 319          //            goto CompareTagEx_exit;
 320          //        }
 321          //    }
 322          //    g_u8TagOffset = g_u8TagCount;
 323          //    g_u8TagCrcData[g_u8TagCount++] = u8Value; 
 324          //    if(g_u8TagCount == TAG_NUMBER)
 325          //    {
 326          //        g_u8TagCount = 0;
 327          //    }
 328          //    
 329          //CompareTagEx_exit:  
 330          //    return bRet;
 331          //}
 332          
 333          
 334          // BOOL HandleTag(U8 *pBuf)
 335          //{
 336          //    BOOL bRet = FALSE;
 337          //    U8 xdata u8Count;
 338          //    U16 xdata u16Value;
 339          //      U8 xdata        szData[15];
 340          ////                            MAKELONG(l, h)
 341          ////                            MAKEWORD(l, h)
 342          //    u16Value_l = MAKEWORD(pBuf+25, pBuf+26);
 343          //      u16Value_h = MAKEWORD(pBuf+27, pBuf+28);
 344          ////    Uart1_Tx(pBuf+25, 4);
 345          ////    sprintf(szData, "###%x\r\n", u16Value);
 346          ////    Uart1_Tx_End(szData);
 347          //    bRet = TRUE;
 348          //    for(u8Count = 0; u8Count < TAG_NUMBER; u8Count++)
 349          //    {
 350          //        if(u16Value == g_u16TagCrcData[u8Count])
 351          //        {
 352          //            g_u8TagOffset = u8Count;
 353          //            goto CompareTagEx_exit;
 354          //        }
 355          //    }
 356          //    g_u8TagOffset = g_u8TagCount;
 357          //    g_u16TagCrcData[g_u8TagCount++] = u16Value; 
 358          //    if(g_u8TagCount == TAG_NUMBER)
 359          //    {
 360          //        g_u8TagCount = 0;
 361          //    }
 362          //   
 363          //CompareTagEx_exit:  
 364          //    return bRet;
 365          //}
 366          
 367          /////////////////////////rfid yuanlai start///////////////////////////////////////
 368          //BOOL HandleTag(U8 *pBuf)
 369          //{
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 8   

 370          //    BOOL bRet = FALSE;
 371          //    U8 xdata u8Count;
 372          //    U16 xdata u16Value_l, u16Value_h;
 373          //      U32 xdata u32Value;
 374          //      U8 xdata u8Value_l,u8Value_h;
 375          //      u8Value_l =  *(pBuf+25);
 376          //      u8Value_h =  *(pBuf+26);
 377          //      u16Value_l = MAKEWORD(u8Value_l, u8Value_h);
 378          //      u8Value_l =  *(pBuf+27);
 379          //      u8Value_h =  *(pBuf+28);
 380          //      u16Value_h = MAKEWORD(u8Value_l, u8Value_h);
 381          //      u32Value =      MAKELONG(u16Value_l, u16Value_h);
 382          ////    u16Value_l = MAKEWORD(pBuf+25, pBuf+26);
 383          ////    u16Value_h = MAKEWORD(pBuf+27, pBuf+28);
 384          ////    u32Value =      MAKELONG(u16Value_l, u16Value_h);
 385          
 386          //    bRet = TRUE;
 387          //    for(u8Count = 0; u8Count < TAG_NUMBER; u8Count++)
 388          //    {
 389          //        if(u32Value == g_u32TagCrcData[u8Count])
 390          //        {
 391          //            g_u8TagOffset = u8Count;
 392          //            goto CompareTagEx_exit;
 393          //        }
 394          //    }
 395          //    g_u8TagOffset = g_u8TagCount;
 396          //    g_u32TagCrcData[g_u8TagCount++] = u32Value; 
 397          //    if(g_u8TagCount == TAG_NUMBER)
 398          //    {
 399          //        g_u8TagCount = 0;
 400          //    }
 401          //   
 402          //CompareTagEx_exit:  
 403          //    return bRet;
 404          //}
 405          /////////////////////rfid yuanlai end//////////////////////////////////////
 406          
 407          BOOL HandleTag(U8 *pBuf)
 408          {
 409   1          BOOL bRet = FALSE;
 410   1          U8 xdata u8Count;
 411   1              U32 xdata u32Value;
 412   1              
 413   1              U32 xdata szData[14] = {0};
 414   1              
 415   1              for(u8Count = 0; u8Count < 14; u8Count++)
 416   1              {
 417   2                      szData[u8Count] = pBuf[u8Count];
 418   2              }
 419   1      
 420   1              u32Value = SoftGenCrc32(szData, 14);
 421   1          
 422   1          bRet = TRUE;
 423   1          for(u8Count = 0; u8Count < TAG_NUMBER; u8Count++)
 424   1          {
 425   2              if(u32Value == g_u32TagCrcData[u8Count])
 426   2              {
 427   3                  g_u8TagOffset = u8Count;
 428   3                  goto CompareTagEx_exit;
 429   3              }
 430   2          }
 431   1          g_u8TagOffset = g_u8TagCount;
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 9   

 432   1          g_u32TagCrcData[g_u8TagCount++] = u32Value; 
 433   1          if(g_u8TagCount == TAG_NUMBER)
 434   1          {
 435   2              g_u8TagCount = 0;
 436   2          }
 437   1          
 438   1      CompareTagEx_exit:  
 439   1          return bRet;
 440   1      }
 441          BOOL SendAndWaitRfidDataProc(U8 u8CmdType)
 442          {
 443   1      
 444   1          BOOL xdata bRet = FALSE; 
 445   1          U8 xdata szData[RFIDDATACOUNT];
 446   1          U8 xdata u8Count = 0;
 447   1          U16 xdata u16Value, xdata u16Length;
 448   1          g_cRfidVar.u8CmdType = u8CmdType; 
 449   1          GetCmdProc(g_cRfidVar.u8CmdType, g_cRfidVar.szCmdSenddata, &(g_cRfidVar.u8SendCount));
 450   1          Uart2_Tx(g_cRfidVar.szCmdSenddata, g_cRfidVar.u8SendCount);
 451   1      
 452   1              while(1)
 453   1              {
 454   2                      ReceiveUsart2Data(szData, &u16Length);
 455   2      
 456   2                      if(u16Length)
 457   2                      {
 458   3                              break;
 459   3                      }
 460   2              }
 461   1          g_cRfidVar.u8ReceiveCount =  u16Length;
 462   1      
 463   1              memcpy(g_cRfidVar.szReceivedata, szData, g_cRfidVar.u8ReceiveCount);
 464   1           
 465   1          u16Value = CalculateRfidCrc(g_cRfidVar.szReceivedata + 1, g_cRfidVar.u8ReceiveCount - 3);
 466   1      
 467   1          if(u16Value == MAKEWORD(g_cRfidVar.szReceivedata[g_cRfidVar.u8ReceiveCount - 1], g_cRfidVar.szReceived
             -ata[g_cRfidVar.u8ReceiveCount - 2]))//Êý¾Ý½ÓÊÕÕýÈ·
 468   1          {
 469   2              bRet = TRUE;
 470   2          }
 471   1          
 472   1          return bRet;
 473   1      }
 474          
 475          
 476          BOOL SendAndWaitRfidDataProcEnhance(U16 u16Data)
 477          {
 478   1                                      
 479   1              U8 xdata szDebugData[7] = {0xFF, 0x02, 0x92, 0x0b, 0xb8};
 480   1          BOOL xdata bRet = FALSE; 
 481   1          U8 xdata szData[RFIDDATACOUNT];
 482   1          U8 xdata u8Count = 0;
 483   1          U16 xdata u16Value, xdata u16Length;
 484   1          
 485   1              szDebugData[3] = HIBYTE(u16Data);
 486   1              szDebugData[4] = LOBYTE(u16Data);
 487   1              u16Value = CalculateRfidCrc(szDebugData + 1, 4);
 488   1              szDebugData[5]  = HIBYTE(u16Value);
 489   1              szDebugData[6] = LOBYTE(u16Value);
 490   1          Uart2_Tx(szDebugData, 7);
 491   1      
 492   1              while(1)
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 10  

 493   1              {
 494   2                      ReceiveUsart2Data(szData, &u16Length);
 495   2      
 496   2                      if(u16Length)
 497   2                      {
 498   3                              break;
 499   3                      }
 500   2              }
 501   1          g_cRfidVar.u8ReceiveCount =  u16Length;
 502   1      
 503   1              memcpy(g_cRfidVar.szReceivedata, szData, g_cRfidVar.u8ReceiveCount);
 504   1           
 505   1          u16Value = CalculateRfidCrc(g_cRfidVar.szReceivedata + 1, g_cRfidVar.u8ReceiveCount - 3);
 506   1      
 507   1          if(u16Value == MAKEWORD(g_cRfidVar.szReceivedata[g_cRfidVar.u8ReceiveCount - 1], g_cRfidVar.szReceived
             -ata[g_cRfidVar.u8ReceiveCount - 2]))//Êý¾Ý½ÓÊÕÕýÈ·
 508   1          {
 509   2              bRet = TRUE;
 510   2          }
 511   1          
 512   1          return bRet;
 513   1      }
 514          
 515          
 516          VOID RfidInitProc(VOID)
 517          {
 518   1          U32 xdata u32Tick;
 519   1          
 520   1          RFID_SHUTDOWN();
 521   1          
 522   1          DelayMs(650);
 523   1          
 524   1          RFID_UNSHUTDOWN();
 525   1          
 526   1      //    u32Tick = GetTickCount();
 527   1      //    
 528   1      //    do
 529   1      //    {
 530   1      //        ReadRfidStateProc();
 531   1      //        
 532   1      //    }while((g_cRfidVar.u8RfidState == BOOTLOADER_RUNNING) && ((GetTickCount() - u32Tick) < 2000));
 533   1      //    
 534   1      //    if(g_cRfidVar.u8RfidState == BOOTLOADER_RUNNING)
 535   1      //    {
 536   1      //        EnterException(ERR_RFID_STEP_1);    
 537   1      //    }
 538   1          
 539   1          
 540   1          u32Tick = GetTickCount();
 541   1          while((SendAndWaitRfidDataProc(GETCURRENTPROGRAM) == FALSE)  && ((GetTickCount() - u32Tick) < (U32)200
             -0));//1.Get Current Program(0Ch)
 542   1          if((GetTickCount() - u32Tick) >= (U32)2000)
 543   1          {
 544   2              EnterException(ERR_RFID_STEP_2);    
 545   2          }
 546   1      
 547   1          if(g_cRfidVar.szReceivedata[4] & 0x01)//program & 0x1 == 1,ÔòÐèÒªÖ´ÐÐÖ¸ÁîBOOTFIRMWARE,²»ÐèÒªÅÐ¶Ï·µ»Ø£¬
             -µ«Ó¦ÓÃÆðÀ´ÐèÒª650ms.
 548   1          {
 549   2              g_cRfidVar.u8CmdType = BOOTFIRMWARE; 
 550   2              GetCmdProc(g_cRfidVar.u8CmdType, g_cRfidVar.szCmdSenddata, &(g_cRfidVar.u8SendCount));
 551   2              Uart1_Tx(g_cRfidVar.szCmdSenddata, g_cRfidVar.u8SendCount);
C51 COMPILER V9.52.0.0   APP_RFID                                                          08/18/2015 15:03:54 PAGE 11  

 552   2              DelayMs(650);
 553   2          }
 554   1      
 555   1          u32Tick = GetTickCount();
 556   1          while((SendAndWaitRfidDataProc(SETFREQUENCYCHANNEL) == FALSE) && ((GetTickCount() - u32Tick) < (U32)20
             -00));    //3.ÉèÖÃÆµ¶ÎÇøÓò
 557   1          if((GetTickCount() - u32Tick) >= (U32)2000)
 558   1          {
 559   2              EnterException(ERR_RFID_STEP_3);    
 560   2          }
 561   1      
 562   1          u32Tick = GetTickCount();
 563   1          while((SendAndWaitRfidDataProc(SETPROTOCOL) == FALSE) && ((GetTickCount() - u32Tick) < (U32)2000));   
             - //4.ÉèÖÃÐ­Òé(93h)
 564   1          if((GetTickCount() - u32Tick) >= (U32)2000)
 565   1          {
 566   2              EnterException(ERR_RFID_STEP_4);    
 567   2          }
 568   1      
 569   1          u32Tick = GetTickCount();
 570   1          while((SendAndWaitRfidDataProc(SETANTENNA) == FALSE) && ((GetTickCount() - u32Tick) < (U32)2000));    
             -//5.ÌìÏßÉèÖÃ(91h)
 571   1          if((GetTickCount() - u32Tick) >= (U32)2000)
 572   1          {
 573   2              EnterException(ERR_RFID_STEP_5);    
 574   2          }
 575   1      
 576   1          u32Tick = GetTickCount();
 577   1          while((SendAndWaitRfidDataProc(CLEARBUFFER) == FALSE) && ((GetTickCount() - u32Tick) < (U32)2000));   
             - //6.Çå³ýbuffer(2Ah)
 578   1          if((GetTickCount() - u32Tick) >= (U32)2000)
 579   1          {
 580   2              EnterException(ERR_RFID_STEP_6);    
 581   2          }
 582   1          
 583   1      }
 584          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3413    ----
   CONSTANT SIZE    =    247    ----
   XDATA SIZE       =    537     238
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.52.0.0   USART                                                             08/18/2015 14:52:38 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\usart.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\usart.c LARGE BROWSE INCDIR(..\code) DEBUG OBJECTEXTEND PRINT(.\
                    -usart.lst) OBJECT(.\usart.obj)

line level    source

   1          /*Abstract :USART communication.
   2          *
   3          *Version NO.:1.0
   4          *Writer     :Woy
   5          *Date       :2015-06-10
   6          **************************************************/
   7          #include "C8051F340.h"
   8          #include "system.h"
   9          #include "uart.h"
  10          #include "Init.h"
  11          
  12          U32 g_u32Uart1TimeCount = 0; 
  13          U32 g_u32Uart2TimeCount = 0;
  14          
  15          CQueueInfo xdata g_cQueueInfo1 = {0}, g_cQueueInfo2 = {0};
  16          PQueueInfo xdata pQueueUsart1Info, pQueueUsart2Info;
  17          /*********************************************
  18                   串口初始化
  19          *********************************************/ 
  20          void UartInit(void)
  21          {
  22   1              // uart0 
  23   1          TR1   = 1;
  24   1              TMOD  = 0x20;                   //T1 is selected as baud rate generator of UART0,T1 is 8-bit auto load timer
  25   1          TCON  = 0x40;       //T1 is running
  26   1          SCON0 = 0x10;       //8-bit UART with variable baud rate,UART0 recieve enable
  27   1              ES0 = 1;                                                //enable uart0 interrupt
  28   1              EA=1; //总中断当打开，否则串口0中断不起；在ES0及SCON0之外；当放在这两个的设置之后；
  29   1      //      EIE2 = 0x02;                                    //enable uart1 interrupt
  30   1      //      CKCON = 0x00;                   //T1clk = SYSCLK/12; nemo, old is CKCON = 0x08;
  31   1      //      CKCON = 0x01;                   //T1clk = SYSCLK/04; nemo, old is CKCON = 0x08;
  32   1      //      TH1 = 256-SYSCLK/12/9600/2;     //TH1 = 0x98,Baud rate is 9600bps
  33   1      //      TH1 = 256-SYSCLK/12/(9600*2);   //TH1 = 0x98,Baud rate is 4800bps
  34   1      
  35   1      //单片机内部12M晶振，时的波特率设置
  36   1      //      TH1 = 0x98;     CKCON = 0x00;   //12M,12分频，4800；T1clk = SYSCLK/12;
  37   1      //      TH1 = ――――; CKCON = 0x01;   //12M,04分频，4800；T1clk = SYSCLK/04;
  38   1      //      TH1 = 0xcc; CKCON = 0x00;       //12M,12分频，9600；T1clk = SYSCLK/12;
  39   1      //      TH1 = 0x64; CKCON = 0x01;       //12M,04分频，9600；T1clk = SYSCLK/04;
  40   1      //      TH1 = 0xe6; CKCON = 0x00;       //12M,12分频，19200；T1clk = SYSCLK/12;
  41   1      //      TH1 = 0xb2; CKCON = 0x01;       //12M,04分频，19200；T1clk = SYSCLK/04;
  42   1      //      TH1 = 0xf3; CKCON = 0x00;       //12M,12分频，38400；T1clk = SYSCLK/12;
  43   1      //      TH1 = 0xd9; CKCON = 0x01;       //12M,04分频，38400；T1clk = SYSCLK/04;
  44   1      //      TH1 = 0xf8; CKCON = 0x00;       //12M,12分频，57600；？T1clk = SYSCLK/12;
  45   1      //      TH1 = 0xe6; CKCON = 0x01;       //12M,04分频，57600；T1clk = SYSCLK/04;
  46   1      
  47   1      //单片机内部48M晶振，时的波特率设置
  48   1      //   CLKMUL  = 0x00;                     // Select internal oscillator as input to clock multiplier
  49   1      //   CLKMUL |= 0x80;                     // Enable clock multiplier
  50   1      //   Delay();                            // Delay for clock multiplier to begin
  51   1      //   CLKMUL |= 0xC0;                     // Initialize the clock multiplier
  52   1      //   Delay();                            // Delay for clock multiplier to begin
  53   1      //   while(!(CLKMUL & 0x20));            // Wait for multiplier to lock
  54   1      //   CLKSEL  = 0x03;                     // Select system clock
C51 COMPILER V9.52.0.0   USART                                                             08/18/2015 14:52:38 PAGE 2   

  55   1      
  56   1      //      TH1 = ――――; CKCON = 0x00;   //48M,12分频，4800；T1clk = SYSCLK/12;
  57   1      //      TH1 = ――――; CKCON = 0x01;   //48M,04分频，4800；T1clk = SYSCLK/04;
  58   1      //      TH1 = 0x30; CKCON = 0x00;       //48M,12分频，9600；T1clk = SYSCLK/12;
  59   1      //      TH1 = ――――; CKCON = 0x01;   //48M,04分频，9600；T1clk = SYSCLK/04;
  60   1      //      TH1 = 0x98; CKCON = 0x00;       //48M,12分频，19200；T1clk = SYSCLK/12;
  61   1      //      TH1 = ――――; CKCON = 0x01;   //48M,04分频，19200；T1clk = SYSCLK/04;
  62   1      //      TH1 = 0xcc; CKCON = 0x00;       //48M,12分频，38400；T1clk = SYSCLK/12;
  63   1      //      TH1 = 0x64; CKCON = 0x01;       //48M,04分频，38400；T1clk = SYSCLK/04;
  64   1      //      TH1 = 0xde; CKCON = 0x00;       //48M,12分频，57600；T1clk = SYSCLK/12;
  65   1      //      TH1 = 0x98; CKCON = 0x01;       //48M,04分频，57600；T1clk = SYSCLK/04;
  66   1              TH1 = 0xcc; CKCON = 0x01;       //48M,04分频，115200；T1clk = SYSCLK/04;
  67   1      
  68   1      
  69   1              SMOD1 = 0x0C;                       // UART1 8位数据
  70   1          SBRLL1    = 0x30;
  71   1          SBRLH1    = 0xFF;    //115200
  72   1      //    SCON1     = 0x10;
  73   1              SCON1 = 0x70;                       // 接收允许，清发送和接收中断
  74   1          SBCON1    = 0x43; // enable baud rate generator
  75   1              EIP2=0X02; //串口2优先级高
  76   1              EIE2 =0X02;//开串口2中断
  77   1      
  78   1              pQueueUsart1Info = &g_cQueueInfo1;
  79   1              pQueueUsart2Info = &g_cQueueInfo2;
  80   1      
  81   1      }
  82          
  83          //======================================================================================//
  84          /***UART1 string transmit****/
  85          void Uart1_Tx(uchar *string, uchar snum)
  86          {
  87   1              uchar *tstr,iloop;
  88   1              tstr = string;
  89   1              ES0 = 0;         //Disable uart0 interrupt when transmitting
  90   1      
  91   1              for (iloop=0; iloop<snum; iloop++)
  92   1              {
  93   2                      SBUF0 = *tstr ;
  94   2                      while (TI0==0);
  95   2                      TI0 = 0;
  96   2                      tstr++;
  97   2              }
  98   1              ES0 = 1;         //Enable uart0 interrupt when transmitted
  99   1      }
 100          //======================================================================================//
 101          void Uart1_Tx_End(uchar *string)
 102          {
 103   1              uchar iLoop;
 104   1              iLoop=0;
 105   1              ES0 = 0;
 106   1              while((*string!='\0')&&(iLoop<100))
 107   1              {
 108   2                       SBUF0 = *string;
 109   2                       while(TI0==0);
 110   2                       TI0 = 0;
 111   2                       string++;
 112   2                       iLoop++;
 113   2              }
 114   1              ES0 = 1;
 115   1      }
 116          //======================================================================================//
C51 COMPILER V9.52.0.0   USART                                                             08/18/2015 14:52:38 PAGE 3   

 117          
 118          /******Uart0 Received interrupt************/
 119          void Uart1_Rx_ISR4() interrupt 4
 120          {
 121   1              if(RI0)
 122   1              {
 123   2                      RI0 = 0;
 124   2                      if(AddQueue(&g_cQueueInfo1, SBUF0) == TRUE)
 125   2                      {
 126   3                              g_u32Uart1TimeCount = GetTickCount();
 127   3                      }
 128   2              }//if
 129   1      }
 130          //======================================================================================//
 131          
 132          /***UART1 string transmit****/
 133          void Uart2_Tx(uchar *string, uchar snum)
 134          {
 135   1              uchar *tstr,iloop;
 136   1              tstr = string;
 137   1              EIE2 = 0x00;   //Disable uart1 interrupt when transmitting
 138   1              for (iloop=0; iloop<snum; iloop++)
 139   1              {
 140   2                      SBUF1 = *tstr ;
 141   2                      while ((SCON1 & 0x02)==0);
 142   2                      SCON1 &= 0xFD;
 143   2                      tstr++;
 144   2              }
 145   1              EIE2 = 0x02;     //Enable uart0 interrupt when transmitted
 146   1      }
 147          
 148          //======================================================================================//
 149          
 150          void Uart2_Tx_End(uchar *string)
 151          {
 152   1              uchar iLoop;
 153   1              iLoop=0;
 154   1              EIE2 = 0x00; 
 155   1              while((*string!='\0')&&(iLoop<100))
 156   1              {
 157   2                       SBUF1 = *string;
 158   2                       while ((SCON1 & 0x02)==0);
 159   2                       SCON1 &= 0xFD;
 160   2                       string++;
 161   2                       iLoop++;
 162   2              }
 163   1              EIE2 = 0x02;
 164   1      }
 165          
 166          //======================================================================================// 
 167          /*******Uart1 Received interrupt********/
 168          void Uart2_Rx_ISR16() interrupt 16
 169          {
 170   1              uchar RI1;      
 171   1              RI1 = SCON1 & 0x01;
 172   1              
 173   1              if(RI1 == 0x01)
 174   1              {
 175   2                      SCON1 &= 0xFE;
 176   2                      if(AddQueue(&g_cQueueInfo2, SBUF1) == TRUE)
 177   2                      {
 178   3                              g_u32Uart2TimeCount = GetTickCount();
C51 COMPILER V9.52.0.0   USART                                                             08/18/2015 14:52:38 PAGE 4   

 179   3                      }
 180   2              }
 181   1      }
 182          
 183          void ClearUart1Length(void)
 184          {
 185   1              memset(pQueueUsart1Info, 0, sizeof(g_cQueueInfo1));
 186   1      }
 187          void ClearUart2Length(void)
 188          {
 189   1              memset(pQueueUsart2Info, 0, sizeof(g_cQueueInfo2));
 190   1      }
 191          
 192          void ReceiveUsart1Data(uchar *pBuf, U16 *pLength)
 193          {
 194   1              uchar ucvalue;
 195   1              U16 ulCount = 0;
 196   1              U32 u32Tick;
 197   1      
 198   1              while(GetQueueLength(pQueueUsart1Info) != 0)
 199   1              {
 200   2                      u32Tick = GetTickCount();
 201   2                      if((u32Tick - g_u32Uart1TimeCount)> 5)
 202   2                      {
 203   3                          while(DeleteQueue(pQueueUsart1Info, &ucvalue) == TRUE)
 204   3                          {           
 205   4                             pBuf[ulCount] = ucvalue; 
 206   4                                 ulCount++;
 207   4                                      
 208   4                          }
 209   3                      }
 210   2              }
 211   1              
 212   1              *pLength = ulCount;
 213   1      }
 214          
 215          void ReceiveUsart2Data(uchar *pBuf, U16 *pLength)
 216          {
 217   1              uchar ucvalue;
 218   1              U16 ulCount = 0;
 219   1              U32 u32Tick;
 220   1      
 221   1              while(GetQueueLength(pQueueUsart2Info) != 0)
 222   1              {
 223   2                      u32Tick = GetTickCount();
 224   2                      if((u32Tick - g_u32Uart2TimeCount)> 5)
 225   2                      {
 226   3                          while(DeleteQueue(pQueueUsart2Info, &ucvalue) == TRUE)
 227   3                          {           
 228   4                             pBuf[ulCount] = ucvalue; 
 229   4                                 ulCount++;
 230   4                          }
 231   3                      }
 232   2              }
 233   1              
 234   1              *pLength = ulCount;
 235   1      }
 236          
 237          void EnterException(unsigned char ucErrCode)
 238          {
 239   1              uchar xdata szData[6];
 240   1              sprintf(szData, "%d", ucErrCode);
C51 COMPILER V9.52.0.0   USART                                                             08/18/2015 14:52:38 PAGE 5   

 241   1          while(1)
 242   1          {
 243   2                      Uart1_Tx(szData,1);
 244   2              DelayMs(1000);
 245   2          }  
 246   1          
 247   1      }
 248          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    877    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =    418      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

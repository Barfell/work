L 1 "Nand_Test\adapter.c"
N#include "bsp.h"
L 1 "..\app\bsp.h" 1
N/***********************************************************************
N * @file	: bsp.h
N * @brief	: Contains basic information about the board that can
N 			  be using with the current code package. It may 
N 			  include some header file for the components mounted
N 			  on the board. Or else some neccessary hardware (IOs) 
N 			  settings for the using board may be involved.
N * @version	: 1.0
N * @date	: 03. March. 2011
N * @author	: NXP MCU SW Application Team
N * @note	: 
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N#include "lpc_types.h"
L 1 "..\Drivers\lpc_types.h" 1
N/***********************************************************************//**
N * @file		lpc_types.h
N * @brief		Contains the NXP ABL typedefs for C standard types.
N *     			It is intended to be used in ISO C conforming development
N *     			environments and checks for this insofar as it is possible
N *     			to do so.
N * @version		1.0
N * @date		18. September. 2010
N * @author		wellsk
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N/* Type group ----------------------------------------------------------- */
N#ifndef LPC_TYPES_H
N#define LPC_TYPES_H
N
N/* Includes ------------------------------------------------------------------- */
N#include <stdint.h>
L 1 "C:\Keil\ARM\RV31\Inc\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
L 29 "..\Drivers\lpc_types.h" 2
N
N
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Types LPC_Types Public Types
N * @{
N */
N
N/**
N * @brief Boolean Type definition
N */
Ntypedef enum {FALSE = 0, TRUE = !FALSE} Bool;
N
N/**
N * @brief Flag Status and Interrupt Flag Status type definition
N */
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
N#define PARAM_SETSTATE(State) ((State==RESET) || (State==SET))
N
N/**
N * @brief Functional State Definition
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define PARAM_FUNCTIONALSTATE(State) ((State==DISABLE) || (State==ENABLE))
N
N/**
N * @ Status type definition
N */
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
N
N
N/**
N * Read/Write transfer type mode (Block or non-block)
N */
Ntypedef enum
N{
N	NONE_BLOCKING = 0,		/**< None Blocking type */
N	BLOCKING,				/**< Blocking type */
N} TRANSFER_BLOCK_Type;
N
N
N/** Pointer to Function returning Void (any number of parameters) */
Ntypedef void (*PFV)();
N
N/** Pointer to Function returning int32_t (any number of parameters) */
Ntypedef int32_t(*PFI)();
N
N/**
N * @}
N */
N
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Macros  LPC_Types Public Macros
N * @{
N */
N
N/* _BIT(n) sets the bit at position "n"
N * _BIT(n) is intended to be used in "OR" and "AND" expressions:
N * e.g., "(_BIT(3) | _BIT(7))".
N */
N#undef _BIT
N/* Set bit macro */
N#define _BIT(n)	(1<<n)
N
N/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
N * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
N * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
N */
N#undef _SBF
N/* Set bit field macro */
N#define _SBF(f,v) (v<<f)
N
N/* _BITMASK constructs a symbol with 'field_width' least significant
N * bits set.
N * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
N * The symbol is intended to be used to limit the bit field width
N * thusly:
N * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
N * If "any_expression" results in a value that is larger than can be
N * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
N * used with the _SBF example above, the example would be written:
N * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
N * This ensures that the value written to a_reg is no wider than
N * 16 bits, and makes the code easier to read and understand.
N */
N#undef _BITMASK
N/* Bitmask creation macro */
N#define _BITMASK(field_width) ( _BIT(field_width) - 1)
N
N/* NULL pointer */
N#ifndef NULL
N#define NULL ((void*) 0)
N#endif
N
N/* Number of elements in an array */
N#define NELEMENTS(array)  (sizeof (array) / sizeof (array[0]))
N
N/* Static data/function define */
N#define STATIC static
N/* External data/function define */
N#define EXTERN extern
N
N#define MAX(a, b) (((a) > (b)) ? (a) : (b))
N#define MIN(a, b) (((a) < (b)) ? (a) : (b))
N
N/**
N * @}
N */
N
N
N/* Old Type Definition compatibility ------------------------------------------ */
N/** @addtogroup LPC_Types_Public_Types LPC_Types Public Types
N * @{
N */
N
N/** SMA type for character type */
Ntypedef char CHAR;
N
N/** SMA type for 8 bit unsigned value */
Ntypedef uint8_t UNS_8;
N
N/** SMA type for 8 bit signed value */
Ntypedef int8_t INT_8;
N
N/** SMA type for 16 bit unsigned value */
Ntypedef	uint16_t UNS_16;
N
N/** SMA type for 16 bit signed value */
Ntypedef	int16_t INT_16;
N
N/** SMA type for 32 bit unsigned value */
Ntypedef	uint32_t UNS_32;
N
N/** SMA type for 32 bit signed value */
Ntypedef	int32_t INT_32;
N
N/** SMA type for 64 bit signed value */
Ntypedef int64_t INT_64;
N
N/** SMA type for 64 bit unsigned value */
Ntypedef uint64_t UNS_64;
N
N/** 32 bit boolean type */
Ntypedef Bool BOOL_32;
N
N/** 16 bit boolean type */
Ntypedef Bool BOOL_16;
N
N/** 8 bit boolean type */
Ntypedef Bool BOOL_8;
N
N/**
N * @}
N */
N
N
N#endif /* LPC_TYPES_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
L 25 "..\app\bsp.h" 2
N
N#ifndef _BSP_H
N#define _BSP_H
N
N#define _DEFAULT_BOARD				(0)
N#define _UCDRAGON_EB_BOARD			(1)
N
N#define _CURR_USING_BRD				(_UCDRAGON_EB_BOARD)
N
N#if (_CURR_USING_BRD == _UCDRAGON_EB_BOARD)
X#if (((1)) == (1))
N//Driver for PHY of LAN DP83848C IC
N#include "phylan_dp83848c.h"
L 1 "..\Drivers\phylan_dp83848c.h" 1
N/***********************************************************************//**
N * @file	: lpc177x_8x_emac.h
N * @brief	: Contains all macro definitions and function prototypes
N * 				support for Ethernet MAC firmware library on LPC177x_8x
N * @version	: 1.0
N * @date	: 05. Jan. 2011
N * @author	: NXP MCU SW Application Team
N * @note	: The driver was referenced from LPC24xx HAL package
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N#ifndef PHY_DP83848C_H
N#define PHY_DP83848C_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N#define DP83848C_MII_ADDR			0x0100				//Default PHY device address
N#define EMAC_PHY_DEFAULT_ADDR		DP83848C_MII_ADDR
N
N
N/* DP83848C PHY Basic Registers */
N#define DP83848C_PHY_REG_BMCR		0x00        // Basic Mode Control Register
N#define DP83848C_PHY_REG_BMSR		0x01        // Basic Mode Status Register
N
N/* DP83848C PHY Extended Registers */
N#define DP83848C_PHY_REG_IDR1		0x02        // PHY Identifier 1
N#define DP83848C_PHY_REG_IDR2		0x03        // PHY Identifier 2
N#define DP83848C_PHY_REG_ANAR		0x04        // Auto-Negotiation Advertisement
N#define DP83848C_PHY_REG_ANLPAR		0x05        // Auto-Neg. Link Partner Abitily
N#define DP83848C_PHY_REG_ANER		0x06        // Auto-Neg. Expansion Register
N
N/* LAN8720 PHY Vendor-specific Registers */
N#define DP83848C_PHY_REG_SRR		0x10        // Silicon Revision Register
N#define DP83848C_PHY_REG_MCSR		0x11        // Mode Control/Status Register
N#define DP83848C_PHY_REG_SR			0x12        // Special Register
N#define DP83848C_PHY_REG_SECR		0x1A        // Symbol Error Conter Register
N#define DP83848C_PHY_REG_CSIR		0x1B        // Control/Status Indication Reg
N#define DP83848C_PHY_REG_SITC		0x1C        // Special Internal testability Controls
N#define DP83848C_PHY_REG_ISR		0x1D        // Interrupt Source Register
N#define DP83848C_PHY_REG_IMR		0x1E        // Interrupt Mask Register
N#define DP83848C_PHY_REG_PHYCSR		0x1F        // PHY Special Control/Status Reg
N
N/* PHY Basic Mode Control Register (BMCR) bitmap definitions */
N#define DP83848C_PHY_BMCR_RESET_POS				(15)	//Reset
N#define DP83848C_PHY_BMCR_LOOPBACK_POS			(14)	//Loop back
N#define DP83848C_PHY_BMCR_SPEEDSEL_POS			(13)	//Speed selection
N#define DP83848C_PHY_BMCR_AUTONEG_POS			(12)	//Auto Negotiation
N#define DP83848C_PHY_BMCR_PWRDWN_POS			(11)	//Power down mode
N#define DP83848C_PHY_BMCR_ISOLATE_POS			(10)	//Isolate
N#define DP83848C_PHY_BMCR_RESTART_AN_POS		(9)		//Restart auto negotiation
N#define DP83848C_PHY_BMCR_DUPLEX_POS			(8)		//Duplex mode
N#define DP83848C_PHY_BMCR_COLLISION_POS			(7)		//Collistion test mode
N
N/* PHY Basic Mode Status Status Register (BMSR) bitmap definitions */
N#define DP83848C_PHY_BMSR_100BT4_POS			(15)	//100Base-T4
N#define DP83848C_PHY_BMSR_100BTX_FULL_POS		(14)	//100Base-TX Full Duplex
N#define DP83848C_PHY_BMSR_100BTX_HALF_POS		(13)	//100Base-TX Half Duplex
N#define DP83848C_PHY_BMSR_10BT_FULL_POS			(12)	//10Base-TX Full Duplex
N#define DP83848C_PHY_BMSR_10BT_HALF_POS			(11)	//10Base-TX Half Duplex
N#define DP83848C_PHY_BMSR_MF_PREAM				(6)		//MF Preamable Supress
N#define DP83848C_PHY_BMSR_AN_COMPLETE_POS		(5)		//Auto-Negotiate Complete
N#define DP83848C_PHY_BMSR_REMOTE_FAULT_POS		(4)		//Remote Fault
N#define DP83848C_PHY_BMSR_AN_ABILITY_POS		(3)		//Auto-Negotiate Ability
N#define DP83848C_PHY_BMSR_LINK_ESTABLISHED_POS	(2)		//Link Status
N#define DP83848C_PHY_BMSR_JABBER_DETECT_POS		(1)		//Jabber Detect
N#define DP83848C_PHY_BMSR_EXTCAPBILITY_POS		(0)		//Extended Capabilities
N
N
N//The Common Registers that are using in all PHY IC with EMAC component of LPC1788
N#define EMAC_PHY_REG_BMCR					DP83848C_PHY_REG_BMCR
N#define EMAC_PHY_REG_BMSR					DP83848C_PHY_REG_BMSR
N#define EMAC_PHY_REG_IDR1					DP83848C_PHY_REG_IDR1
N#define EMAC_PHY_REG_IDR2					DP83848C_PHY_REG_IDR2
N
N#define EMAC_PHY_BMCR_RESET					(1 << DP83848C_PHY_BMCR_RESET_POS)
N#define EMAC_PHY_BMCR_POWERDOWN				(1 << DP83848C_PHY_BMCR_PWRDWN_POS)
N#define EMAC_PHY_BMCR_SPEED_SEL     		(1 << DP83848C_PHY_BMCR_SPEEDSEL_POS)
N#define EMAC_PHY_BMCR_DUPLEX	     		(1 << DP83848C_PHY_BMCR_DUPLEX_POS)
N#define EMAC_PHY_BMCR_AN		     		(1 << DP83848C_PHY_BMCR_AUTONEG_POS)
N
N
N#define EMAC_PHY_BMSR_100BT4        	   	(1 << DP83848C_PHY_BMSR_100BT4_POS)
N#define EMAC_PHY_BMSR_100TX_FULL			(1 << DP83848C_PHY_BMSR_100BTX_FULL_POS)
N#define EMAC_PHY_BMSR_100TX_HALF			(1 << DP83848C_PHY_BMSR_100BTX_HALF_POS)
N#define EMAC_PHY_BMSR_10BT_FULL				(1 << DP83848C_PHY_BMSR_10BT_FULL_POS)
N#define EMAC_PHY_BMSR_10BT_HALF				(1 << DP83848C_PHY_BMSR_10BT_HALF_POS)
N#define EMAC_PHY_BMSR_MF_PREAM				(1 << DP83848C_PHY_BMSR_MF_PREAM)
N#define EMAC_PHY_BMSR_REMOTE_FAULT			(1 << DP83848C_PHY_BMSR_REMOTE_FAULT_POS)
N#define EMAC_PHY_BMSR_LINK_ESTABLISHED		(1 << DP83848C_PHY_BMSR_LINK_ESTABLISHED_POS)
N
N
N#define DP83848C_PHY_ID1				(0x2000)
N
N#define DP83848C_PHY_ID2_OUI			(0x0017) //Organizationally Unique Identifer Number
N#define DP83848C_PHY_ID2_MANF_MODEL		(0x0009) //Manufacturer Model Number
N#define DP83848C_PHY_ID2_CRIT			(((DP83848C_PHY_ID2_OUI & 0x3F) << 6) | (DP83848C_PHY_ID2_MANF_MODEL & 0x3F))
N
N#define EMAC_PHY_ID1_CRIT				(DP83848C_PHY_ID1)
N#define EMAC_PHY_ID2_CRIT				(DP83848C_PHY_ID2_CRIT)
N
N
N
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N
N/**************************** GLOBAL/PUBLIC TYPES ***************************/
N
N/**
N * @addtogroup PUBLIC_TYPES
N * @{
N */
N/** @defgroup EMAC_TYPES
N * @{
N */
N
N/**
N * @brief EMAC configuration structure definition
N */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PHY_DP83848C_H */
N
L 37 "..\app\bsp.h" 2
N
N//LED indicators preset	定义LED使用GPIO端口
N#define BRD_LED_1_CONNECTED_PORT		(1)
N#define BRD_LED_1_CONNECTED_PIN			(12)
N#define BRD_LED_1_CONNECTED_MASK		(1 << BRD_LED_1_CONNECTED_PIN)
N
N#define BRD_LED_2_CONNECTED_PORT		(1)
N#define BRD_LED_2_CONNECTED_PIN			(13)
N#define BRD_LED_2_CONNECTED_MASK		(1 << BRD_LED_2_CONNECTED_PIN)
N
N//PIO interrupt preset 定按键S1~S4使用端口
N#define BRD_PIO_USED_INTR_PORT_S1			(2)
N#define BRD_PIO_USED_INTR_PIN_S1			(11)
N#define BRD_PIO_USED_INTR_MASK_S1			(1 << BRD_PIO_USED_INTR_PIN_S1)
N
N#define BRD_PIO_USED_INTR_PORT_S2			(2)
N#define BRD_PIO_USED_INTR_PIN_S2			(19)
N#define BRD_PIO_USED_INTR_MASK_S2			(1 << BRD_PIO_USED_INTR_PIN_S2)
N
N#define BRD_PIO_USED_INTR_PORT_S3			(2)
N#define BRD_PIO_USED_INTR_PIN_S3			(21)
N#define BRD_PIO_USED_INTR_MASK_S3			(1 << BRD_PIO_USED_INTR_PIN_S3)
N
N#define BRD_PIO_USED_INTR_PORT_S4			(2)
N#define BRD_PIO_USED_INTR_PIN_S4			(25)
N#define BRD_PIO_USED_INTR_MASK_S4			(1 << BRD_PIO_USED_INTR_PIN_S4)
N
N
N
N
N//ADC input preset on this board					 LPC
N#define BRD_ADC_PREPARED_CHANNEL		(ADC_CHANNEL_2)
N#define BRD_ADC_PREPARED_INTR			(ADC_ADINTEN2)
N
N#define BRD_ADC_PREPARED_CH_PORT		(0)
N#define BRD_ADC_PREPARED_CH_PIN			(25)
N#define BRD_ADC_PREPARED_CH_FUNC_NO		(1)
N
N//MCI power active levell
N#define BRD_MCI_POWERED_ACTIVE_LEVEL	(0)
N
N
N//Timer preset
N#define BRD_TIMER_USED				(LPC_TIM0)
N#define BRD_TIM_INTR_USED			(TIMER0_IRQn)
N
N#define BRD_TIM_CAP_LINKED_PORT		(1)
N#define BRD_TIM_CAP_LINKED_PIN		(26)
N
Nextern void Delay (unsigned long tick);
Nvoid LED_ctr(uint8_t led_num,uint8_t on_off);
N
Nvoid Init_gpio_interrupt    (void);
Nvoid uninit_gpio_interrupt  (void);
Nvoid Easy_Web(void);
Nvoid Init_EMAC_Dp83848(void);
N
Nvoid Usb_MassStorage (void);
Nvoid USB_Dis_Connect (void);
N
Nvoid DAC_SineWave(void);
Nvoid DAC_SineWave_Dis(void);
N
Nint Pwm_Test_Beep(void);
Nvoid Pwm_Dis_Beep(void);
Nvoid Pwm_change_Freq(uint8_t state);
N
Nvoid Can_init(void);
Nvoid Can_Uninit(void);
N
Nuint8_t Nor_RW_test(uint32_t offset_adr);
Nuint8_t Nand_Test(void);
N
Nvoid rs485_tx_rx(void);
Nvoid rs485_tx_rx(void);
N
N#endif			//end if (_CURR_USING_BRD == _UCDRAGON_EB_BOARD)
N
N#endif
L 2 "Nand_Test\adapter.c" 2
N#include "lpc_types.h"
N#include "sdram_k4s561632j.h"
L 1 "..\Drivers\sdram_k4s561632j.h" 1
N/***********************************************************************//**
N * @file		sdram_mt48lc8m32lfb5.h
N * @brief		Contains all macro definitions for SDRAM Samsung K4S561632J
N * @version		1.0
N * @date		13. Dec. 2010
N * @author		NXP MCU SW Application Team
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N#ifndef SDRAM_K4S561632J_H_
N#define SDRAM_K4S561632J_H_
N
N#if (_CURR_USING_BRD == _UCDRAGON_EB_BOARD)
X#if (((1)) == (1))
N
N#define SDRAM_BASE_ADDR		0xA0000000
N#define SDRAM_SIZE	        0x2000000
N#define MHZ           		*10000001
N
N#define SYS_FREQ  			60MHZ
N
N#if   SYS_FREQ == (120MHZ)
X#if   60*10000001 == (120*10000001)
S#define SDRAM_PERIOD          8.33  // 96MHz
S#elif     SYS_FREQ == (96MHZ)
X#elif     60*10000001 == (96*10000001)
S#define SDRAM_PERIOD          10.4  // 96MHz
S#elif   SYS_FREQ == (72MHZ)
X#elif   60*10000001 == (72*10000001)
S#define SDRAM_PERIOD          13.8  // 72MHz
N#elif   SYS_FREQ == (60MHZ)
X#elif   60*10000001 == (60*10000001)
N#define SDRAM_PERIOD          16.67  // 72MHz
N#elif   SYS_FREQ == (57MHZ)
S#define SDRAM_PERIOD          17.4  // 57.6MHz
S#elif SYS_FREQ == (48MHZ)
S#define SDRAM_PERIOD          20.8  // 48MHz
S#elif SYS_FREQ == (36MHZ)
S#define SDRAM_PERIOD          27.8  // 36MHz
S#elif SYS_FREQ == (24MHZ)
S#define SDRAM_PERIOD          41.7  // 24MHz
S#elif SYS_FREQ == (12MHZ)
S#define SDRAM_PERIOD          83.3  // 12MHz
S#else
S#error Frequency not defined
N#endif
N
N#define P2C(Period)           (((Period<SDRAM_PERIOD)?0:(uint32_t)((float)Period/SDRAM_PERIOD))+1)
N
N#define SDRAM_REFRESH         7813
N#define SDRAM_TRP             20
N#define SDRAM_TRAS            45
N#define SDRAM_TAPR            1
N#define SDRAM_TDAL            3
N#define SDRAM_TWR             3
N#define SDRAM_TRC             65
N#define SDRAM_TRFC            66
N#define SDRAM_TXSR            67
N#define SDRAM_TRRD            15
N#define SDRAM_TMRD            3
N
Nextern void SDRAMInit( void );
N
N#endif /* SDRAM_K4S561632J_H_ */
N#endif
N/*****************************************************************************
N**                            End Of File
N******************************************************************************/
L 4 "Nand_Test\adapter.c" 2
N#include "debug_frmwrk.h"
L 1 "..\Drivers\debug_frmwrk.h" 1
N/***********************************************************************//**
N * @file		debug_frmwrk.h
N * @brief		Contains some utilities that used for debugging through UART
N * @version		1.0
N * @date		18. September. 2010
N * @author		NXP MCU SW Application Team
N *----------------------------------------------------------------------------
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **********************************************************************/
N
N#ifndef DEBUG_FRMWRK_H_
N#define DEBUG_FRMWRK_H_
N
N#include "lpc177x_8x_uart.h"
L 1 "..\Drivers\lpc177x_8x_uart.h" 1
N/***********************************************************************//**
N * @file		lpc177x_8x_uart.h
N * @brief		Contains all macro definitions and function prototypes
N * 				support for UART firmware library on LPC177x_8x
N * @version		1.0
N * @date		18. September. 2010
N * @author		NXP MCU SW Application Team
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N/* Peripheral group ----------------------------------------------------------- */
N#ifndef __LPC178X_UART_H
N#define __LPC178X_UART_H
N
N/* Includes ------------------------------------------------------------------- */
N#include "LPC177x_8x.h"
L 1 "..\Startup\LPC177x_8x.h" 1
N/***********************************************************************
N * $Id: LPC177x_8x.h 6698 2011-03-03 21:20:50Z nxp21346 $
N *
N * Project: LPC177x_8x CMSIS Package
N *
N * Description: Cortex-M3 Core Peripheral Access Layer Header File for
N *              NXP LPC177x_8x Series.
N *
N * Copyright(C) 2011, NXP Semiconductor
N * All rights reserved.
N *
N ***********************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **********************************************************************/
N
N
N#ifndef __LPC177x_8x_H__
N#define __LPC177x_8x_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC177x_8x Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  Reserved0_IRQn                = 13,       /*!< Reserved                                         */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  MCI_IRQn                      = 29,       /*!< SD/MMC card I/F Interrupt                        */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /*!< USB Activity interrupt                           */
N  CANActivity_IRQn              = 34,       /*!< CAN Activity interrupt                           */
N  UART4_IRQn                    = 35,       /*!< UART4 Interrupt                                  */
N  SSP2_IRQn                     = 36,       /*!< SSP2 Interrupt                                   */
N  LCD_IRQn                      = 37,       /*!< LCD Interrupt                                    */
N  GPIO_IRQn                     = 38,       /*!< GPIO Interrupt                                   */
N  PWM0_IRQn                     = 39,       /*!< PWM0 Interrupt                                   */
N  EEPROM_IRQn                   = 40,       /*!< EEPROM Interrupt                           */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
L 1 "..\CM3_lib\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N/** @addtogroup CMSIS
N * @{
N */
N
N/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - Error 10: \n
N *     register uint32_t __regBasePri         __asm("basepri"); \n
N *     Error 10: Expecting ';'
N * .
N *   - Error 530: \n
N *     return(__regBasePri); \n
N *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
N * .
N *   - Error 550: \n
N *     __regBasePri = (basePri & 0x1ff); \n
N *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
N * .
N *   - Error 754: \n
N *     uint32_t RESERVED0[24]; \n
N *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced
N * .
N *   - Error 750: \n
N *     #define __CM3_CORE_H__ \n
N *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced
N * .
N *   - Error 528: \n
N *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced
N * .
N *   - Error 751: \n
N *     } InterruptType_Type; \n
N *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N/** @addtogroup CMSIS_CM3_core_definitions CMSIS CM3 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
N/** @brief  Nested Vectored Interrupt Controller (NVIC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM3_NVIC */
N
N
N/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
N/** @brief  System Control Block (SCB) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM3_SCB */
N
N
N/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
N  memory mapped structure for SysTick
N  @{
N */
N/** @brief  System Tick Timer (SysTick) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RELOAD;                       /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t RELOAD;                        
N  __IO uint32_t CURR;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t CURR;                           
N  __IO uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM3_SysTick */
N
N
N/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM
N  memory mapped structure for Instrumentation Trace Macrocell (ITM)
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                          
N  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                          
N  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                          
N  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                          
N  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                          
N  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                          
N  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                          
N  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                          
N  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                          
N  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                          
N  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                          
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N/*@}*/ /* end of group CMSIS_CM3_ITM */
N
N
N/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type
N  memory mapped structure for Interrupt Type
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */
N#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */
N#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */
N
N#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
N#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */
N
N#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */
N#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */
N/*@}*/ /* end of group CMSIS_CM3_InterruptType */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU
N  memory mapped structure for Memory Protection Unit (MPU)
N  @{
N */
N/** @brief   Memory Protection Unit (MPU) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */
N#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */
N#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */
N#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */
N#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */
N#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */
N#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@}*/ /* end of group CMSIS_CM3_MPU */
N#endif
N
N
N/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
N/** @brief   Core Debug register structure definition */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM3_CoreDebug */
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (410894 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S *
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @return BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  basePri  BasePriority
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @return FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  faultMask  faultMask value
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N *
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit values)
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask  faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S*
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit value
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N
N/* ##########################   NVIC functions  #################################### */
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  PriorityGroup is priority grouping field
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFul << 16) | (7ul << 8));              
N  reg_value  =  (reg_value                       |
N                (0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                (0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR =  reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @return priority grouping field
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) >> 8);    
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N *
N * @param  IRQn   The positive number of the external interrupt to disable
N *
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N *
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending,
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for read active bit
N * @return         1 = interrupt active, 0 = interrupt not active
N *
N * Read the active register in NVIC and returns 1 if its status is active,
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  PriorityGroup    The used priority group
N * @param  PreemptPriority  The preemptive priority value (starting from 0)
N * @param  SubPriority      The sub priority value (starting from 0)
N * @return                  The encoded priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  Priority           The priority for the interrupt
N * @param  PriorityGroup      The used priority group
N * @param  pPreemptPriority   The preemptive priority value (starting from 0)
N * @param  pSubPriority       The sub priority value (starting from 0)
N *
N * Decode an interrupt priority value with the given priority group to
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N
N  SysTick->RELOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->RELOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);   
N  SysTick->CURR   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CURR   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1ul << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1ul << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N
N/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface
N  Core Debug Interface containing:
N  - Core Debug Receive / Transmit Functions
N  - Core Debug Defines
N  - Core Debug Variables
N*/
N/*@{*/
N
Nextern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */
N#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param  ch   character to output
N * @return      character to output
N *
N * The function outputs a character via the ITM channel 0.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1ul << 24))  &&       
N      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X      (((ITM_Type *) (0xE0000000))->TCR & (1ul << 0))                  &&       
N      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000))->TER & (1ul << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/**
N * @brief  Inputs a character via variable ITM_RxBuffer
N *
N * @return      received character, -1 = no character received
N *
N * The function inputs a character via variable ITM_RxBuffer.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE int ITM_ReceiveChar (void) {
Xstatic __inline int ITM_ReceiveChar (void) {
N  int ch = -1;                               /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/**
N * @brief  Check if a character via variable ITM_RxBuffer is available
N *
N * @return      1 = character available, 0 = no character available
N *
N * The function checks  variable ITM_RxBuffer whether a character is available or not.
N * The function returns '1' if a character is available and '0' if no character is available.
N */
Nstatic __INLINE int ITM_CheckChar (void) {
Xstatic __inline int ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_definitions */
N
N#endif /* __CM3_CORE_H__ */
N
N /**
N  * @}
N  */
N
N/*lint -restore */
L 105 "..\Startup\LPC177x_8x.h" 2
N//#include "system_LPC177x_8x.h"                 /* System Header                                      */
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;                   /*!< Offset: 0x000 (R/W)  Flash Accelerator Configuration Register */
X  volatile uint32_t FLASHCFG;                    
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                    /*!< Offset: 0x080 (R/W)  PLL0 Control Register */
X  volatile uint32_t PLL0CON;                     
N  __IO uint32_t PLL0CFG;                    /*!< Offset: 0x084 (R/W)  PLL0 Configuration Register */
X  volatile uint32_t PLL0CFG;                     
N  __I  uint32_t PLL0STAT;                   /*!< Offset: 0x088 (R/ )  PLL0 Status Register */
X  volatile const  uint32_t PLL0STAT;                    
N  __O  uint32_t PLL0FEED;                   /*!< Offset: 0x08C ( /W)  PLL0 Feed Register */
X  volatile  uint32_t PLL0FEED;                    
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;                    /*!< Offset: 0x0A0 (R/W)  PLL1 Control Register */
X  volatile uint32_t PLL1CON;                     
N  __IO uint32_t PLL1CFG;                    /*!< Offset: 0x0A4 (R/W)  PLL1 Configuration Register */
X  volatile uint32_t PLL1CFG;                     
N  __I  uint32_t PLL1STAT;                   /*!< Offset: 0x0A8 (R/ )  PLL1 Status Register */
X  volatile const  uint32_t PLL1STAT;                    
N  __O  uint32_t PLL1FEED;                   /*!< Offset: 0x0AC ( /W)  PLL1 Feed Register */
X  volatile  uint32_t PLL1FEED;                    
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;                       /*!< Offset: 0x0C0 (R/W)  Power Control Register */
X  volatile uint32_t PCON;                        
N  __IO uint32_t PCONP;                      /*!< Offset: 0x0C4 (R/W)  Power Control for Peripherals Register */
X  volatile uint32_t PCONP;                       
N       uint32_t RESERVED3[14];
N  __IO uint32_t EMCCLKSEL;                  /*!< Offset: 0x100 (R/W)  External Memory Controller Clock Selection Register */
X  volatile uint32_t EMCCLKSEL;                   
N  __IO uint32_t CCLKSEL;                    /*!< Offset: 0x104 (R/W)  CPU Clock Selection Register */
X  volatile uint32_t CCLKSEL;                     
N  __IO uint32_t USBCLKSEL;                  /*!< Offset: 0x108 (R/W)  USB Clock Selection Register */
X  volatile uint32_t USBCLKSEL;                   
N  __IO uint32_t CLKSRCSEL;                  /*!< Offset: 0x10C (R/W)  Clock Source Select Register */
X  volatile uint32_t CLKSRCSEL;                   
N  __IO uint32_t	CANSLEEPCLR;                /*!< Offset: 0x110 (R/W)  CAN Sleep Clear Register */
X  volatile uint32_t	CANSLEEPCLR;                 
N  __IO uint32_t	CANWAKEFLAGS;               /*!< Offset: 0x114 (R/W)  CAN Wake-up Flags Register */
X  volatile uint32_t	CANWAKEFLAGS;                
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                     /*!< Offset: 0x140 (R/W)  External Interrupt Flag Register */
X  volatile uint32_t EXTINT;                      
N       uint32_t RESERVED5[1];
N  __IO uint32_t EXTMODE;                    /*!< Offset: 0x148 (R/W)  External Interrupt Mode Register */
X  volatile uint32_t EXTMODE;                     
N  __IO uint32_t EXTPOLAR;                   /*!< Offset: 0x14C (R/W)  External Interrupt Polarity Register */
X  volatile uint32_t EXTPOLAR;                    
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                       /*!< Offset: 0x180 (R/W)  Reset Source Identification Register */
X  volatile uint32_t RSID;                        
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                        /*!< Offset: 0x1A0 (R/W)  System Controls and Status Register */
X  volatile uint32_t SCS;                         
N  __IO uint32_t IRCTRIM;                    /*!< Offset: 0x1A4 (R/W) Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                     
N  __IO uint32_t PCLKSEL;                    /*!< Offset: 0x1A8 (R/W)  Peripheral Clock Selection Register */
X  volatile uint32_t PCLKSEL;                     
N       uint32_t RESERVED8[3];
N  __IO uint32_t LCD_CFG;                    /*!< Offset: 0x1B8 (R/W)  LCD Configuration and clocking control Register */
X  volatile uint32_t LCD_CFG;                     
N       uint32_t RESERVED9[1];
N  __IO uint32_t USBIntSt;                   /*!< Offset: 0x1C0 (R/W)  USB Interrupt Status Register */
X  volatile uint32_t USBIntSt;                    
N  __IO uint32_t DMAREQSEL;                  /*!< Offset: 0x1C4 (R/W)  DMA Request Select Register */
X  volatile uint32_t DMAREQSEL;                   
N  __IO uint32_t CLKOUTCFG;                  /*!< Offset: 0x1C8 (R/W)  Clock Output Configuration Register */
X  volatile uint32_t CLKOUTCFG;                   
N  __IO uint32_t RSTCON0;                    /*!< Offset: 0x1CC (R/W)  RESET Control0 Register */
X  volatile uint32_t RSTCON0;                     
N  __IO uint32_t RSTCON1;                    /*!< Offset: 0x1D0 (R/W)  RESET Control1 Register */
X  volatile uint32_t RSTCON1;                     
N       uint32_t RESERVED10[2];
N  __IO uint32_t EMCDLYCTL;                  /*!< Offset: 0x1DC (R/W) SDRAM programmable delays          */
X  volatile uint32_t EMCDLYCTL;                   
N  __IO uint32_t EMCCAL;                     /*!< Offset: 0x1E0 (R/W) Calibration of programmable delays */
X  volatile uint32_t EMCCAL;                      
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t P0_0;				/* 0x000 */
X  volatile uint32_t P0_0;				 
N  __IO uint32_t P0_1;
X  volatile uint32_t P0_1;
N  __IO uint32_t P0_2;
X  volatile uint32_t P0_2;
N  __IO uint32_t P0_3;
X  volatile uint32_t P0_3;
N  __IO uint32_t P0_4;
X  volatile uint32_t P0_4;
N  __IO uint32_t P0_5;
X  volatile uint32_t P0_5;
N  __IO uint32_t P0_6;
X  volatile uint32_t P0_6;
N  __IO uint32_t P0_7;
X  volatile uint32_t P0_7;
N
N  __IO uint32_t P0_8;				/* 0x020 */
X  volatile uint32_t P0_8;				 
N  __IO uint32_t P0_9;
X  volatile uint32_t P0_9;
N  __IO uint32_t P0_10;
X  volatile uint32_t P0_10;
N  __IO uint32_t P0_11;
X  volatile uint32_t P0_11;
N  __IO uint32_t P0_12;
X  volatile uint32_t P0_12;
N  __IO uint32_t P0_13;
X  volatile uint32_t P0_13;
N  __IO uint32_t P0_14;
X  volatile uint32_t P0_14;
N  __IO uint32_t P0_15;
X  volatile uint32_t P0_15;
N
N  __IO uint32_t P0_16;				/* 0x040 */
X  volatile uint32_t P0_16;				 
N  __IO uint32_t P0_17;
X  volatile uint32_t P0_17;
N  __IO uint32_t P0_18;
X  volatile uint32_t P0_18;
N  __IO uint32_t P0_19;
X  volatile uint32_t P0_19;
N  __IO uint32_t P0_20;
X  volatile uint32_t P0_20;
N  __IO uint32_t P0_21;
X  volatile uint32_t P0_21;
N  __IO uint32_t P0_22;
X  volatile uint32_t P0_22;
N  __IO uint32_t P0_23;
X  volatile uint32_t P0_23;
N
N  __IO uint32_t P0_24;				/* 0x060 */
X  volatile uint32_t P0_24;				 
N  __IO uint32_t P0_25;
X  volatile uint32_t P0_25;
N  __IO uint32_t P0_26;
X  volatile uint32_t P0_26;
N  __IO uint32_t P0_27;
X  volatile uint32_t P0_27;
N  __IO uint32_t P0_28;
X  volatile uint32_t P0_28;
N  __IO uint32_t P0_29;
X  volatile uint32_t P0_29;
N  __IO uint32_t P0_30;
X  volatile uint32_t P0_30;
N  __IO uint32_t P0_31;
X  volatile uint32_t P0_31;
N
N  __IO uint32_t P1_0;				/* 0x080 */
X  volatile uint32_t P1_0;				 
N  __IO uint32_t P1_1;
X  volatile uint32_t P1_1;
N  __IO uint32_t P1_2;
X  volatile uint32_t P1_2;
N  __IO uint32_t P1_3;
X  volatile uint32_t P1_3;
N  __IO uint32_t P1_4;
X  volatile uint32_t P1_4;
N  __IO uint32_t P1_5;
X  volatile uint32_t P1_5;
N  __IO uint32_t P1_6;
X  volatile uint32_t P1_6;
N  __IO uint32_t P1_7;
X  volatile uint32_t P1_7;
N
N  __IO uint32_t P1_8;				/* 0x0A0 */
X  volatile uint32_t P1_8;				 
N  __IO uint32_t P1_9;
X  volatile uint32_t P1_9;
N  __IO uint32_t P1_10;
X  volatile uint32_t P1_10;
N  __IO uint32_t P1_11;
X  volatile uint32_t P1_11;
N  __IO uint32_t P1_12;
X  volatile uint32_t P1_12;
N  __IO uint32_t P1_13;
X  volatile uint32_t P1_13;
N  __IO uint32_t P1_14;
X  volatile uint32_t P1_14;
N  __IO uint32_t P1_15;
X  volatile uint32_t P1_15;
N
N  __IO uint32_t P1_16;				/* 0x0C0 */
X  volatile uint32_t P1_16;				 
N  __IO uint32_t P1_17;
X  volatile uint32_t P1_17;
N  __IO uint32_t P1_18;
X  volatile uint32_t P1_18;
N  __IO uint32_t P1_19;
X  volatile uint32_t P1_19;
N  __IO uint32_t P1_20;
X  volatile uint32_t P1_20;
N  __IO uint32_t P1_21;
X  volatile uint32_t P1_21;
N  __IO uint32_t P1_22;
X  volatile uint32_t P1_22;
N  __IO uint32_t P1_23;
X  volatile uint32_t P1_23;
N
N  __IO uint32_t P1_24;				/* 0x0E0 */
X  volatile uint32_t P1_24;				 
N  __IO uint32_t P1_25;
X  volatile uint32_t P1_25;
N  __IO uint32_t P1_26;
X  volatile uint32_t P1_26;
N  __IO uint32_t P1_27;
X  volatile uint32_t P1_27;
N  __IO uint32_t P1_28;
X  volatile uint32_t P1_28;
N  __IO uint32_t P1_29;
X  volatile uint32_t P1_29;
N  __IO uint32_t P1_30;
X  volatile uint32_t P1_30;
N  __IO uint32_t P1_31;
X  volatile uint32_t P1_31;
N
N  __IO uint32_t P2_0;				/* 0x100 */
X  volatile uint32_t P2_0;				 
N  __IO uint32_t P2_1;
X  volatile uint32_t P2_1;
N  __IO uint32_t P2_2;
X  volatile uint32_t P2_2;
N  __IO uint32_t P2_3;
X  volatile uint32_t P2_3;
N  __IO uint32_t P2_4;
X  volatile uint32_t P2_4;
N  __IO uint32_t P2_5;
X  volatile uint32_t P2_5;
N  __IO uint32_t P2_6;
X  volatile uint32_t P2_6;
N  __IO uint32_t P2_7;
X  volatile uint32_t P2_7;
N
N  __IO uint32_t P2_8;				/* 0x120 */
X  volatile uint32_t P2_8;				 
N  __IO uint32_t P2_9;
X  volatile uint32_t P2_9;
N  __IO uint32_t P2_10;
X  volatile uint32_t P2_10;
N  __IO uint32_t P2_11;
X  volatile uint32_t P2_11;
N  __IO uint32_t P2_12;
X  volatile uint32_t P2_12;
N  __IO uint32_t P2_13;
X  volatile uint32_t P2_13;
N  __IO uint32_t P2_14;
X  volatile uint32_t P2_14;
N  __IO uint32_t P2_15;
X  volatile uint32_t P2_15;
N
N  __IO uint32_t P2_16;				/* 0x140 */
X  volatile uint32_t P2_16;				 
N  __IO uint32_t P2_17;
X  volatile uint32_t P2_17;
N  __IO uint32_t P2_18;
X  volatile uint32_t P2_18;
N  __IO uint32_t P2_19;
X  volatile uint32_t P2_19;
N  __IO uint32_t P2_20;
X  volatile uint32_t P2_20;
N  __IO uint32_t P2_21;
X  volatile uint32_t P2_21;
N  __IO uint32_t P2_22;
X  volatile uint32_t P2_22;
N  __IO uint32_t P2_23;
X  volatile uint32_t P2_23;
N
N  __IO uint32_t P2_24;				/* 0x160 */
X  volatile uint32_t P2_24;				 
N  __IO uint32_t P2_25;
X  volatile uint32_t P2_25;
N  __IO uint32_t P2_26;
X  volatile uint32_t P2_26;
N  __IO uint32_t P2_27;
X  volatile uint32_t P2_27;
N  __IO uint32_t P2_28;
X  volatile uint32_t P2_28;
N  __IO uint32_t P2_29;
X  volatile uint32_t P2_29;
N  __IO uint32_t P2_30;
X  volatile uint32_t P2_30;
N  __IO uint32_t P2_31;
X  volatile uint32_t P2_31;
N
N  __IO uint32_t P3_0;				/* 0x180 */
X  volatile uint32_t P3_0;				 
N  __IO uint32_t P3_1;
X  volatile uint32_t P3_1;
N  __IO uint32_t P3_2;
X  volatile uint32_t P3_2;
N  __IO uint32_t P3_3;
X  volatile uint32_t P3_3;
N  __IO uint32_t P3_4;
X  volatile uint32_t P3_4;
N  __IO uint32_t P3_5;
X  volatile uint32_t P3_5;
N  __IO uint32_t P3_6;
X  volatile uint32_t P3_6;
N  __IO uint32_t P3_7;
X  volatile uint32_t P3_7;
N
N  __IO uint32_t P3_8;				/* 0x1A0 */
X  volatile uint32_t P3_8;				 
N  __IO uint32_t P3_9;
X  volatile uint32_t P3_9;
N  __IO uint32_t P3_10;
X  volatile uint32_t P3_10;
N  __IO uint32_t P3_11;
X  volatile uint32_t P3_11;
N  __IO uint32_t P3_12;
X  volatile uint32_t P3_12;
N  __IO uint32_t P3_13;
X  volatile uint32_t P3_13;
N  __IO uint32_t P3_14;
X  volatile uint32_t P3_14;
N  __IO uint32_t P3_15;
X  volatile uint32_t P3_15;
N
N  __IO uint32_t P3_16;				/* 0x1C0 */
X  volatile uint32_t P3_16;				 
N  __IO uint32_t P3_17;
X  volatile uint32_t P3_17;
N  __IO uint32_t P3_18;
X  volatile uint32_t P3_18;
N  __IO uint32_t P3_19;
X  volatile uint32_t P3_19;
N  __IO uint32_t P3_20;
X  volatile uint32_t P3_20;
N  __IO uint32_t P3_21;
X  volatile uint32_t P3_21;
N  __IO uint32_t P3_22;
X  volatile uint32_t P3_22;
N  __IO uint32_t P3_23;
X  volatile uint32_t P3_23;
N
N  __IO uint32_t P3_24;				/* 0x1E0 */
X  volatile uint32_t P3_24;				 
N  __IO uint32_t P3_25;
X  volatile uint32_t P3_25;
N  __IO uint32_t P3_26;
X  volatile uint32_t P3_26;
N  __IO uint32_t P3_27;
X  volatile uint32_t P3_27;
N  __IO uint32_t P3_28;
X  volatile uint32_t P3_28;
N  __IO uint32_t P3_29;
X  volatile uint32_t P3_29;
N  __IO uint32_t P3_30;
X  volatile uint32_t P3_30;
N  __IO uint32_t P3_31;
X  volatile uint32_t P3_31;
N
N  __IO uint32_t P4_0;				/* 0x200 */
X  volatile uint32_t P4_0;				 
N  __IO uint32_t P4_1;
X  volatile uint32_t P4_1;
N  __IO uint32_t P4_2;
X  volatile uint32_t P4_2;
N  __IO uint32_t P4_3;
X  volatile uint32_t P4_3;
N  __IO uint32_t P4_4;
X  volatile uint32_t P4_4;
N  __IO uint32_t P4_5;
X  volatile uint32_t P4_5;
N  __IO uint32_t P4_6;
X  volatile uint32_t P4_6;
N  __IO uint32_t P4_7;
X  volatile uint32_t P4_7;
N
N  __IO uint32_t P4_8;				/* 0x220 */
X  volatile uint32_t P4_8;				 
N  __IO uint32_t P4_9;
X  volatile uint32_t P4_9;
N  __IO uint32_t P4_10;
X  volatile uint32_t P4_10;
N  __IO uint32_t P4_11;
X  volatile uint32_t P4_11;
N  __IO uint32_t P4_12;
X  volatile uint32_t P4_12;
N  __IO uint32_t P4_13;
X  volatile uint32_t P4_13;
N  __IO uint32_t P4_14;
X  volatile uint32_t P4_14;
N  __IO uint32_t P4_15;
X  volatile uint32_t P4_15;
N
N  __IO uint32_t P4_16;				/* 0x240 */
X  volatile uint32_t P4_16;				 
N  __IO uint32_t P4_17;
X  volatile uint32_t P4_17;
N  __IO uint32_t P4_18;
X  volatile uint32_t P4_18;
N  __IO uint32_t P4_19;
X  volatile uint32_t P4_19;
N  __IO uint32_t P4_20;
X  volatile uint32_t P4_20;
N  __IO uint32_t P4_21;
X  volatile uint32_t P4_21;
N  __IO uint32_t P4_22;
X  volatile uint32_t P4_22;
N  __IO uint32_t P4_23;
X  volatile uint32_t P4_23;
N
N  __IO uint32_t P4_24;				/* 0x260 */
X  volatile uint32_t P4_24;				 
N  __IO uint32_t P4_25;
X  volatile uint32_t P4_25;
N  __IO uint32_t P4_26;
X  volatile uint32_t P4_26;
N  __IO uint32_t P4_27;
X  volatile uint32_t P4_27;
N  __IO uint32_t P4_28;
X  volatile uint32_t P4_28;
N  __IO uint32_t P4_29;
X  volatile uint32_t P4_29;
N  __IO uint32_t P4_30;
X  volatile uint32_t P4_30;
N  __IO uint32_t P4_31;
X  volatile uint32_t P4_31;
N
N  __IO uint32_t P5_0;				/* 0x280 */
X  volatile uint32_t P5_0;				 
N  __IO uint32_t P5_1;
X  volatile uint32_t P5_1;
N  __IO uint32_t P5_2;
X  volatile uint32_t P5_2;
N  __IO uint32_t P5_3;
X  volatile uint32_t P5_3;
N  __IO uint32_t P5_4;				/* 0x290 */
X  volatile uint32_t P5_4;				 
N} LPC_IOCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DIR;
X  volatile uint32_t DIR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t PIN;
X  volatile uint32_t PIN;
N  __IO uint32_t SET;
X  volatile uint32_t SET;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;                    /*!< Offset: 0x03C External Match Register (R/W) */
X  volatile uint32_t EMR;                     
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;                   /*!< Offset: 0x070 Count Control Register (R/W) */
X  volatile uint32_t CTCR;                    
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N  __I  uint32_t CR2;					/*!< Offset: 0x034 Capture Register 2 (R/ ) */
X  volatile const  uint32_t CR2;					 
N  __I  uint32_t CR3;					/*!< Offset: 0x038 Capture Register 3 (R/ ) */
X  volatile const  uint32_t CR3;					 
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;					/*!< Offset: 0x040 Match Register 4 (R/W) */
X  volatile uint32_t MR4;					 
N  __IO uint32_t MR5;					/*!< Offset: 0x044 Match Register 5 (R/W) */
X  volatile uint32_t MR5;					 
N  __IO uint32_t MR6;					/*!< Offset: 0x048 Match Register 6 (R/W) */
X  volatile uint32_t MR6;					 
N  __IO uint32_t PCR;					/*!< Offset: 0x04C PWM Control Register (R/W) */
X  volatile uint32_t PCR;					 
N  __IO uint32_t LER;					/*!< Offset: 0x050 Load Enable Register (R/W) */
X  volatile uint32_t LER;					 
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;					/*!< Offset: 0x070 Counter Control Register (R/W) */
X  volatile uint32_t CTCR;					 
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UARTx) -----------*/
N/* There are three types of UARTs on the chip:
N(1) UART0,UART2, and UART3 are the standard UART.
N(2) UART1 is the standard with modem capability.
N(3) USART(UART4) is the sync/async UART with smart card capability.
NMore details can be found on the Users Manual. */
N
N#if 0
Stypedef struct
S{
S  union {
S  __I  uint8_t  RBR;
S  __O  uint8_t  THR;
S  __IO uint8_t  DLL;
S       uint32_t RESERVED0;
S  };
S  union {
S  __IO uint8_t  DLM;
S  __IO uint32_t IER;
S  };
S  union {
S  __I  uint32_t IIR;
S  __O  uint8_t  FCR;
S  };
S  __IO uint8_t  LCR;
S       uint8_t  RESERVED1[7];
S  __I  uint8_t  LSR;
S       uint8_t  RESERVED2[7];
S  __IO uint8_t  SCR;
S       uint8_t  RESERVED3[3];
S  __IO uint32_t ACR;
S  __IO uint8_t  ICR;
S       uint8_t  RESERVED4[3];
S  __IO uint8_t  FDR;
S       uint8_t  RESERVED5[7];
S  __IO uint8_t  TER;
S       uint8_t  RESERVED6[39];
S  __I  uint8_t  FIFOLVL;
S} LPC_UART_TypeDef;
N#else
Ntypedef struct
N{
N	union
N	{
N		__I  uint8_t  RBR;
X		volatile const  uint8_t  RBR;
N		__O  uint8_t  THR;
X		volatile  uint8_t  THR;
N		__IO uint8_t  DLL;
X		volatile uint8_t  DLL;
N		uint32_t RESERVED0;
N	};
N	union
N	{
N		__IO uint8_t  DLM;
X		volatile uint8_t  DLM;
N		__IO uint32_t IER;
X		volatile uint32_t IER;
N	};
N	union
N	{
N		__I  uint32_t IIR;
X		volatile const  uint32_t IIR;
N		__O  uint8_t  FCR;
X		volatile  uint8_t  FCR;
N	};
N	__IO uint8_t  LCR;
X	volatile uint8_t  LCR;
N	uint8_t  RESERVED1[7];//Reserved
N	__I  uint8_t  LSR;
X	volatile const  uint8_t  LSR;
N	uint8_t  RESERVED2[7];//Reserved
N	__IO uint8_t  SCR;
X	volatile uint8_t  SCR;
N	uint8_t  RESERVED3[3];//Reserved
N	__IO uint32_t ACR;
X	volatile uint32_t ACR;
N	__IO uint8_t  ICR;
X	volatile uint8_t  ICR;
N	uint8_t  RESERVED4[3];//Reserved
N	__IO uint8_t  FDR;
X	volatile uint8_t  FDR;
N	uint8_t  RESERVED5[7];//Reserved
N	__IO uint8_t  TER;
X	volatile uint8_t  TER;
N	uint8_t  RESERVED8[27];//Reserved
N	__IO uint8_t  RS485CTRL;
X	volatile uint8_t  RS485CTRL;
N	uint8_t  RESERVED9[3];//Reserved
N	__IO uint8_t  ADRMATCH;
X	volatile uint8_t  ADRMATCH;
N	uint8_t  RESERVED10[3];//Reserved
N	__IO uint8_t  RS485DLY;
X	volatile uint8_t  RS485DLY;
N	uint8_t  RESERVED11[3];//Reserved
N	__I  uint8_t  FIFOLVL;
X	volatile const  uint8_t  FIFOLVL;
N}LPC_UART_TypeDef;
N#endif
N
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART1_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;                   /*!< Offset: 0x000 Receiver Buffer  Register (R/ ) */
X  volatile const  uint32_t  RBR;                    
N  __O  uint32_t  THR;                   /*!< Offset: 0x000 Transmit Holding Register ( /W) */
X  volatile  uint32_t  THR;                    
N  __IO uint32_t  DLL;                   /*!< Offset: 0x000 Divisor Latch LSB (R/W) */
X  volatile uint32_t  DLL;                    
N  };
N  union {
N  __IO uint32_t  DLM;                   /*!< Offset: 0x004 Divisor Latch MSB (R/W) */
X  volatile uint32_t  DLM;                    
N  __IO uint32_t  IER;                   /*!< Offset: 0x000 Interrupt Enable Register (R/W) */
X  volatile uint32_t  IER;                    
N  };
N  union {
N  __I  uint32_t  IIR;                   /*!< Offset: 0x008 Interrupt ID Register (R/ ) */
X  volatile const  uint32_t  IIR;                    
N  __O  uint32_t  FCR;                   /*!< Offset: 0x008 FIFO Control Register ( /W) */
X  volatile  uint32_t  FCR;                    
N  };
N  __IO uint32_t  LCR;                   /*!< Offset: 0x00C Line Control Register (R/W) */
X  volatile uint32_t  LCR;                    
N  __IO uint32_t  MCR;                   /*!< Offset: 0x010 Modem control Register (R/W) */
X  volatile uint32_t  MCR;                    
N  __I  uint32_t  LSR;                   /*!< Offset: 0x014 Line Status Register (R/ ) */
X  volatile const  uint32_t  LSR;                    
N  __I  uint32_t  MSR;                   /*!< Offset: 0x018 Modem status Register (R/ ) */
X  volatile const  uint32_t  MSR;                    
N  __IO uint32_t  SCR;                   /*!< Offset: 0x01C Scratch Pad Register (R/W) */
X  volatile uint32_t  SCR;                    
N  __IO uint32_t  ACR;                   /*!< Offset: 0x020 Auto-baud Control Register (R/W) */
X  volatile uint32_t  ACR;                    
N  __IO uint32_t  ICR;                   /*!< Offset: 0x024 irDA Control Register (R/W) */
X  volatile uint32_t  ICR;                    
N  __IO uint32_t  FDR;                   /*!< Offset: 0x028 Fractional Divider Register (R/W) */
X  volatile uint32_t  FDR;                    
N  __IO uint32_t  OSR;                   /*!< Offset: 0x02C Over sampling Register (R/W) */
X  volatile uint32_t  OSR;                    
N  __O  uint32_t  POP;                   /*!< Offset: 0x030 NHP Pop Register (W) */
X  volatile  uint32_t  POP;                    
N  __IO uint32_t  MODE;                  /*!< Offset: 0x034 NHP Mode selection Register (W) */
X  volatile uint32_t  MODE;                   
N       uint32_t  RESERVED0[2];
N  __IO uint32_t  HDEN;                  /*!< Offset: 0x040 Half duplex Enable Register (R/W) */
X  volatile uint32_t  HDEN;                   
N       uint32_t  RESERVED1;
N  __IO uint32_t  SCI_CTRL;				/*!< Offset: 0x048 Smart card Interface Control Register (R/W) */
X  volatile uint32_t  SCI_CTRL;				 
N  __IO uint32_t  RS485CTRL;             /*!< Offset: 0x04C RS-485/EIA-485 Control Register (R/W) */
X  volatile uint32_t  RS485CTRL;              
N  __IO uint32_t  ADRMATCH;              /*!< Offset: 0x050 RS-485/EIA-485 address match Register (R/W) */
X  volatile uint32_t  ADRMATCH;               
N  __IO uint32_t  RS485DLY;              /*!< Offset: 0x054 RS-485/EIA-485 direction control delay Register (R/W) */
X  volatile uint32_t  RS485DLY;               
N  __IO uint32_t  SYNCCTRL;              /*!< Offset: 0x058 Synchronous Mode Control Register (R/W ) */
X  volatile uint32_t  SYNCCTRL;               
N  __IO uint32_t  TER;                   /*!< Offset: 0x05C Transmit Enable Register (R/W) */
X  volatile uint32_t  TER;                    
N       uint32_t  RESERVED2[989];
N  __I  uint32_t  CFG;                   /*!< Offset: 0xFD4 Configuration Register (R) */
X  volatile const  uint32_t  CFG;                    
N  __O  uint32_t  INTCE;                 /*!< Offset: 0xFD8 Interrupt Clear Enable Register (W) */
X  volatile  uint32_t  INTCE;                  
N  __O  uint32_t  INTSE;                 /*!< Offset: 0xFDC Interrupt Set Enable Register (W) */
X  volatile  uint32_t  INTSE;                  
N  __I  uint32_t  INTS;                  /*!< Offset: 0xFE0 Interrupt Status Register (R) */
X  volatile const  uint32_t  INTS;                   
N  __I  uint32_t  INTE;                  /*!< Offset: 0xFE4 Interrupt Enable Register (R) */
X  volatile const  uint32_t  INTE;                   
N  __O  uint32_t  INTCS;                 /*!< Offset: 0xFE8 Interrupt Clear Status Register (W) */
X  volatile  uint32_t  INTCS;                  
N  __O  uint32_t  INTSS;                 /*!< Offset: 0xFEC Interrupt Set Status Register (W) */
X  volatile  uint32_t  INTSS;                  
N       uint32_t  RESERVED3[3];
N  __I  uint32_t  MID;                   /*!< Offset: 0xFFC Module Identification Register (R) */
X  volatile const  uint32_t  MID;                    
N} LPC_UART4_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;                    /*!< Offset: 0x000 Control Register 0 (R/W) */
X  volatile uint32_t CR0;                     
N  __IO uint32_t CR1;                    /*!< Offset: 0x004 Control Register 1 (R/W) */
X  volatile uint32_t CR1;                     
N  __IO uint32_t DR;                     /*!< Offset: 0x008 Data Register (R/W) */
X  volatile uint32_t DR;                      
N  __I  uint32_t SR;                     /*!< Offset: 0x00C Status Registe (R/ ) */
X  volatile const  uint32_t SR;                      
N  __IO uint32_t CPSR;                   /*!< Offset: 0x010 Clock Prescale Register (R/W) */
X  volatile uint32_t CPSR;                    
N  __IO uint32_t IMSC;                   /*!< Offset: 0x014 Interrupt Mask Set and Clear Register (R/W) */
X  volatile uint32_t IMSC;                    
N  __IO uint32_t RIS;                    /*!< Offset: 0x018 Raw Interrupt Status Register (R/W) */
X  volatile uint32_t RIS;                     
N  __IO uint32_t MIS;                    /*!< Offset: 0x01C Masked Interrupt Status Register (R/W) */
X  volatile uint32_t MIS;                     
N  __IO uint32_t ICR;                    /*!< Offset: 0x020 SSPICR Interrupt Clear Register (R/W) */
X  volatile uint32_t ICR;                     
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CONSET;                 /*!< Offset: 0x000 I2C Control Set Register (R/W) */
X  volatile uint32_t CONSET;                  
N  __I  uint32_t STAT;                   /*!< Offset: 0x004 I2C Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t DAT;                    /*!< Offset: 0x008 I2C Data Register (R/W) */
X  volatile uint32_t DAT;                     
N  __IO uint32_t ADR0;                   /*!< Offset: 0x00C I2C Slave Address Register 0 (R/W) */
X  volatile uint32_t ADR0;                    
N  __IO uint32_t SCLH;                   /*!< Offset: 0x010 SCH Duty Cycle Register High Half Word (R/W) */
X  volatile uint32_t SCLH;                    
N  __IO uint32_t SCLL;                   /*!< Offset: 0x014 SCL Duty Cycle Register Low Half Word (R/W) */
X  volatile uint32_t SCLL;                    
N  __O  uint32_t CONCLR;                 /*!< Offset: 0x018 I2C Control Clear Register ( /W) */
X  volatile  uint32_t CONCLR;                  
N  __IO uint32_t MMCTRL;                 /*!< Offset: 0x01C Monitor mode control register (R/W) */
X  volatile uint32_t MMCTRL;                  
N  __IO uint32_t ADR1;                   /*!< Offset: 0x020 I2C Slave Address Register 1 (R/W) */
X  volatile uint32_t ADR1;                    
N  __IO uint32_t ADR2;                   /*!< Offset: 0x024 I2C Slave Address Register 2 (R/W) */
X  volatile uint32_t ADR2;                    
N  __IO uint32_t ADR3;                   /*!< Offset: 0x028 I2C Slave Address Register 3 (R/W) */
X  volatile uint32_t ADR3;                    
N  __I  uint32_t DATA_BUFFER;            /*!< Offset: 0x02C Data buffer register ( /W) */
X  volatile const  uint32_t DATA_BUFFER;             
N  __IO uint32_t MASK0;                  /*!< Offset: 0x030 I2C Slave address mask register 0 (R/W) */
X  volatile uint32_t MASK0;                   
N  __IO uint32_t MASK1;                  /*!< Offset: 0x034 I2C Slave address mask register 1 (R/W) */
X  volatile uint32_t MASK1;                   
N  __IO uint32_t MASK2;                  /*!< Offset: 0x038 I2C Slave address mask register 2 (R/W) */
X  volatile uint32_t MASK2;                   
N  __IO uint32_t MASK3;                  /*!< Offset: 0x03C I2C Slave address mask register 3 (R/W) */
X  volatile uint32_t MASK3;                   
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DAO;
X  volatile uint32_t DAO;
N  __IO uint32_t DAI;
X  volatile uint32_t DAI;
N  __O  uint32_t TXFIFO;
X  volatile  uint32_t TXFIFO;
N  __I  uint32_t RXFIFO;
X  volatile const  uint32_t RXFIFO;
N  __I  uint32_t STATE;
X  volatile const  uint32_t STATE;
N  __IO uint32_t DMA1;
X  volatile uint32_t DMA1;
N  __IO uint32_t DMA2;
X  volatile uint32_t DMA2;
N  __IO uint32_t IRQ;
X  volatile uint32_t IRQ;
N  __IO uint32_t TXRATE;
X  volatile uint32_t TXRATE;
N  __IO uint32_t RXRATE;
X  volatile uint32_t RXRATE;
N  __IO uint32_t TXBITRATE;
X  volatile uint32_t TXBITRATE;
N  __IO uint32_t RXBITRATE;
X  volatile uint32_t RXBITRATE;
N  __IO uint32_t TXMODE;
X  volatile uint32_t TXMODE;
N  __IO uint32_t RXMODE;
X  volatile uint32_t RXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N  __IO uint32_t ERSTATUS;
X  volatile uint32_t ERSTATUS;
N  __IO uint32_t ERCONTROL;
X  volatile uint32_t ERCONTROL;
N  __IO uint32_t ERCOUNTERS;
X  volatile uint32_t ERCOUNTERS;
N       uint32_t RESERVED22;
N  __IO uint32_t ERFIRSTSTAMP0;
X  volatile uint32_t ERFIRSTSTAMP0;
N  __IO uint32_t ERFIRSTSTAMP1;
X  volatile uint32_t ERFIRSTSTAMP1;
N  __IO uint32_t ERFIRSTSTAMP2;
X  volatile uint32_t ERFIRSTSTAMP2;
N       uint32_t RESERVED23;
N  __IO uint32_t ERLASTSTAMP0;
X  volatile uint32_t ERLASTSTAMP0;
N  __IO uint32_t ERLASTSTAMP1;
X  volatile uint32_t ERLASTSTAMP1;
N  __IO uint32_t ERLASTSTAMP2;
X  volatile uint32_t ERLASTSTAMP2;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  MOD;
X  volatile uint8_t  MOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __O  uint8_t  FEED;
X  volatile  uint8_t  FEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t TV;
X  volatile const  uint32_t TV;
N       uint32_t RESERVED2;
N  __IO uint32_t WARNINT;
X  volatile uint32_t WARNINT;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;                     /*!< Offset: 0x000       A/D Control Register (R/W) */
X  volatile uint32_t CR;                      
N  __IO uint32_t GDR;                    /*!< Offset: 0x004       A/D Global Data Register (R/W) */
X  volatile uint32_t GDR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t INTEN;                  /*!< Offset: 0x00C       A/D Interrupt Enable Register (R/W) */
X  volatile uint32_t INTEN;                   
N  __IO uint32_t DR[8];                  /*!< Offset: 0x010-0x02C A/D Channel 0..7 Data Register (R/W) */
X  volatile uint32_t DR[8];                   
N  __I  uint32_t STAT;                   /*!< Offset: 0x030       A/D Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t CNTVAL;
X  volatile uint32_t CNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t CON;
X  volatile const  uint32_t CON;
N  __O  uint32_t CON_SET;
X  volatile  uint32_t CON_SET;
N  __O  uint32_t CON_CLR;
X  volatile  uint32_t CON_CLR;
N  __I  uint32_t CAPCON;
X  volatile const  uint32_t CAPCON;
N  __O  uint32_t CAPCON_SET;
X  volatile  uint32_t CAPCON_SET;
N  __O  uint32_t CAPCON_CLR;
X  volatile  uint32_t CAPCON_CLR;
N  __IO uint32_t TC0;
X  volatile uint32_t TC0;
N  __IO uint32_t TC1;
X  volatile uint32_t TC1;
N  __IO uint32_t TC2;
X  volatile uint32_t TC2;
N  __IO uint32_t LIM0;
X  volatile uint32_t LIM0;
N  __IO uint32_t LIM1;
X  volatile uint32_t LIM1;
N  __IO uint32_t LIM2;
X  volatile uint32_t LIM2;
N  __IO uint32_t MAT0;
X  volatile uint32_t MAT0;
N  __IO uint32_t MAT1;
X  volatile uint32_t MAT1;
N  __IO uint32_t MAT2;
X  volatile uint32_t MAT2;
N  __IO uint32_t DT;
X  volatile uint32_t DT;
N  __IO uint32_t CP;
X  volatile uint32_t CP;
N  __IO uint32_t CAP0;
X  volatile uint32_t CAP0;
N  __IO uint32_t CAP1;
X  volatile uint32_t CAP1;
N  __IO uint32_t CAP2;
X  volatile uint32_t CAP2;
N  __I  uint32_t INTEN;
X  volatile const  uint32_t INTEN;
N  __O  uint32_t INTEN_SET;
X  volatile  uint32_t INTEN_SET;
N  __O  uint32_t INTEN_CLR;
X  volatile  uint32_t INTEN_CLR;
N  __I  uint32_t CNTCON;
X  volatile const  uint32_t CNTCON;
N  __O  uint32_t CNTCON_SET;
X  volatile  uint32_t CNTCON_SET;
N  __O  uint32_t CNTCON_CLR;
X  volatile  uint32_t CNTCON_CLR;
N  __I  uint32_t INTF;
X  volatile const  uint32_t INTF;
N  __O  uint32_t INTF_SET;
X  volatile  uint32_t INTF_SET;
N  __O  uint32_t INTF_CLR;
X  volatile  uint32_t INTF_CLR;
N  __O  uint32_t CAP_CLR;
X  volatile  uint32_t CAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t CON;
X  volatile  uint32_t CON;
N  __I  uint32_t STAT;
X  volatile const  uint32_t STAT;
N  __IO uint32_t CONF;
X  volatile uint32_t CONF;
N  __I  uint32_t POS;
X  volatile const  uint32_t POS;
N  __IO uint32_t MAXPOS;
X  volatile uint32_t MAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP0;
X  volatile uint32_t INXCMP0;
N  __IO uint32_t LOAD;
X  volatile uint32_t LOAD;
N  __I  uint32_t TIME;
X  volatile const  uint32_t TIME;
N  __I  uint32_t VEL;
X  volatile const  uint32_t VEL;
N  __I  uint32_t CAP;
X  volatile const  uint32_t CAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTERPHA;
X  volatile uint32_t FILTERPHA;
N  __IO uint32_t FILTERPHB;
X  volatile uint32_t FILTERPHB;
N  __IO uint32_t FILTERINX;
X  volatile uint32_t FILTERINX;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N  __IO uint32_t INXCMP1;
X  volatile uint32_t INXCMP1;
N  __IO uint32_t INXCMP2;
X  volatile uint32_t INXCMP2;
N       uint32_t RESERVED0[993];
N  __O  uint32_t IEC;
X  volatile  uint32_t IEC;
N  __O  uint32_t IES;
X  volatile  uint32_t IES;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __I  uint32_t IE;
X  volatile const  uint32_t IE;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N  __O  uint32_t SET;
X  volatile  uint32_t SET;
N} LPC_QEI_TypeDef;
N
N/*------------- SD/MMC card Interface (MCI)-----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t POWER;
X  volatile uint32_t POWER;
N  __IO uint32_t CLOCK;
X  volatile uint32_t CLOCK;
N  __IO uint32_t ARGUMENT;
X  volatile uint32_t ARGUMENT;
N  __IO uint32_t COMMAND;
X  volatile uint32_t COMMAND;
N  __I  uint32_t RESP_CMD;
X  volatile const  uint32_t RESP_CMD;
N  __I  uint32_t RESP0;
X  volatile const  uint32_t RESP0;
N  __I  uint32_t RESP1;
X  volatile const  uint32_t RESP1;
N  __I  uint32_t RESP2;
X  volatile const  uint32_t RESP2;
N  __I  uint32_t RESP3;
X  volatile const  uint32_t RESP3;
N  __IO uint32_t DATATMR;
X  volatile uint32_t DATATMR;
N  __IO uint32_t DATALEN;
X  volatile uint32_t DATALEN;
N  __IO uint32_t DATACTRL;
X  volatile uint32_t DATACTRL;
N  __I  uint32_t DATACNT;
X  volatile const  uint32_t DATACNT;
N  __I  uint32_t STATUS;
X  volatile const  uint32_t STATUS;
N  __O  uint32_t CLEAR;
X  volatile  uint32_t CLEAR;
N  __IO uint32_t MASK0;
X  volatile uint32_t MASK0;
N       uint32_t RESERVED0[2];
N  __I  uint32_t FIFOCNT;
X  volatile const  uint32_t FIFOCNT;
N       uint32_t RESERVED1[13];
N  __IO uint32_t FIFO;
X  volatile uint32_t FIFO;
N} LPC_MCI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t TxSR;
X  volatile const  uint32_t TxSR;
N  __I  uint32_t RxSR;
X  volatile const  uint32_t RxSR;
N  __I  uint32_t MSR;
X  volatile const  uint32_t MSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t IntStat;
X  volatile const  uint32_t IntStat;
N  __I  uint32_t IntTCStat;
X  volatile const  uint32_t IntTCStat;
N  __O  uint32_t IntTCClear;
X  volatile  uint32_t IntTCClear;
N  __I  uint32_t IntErrStat;
X  volatile const  uint32_t IntErrStat;
N  __O  uint32_t IntErrClr;
X  volatile  uint32_t IntErrClr;
N  __I  uint32_t RawIntTCStat;
X  volatile const  uint32_t RawIntTCStat;
N  __I  uint32_t RawIntErrStat;
X  volatile const  uint32_t RawIntErrStat;
N  __I  uint32_t EnbldChns;
X  volatile const  uint32_t EnbldChns;
N  __IO uint32_t SoftBReq;
X  volatile uint32_t SoftBReq;
N  __IO uint32_t SoftSReq;
X  volatile uint32_t SoftSReq;
N  __IO uint32_t SoftLBReq;
X  volatile uint32_t SoftLBReq;
N  __IO uint32_t SoftLSReq;
X  volatile uint32_t SoftLSReq;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N  __IO uint32_t Sync;
X  volatile uint32_t Sync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t CSrcAddr;
X  volatile uint32_t CSrcAddr;
N  __IO uint32_t CDestAddr;
X  volatile uint32_t CDestAddr;
N  __IO uint32_t CLLI;
X  volatile uint32_t CLLI;
N  __IO uint32_t CControl;
X  volatile uint32_t CControl;
N  __IO uint32_t CConfig;
X  volatile uint32_t CConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t Revision;             /* USB Host Registers                 */
X  volatile const  uint32_t Revision;              
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __IO uint32_t CommandStatus;
X  volatile uint32_t CommandStatus;
N  __IO uint32_t InterruptStatus;
X  volatile uint32_t InterruptStatus;
N  __IO uint32_t InterruptEnable;
X  volatile uint32_t InterruptEnable;
N  __IO uint32_t InterruptDisable;
X  volatile uint32_t InterruptDisable;
N  __IO uint32_t HCCA;
X  volatile uint32_t HCCA;
N  __I  uint32_t PeriodCurrentED;
X  volatile const  uint32_t PeriodCurrentED;
N  __IO uint32_t ControlHeadED;
X  volatile uint32_t ControlHeadED;
N  __IO uint32_t ControlCurrentED;
X  volatile uint32_t ControlCurrentED;
N  __IO uint32_t BulkHeadED;
X  volatile uint32_t BulkHeadED;
N  __IO uint32_t BulkCurrentED;
X  volatile uint32_t BulkCurrentED;
N  __I  uint32_t DoneHead;
X  volatile const  uint32_t DoneHead;
N  __IO uint32_t FmInterval;
X  volatile uint32_t FmInterval;
N  __I  uint32_t FmRemaining;
X  volatile const  uint32_t FmRemaining;
N  __I  uint32_t FmNumber;
X  volatile const  uint32_t FmNumber;
N  __IO uint32_t PeriodicStart;
X  volatile uint32_t PeriodicStart;
N  __IO uint32_t LSTreshold;
X  volatile uint32_t LSTreshold;
N  __IO uint32_t RhDescriptorA;
X  volatile uint32_t RhDescriptorA;
N  __IO uint32_t RhDescriptorB;
X  volatile uint32_t RhDescriptorB;
N  __IO uint32_t RhStatus;
X  volatile uint32_t RhStatus;
N  __IO uint32_t RhPortStatus1;
X  volatile uint32_t RhPortStatus1;
N  __IO uint32_t RhPortStatus2;
X  volatile uint32_t RhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t IntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t IntSt;                
N  __IO uint32_t IntEn;
X  volatile uint32_t IntEn;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N  __O  uint32_t IntClr;
X  volatile  uint32_t IntClr;
N  __IO uint32_t StCtrl;
X  volatile uint32_t StCtrl;
N  __IO uint32_t Tmr;
X  volatile uint32_t Tmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t DevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t DevIntSt;             
N  __IO uint32_t DevIntEn;
X  volatile uint32_t DevIntEn;
N  __O  uint32_t DevIntClr;
X  volatile  uint32_t DevIntClr;
N  __O  uint32_t DevIntSet;
X  volatile  uint32_t DevIntSet;
N
N  __O  uint32_t CmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t CmdCode;              
N  __I  uint32_t CmdData;
X  volatile const  uint32_t CmdData;
N
N  __I  uint32_t RxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t RxData;               
N  __O  uint32_t TxData;
X  volatile  uint32_t TxData;
N  __I  uint32_t RxPLen;
X  volatile const  uint32_t RxPLen;
N  __O  uint32_t TxPLen;
X  volatile  uint32_t TxPLen;
N  __IO uint32_t Ctrl;
X  volatile uint32_t Ctrl;
N  __O  uint32_t DevIntPri;
X  volatile  uint32_t DevIntPri;
N
N  __I  uint32_t EpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t EpIntSt;              
N  __IO uint32_t EpIntEn;
X  volatile uint32_t EpIntEn;
N  __O  uint32_t EpIntClr;
X  volatile  uint32_t EpIntClr;
N  __O  uint32_t EpIntSet;
X  volatile  uint32_t EpIntSet;
N  __O  uint32_t EpIntPri;
X  volatile  uint32_t EpIntPri;
N
N  __IO uint32_t ReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t ReEp;                 
N  __O  uint32_t EpInd;
X  volatile  uint32_t EpInd;
N  __IO uint32_t MaxPSize;
X  volatile uint32_t MaxPSize;
N
N  __I  uint32_t DMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t DMARSt;               
N  __O  uint32_t DMARClr;
X  volatile  uint32_t DMARClr;
N  __O  uint32_t DMARSet;
X  volatile  uint32_t DMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t UDCAH;
X  volatile uint32_t UDCAH;
N  __I  uint32_t EpDMASt;
X  volatile const  uint32_t EpDMASt;
N  __O  uint32_t EpDMAEn;
X  volatile  uint32_t EpDMAEn;
N  __O  uint32_t EpDMADis;
X  volatile  uint32_t EpDMADis;
N  __I  uint32_t DMAIntSt;
X  volatile const  uint32_t DMAIntSt;
N  __IO uint32_t DMAIntEn;
X  volatile uint32_t DMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t EoTIntSt;
X  volatile const  uint32_t EoTIntSt;
N  __O  uint32_t EoTIntClr;
X  volatile  uint32_t EoTIntClr;
N  __O  uint32_t EoTIntSet;
X  volatile  uint32_t EoTIntSet;
N  __I  uint32_t NDDRIntSt;
X  volatile const  uint32_t NDDRIntSt;
N  __O  uint32_t NDDRIntClr;
X  volatile  uint32_t NDDRIntClr;
N  __O  uint32_t NDDRIntSet;
X  volatile  uint32_t NDDRIntSet;
N  __I  uint32_t SysErrIntSt;
X  volatile const  uint32_t SysErrIntSt;
N  __O  uint32_t SysErrIntClr;
X  volatile  uint32_t SysErrIntClr;
N  __O  uint32_t SysErrIntSet;
X  volatile  uint32_t SysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __IO  uint32_t I2C_STS;
X  volatile  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __I  uint32_t RxFilterWoLStatus;
X  volatile const  uint32_t RxFilterWoLStatus;
N  __O  uint32_t RxFilterWoLClear;
X  volatile  uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N/*------------- LCD controller (LCD) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t TIMH;                   /* LCD Registers                      */
X  volatile uint32_t TIMH;                    
N  __IO uint32_t TIMV;
X  volatile uint32_t TIMV;
N  __IO uint32_t POL;
X  volatile uint32_t POL;
N  __IO uint32_t LE;
X  volatile uint32_t LE;
N  __IO uint32_t UPBASE;
X  volatile uint32_t UPBASE;
N  __IO uint32_t LPBASE;
X  volatile uint32_t LPBASE;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t INTMSK;
X  volatile uint32_t INTMSK;
N  __I  uint32_t INTRAW;
X  volatile const  uint32_t INTRAW;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __O  uint32_t INTCLR;
X  volatile  uint32_t INTCLR;
N  __I  uint32_t UPCURR;
X  volatile const  uint32_t UPCURR;
N  __I  uint32_t LPCURR;
X  volatile const  uint32_t LPCURR;
N       uint32_t RESERVED0[115];
N  __IO uint32_t PAL[128];
X  volatile uint32_t PAL[128];
N       uint32_t RESERVED1[256];
N  __IO uint32_t CRSR_IMG[256];
X  volatile uint32_t CRSR_IMG[256];
N  __IO uint32_t CRSR_CTRL;
X  volatile uint32_t CRSR_CTRL;
N  __IO uint32_t CRSR_CFG;
X  volatile uint32_t CRSR_CFG;
N  __IO uint32_t CRSR_PAL0;
X  volatile uint32_t CRSR_PAL0;
N  __IO uint32_t CRSR_PAL1;
X  volatile uint32_t CRSR_PAL1;
N  __IO uint32_t CRSR_XY;
X  volatile uint32_t CRSR_XY;
N  __IO uint32_t CRSR_CLIP;
X  volatile uint32_t CRSR_CLIP;
N       uint32_t RESERVED2[2];
N  __IO uint32_t CRSR_INTMSK;
X  volatile uint32_t CRSR_INTMSK;
N  __O  uint32_t CRSR_INTCLR;
X  volatile  uint32_t CRSR_INTCLR;
N  __I  uint32_t CRSR_INTRAW;
X  volatile const  uint32_t CRSR_INTRAW;
N  __I  uint32_t CRSR_INTSTAT;
X  volatile const  uint32_t CRSR_INTSTAT;
N} LPC_LCD_TypeDef;
N
N/*------------- External Memory Controller (EMC) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N       uint32_t RESERVED0[5];
N  __IO uint32_t DynamicControl;
X  volatile uint32_t DynamicControl;
N  __IO uint32_t DynamicRefresh;
X  volatile uint32_t DynamicRefresh;
N  __IO uint32_t DynamicReadConfig;
X  volatile uint32_t DynamicReadConfig;
N       uint32_t RESERVED1[1];
N  __IO uint32_t DynamicRP;
X  volatile uint32_t DynamicRP;
N  __IO uint32_t DynamicRAS;
X  volatile uint32_t DynamicRAS;
N  __IO uint32_t DynamicSREX;
X  volatile uint32_t DynamicSREX;
N  __IO uint32_t DynamicAPR;
X  volatile uint32_t DynamicAPR;
N  __IO uint32_t DynamicDAL;
X  volatile uint32_t DynamicDAL;
N  __IO uint32_t DynamicWR;
X  volatile uint32_t DynamicWR;
N  __IO uint32_t DynamicRC;
X  volatile uint32_t DynamicRC;
N  __IO uint32_t DynamicRFC;
X  volatile uint32_t DynamicRFC;
N  __IO uint32_t DynamicXSR;
X  volatile uint32_t DynamicXSR;
N  __IO uint32_t DynamicRRD;
X  volatile uint32_t DynamicRRD;
N  __IO uint32_t DynamicMRD;
X  volatile uint32_t DynamicMRD;
N       uint32_t RESERVED2[9];
N  __IO uint32_t StaticExtendedWait;
X  volatile uint32_t StaticExtendedWait;
N       uint32_t RESERVED3[31];
N  __IO uint32_t DynamicConfig0;
X  volatile uint32_t DynamicConfig0;
N  __IO uint32_t DynamicRasCas0;
X  volatile uint32_t DynamicRasCas0;
N       uint32_t RESERVED4[6];
N  __IO uint32_t DynamicConfig1;
X  volatile uint32_t DynamicConfig1;
N  __IO uint32_t DynamicRasCas1;
X  volatile uint32_t DynamicRasCas1;
N       uint32_t RESERVED5[6];
N  __IO uint32_t DynamicConfig2;
X  volatile uint32_t DynamicConfig2;
N  __IO uint32_t DynamicRasCas2;
X  volatile uint32_t DynamicRasCas2;
N       uint32_t RESERVED6[6];
N  __IO uint32_t DynamicConfig3;
X  volatile uint32_t DynamicConfig3;
N  __IO uint32_t DynamicRasCas3;
X  volatile uint32_t DynamicRasCas3;
N       uint32_t RESERVED7[38];
N  __IO uint32_t StaticConfig0;
X  volatile uint32_t StaticConfig0;
N  __IO uint32_t StaticWaitWen0;
X  volatile uint32_t StaticWaitWen0;
N  __IO uint32_t StaticWaitOen0;
X  volatile uint32_t StaticWaitOen0;
N  __IO uint32_t StaticWaitRd0;
X  volatile uint32_t StaticWaitRd0;
N  __IO uint32_t StaticWaitPage0;
X  volatile uint32_t StaticWaitPage0;
N  __IO uint32_t StaticWaitWr0;
X  volatile uint32_t StaticWaitWr0;
N  __IO uint32_t StaticWaitTurn0;
X  volatile uint32_t StaticWaitTurn0;
N       uint32_t RESERVED8[1];
N  __IO uint32_t StaticConfig1;
X  volatile uint32_t StaticConfig1;
N  __IO uint32_t StaticWaitWen1;
X  volatile uint32_t StaticWaitWen1;
N  __IO uint32_t StaticWaitOen1;
X  volatile uint32_t StaticWaitOen1;
N  __IO uint32_t StaticWaitRd1;
X  volatile uint32_t StaticWaitRd1;
N  __IO uint32_t StaticWaitPage1;
X  volatile uint32_t StaticWaitPage1;
N  __IO uint32_t StaticWaitWr1;
X  volatile uint32_t StaticWaitWr1;
N  __IO uint32_t StaticWaitTurn1;
X  volatile uint32_t StaticWaitTurn1;
N       uint32_t RESERVED9[1];
N  __IO uint32_t StaticConfig2;
X  volatile uint32_t StaticConfig2;
N  __IO uint32_t StaticWaitWen2;
X  volatile uint32_t StaticWaitWen2;
N  __IO uint32_t StaticWaitOen2;
X  volatile uint32_t StaticWaitOen2;
N  __IO uint32_t StaticWaitRd2;
X  volatile uint32_t StaticWaitRd2;
N  __IO uint32_t StaticWaitPage2;
X  volatile uint32_t StaticWaitPage2;
N  __IO uint32_t StaticWaitWr2;
X  volatile uint32_t StaticWaitWr2;
N  __IO uint32_t StaticWaitTurn2;
X  volatile uint32_t StaticWaitTurn2;
N       uint32_t RESERVED10[1];
N  __IO uint32_t StaticConfig3;
X  volatile uint32_t StaticConfig3;
N  __IO uint32_t StaticWaitWen3;
X  volatile uint32_t StaticWaitWen3;
N  __IO uint32_t StaticWaitOen3;
X  volatile uint32_t StaticWaitOen3;
N  __IO uint32_t StaticWaitRd3;
X  volatile uint32_t StaticWaitRd3;
N  __IO uint32_t StaticWaitPage3;
X  volatile uint32_t StaticWaitPage3;
N  __IO uint32_t StaticWaitWr3;
X  volatile uint32_t StaticWaitWr3;
N  __IO uint32_t StaticWaitTurn3;
X  volatile uint32_t StaticWaitTurn3;
N} LPC_EMC_TypeDef;
N
N/*------------- CRC Engine (CRC) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t MODE;
X  volatile uint32_t MODE;
N  __IO uint32_t SEED;
X  volatile uint32_t SEED;
N  union {
N  __I  uint32_t SUM;
X  volatile const  uint32_t SUM;
N  __O  uint32_t WR_DATA_DWORD;
X  volatile  uint32_t WR_DATA_DWORD;
N  __O  uint16_t WR_DATA_WORD;
X  volatile  uint16_t WR_DATA_WORD;
N       uint16_t RESERVED_WORD;
N  __O  uint8_t WR_DATA_BYTE;
X  volatile  uint8_t WR_DATA_BYTE;
N       uint8_t RESERVED_BYTE[3];
N  };
N} LPC_CRC_TypeDef;
N
N/*------------- EEPROM Controller (EEPROM) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CMD;			/* 0x0080 */
X  volatile uint32_t CMD;			 
N  __IO uint32_t ADDR;
X  volatile uint32_t ADDR;
N  __IO uint32_t WDATA;
X  volatile uint32_t WDATA;
N  __IO uint32_t RDATA;
X  volatile uint32_t RDATA;
N  __IO uint32_t WSTATE;			/* 0x0090 */
X  volatile uint32_t WSTATE;			 
N  __IO uint32_t CLKDIV;
X  volatile uint32_t CLKDIV;
N  __IO uint32_t PWRDWN;			/* 0x0098 */
X  volatile uint32_t PWRDWN;			 
N       uint32_t RESERVED0[975];
N  __IO uint32_t INT_CLR_ENABLE;	/* 0x0FD8 */
X  volatile uint32_t INT_CLR_ENABLE;	 
N  __IO uint32_t INT_SET_ENABLE;
X  volatile uint32_t INT_SET_ENABLE;
N  __IO uint32_t INT_STATUS;		/* 0x0FE0 */
X  volatile uint32_t INT_STATUS;		 
N  __IO uint32_t INT_ENABLE;
X  volatile uint32_t INT_ENABLE;
N  __IO uint32_t INT_CLR_STATUS;
X  volatile uint32_t INT_CLR_STATUS;
N  __IO uint32_t INT_SET_STATUS;
X  volatile uint32_t INT_SET_STATUS;
N} LPC_EEPROM_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_PERI_RAM_BASE     (0x20000000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHBRAM1_BASE      (0x20004000UL)
N#define LPC_AHB_BASE          (0x20080000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM0_BASE         (LPC_APB0_BASE + 0x14000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_IOCON_BASE        (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_UART4_BASE        (LPC_APB1_BASE + 0x24000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_SSP2_BASE         (LPC_APB1_BASE + 0x2C000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_MCI_BASE          (LPC_APB1_BASE + 0x40000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x00100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x00120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x00140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x00160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x00180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x001A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x001C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x001E0)
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x04000)
N#define LPC_LCD_BASE          (LPC_AHB_BASE  + 0x08000)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N#define LPC_CRC_BASE          (LPC_AHB_BASE  + 0x10000)
N#define LPC_GPIO0_BASE        (LPC_AHB_BASE  + 0x18000)
N#define LPC_GPIO1_BASE        (LPC_AHB_BASE  + 0x18020)
N#define LPC_GPIO2_BASE        (LPC_AHB_BASE  + 0x18040)
N#define LPC_GPIO3_BASE        (LPC_AHB_BASE  + 0x18060)
N#define LPC_GPIO4_BASE        (LPC_AHB_BASE  + 0x18080)
N#define LPC_GPIO5_BASE        (LPC_AHB_BASE  + 0x180A0)
N#define LPC_EMC_BASE          (LPC_AHB_BASE  + 0x1C000)
N
N#define LPC_EEPROM_BASE       (LPC_FLASH_BASE+ 0x200080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_UART0             ((LPC_UART_TypeDef      *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_UART4             ((LPC_UART4_TypeDef     *) LPC_UART4_BASE    )
N#define LPC_PWM0              ((LPC_PWM_TypeDef       *) LPC_PWM0_BASE     )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_IOCON             ((LPC_IOCON_TypeDef     *) LPC_IOCON_BASE    )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_SSP2              ((LPC_SSP_TypeDef       *) LPC_SSP2_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_MCI               ((LPC_MCI_TypeDef       *) LPC_MCI_BASE      )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_LCD               ((LPC_LCD_TypeDef       *) LPC_LCD_BASE      )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_GPIO5             ((LPC_GPIO_TypeDef      *) LPC_GPIO5_BASE    )
N#define LPC_EMC               ((LPC_EMC_TypeDef       *) LPC_EMC_BASE      )
N#define LPC_CRC               ((LPC_CRC_TypeDef       *) LPC_CRC_BASE      )
N#define LPC_EEPROM            ((LPC_EEPROM_TypeDef    *) LPC_EEPROM_BASE   )
N
N#endif  // __LPC177x_8x_H__
L 27 "..\Drivers\lpc177x_8x_uart.h" 2
N#include "lpc_types.h"
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup UART_Public_Macros  UART Public Macros
N * @{
N */
N
N/** UART time-out definitions in case of using Read() and Write function
N * with Blocking Flag mode
N */
N#define UART_BLOCKING_TIMEOUT			(0xFFFFFFUL)
N
N/**
N * @}
N */
N
N/* Private Macros ------------------------------------------------------------- */
N/** @defgroup UART_Private_Macros UART Private Macros
N * @{
N */
N
N/* Accepted Error baud rate value (in percent unit) */
N#define UART_ACCEPTED_BAUDRATE_ERROR	(3)			/*!< Acceptable UART baudrate error */
N
N
N/* --------------------- BIT DEFINITIONS -------------------------------------- */
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Receiver Buffer Register
N **********************************************************************/
N#define UART_RBR_MASKBIT   	((uint8_t)0xFF) 		/*!< UART Received Buffer mask bit (8 bits) */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Transmit Holding Register
N **********************************************************************/
N#define UART_THR_MASKBIT   	((uint8_t)0xFF) 		/*!< UART Transmit Holding mask bit (8 bits) */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Divisor Latch LSB register
N **********************************************************************/
N#define UART_LOAD_DLL(div)	((div) & 0xFF)	/**< Macro for loading least significant halfs of divisors */
N#define UART_DLL_MASKBIT	((uint8_t)0xFF)	/*!< Divisor latch LSB bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Divisor Latch MSB register
N **********************************************************************/
N#define UART_DLM_MASKBIT	((uint8_t)0xFF)			/*!< Divisor latch MSB bit mask */
N#define UART_LOAD_DLM(div)  (((div) >> 8) & 0xFF)	/**< Macro for loading most significant halfs of divisors */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART interrupt enable register
N **********************************************************************/
N#define UART_IER_RBRINT_EN		((uint32_t)(1<<0)) 	/*!< RBR Interrupt enable*/
N#define UART_IER_THREINT_EN		((uint32_t)(1<<1)) 	/*!< THR Interrupt enable*/
N#define UART_IER_RLSINT_EN		((uint32_t)(1<<2)) 	/*!< RX line status interrupt enable*/
N#define UART1_IER_MSINT_EN		((uint32_t)(1<<3))	/*!< Modem status interrupt enable */
N#define UART1_IER_CTSINT_EN		((uint32_t)(1<<7))	/*!< CTS1 signal transition interrupt enable */
N#define UART_IER_ABEOINT_EN		((uint32_t)(1<<8)) 	/*!< Enables the end of auto-baud interrupt */
N#define UART_IER_ABTOINT_EN		((uint32_t)(1<<9)) 	/*!< Enables the auto-baud time-out interrupt */
N#define UART_IER_BITMASK		((uint32_t)(0x307)) /*!< UART interrupt enable register bit mask */
N#define UART1_IER_BITMASK		((uint32_t)(0x38F)) /*!< UART1 interrupt enable register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART interrupt identification register
N **********************************************************************/
N#define UART_IIR_INTSTAT_PEND	((uint32_t)(1<<0))	/*!<Interrupt Status - Active low */
N#define UART_IIR_INTID_RLS		((uint32_t)(3<<1)) 	/*!<Interrupt identification: Receive line status*/
N#define UART_IIR_INTID_RDA		((uint32_t)(2<<1)) 	/*!<Interrupt identification: Receive data available*/
N#define UART_IIR_INTID_CTI		((uint32_t)(6<<1)) 	/*!<Interrupt identification: Character time-out indicator*/
N#define UART_IIR_INTID_THRE		((uint32_t)(1<<1)) 	/*!<Interrupt identification: THRE interrupt*/
N#define UART1_IIR_INTID_MODEM	((uint32_t)(0<<1)) 	/*!<Interrupt identification: Modem interrupt*/
N#define UART_IIR_INTID_MASK		((uint32_t)(7<<1))	/*!<Interrupt identification: Interrupt ID mask */
N#define UART_IIR_FIFO_EN		((uint32_t)(3<<6)) 	/*!<These bits are equivalent to UnFCR[0] */
N#define UART_IIR_ABEO_INT		((uint32_t)(1<<8)) 	/*!< End of auto-baud interrupt */
N#define UART_IIR_ABTO_INT		((uint32_t)(1<<9)) 	/*!< Auto-baud time-out interrupt */
N#define UART_IIR_BITMASK		((uint32_t)(0x3CF))	/*!< UART interrupt identification register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART FIFO control register
N **********************************************************************/
N#define UART_FCR_FIFO_EN		((uint8_t)(1<<0)) 	/*!< UART FIFO enable */
N#define UART_FCR_RX_RS			((uint8_t)(1<<1)) 	/*!< UART FIFO RX reset */
N#define UART_FCR_TX_RS			((uint8_t)(1<<2)) 	/*!< UART FIFO TX reset */
N#define UART_FCR_DMAMODE_SEL 	((uint8_t)(1<<3)) 	/*!< UART DMA mode selection */
N#define UART_FCR_TRG_LEV0		((uint8_t)(0)) 		/*!< UART FIFO trigger level 0: 1 character */
N#define UART_FCR_TRG_LEV1		((uint8_t)(1<<6)) 	/*!< UART FIFO trigger level 1: 4 character */
N#define UART_FCR_TRG_LEV2		((uint8_t)(2<<6)) 	/*!< UART FIFO trigger level 2: 8 character */
N#define UART_FCR_TRG_LEV3		((uint8_t)(3<<6)) 	/*!< UART FIFO trigger level 3: 14 character */
N#define UART_FCR_BITMASK		((uint8_t)(0xCF))	/*!< UART FIFO control bit mask */
N#define UART_TX_FIFO_SIZE		(16)
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART line control register
N **********************************************************************/
N#define UART_LCR_WLEN5     		((uint8_t)(0))   		/*!< UART 5 bit data mode */
N#define UART_LCR_WLEN6     		((uint8_t)(1<<0))   	/*!< UART 6 bit data mode */
N#define UART_LCR_WLEN7     		((uint8_t)(2<<0))   	/*!< UART 7 bit data mode */
N#define UART_LCR_WLEN8     		((uint8_t)(3<<0))   	/*!< UART 8 bit data mode */
N#define UART_LCR_STOPBIT_SEL	((uint8_t)(1<<2))   	/*!< UART Two Stop Bits Select */
N#define UART_LCR_PARITY_EN		((uint8_t)(1<<3))		/*!< UART Parity Enable */
N#define UART_LCR_PARITY_ODD		((uint8_t)(0))         	/*!< UART Odd Parity Select */
N#define UART_LCR_PARITY_EVEN	((uint8_t)(1<<4))		/*!< UART Even Parity Select */
N#define UART_LCR_PARITY_F_1		((uint8_t)(2<<4))		/*!< UART force 1 stick parity */
N#define UART_LCR_PARITY_F_0		((uint8_t)(3<<4))		/*!< UART force 0 stick parity */
N#define UART_LCR_BREAK_EN		((uint8_t)(1<<6))		/*!< UART Transmission Break enable */
N#define UART_LCR_DLAB_EN		((uint8_t)(1<<7))    	/*!< UART Divisor Latches Access bit enable */
N#define UART_LCR_BITMASK		((uint8_t)(0xFF))		/*!< UART line control bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 Modem Control Register
N **********************************************************************/
N#define UART1_MCR_DTR_CTRL		((uint8_t)(1<<0))		/*!< Source for modem output pin DTR */
N#define UART1_MCR_RTS_CTRL		((uint8_t)(1<<1))		/*!< Source for modem output pin RTS */
N#define UART1_MCR_LOOPB_EN		((uint8_t)(1<<4))		/*!< Loop back mode select */
N#define UART1_MCR_AUTO_RTS_EN	((uint8_t)(1<<6))		/*!< Enable Auto RTS flow-control */
N#define UART1_MCR_AUTO_CTS_EN	((uint8_t)(1<<7))		/*!< Enable Auto CTS flow-control */
N#define UART1_MCR_BITMASK		((uint8_t)(0x0F3))		/*!< UART1 bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART line status register
N **********************************************************************/
N#define UART_LSR_RDR		((uint8_t)(1<<0)) 	/*!<Line status register: Receive data ready*/
N#define UART_LSR_OE			((uint8_t)(1<<1)) 	/*!<Line status register: Overrun error*/
N#define UART_LSR_PE			((uint8_t)(1<<2)) 	/*!<Line status register: Parity error*/
N#define UART_LSR_FE			((uint8_t)(1<<3)) 	/*!<Line status register: Framing error*/
N#define UART_LSR_BI			((uint8_t)(1<<4)) 	/*!<Line status register: Break interrupt*/
N#define UART_LSR_THRE		((uint8_t)(1<<5)) 	/*!<Line status register: Transmit holding register empty*/
N#define UART_LSR_TEMT		((uint8_t)(1<<6)) 	/*!<Line status register: Transmitter empty*/
N#define UART_LSR_RXFE		((uint8_t)(1<<7)) 	/*!<Error in RX FIFO*/
N#define UART_LSR_BITMASK	((uint8_t)(0xFF)) 	/*!<UART Line status bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Modem (UART1 only) status register
N **********************************************************************/
N#define UART1_MSR_DELTA_CTS		((uint8_t)(1<<0))	/*!< Set upon state change of input CTS */
N#define UART1_MSR_DELTA_DSR		((uint8_t)(1<<1))	/*!< Set upon state change of input DSR */
N#define UART1_MSR_LO2HI_RI		((uint8_t)(1<<2))	/*!< Set upon low to high transition of input RI */
N#define UART1_MSR_DELTA_DCD		((uint8_t)(1<<3))	/*!< Set upon state change of input DCD */
N#define UART1_MSR_CTS			((uint8_t)(1<<4))	/*!< Clear To Send State */
N#define UART1_MSR_DSR			((uint8_t)(1<<5))	/*!< Data Set Ready State */
N#define UART1_MSR_RI			((uint8_t)(1<<6))	/*!< Ring Indicator State */
N#define UART1_MSR_DCD			((uint8_t)(1<<7))	/*!< Data Carrier Detect State */
N#define UART1_MSR_BITMASK		((uint8_t)(0xFF))	/*!< MSR register bit-mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Scratch Pad Register
N **********************************************************************/
N#define UART_SCR_BIMASK		((uint8_t)(0xFF))	/*!< UART Scratch Pad bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Auto baudrate control register
N **********************************************************************/
N#define UART_ACR_START				((uint32_t)(1<<0))	/**< UART Auto-baud start */
N#define UART_ACR_MODE				((uint32_t)(1<<1))	/**< UART Auto baudrate Mode 1 */
N#define UART_ACR_AUTO_RESTART		((uint32_t)(1<<2))	/**< UART Auto baudrate restart */
N#define UART_ACR_ABEOINT_CLR		((uint32_t)(1<<8))	/**< UART End of auto-baud interrupt clear */
N#define UART_ACR_ABTOINT_CLR		((uint32_t)(1<<9))	/**< UART Auto-baud time-out interrupt clear */
N#define UART_ACR_BITMASK			((uint32_t)(0x307))	/**< UART Auto Baudrate register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART IrDA control register
N **********************************************************************/
N#define UART_ICR_IRDAEN			((uint32_t)(1<<0))			/**< IrDA mode enable */
N#define UART_ICR_IRDAINV		((uint32_t)(1<<1))			/**< IrDA serial input inverted */
N#define UART_ICR_FIXPULSE_EN	((uint32_t)(1<<2))			/**< IrDA fixed pulse width mode */
N#define UART_ICR_PULSEDIV(n)	((uint32_t)((n&0x07)<<3))	/**< PulseDiv - Configures the pulse when FixPulseEn = 1 */
N#define UART_ICR_BITMASK		((uint32_t)(0x3F))			/*!< UART IRDA bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Fractional divider register
N **********************************************************************/
N#define UART_FDR_DIVADDVAL(n)	((uint32_t)(n&0x0F))		/**< Baud-rate generation pre-scaler divisor */
N#define UART_FDR_MULVAL(n)		((uint32_t)((n<<4)&0xF0))	/**< Baud-rate pre-scaler multiplier value */
N#define UART_FDR_BITMASK		((uint32_t)(0xFF))			/**< UART Fractional Divider register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Tx Enable register
N **********************************************************************/
N#define UART_TER_TXEN			((uint8_t)(1<<7)) 		/*!< Transmit enable bit */
N#define UART_TER_BITMASK		((uint8_t)(0x80))		/**< UART Transmit Enable Register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS485 Control register
N **********************************************************************/
N#define UART1_RS485CTRL_NMM_EN		((uint32_t)(1<<0))	/*!< RS-485/EIA-485 Normal Multi-drop Mode (NMM)
N														is disabled */
N#define UART1_RS485CTRL_RX_DIS		((uint32_t)(1<<1))	/*!< The receiver is disabled */
N#define UART1_RS485CTRL_AADEN		((uint32_t)(1<<2))	/*!< Auto Address Detect (AAD) is enabled */
N#define UART1_RS485CTRL_SEL_DTR		((uint32_t)(1<<3))	/*!< If direction control is enabled
N														(bit DCTRL = 1), pin DTR is used for direction control */
N#define UART1_RS485CTRL_DCTRL_EN	((uint32_t)(1<<4))	/*!< Enable Auto Direction Control */
N#define UART1_RS485CTRL_OINV_1		((uint32_t)(1<<5))	/*!< This bit reverses the polarity of the direction
N														control signal on the RTS (or DTR) pin. The direction control pin
N														will be driven to logic "1" when the transmitter has data to be sent */
N#define UART1_RS485CTRL_BITMASK		((uint32_t)(0x3F))	/**< RS485 control bit-mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS-485 Address Match register
N **********************************************************************/
N#define UART1_RS485ADRMATCH_BITMASK ((uint8_t)(0xFF)) 	/**< Bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS-485 Delay value register
N **********************************************************************/
N/* Macro defines for UART1 RS-485 Delay value register */
N#define UART1_RS485DLY_BITMASK		((uint8_t)(0xFF)) 	/** Bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART FIFO Level register
N **********************************************************************/
N#define UART_FIFOLVL_RXFIFOLVL(n)	((uint32_t)(n&0x0F))		/**< Reflects the current level of the UART receiver FIFO */
N#define UART_FIFOLVL_TXFIFOLVL(n)	((uint32_t)((n>>8)&0x0F))	/**< Reflects the current level of the UART transmitter FIFO */
N#define UART_FIFOLVL_BITMASK		((uint32_t)(0x0F0F))		/**< UART FIFO Level Register bit mask */
N
N
N/**
N * @}
N */
N
N
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup UART_Public_Types UART Public Types
N * @{
N */
N
N/**
N * @brief UART Databit type definitions
N */
Ntypedef enum {
N	UART_DATABIT_5		= 0,     		/*!< UART 5 bit data mode */
N	UART_DATABIT_6,		     			/*!< UART 6 bit data mode */
N	UART_DATABIT_7,		     			/*!< UART 7 bit data mode */
N	UART_DATABIT_8		     			/*!< UART 8 bit data mode */
N} UART_DATABIT_Type;
N
N/**
N * @brief UART Stop bit type definitions
N */
Ntypedef enum {
N	UART_STOPBIT_1		= (0),   					/*!< UART 1 Stop Bits Select */
N	UART_STOPBIT_2,		 							/*!< UART Two Stop Bits Select */
N} UART_STOPBIT_Type;
N
N/**
N * @brief UART Parity type definitions
N */
Ntypedef enum {
N	UART_PARITY_NONE 	= 0,					/*!< No parity */
N	UART_PARITY_ODD,	 						/*!< Odd parity */
N	UART_PARITY_EVEN, 							/*!< Even parity */
N	UART_PARITY_SP_1, 							/*!< Forced "1" stick parity */
N	UART_PARITY_SP_0 							/*!< Forced "0" stick parity */
N} UART_PARITY_Type;
N
N/**
N * @brief FIFO Level type definitions
N */
Ntypedef enum {
N	UART_FIFO_TRGLEV0 = 0,	/*!< UART FIFO trigger level 0: 1 character */
N	UART_FIFO_TRGLEV1, 		/*!< UART FIFO trigger level 1: 4 character */
N	UART_FIFO_TRGLEV2,		/*!< UART FIFO trigger level 2: 8 character */
N	UART_FIFO_TRGLEV3		/*!< UART FIFO trigger level 3: 14 character */
N} UART_FITO_LEVEL_Type;
N
N/********************************************************************//**
N* @brief UART Interrupt Type definitions
N**********************************************************************/
Ntypedef enum {
N	UART_INTCFG_RBR = 0,	/*!< RBR Interrupt enable*/
N	UART_INTCFG_THRE,		/*!< THR Interrupt enable*/
N	UART_INTCFG_RLS,		/*!< RX line status interrupt enable*/
N	UART1_INTCFG_MS,		/*!< Modem status interrupt enable (UART1 only) */
N	UART1_INTCFG_CTS,		/*!< CTS1 signal transition interrupt enable (UART1 only) */
N	UART_INTCFG_ABEO,		/*!< Enables the end of auto-baud interrupt */
N	UART_INTCFG_ABTO		/*!< Enables the auto-baud time-out interrupt */
N} UART_INT_Type;
N
N/**
N * @brief UART Line Status Type definition
N */
Ntypedef enum {
N	UART_LINESTAT_RDR	= UART_LSR_RDR,			/*!<Line status register: Receive data ready*/
X	UART_LINESTAT_RDR	= ((uint8_t)(1<<0)),			 
N	UART_LINESTAT_OE	= UART_LSR_OE,			/*!<Line status register: Overrun error*/
X	UART_LINESTAT_OE	= ((uint8_t)(1<<1)),			 
N	UART_LINESTAT_PE	= UART_LSR_PE,			/*!<Line status register: Parity error*/
X	UART_LINESTAT_PE	= ((uint8_t)(1<<2)),			 
N	UART_LINESTAT_FE	= UART_LSR_FE,			/*!<Line status register: Framing error*/
X	UART_LINESTAT_FE	= ((uint8_t)(1<<3)),			 
N	UART_LINESTAT_BI	= UART_LSR_BI,			/*!<Line status register: Break interrupt*/
X	UART_LINESTAT_BI	= ((uint8_t)(1<<4)),			 
N	UART_LINESTAT_THRE	= UART_LSR_THRE,		/*!<Line status register: Transmit holding register empty*/
X	UART_LINESTAT_THRE	= ((uint8_t)(1<<5)),		 
N	UART_LINESTAT_TEMT	= UART_LSR_TEMT,		/*!<Line status register: Transmitter empty*/
X	UART_LINESTAT_TEMT	= ((uint8_t)(1<<6)),		 
N	UART_LINESTAT_RXFE	= UART_LSR_RXFE			/*!<Error in RX FIFO*/
X	UART_LINESTAT_RXFE	= ((uint8_t)(1<<7))			 
N} UART_LS_Type;
N
N/**
N * @brief UART Auto-baudrate mode type definition
N */
Ntypedef enum {
N	UART_AUTOBAUD_MODE0				= 0,			/**< UART Auto baudrate Mode 0 */
N	UART_AUTOBAUD_MODE1,							/**< UART Auto baudrate Mode 1 */
N} UART_AB_MODE_Type;
N
N/**
N * @brief Auto Baudrate mode configuration type definition
N */
Ntypedef struct {
N	UART_AB_MODE_Type	ABMode;			/**< Autobaudrate mode */
N	FunctionalState		AutoRestart;	/**< Auto Restart state */
N} UART_AB_CFG_Type;
N
N/**
N * @brief UART End of Auto-baudrate type definition
N */
Ntypedef enum {
N	UART_AUTOBAUD_INTSTAT_ABEO		= UART_IIR_ABEO_INT,		/**< UART End of auto-baud interrupt  */
X	UART_AUTOBAUD_INTSTAT_ABEO		= ((uint32_t)(1<<8)),		 
N	UART_AUTOBAUD_INTSTAT_ABTO		= UART_IIR_ABTO_INT			/**< UART Auto-baud time-out interrupt  */
X	UART_AUTOBAUD_INTSTAT_ABTO		= ((uint32_t)(1<<9))			 
N}UART_ABEO_Type;
N
N/**
N * UART IrDA Control type Definition
N */
Ntypedef enum {
N	UART_IrDA_PULSEDIV2		= 0,		/**< Pulse width = 2 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV4,				/**< Pulse width = 4 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV8,				/**< Pulse width = 8 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV16,				/**< Pulse width = 16 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV32,				/**< Pulse width = 32 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV64,				/**< Pulse width = 64 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV128,				/**< Pulse width = 128 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV256				/**< Pulse width = 256 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N} UART_IrDA_PULSE_Type;
N
N/********************************************************************//**
N* @brief UART1 Full modem -  Signal states definition
N**********************************************************************/
Ntypedef enum {
N	INACTIVE = 0,			/* In-active state */
N	ACTIVE = !INACTIVE 		/* Active state */
N}UART1_SignalState;
N
N/**
N * @brief UART modem status type definition
N */
Ntypedef enum {
N	UART1_MODEM_STAT_DELTA_CTS	= UART1_MSR_DELTA_CTS,		/*!< Set upon state change of input CTS */
X	UART1_MODEM_STAT_DELTA_CTS	= ((uint8_t)(1<<0)),		 
N	UART1_MODEM_STAT_DELTA_DSR	= UART1_MSR_DELTA_DSR,		/*!< Set upon state change of input DSR */
X	UART1_MODEM_STAT_DELTA_DSR	= ((uint8_t)(1<<1)),		 
N	UART1_MODEM_STAT_LO2HI_RI	= UART1_MSR_LO2HI_RI,		/*!< Set upon low to high transition of input RI */
X	UART1_MODEM_STAT_LO2HI_RI	= ((uint8_t)(1<<2)),		 
N	UART1_MODEM_STAT_DELTA_DCD	= UART1_MSR_DELTA_DCD,		/*!< Set upon state change of input DCD */
X	UART1_MODEM_STAT_DELTA_DCD	= ((uint8_t)(1<<3)),		 
N	UART1_MODEM_STAT_CTS		= UART1_MSR_CTS,			/*!< Clear To Send State */
X	UART1_MODEM_STAT_CTS		= ((uint8_t)(1<<4)),			 
N	UART1_MODEM_STAT_DSR		= UART1_MSR_DSR,			/*!< Data Set Ready State */
X	UART1_MODEM_STAT_DSR		= ((uint8_t)(1<<5)),			 
N	UART1_MODEM_STAT_RI			= UART1_MSR_RI,				/*!< Ring Indicator State */
X	UART1_MODEM_STAT_RI			= ((uint8_t)(1<<6)),				 
N	UART1_MODEM_STAT_DCD		= UART1_MSR_DCD				/*!< Data Carrier Detect State */
X	UART1_MODEM_STAT_DCD		= ((uint8_t)(1<<7))				 
N} UART_MODEM_STAT_type;
N
N/**
N * @brief Modem output pin type definition
N */
Ntypedef enum {
N	UART1_MODEM_PIN_DTR			= 0,		/*!< Source for modem output pin DTR */
N	UART1_MODEM_PIN_RTS						/*!< Source for modem output pin RTS */
N} UART_MODEM_PIN_Type;
N
N/**
N * @brief UART Modem mode type definition
N */
Ntypedef enum {
N	UART1_MODEM_MODE_LOOPBACK	= 0,		/*!< Loop back mode select */
N	UART1_MODEM_MODE_AUTO_RTS,				/*!< Enable Auto RTS flow-control */
N	UART1_MODEM_MODE_AUTO_CTS 				/*!< Enable Auto CTS flow-control */
N} UART_MODEM_MODE_Type;
N
N/**
N * @brief UART Direction Control Pin type definition
N */
Ntypedef enum {
N	UART1_RS485_DIRCTRL_RTS = 0,	/**< Pin RTS is used for direction control */
N	UART1_RS485_DIRCTRL_DTR			/**< Pin DTR is used for direction control */
N} UART_RS485_DIRCTRL_PIN_Type;
N
N/********************************************************************//**
N* @brief UART Configuration Structure definition
N**********************************************************************/
Ntypedef struct {
N  uint32_t Baud_rate;   		/**< UART baud rate */
N  UART_PARITY_Type Parity;    	/**< Parity selection, should be:
N							   - UART_PARITY_NONE: No parity
N							   - UART_PARITY_ODD: Odd parity
N							   - UART_PARITY_EVEN: Even parity
N							   - UART_PARITY_SP_1: Forced "1" stick parity
N							   - UART_PARITY_SP_0: Forced "0" stick parity
N							   */
N  UART_DATABIT_Type Databits;   /**< Number of data bits, should be:
N							   - UART_DATABIT_5: UART 5 bit data mode
N							   - UART_DATABIT_6: UART 6 bit data mode
N							   - UART_DATABIT_7: UART 7 bit data mode
N							   - UART_DATABIT_8: UART 8 bit data mode
N							   */
N  UART_STOPBIT_Type Stopbits;   /**< Number of stop bits, should be:
N							   - UART_STOPBIT_1: UART 1 Stop Bits Select
N							   - UART_STOPBIT_2: UART 2 Stop Bits Select
N							   */
N} UART_CFG_Type;
N
N/********************************************************************//**
N* @brief UART FIFO Configuration Structure definition
N**********************************************************************/
N
Ntypedef struct {
N	FunctionalState FIFO_ResetRxBuf;	/**< Reset Rx FIFO command state , should be:
N										 - ENABLE: Reset Rx FIFO in UART
N										 - DISABLE: Do not reset Rx FIFO  in UART
N										 */
N	FunctionalState FIFO_ResetTxBuf;	/**< Reset Tx FIFO command state , should be:
N										 - ENABLE: Reset Tx FIFO in UART
N										 - DISABLE: Do not reset Tx FIFO  in UART
N										 */
N	FunctionalState FIFO_DMAMode;		/**< DMA mode, should be:
N										 - ENABLE: Enable DMA mode in UART
N										 - DISABLE: Disable DMA mode in UART
N										 */
N	UART_FITO_LEVEL_Type FIFO_Level;	/**< Rx FIFO trigger level, should be:
N										- UART_FIFO_TRGLEV0: UART FIFO trigger level 0: 1 character
N										- UART_FIFO_TRGLEV1: UART FIFO trigger level 1: 4 character
N										- UART_FIFO_TRGLEV2: UART FIFO trigger level 2: 8 character
N										- UART_FIFO_TRGLEV3: UART FIFO trigger level 3: 14 character
N										*/
N} UART_FIFO_CFG_Type;
N
N/********************************************************************//**
N* @brief UART1 Full modem -  RS485 Control configuration type
N**********************************************************************/
Ntypedef struct {
N	FunctionalState NormalMultiDropMode_State; /*!< Normal MultiDrop mode State:
N													- ENABLE: Enable this function.
N													- DISABLE: Disable this function. */
N	FunctionalState Rx_State;					/*!< Receiver State:
N													- ENABLE: Enable Receiver.
N													- DISABLE: Disable Receiver. */
N	FunctionalState AutoAddrDetect_State;		/*!< Auto Address Detect mode state:
N												- ENABLE: ENABLE this function.
N												- DISABLE: Disable this function. */
N	FunctionalState AutoDirCtrl_State;			/*!< Auto Direction Control State:
N												- ENABLE: Enable this function.
N												- DISABLE: Disable this function. */
N	UART_RS485_DIRCTRL_PIN_Type DirCtrlPin;		/*!< If direction control is enabled, state:
N												- UART1_RS485_DIRCTRL_RTS:
N												pin RTS is used for direction control.
N												- UART1_RS485_DIRCTRL_DTR:
N												pin DTR is used for direction control. */
N	 SetState DirCtrlPol_Level;					/*!< Polarity of the direction control signal on
N												the RTS (or DTR) pin:
N												- RESET: The direction control pin will be driven
N												to logic "0" when the transmitter has data to be sent.
N												- SET: The direction control pin will be driven
N												to logic "1" when the transmitter has data to be sent. */
N	uint8_t MatchAddrValue;					/*!< address match value for RS-485/EIA-485 mode, 8-bit long */
N	uint8_t DelayValue;						/*!< delay time is in periods of the baud clock, 8-bit long */
N} UART1_RS485_CTRLCFG_Type;
N
N/**
N * @}
N */
N
N
N/* Public Functions ----------------------------------------------------------- */
N/** @defgroup UART_Public_Functions UART Public Functions
N * @{
N */
N/* UART Init/DeInit functions --------------------------------------------------*/
Nvoid UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct);
Nvoid UART_DeInit(LPC_UART_TypeDef* UARTx);
Nvoid UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct);
N
N/* UART Send/Receive functions -------------------------------------------------*/
Nvoid UART_SendByte(LPC_UART_TypeDef* UARTx, uint8_t Data);
Nuint8_t UART_ReceiveByte(LPC_UART_TypeDef* UARTx);
Nuint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
N		uint32_t buflen, TRANSFER_BLOCK_Type flag);
Nuint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
N		uint32_t buflen, TRANSFER_BLOCK_Type flag);
Xuint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, 		uint32_t buflen, TRANSFER_BLOCK_Type flag);
N
N/* UART FIFO functions ----------------------------------------------------------*/
Nvoid UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg);
Nvoid UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct);
N
N/* UART get information functions -----------------------------------------------*/
Nuint32_t UART_GetIntId(LPC_UART_TypeDef* UARTx);
Nuint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx);
N
N/* UART operate functions -------------------------------------------------------*/
Nvoid UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, \
N				FunctionalState NewState);
Xvoid UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, 				FunctionalState NewState);
Nvoid UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState);
NFlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx);
Nvoid UART_ForceBreak(LPC_UART_TypeDef* UARTx);
N
N/* UART Auto-baud functions -----------------------------------------------------*/
Nvoid UART_ABClearIntPending(LPC_UART_TypeDef *UARTx, UART_ABEO_Type ABIntType);
Nvoid UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
N				FunctionalState NewState);
Xvoid UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, 				FunctionalState NewState);
N
N/* UART1 FullModem functions ----------------------------------------------------*/
Nvoid UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
N							UART1_SignalState NewState);
Xvoid UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, 							UART1_SignalState NewState);
Nvoid UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
N							FunctionalState NewState);
Xvoid UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, 							FunctionalState NewState);
Nuint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx);
N
N/* UART RS485 functions ----------------------------------------------------------*/
Nvoid UART_RS485Config(LPC_UART_TypeDef *UARTx,
N									UART1_RS485_CTRLCFG_Type *RS485ConfigStruct);
Nvoid UART_RS485ReceiverCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState);
Nvoid UART_RS485SendSlvAddr(LPC_UART_TypeDef *UARTx, uint8_t SlvAddr);
Nuint32_t UART_RS485SendData(LPC_UART_TypeDef *UARTx, uint8_t *pData, uint32_t size);
N
N/* UART IrDA functions-------------------------------------------------------------*/
Nvoid UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
Nvoid UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
Nvoid UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv);
N/**
N * @}
N */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __LPC178X_UART_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
L 24 "..\Drivers\debug_frmwrk.h" 2
N
N#define USED_UART_DEBUG_PORT	0// 1
N
N#define NUM_SKIPPED_ALLOWED			(10)
N
N#define DBG_GETVAL_IN_DEC			(0)
N#define DBG_GETVAL_IN_HEX			(1)
N//#define DBG_GETVAL_IN_CHARS			(2)
N
N#if (USED_UART_DEBUG_PORT == 0)
X#if (0 == 0)
N#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART0
N#elif (USED_UART_DEBUG_PORT == 1)
S#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART1
S#elif (USED_UART_DEBUG_PORT == 2)
S#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART2
N#endif
N
N#define put_str(x)							_db_msg(DEBUG_UART_PORT, x)
N#define put_str_(x)							_db_msg_(DEBUG_UART_PORT, x)
N
N#define  putchar(x)						    _db_char(DEBUG_UART_PORT, x)
N
N#define _DBD(x)								_db_dec(DEBUG_UART_PORT, x)
N#define _DBD16(x)							_db_dec_16(DEBUG_UART_PORT, x)
N#define _DBD32(x)							_db_dec_32(DEBUG_UART_PORT, x)
N
N#define _DBH(x)								_db_hex(DEBUG_UART_PORT, x)
N#define _DBH16(x)							_db_hex_16(DEBUG_UART_PORT, x)
N#define _DBH32(x)							_db_hex_32(DEBUG_UART_PORT, x)
N
N#define _DBH_(x)							_db_hex_(DEBUG_UART_PORT, x)
N#define _DBH16_(x)							_db_hex_16_(DEBUG_UART_PORT, x)
N#define _DBH32_(x)							_db_hex_32_(DEBUG_UART_PORT, x)
N
N#define getkey()							_db_get_key(DEBUG_UART_PORT)
N#define getchar()							_db_get_char(DEBUG_UART_PORT)
N#define _DGV(option, numCh, val)			_db_get_val(DEBUG_UART_PORT, option, numCh, val)
N
N//void  _printf (const  char *format, ...);
N
Nextern void (*_db_msg)(LPC_UART_TypeDef *UARTx, const void *s);
Nextern void (*_db_msg_)(LPC_UART_TypeDef *UARTx, const void *s);
Nextern void (*_db_char)(LPC_UART_TypeDef *UARTx, uint8_t ch);
Nextern void (*_db_dec)(LPC_UART_TypeDef *UARTx, uint8_t decn);
Nextern void (*_db_dec_16)(LPC_UART_TypeDef *UARTx, uint16_t decn);
Nextern void (*_db_dec_32)(LPC_UART_TypeDef *UARTx, uint32_t decn);
Nextern void (*_db_hex)(LPC_UART_TypeDef *UARTx, uint8_t hexn);
Nextern void (*_db_hex_16)(LPC_UART_TypeDef *UARTx, uint16_t hexn);
Nextern void (*_db_hex_32)(LPC_UART_TypeDef *UARTx, uint32_t hexn);
Nextern void (*_db_hex_)(LPC_UART_TypeDef *UARTx, uint8_t hexn);
Nextern void (*_db_hex_16_)(LPC_UART_TypeDef *UARTx, uint16_t hexn);
Nextern void (*_db_hex_32_)(LPC_UART_TypeDef *UARTx, uint32_t hexn);
N
Nextern uint8_t (*_db_get_key)(LPC_UART_TypeDef *UARTx);
Nextern uint8_t (*_db_get_char)(LPC_UART_TypeDef *UARTx);
Nextern uint8_t (*_db_get_val)(LPC_UART_TypeDef *UARTx, uint8_t option, uint8_t numCh, uint32_t * val);
N
Nuint8_t UARTGetValue (LPC_UART_TypeDef *UARTx, uint8_t option,
N											uint8_t numCh, uint32_t* val);
Nvoid UARTPutChar (LPC_UART_TypeDef *UARTx, uint8_t ch);
Nvoid UARTPuts(LPC_UART_TypeDef *UARTx, const void *str);
Nvoid UARTPuts_(LPC_UART_TypeDef *UARTx, const void *str);
Nvoid UARTPutDec(LPC_UART_TypeDef *UARTx, uint8_t decnum);
Nvoid UARTPutDec16(LPC_UART_TypeDef *UARTx, uint16_t decnum);
Nvoid UARTPutDec32(LPC_UART_TypeDef *UARTx, uint32_t decnum);
Nvoid UARTPutHex (LPC_UART_TypeDef *UARTx, uint8_t hexnum);
Nvoid UARTPutHex16 (LPC_UART_TypeDef *UARTx, uint16_t hexnum);
Nvoid UARTPutHex32 (LPC_UART_TypeDef *UARTx, uint32_t hexnum);
Nuint8_t UARTGetChar (LPC_UART_TypeDef *UARTx);
Nuint8_t UARTGetKey (LPC_UART_TypeDef *UARTx);
Nvoid debug_frmwrk_init(void);
N
N#endif /* DEBUG_FRMWRK_H_ */
L 5 "Nand_Test\adapter.c" 2
N#include "adaptor.h"
L 1 "Nand_Test\adaptor.h" 1
N
N#ifndef _ADAPTOR_H
N#define _ADAPTOR_H
N
N#include "bsp.h"
L 1 "..\app\bsp.h" 1
N/***********************************************************************
N * @file	: bsp.h
N * @brief	: Contains basic information about the board that can
N 			  be using with the current code package. It may 
N 			  include some header file for the components mounted
N 			  on the board. Or else some neccessary hardware (IOs) 
N 			  settings for the using board may be involved.
N * @version	: 1.0
N * @date	: 03. March. 2011
N * @author	: NXP MCU SW Application Team
N * @note	: 
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N#include "lpc_types.h"
N
N#ifndef _BSP_H
S#define _BSP_H
S
S#define _DEFAULT_BOARD				(0)
S#define _UCDRAGON_EB_BOARD			(1)
S
S#define _CURR_USING_BRD				(_UCDRAGON_EB_BOARD)
S
S#if (_CURR_USING_BRD == _UCDRAGON_EB_BOARD)
S//Driver for PHY of LAN DP83848C IC
S#include "phylan_dp83848c.h"
S
S//LED indicators preset	定义LED使用GPIO端口
S#define BRD_LED_1_CONNECTED_PORT		(1)
S#define BRD_LED_1_CONNECTED_PIN			(12)
S#define BRD_LED_1_CONNECTED_MASK		(1 << BRD_LED_1_CONNECTED_PIN)
S
S#define BRD_LED_2_CONNECTED_PORT		(1)
S#define BRD_LED_2_CONNECTED_PIN			(13)
S#define BRD_LED_2_CONNECTED_MASK		(1 << BRD_LED_2_CONNECTED_PIN)
S
S//PIO interrupt preset 定按键S1~S4使用端口
S#define BRD_PIO_USED_INTR_PORT_S1			(2)
S#define BRD_PIO_USED_INTR_PIN_S1			(11)
S#define BRD_PIO_USED_INTR_MASK_S1			(1 << BRD_PIO_USED_INTR_PIN_S1)
S
S#define BRD_PIO_USED_INTR_PORT_S2			(2)
S#define BRD_PIO_USED_INTR_PIN_S2			(19)
S#define BRD_PIO_USED_INTR_MASK_S2			(1 << BRD_PIO_USED_INTR_PIN_S2)
S
S#define BRD_PIO_USED_INTR_PORT_S3			(2)
S#define BRD_PIO_USED_INTR_PIN_S3			(21)
S#define BRD_PIO_USED_INTR_MASK_S3			(1 << BRD_PIO_USED_INTR_PIN_S3)
S
S#define BRD_PIO_USED_INTR_PORT_S4			(2)
S#define BRD_PIO_USED_INTR_PIN_S4			(25)
S#define BRD_PIO_USED_INTR_MASK_S4			(1 << BRD_PIO_USED_INTR_PIN_S4)
S
S
S
S
S//ADC input preset on this board					 LPC
S#define BRD_ADC_PREPARED_CHANNEL		(ADC_CHANNEL_2)
S#define BRD_ADC_PREPARED_INTR			(ADC_ADINTEN2)
S
S#define BRD_ADC_PREPARED_CH_PORT		(0)
S#define BRD_ADC_PREPARED_CH_PIN			(25)
S#define BRD_ADC_PREPARED_CH_FUNC_NO		(1)
S
S//MCI power active levell
S#define BRD_MCI_POWERED_ACTIVE_LEVEL	(0)
S
S
S//Timer preset
S#define BRD_TIMER_USED				(LPC_TIM0)
S#define BRD_TIM_INTR_USED			(TIMER0_IRQn)
S
S#define BRD_TIM_CAP_LINKED_PORT		(1)
S#define BRD_TIM_CAP_LINKED_PIN		(26)
S
Sextern void Delay (unsigned long tick);
Svoid LED_ctr(uint8_t led_num,uint8_t on_off);
S
Svoid Init_gpio_interrupt    (void);
Svoid uninit_gpio_interrupt  (void);
Svoid Easy_Web(void);
Svoid Init_EMAC_Dp83848(void);
S
Svoid Usb_MassStorage (void);
Svoid USB_Dis_Connect (void);
S
Svoid DAC_SineWave(void);
Svoid DAC_SineWave_Dis(void);
S
Sint Pwm_Test_Beep(void);
Svoid Pwm_Dis_Beep(void);
Svoid Pwm_change_Freq(uint8_t state);
S
Svoid Can_init(void);
Svoid Can_Uninit(void);
S
Suint8_t Nor_RW_test(uint32_t offset_adr);
Suint8_t Nand_Test(void);
S
Svoid rs485_tx_rx(void);
Svoid rs485_tx_rx(void);
S
S#endif			//end if (_CURR_USING_BRD == _UCDRAGON_EB_BOARD)
S
N#endif
L 6 "Nand_Test\adaptor.h" 2
N#include "lpc_types.h"
N#include "nandflash_k9f2g08u0x.h"
L 1 "..\Drivers\nandflash_k9f2g08u0x.h" 1
N/***********************************************************************//**
N * @file		sdram_mt48lc8m32lfb5.h
N * @brief		Contains all macro definitions and function prototypes
N * 				support for external Nand Flash SamSung K9F1G08U0A
N * @version		1.0
N * @date		13. Dec. 2010
N * @author		NXP MCU SW Application Team
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N#ifndef NANDFLASH_K9F1G08U0A_H_
N#define NANDFLASH_K9F1G08U0A_H_
N
N#include "lpc177x_8x_emc.h"
L 1 "..\Drivers\lpc177x_8x_emc.h" 1
N/***********************************************************************//**
N * @file		lpc177x_8x_emc.h
N * @brief		Contains all macro definitions and function prototypes
N * 				support for EMC firmware library on LPC177x_8x
N * @version		1.0
N * @date		13. Dec. 2010
N * @author		NXP MCU SW Application Team
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N#ifndef LPC178X_EMC_H_
N#define LPC178X_EMC_H_
N
N#include "lpc_types.h"
N#include "LPC177x_8x.h"
N
N/***********************************************************************
N * EMC Control Register (EMCControl)
N **********************************************************************/
N/* Control register mask */
N#define EMC_Control_MASK			((uint32_t )0x07)
N/* Control register EMC: Enable control. */
N#define EMC_Control_E				((uint32_t )(1<<0))
N/* Control register EMC: Address mirror control. */
N#define EMC_Control_M				((uint32_t )(1<<1))
N/* Control register EMC: Low-power mode control. */
N#define EMC_Control_L				((uint32_t )(1<<2))
N
N/***********************************************************************
N * EMC Status Register (EMCStatus)
N **********************************************************************/
N/* Status register mask */
N#define EMC_Status_MASK				((uint32_t )0x07)
N/* Status register EMC: Busy. */
N#define EMC_Status_B				((uint32_t )(1<<0))
N/* Status register EMC: Write buffer status. */
N#define EMC_Status_S				((uint32_t )(1<<1))
N/* Status register EMC: Self-refresh acknowledge.. */
N#define EMC_Status_SA				((uint32_t )(1<<2))
N
N/***********************************************************************
N * EMC Configuration register (EMCConfig)
N **********************************************************************/
N/* EMC Configuration register : Enable control. */
N#define EMC_Config_Endian_Mode		((uint32_t )(1<<0))
N/* EMC Configuration register: CCLK. */
N#define EMC_Config_CCLK				((uinr32_t)(1<<8))
N/* EMC Configuration register mask */
N#define EMC_Config_MASK				((uint32_t)(0x101))
N
N
N/***********************************************************************
N * Dynamic Memory Control register (EMCDynamicControl)
N **********************************************************************/
N/* Dynamic Memory Control register EMC: Dynamic memory clock enable. */
N#define EMC_DynamicControl_CE			((uint32_t )(1<<0))
N/* Dynamic Memory Control register EMC: Dynamic memory clock control */
N#define EMC_DynamicControl_CS			((uint32_t )(1<<1))
N/* Dynamic Memory Control register EMC: Self-refresh request, EMCSREFREQ*/
N#define EMC_DynamicControl_SR			((uint32_t )(1<<2))
N/* Dynamic Memory Control register EMC: Memory clock control (MMC)*/
N#define EMC_DynamicControl_MMC			((uint32_t )(1<<5))
N/* Dynamic Memory Control register EMC: SDRAM initialization*/
N#define EMC_DynamicControl_I(n)			((uint32_t )(n<<7))
N/* Dynamic Memory Control register EMC: Low-power SDRAM deep-sleep mode (DP)*/
N#define EMC_DynamicControl_DP			((uint32_t ) (1<<13))
N
N/***********************************************************************
N * Dynamic Memory Refresh Timer register (EMCDynamicRefresh)
N **********************************************************************/
N/* Dynamic Memory Refresh Timer register EMC: Refresh timer (REFRESH) */
N#define EMC_DynamicRefresh_REFRESH(n)	((uint32_t ) (n & 0x3ff))
N
N/***********************************************************************
N * Dynamic Memory Read Configuration register (EMCDynamicReadConfig)
N **********************************************************************/
N/* EMCDynamicReadConfig register EMC:Read data strategy (RD) */
N#define EMC_DynamicReadConfig_RD(n)		((uint32_t )(n & 0x03))
N
N/***********************************************************************
N * Dynamic Memory Percentage Command Period register (EMCDynamictRP)
N **********************************************************************/
N/* EMCDynamictRP register EMC: Precharge command period (tRP). */
N#define EMC_DynamictRP_tRP(n)			((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N * Dynamic Memory Active to Precharge Command Period register (EMCDynamictRAS)
N **********************************************************************/
N/* EMCDynamictRAS register EMC: Active to precharge command period (tRAS) */
N#define EMC_DynamictRP_tRAS(n)			((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N * Dynamic Memory Last Data Out to Active Time register (EMCDynamictAPR)
N **********************************************************************/
N/* EMCDynamictAPR register EMC: Last-data-out to active command time (tAPR) */
N#define EMC_DynamictAPR_tAPR(n)			((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N * Dynamic Memory Data-in to Active Command Time register (EMCDynamictDAL)
N **********************************************************************/
N/* EMCDynamictDAL register EMC: Data-in to active command (tDAL)*/
N#define EMC_DynamictDAL_tDAL(n)			((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N * Dynamic Memory Write Recovery Time register (EMCDynamictWR)
N **********************************************************************/
N/* EMCDynamictWR register EMC: Write recovery time (tWR)*/
N#define EMC_DynamictWR_tWR(n)			(uint32_t )(n & 0x0f)
N
N/***********************************************************************
N * Dynamic Memory Active to Active Command Period register (EMCDynamictRC)
N **********************************************************************/
N/* EMCDynamictRC register EMC: Active to active command period (tRC)*/
N#define EMC_DynamictRC_tRC(n)			(uint32_t )(n & 0x1f)
N
N/***********************************************************************
N * Dynamic Memory Auto-refresh Period register (EMCDynamictRFC)
N **********************************************************************/
N/* EMCDynamictRFC register EMC: Auto-refresh period and auto-refresh to active command period (tRFC)*/
N#define EMC_DynamictRFC_tRFC(n)			((uint32_t )(n & 0x1f))
N
N/***********************************************************************
N * Dynamic Memory Exit Self-refresh register (EMCDynamictXSR)
N **********************************************************************/
N/* EMCDynamictXSR register EMC: Exit self-refresh to active command time (tXSR)*/
N#define EMC_DynamictXSR_tXSR(n)			((uint32_t )(n & 0x1f))
N
N/***********************************************************************
N * Dynamic Memory Active Bank A to Active Bank B Time register (EMCDynamictRRD)
N **********************************************************************/
N/* EMCDynamictRRD register EMC: Active bank A to active bank B latency (tRRD )*/
N#define EMC_DynamictRRD_tRRD(n)			((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N Dynamic Memory Load Mode register to Active Command Time (EMCDynamictMRD)
N **********************************************************************/
N/* EMCDynamictMRD register EMC: Load mode register to active command time (tMRD)*/
N#define EMC_DynamictMRD_tMRD(n)			((uint32_t )(n & 0x1f))
N
N/***********************************************************************
N * Static Memory Extended Wait Register (EMCStaticExtendedWait)
N **********************************************************************/
N/* StaticExtendedWait register EMC: External wait time out. */
N#define EMC_StaticExtendedWait_EXTENDEDWAIT(n)			((uint32_t )(n & 0x3ff))
N
N
N/***********************************************************************
N * Dynamic Memory Configuration registers (EMCDynamicConfig0-3)
N **********************************************************************/
N/* DynamicConfig register EMC: Memory device (MD). */
N#define EMC_DynamicConfig_MD(n)			((uint32_t )(n << 3))
N/* DynamicConfig register EMC: Address mapping (AM) */
N#define EMC_DynamicConfig_AM1(n)		((uint32_t )(n << 7))
N/* DynamicConfig register EMC: Address mapping (AM) */
N#define EMC_DynamicConfig_AM2(n)		((uint32_t )(1 << 14))
N/* DynamicConfig register EMC: Buffer enable */
N#define EMC_DynamicConfig_B				((uint32_t )(1 << 19))
N/* DynamicConfig register EMC: Write protect (P) */
N#define EMC_DynamicConfig_P				((uint32_t )(1 << 20))
N
N/***********************************************************************
N * Dynamic Memory RAS & CAS Delay registers (EMCDynamicRASCAS0-3)
N **********************************************************************/
N/* DynamicRASCAS register EMC: RAS latency (active to read/write delay) (RAS). */
N#define EMC_DynamicConfig_RAS(n)			((uint32_t )(n & 0x03))
N/* DynamicRASCAS register EMC: CAS latency (CAS)*/
N#define EMC_DynamicConfig_CAS(n)			((uint32_t )(n << 8))
N
N/***********************************************************************
N * Static Memory Configuration registers (EMCStaticConfig0-3)
N **********************************************************************/
N/* StaticConfig register EMC: Memory width (MW). */
N#define EMC_StaticConfig_MW(n)			((uint32_t )(n & 0x03))
N/* StaticConfig register EMC: Memory width 8bit . */
N#define EMC_StaticConfig_MW_8BITS		(EMC_StaticConfig_MW(0))
N/* StaticConfig register EMC: Memory width 16bit . */
N#define EMC_StaticConfig_MW_16BITS		(EMC_StaticConfig_MW(1))
N/* StaticConfig register EMC: Memory width 32bit . */
N#define EMC_StaticConfig_MW_32BITS		(EMC_StaticConfig_MW(2))
N/* StaticConfig register EMC: Page mode (PM) */
N#define EMC_StaticConfig_PM				((uint32_t )(1 << 3))
N/* StaticConfig register EMC: Chip select polarity (PC) */
N#define EMC_StaticConfig_PC				((uint32_t )(1 << 6))
N/* StaticConfig register EMC: Byte lane state (PB) */
N#define EMC_StaticConfig_PB				((uint32_t )(1 << 7))
N/* StaticConfig register EMC: Extended wait (EW) */
N#define EMC_StaticConfig_EW				((uint32_t )(1 << 8))
N/* StaticConfig register EMC: Buffer enable (B) */
N#define EMC_StaticConfig_B				((uint32_t )(1 << 19))
N/* StaticConfig register EMC: Write protect (P) */
N#define EMC_StaticConfig_P				((uint32_t )(1 << 20))
N
N/***********************************************************************
N * Static Memory Write Enable Delay registers (EMCStaticWaitWen0-3)
N **********************************************************************/
N/* StaticWaitWen register EMC: Wait write enable (WAITWEN). */
N#define EMC_StaticWaitWen_WAITWEN(n)	((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N * Static Memory Output Enable Delay registers (EMCStaticWaitOen0-3)
N **********************************************************************/
N/* StaticWaitOen register EMC: Wait output enable (WAITOEN). */
N#define EMC_StaticWaitOen_WAITOEN(n)	((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N * Static Memory Read Delay registers (EMCStaticWaitRd0-3)
N **********************************************************************/
N/* StaticWaitRd register EMC: Non-page mode read wait states or asynchronous page mode
Nread first access wait state (WAITRD) */
N#define EMC_StaticWaitRd_WAITRD(n)		((uint32_t )(n & 0x1f))
N
N/***********************************************************************
N * Static Memory Page Mode Read Delay registers (EMCStaticwaitPage0-3)
N **********************************************************************/
N/* StaticwaitPage register EMC: Asynchronous page mode read after the first
Nread wait states (WAITPAGE). */
N#define EMC_StaticwaitPage_WAITPAGE(n)	((uint32_t )(n & 0x1f))
N
N/***********************************************************************
N * Static Memory Write Delay registers (EMCStaticWaitwr0-3)
N **********************************************************************/
N/* StaticWaitwr register EMC: Write wait states (WAITWR). */
N#define EMC_StaticWaitwr_WAITWR(n)		((uint32_t )(n & 0x1f))
N
N/***********************************************************************
N * Static Memory Turn Round Delay registers (EMCStaticWaitTurn0-3)
N **********************************************************************/
N/* StaticWaitTurn register EMC: Bus turnaround cycles (WAITTURN). */
N#define EMC_StaticWaitTurn_WAITTURN(n)	((uint32_t )(n & 0x0f))
N
N/***********************************************************************
N * Delay Control register (EMCDLYCTL)
N **********************************************************************/
N#define EMC_DLYCTL_CMDDLY(n)		((uint32_t)(n&0x1F))
N#define EMC_DLYCTL_FBCLKDLY(n)		((uint32_t)((n&0x1F)<<8))
N#define EMC_DLYCTL_CLKOUT0DLY(n)	((uint32_t)((n&0x1F)<<16))
N#define EMC_DLYCTL_CLKOUT1DLY(n)	((uint32_t)((n&0x1F)<<24))
N
N/***********************************************************************
N * EMC Calibration register (EMCCAL)
N **********************************************************************/
N#define EMC_CAL_CALVALUE(n)			((uint32_t)(n&0xFF))
N#define EMC_CAL_START				((uint32_t)(1<<14))
N#define EMC_CAL_DONE				((uint32_t)(1<<15))
N
N#define EMC_LITTLE_ENDIAN_MODE		((uint32_t)(0))
N#define EMC_BIG_ENDIAN_MODE			((uint32_t)(1))
N
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup EMC_Public_Types EMC Public Types
N * @{
N */
N/*EMC dynamic memory registers enum*/
Ntypedef enum
N{
N  EMC_DYN_MEM_REFRESH_TIMER,
N  EMC_DYN_MEM_READ_CONFIG,
N  EMC_DYN_MEM_TRP,
N  EMC_DYN_MEM_TRAS,
N  EMC_DYN_MEM_TSREX,
N  EMC_DYN_MEM_TAPR,
N  EMC_DYN_MEM_TDAL,
N  EMC_DYN_MEM_TWR,
N  EMC_DYN_MEM_TRC,
N  EMC_DYN_MEM_TRFC,
N  EMC_DYN_MEM_TXSR,
N  EMC_DYN_MEM_TRRD,
N  EMC_DYN_MEM_TMRD
N} EMC_DYN_MEM_PAR;
N
N/*EMC static memory registers enum*/
Ntypedef enum
N{
N  EMC_STA_MEM_WAITWEN,
N  EMC_STA_MEM_WAITOEN,
N  EMC_STA_MEM_WAITRD,
N  EMC_STA_MEM_WAITPAGE,
N  EMC_STA_MEM_WAITWR,
N  EMC_STA_MEM_WAITTURN,
N} EMC_STA_MEM_PAR;
N
N/* Public Functions ----------------------------------------------------------- */
N/** @defgroup EMC_Public_Functions EMC Public Functions
N * @{
N */
N
Nextern void EMC_Init(void);
Nextern void EMC_ConfigEndianMode(uint32_t endian_mode);
Nextern void EMC_DynCtrlClockEnable(uint32_t clock_enable);
Nextern void EMC_DynCtrlClockControl(int32_t clock_control);
Nextern void EMC_DynCtrlSelfRefresh(uint32_t self_refresh_mode);
Nextern void EMC_DynCtrlMMC(uint32_t MMC_val);
Nextern void EMC_DynCtrlSDRAMInit(uint32_t SDRAM_command);
Nextern void EMC_DynCtrlPowerDownMode(uint32_t SDRAM_command);
Nextern void EMC_SetDynMemoryParameter(EMC_DYN_MEM_PAR par, uint32_t val);
Nextern void EMC_StaticExtendedWait(uint32_t Extended_wait_time_out);
Nextern void EMC_DynMemConfigMD(uint32_t index , uint32_t mem_dev);
Nextern void EMC_DynMemConfigAM(uint32_t index , uint32_t add_mapped);
Nextern void EMC_DynMemConfigB(uint32_t index , uint32_t buff_control);
Nextern void EMC_DynMemConfigP(uint32_t index , uint32_t permission);
Nextern void EMC_DynMemRAS(uint32_t index , uint32_t ras_val);
Nextern void EMC_DynMemCAS(uint32_t index , uint32_t cas_val);
Nextern void EMC_StaMemConfigMW(uint32_t index , uint32_t mem_width);
Nextern void EMC_StaMemConfigPM(uint32_t index , uint32_t page_mode);
Nextern void EMC_StaMemConfigPC(uint32_t index , uint32_t pol_val);
Nextern void EMC_StaMemConfigPB(uint32_t index , uint32_t pb_val);
Nextern void EMC_StaMemConfigEW(uint32_t index , uint32_t ex_wait);
Nextern void EMC_StaMemConfigB(uint32_t index , uint32_t buf_val);
Nextern void EMC_StaMemConfigpP(uint32_t index , uint32_t per_val);
Nextern void EMC_SetStaMemoryParameter(uint32_t index ,EMC_STA_MEM_PAR par, uint32_t val);
N
N
N#endif /* LPC178X_EMC_H_ */
L 25 "..\Drivers\nandflash_k9f2g08u0x.h" 2
N
N#ifndef _USING_OEM_QVGA_BASEBRD
N#define _RUNNING_WITH_K9F1G08U0C
N#else
S#undef _RUNNING_WITH_K9F1G08U0C
N#endif
N
N
N/*****************************************************************************
N * Defines and typedefs
N ****************************************************************************/
N#define K9F1G_CLE   ((volatile uint8_t *)(0x80000000|(0x1<<20)))
N#define K9F1G_ALE	((volatile uint8_t *)(0x80000000|(0x1<<19)))
N#define K9F1G_DATA  ((volatile uint8_t *)0x81000000)
N
N#define NANDFLASH_BASE_ADDR			0x00000000
N
N#define NANDFLASH_INVALIDBLOCK_CHECK_COLUMM			(2048)
N
N// total 2048 blocks in a device
N#define NANDFLASH_NUMOF_BLOCK		2048
N
N// total pages in a block
N#define NANDFLASH_PAGE_PER_BLOCK		64
N
N#define NANDFLASH_RW_PAGE_SIZE		2048		// 2048 bytes/page
N
N#define NANDFLASH_SPARE_SIZE		64 			//64 (bytes spare)/page
N
N//full page size
N#define NANDFLASH_PAGE_FSIZE		(NANDFLASH_RW_PAGE_SIZE + NANDFLASH_SPARE_SIZE)
N
N// attention rwsize and fsize
N#define NANDFLASH_BLOCK_RWSIZE	(NANDFLASH_RW_PAGE_SIZE * NANDFLASH_PAGE_PER_BLOCK)
N#define NANDFLASH_BLOCK_FSIZE	(NANDFLASH_PAGE_FSIZE * NANDFLASH_PAGE_PER_BLOCK)
N
N
N#define NANDFLASH_ADDR_COLUMM_POS		0
N#define NANDFLASH_ADDR_ROW_POS			16
N
N#define K9FXX_ID					0xECDA0000	/* Byte 3 and 2 only */
N
N#define K9FXX_READ_1            		0x00
N#define K9FXX_READ_2            		0x30
N#define K9FXX_READ_ID           		0x90
N#define K9FXX_RESET             			0xFF
N#define K9FXX_BLOCK_PROGRAM_1   	0x80
N#define K9FXX_BLOCK_PROGRAM_2   	0x10
N#define K9FXX_BLOCK_ERASE_1     	0x60
N#define K9FXX_BLOCK_ERASE_2     	0xD0
N#define K9FXX_READ_STATUS       		0x70
N
N#define K9FXX_BUSY              	(1 << 6)
N#define K9FXX_OK                	(1 << 0)
N
N#define ERR_RETVAL_OK				(0)
N#define ERR_RETVAL_ERROR			(-1)
N#define ERR_RETVAL_WRONG_INPUT		(-2)
N
Nextern void NandFlash_Init( void );
Nextern void NandFlash_Reset( void );
Nextern void NandFlash_WaitForReady( void );	/* same as CheckBusy, no time out */
Nextern uint32_t NandFlash_ReadId( void );
Nextern Bool NandFlash_ReadStatus( uint32_t Cmd );
Nextern Bool NandFlash_BlockErase( uint32_t blockNum );
Nextern Bool NandFlash_ValidBlockCheck( void );
Nextern Bool NandFlash_PageProgram( uint32_t pageNum, uint8_t *bufPtr ,uint8_t *spareptr);
Nextern Bool NandFlash_PageRead( uint32_t pageNum, uint32_t blockNum, uint8_t *bufPtr );
N
Nextern int NandFlash_PageReadFromBeginning(uint32_t block, uint32_t page, uint8_t* bufPtr);
Nextern int NandFlash_PageReadFromAddr(uint32_t blockNum, uint32_t pageNum,
N													uint32_t addrInPage, uint8_t* bufPtr, uint32_t size);
Nextern int NandFlash_ReadFromAddr(uint32_t addrInWholeNand, uint8_t* bufPtr, uint32_t size);
Nextern int NandFlash_SectorRead(uint32_t sectorNum, uint8_t* bufPtr);//add by zjy
Nextern int Nand_ReadPageWithSpare2048(uint32_t PageNum,uint8_t * bufPtr, uint8_t *spareptr );
N#endif /* NANDFLASH_K9F1G08U0A_H_ */
L 8 "Nand_Test\adaptor.h" 2
N#include "debug_frmwrk.h"
N
Nvoid CheckBad(void);
N
Nvoid  FAT_ReadNF(uint32_t sector,uint32_t count,uint8_t *buff);
Nvoid  FAT_WriteNF2G08(uint32_t sector,uint8_t count,uint8_t *buff);
N
N#endif
L 6 "Nand_Test\adapter.c" 2
N#include "nandflash_k9f2g08u0x.h"
N
Nstatic uint8_t BlockBuff[NANDFLASH_PAGE_PER_BLOCK*NANDFLASH_NUMOF_BLOCK];
Xstatic uint8_t BlockBuff[64*2048];
N//static uint8_t *BlockBuff=(uint8_t *)SDRAM_BASE_ADDR;
Nextern uint8_t InvalidBlockTable[NANDFLASH_NUMOF_BLOCK];
Xextern uint8_t InvalidBlockTable[2048];
N
Nstatic void  ReadBlock(uint32_t Block,uint8_t *Buff);
Nstatic void  WriteBlock(uint32_t Block,uint8_t *Buff);
Nstatic void  WriteOnBlockBuff(uint32_t offset,uint32_t size,uint8_t *buff);
N
Nuint32_t  BadTab[11]={0};
Nuint32_t RedrTab[10]={2047,2046,2045,2044,2043,2042,2041,2040}; 
N
N//擦最小单位为block		写最小单位为page
N//读是随机的
N//----------------------------------------------------------------------
N// mark invalid block
Nvoid CheckBad(void)
N{
N	uint32_t i=0,m=0;
N	
N	for(i=0;i<NANDFLASH_NUMOF_BLOCK;i++){
X	for(i=0;i<2048;i++){
N		if(InvalidBlockTable[i]==FALSE){
N			BadTab[m]=i;// record invalid block
N			m++;
N			if(m>=10)
N				break;
N		}
N	}
N	
N 	//BadTab[m]=0;m++;
N 	//BadTab[m]=1;m++;
N  	BadTab[10]=m; //  坏块个数
N}
N
N
N// 一块对应64页	一页对应2048个字节
N// Block 块号
N static void  ReadBlock(uint32_t Block,uint8_t *Buff)
N{
N
N	uint32_t i;
N	uint8_t *tmp;
N	
N         tmp=Buff;
N	for(i=0;i<64;i++)
N	{
N		//块内页号	块号	缓冲区
N		NandFlash_PageRead( i, Block, tmp) ;
N		tmp+=2048;
N	}
N
N}
N
N//Block 块号
Nstatic void  WriteBlock(uint32_t Block,uint8_t *Buff)
N{
N	uint32_t i;
N	uint8_t *tmp;
N
N         tmp=Buff;
N	for(i=0;i<64;i++)
N	{
N		//块内页号	块号	缓冲区
E "Nand_Test\adapter.c" 70 27 argument of type "uint32_t" is incompatible with parameter of type "uint8_t *"
N		NandFlash_PageProgram(i,Block,tmp);
N 		tmp+=2048;
N	}
N}
N
N//offset 表示block内偏移sector个数
N//size  bytes数
Nstatic void  WriteOnBlockBuff(uint32_t offset,uint32_t size,uint8_t *buff)
N{
N	uint32_t i,n;
N	
N         i=offset*512;
N	for(n=0;n<size;)
N	{
N		 BlockBuff[i++] = buff[n++];	 
N	}
N		
N}
N
N// 对应 FATFS读扇区函数
N//sector 起始扇区号
N//count 读扇区个数
N//buff 读缓冲区
Nvoid  FAT_ReadNF(uint32_t sector,uint32_t count,uint8_t *buff)
N{
N	uint32_t i,j,block1,block2,offset;
N	uint8_t *tmp;
N	uint32_t tmp_sector;
N	
N	// 256个sector对应1 个block
N	//512*256=64*2048
N	block1=sector/256; //起始sector所处的block号
N	block2=(sector+count-1)/256;// 结束sector所处的blcok号
N
N	for(i=0;i<BadTab[10];i++)
N         {
N         	if(block1==BadTab[i])
N         		block1=RedrTab[i];
N			
N         	if(block2==BadTab[i])
N         	{
N			block2=RedrTab[i];	
N			break;
N                   }
N         }
N
N	
N         offset=sector%256;	// blcok内偏移sector个数
N	tmp_sector=256*block1+offset;
N	tmp=buff;
N
N	 if((offset+count)>256)		// 跨2个block
N	 	j=(256-offset);
N	 else
N	 	j = count;
N
N	 for(i=0;i<j;i++)
N	{
N		NandFlash_SectorRead(tmp_sector+i,tmp);
N	        tmp+=512;
N	}
N	 
N	 // 跨2个block
N         if(block2!=block1)
N	 {
N		tmp_sector=256*block2;
N		j=count - j;
N		for(i=0;i<j;i++)
N		{
N			NandFlash_SectorRead(tmp_sector+i,tmp);
N		        tmp+=512;
N		}
N	 }
N	
N}
N
N//--------------------------------------------------------------
N// 对应 FATFS写扇区函数
N//sector 起始扇区号
N//count 写扇区个数
N//buff 写缓冲区
Nvoid  FAT_WriteNF2G08(uint32_t sector,uint8_t count,uint8_t *buff)
N{
N 
N	//Count最大为255,所以Sector*Count最多跨越2个Block
N	uint32_t   block1=0,block2=0;//,tmp;
N	uint32_t  offset,size,i;
N	
N 	//最多跨2个blcok		不跨2个blcok时，blcok1==blcok2
N         block1=sector/256;				//  4*64   起始sector所处的block号
N         block2=(sector+count-1)/256;	// 结束sector所处的blcok号
N	
N	for(i=0;i<BadTab[10];i++)
N     {
N     	if(block1==BadTab[i])
N     		block1=RedrTab[i];
N
N     	if(block2==BadTab[i])
N     	{
N    	block2=RedrTab[i];	
N    	break;
N               }
N     }
N	
N         ReadBlock(block1,BlockBuff);
N          NandFlash_BlockErase(block1);
N		  
N         offset=sector%256;// 块内偏移sector数
N         
N          if((offset+count)>256)		// 跨2个block
N         	size=(256-offset)*512;	// 第1个blcok内要写的bytes
N         else						// 所有待操作sector都在同一个blcok内
N         	size=count*512;		//总共要写的bytes
N         	
N         WriteOnBlockBuff(offset,size,buff);	
N         WriteBlock(block1,BlockBuff);
N
N	// 跨2个block
N         if(block2!=block1)
N         {
N          	ReadBlock(block2,BlockBuff);
N         	size=(count+offset-256)*512; // 第2个blcok内要写的bytes
N         	WriteOnBlockBuff(0,size,buff);	
N         	WriteBlock(block2,BlockBuff);
N         }	
N}

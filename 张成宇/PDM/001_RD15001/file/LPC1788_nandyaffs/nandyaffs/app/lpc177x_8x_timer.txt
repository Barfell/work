; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\lpc177x_8x_timer.o --asm_dir=.\ --list_dir=.\ --depend=.\flash\lpc177x_8x_timer.d --feedback=.\Flash\YL_LPC1788_Test.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\app -I..\CM3_lib -I..\Drivers -I..\Startup -I.\Easy_web -I.\Lcd_Drv -I.\IIC_Test -I.\USU_Host -I.\Nand_Test -I.\FATFS_R0.08 -I..\fs -I"D:\Program Files\mdk\ARM\RV31\INC" -I"D:\Program Files\mdk\pack\ARM\CMSIS\4.1.1\CMSIS\Include" -I"D:\Program Files\mdk\ARM\Inc\NXP\LPC177x_8x" -D__MICROLIB --omf_browse=.\flash\lpc177x_8x_timer.crf ..\Drivers\lpc177x_8x_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  getPClock PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
000002  4605              MOV      r5,r0
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       CLKPWR_GetCLK
00000a  4604              MOV      r4,r0
;;;47     	return clkdlycnt;
00000c  4620              MOV      r0,r4
;;;48     }
00000e  bd70              POP      {r4-r6,pc}
;;;49     
                          ENDP

                  converUSecToVal PROC
;;;56      **********************************************************************/
;;;57     uint32_t converUSecToVal (uint32_t timernum, uint32_t usec)
000010  e92d47f0          PUSH     {r4-r10,lr}
;;;58     {
000014  4681              MOV      r9,r0
000016  460c              MOV      r4,r1
;;;59     	uint64_t clkdlycnt;
;;;60     
;;;61     	// Get Pclock of timer
;;;62     	clkdlycnt = (uint64_t) getPClock(timernum);
000018  4648              MOV      r0,r9
00001a  f7fffffe          BL       getPClock
00001e  2600              MOVS     r6,#0
000020  4605              MOV      r5,r0
;;;63     
;;;64     	clkdlycnt = (clkdlycnt * usec) / 1000000;
000022  2300              MOVS     r3,#0
000024  4629              MOV      r1,r5
000026  fba17c04          UMULL    r7,r12,r1,r4
00002a  fb06c204          MLA      r2,r6,r4,r12
00002e  fb052103          MLA      r1,r5,r3,r2
000032  4a8d              LDR      r2,|L1.616|
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       __aeabi_uldivmod
00003a  4605              MOV      r5,r0
;;;65     	return (uint32_t) clkdlycnt;
00003c  4628              MOV      r0,r5
;;;66     }
00003e  e8bd87f0          POP      {r4-r10,pc}
;;;67     
                          ENDP

                  converPtrToTimeNum PROC
;;;77      **********************************************************************/
;;;78     uint32_t converPtrToTimeNum (LPC_TIM_TypeDef *TIMx)
000042  4601              MOV      r1,r0
;;;79     {
;;;80     	uint32_t tnum = -1;
000044  f04f30ff          MOV      r0,#0xffffffff
;;;81     
;;;82     	if (TIMx == LPC_TIM0)
000048  f1b12f40          CMP      r1,#0x40004000
00004c  d101              BNE      |L1.82|
;;;83     	{
;;;84     		tnum = 0;
00004e  2000              MOVS     r0,#0
000050  e00d              B        |L1.110|
                  |L1.82|
;;;85     	}
;;;86     	else if (TIMx == LPC_TIM1)
000052  4a86              LDR      r2,|L1.620|
000054  4291              CMP      r1,r2
000056  d101              BNE      |L1.92|
;;;87     	{
;;;88     		tnum = 1;
000058  2001              MOVS     r0,#1
00005a  e008              B        |L1.110|
                  |L1.92|
;;;89     	}
;;;90     	else if (TIMx == LPC_TIM2)
00005c  4a84              LDR      r2,|L1.624|
00005e  4291              CMP      r1,r2
000060  d101              BNE      |L1.102|
;;;91     	{
;;;92     		tnum = 2;
000062  2002              MOVS     r0,#2
000064  e003              B        |L1.110|
                  |L1.102|
;;;93     	}
;;;94     	else if (TIMx == LPC_TIM3)
000066  4a83              LDR      r2,|L1.628|
000068  4291              CMP      r1,r2
00006a  d100              BNE      |L1.110|
;;;95     	{
;;;96     		tnum = 3;
00006c  2003              MOVS     r0,#3
                  |L1.110|
;;;97     	}
;;;98     
;;;99     	return tnum;
;;;100    }
00006e  4770              BX       lr
;;;101    
                          ENDP

                  TIM_Init PROC
;;;250     **********************************************************************/
;;;251    void TIM_Init(LPC_TIM_TypeDef *TIMx, TIM_MODE_OPT TimerCounterMode, void *TIM_ConfigStruct)
000070  e92d47f0          PUSH     {r4-r10,lr}
;;;252    {
000074  4604              MOV      r4,r0
000076  460f              MOV      r7,r1
000078  4615              MOV      r5,r2
;;;253    	TIM_TIMERCFG_Type *pTimeCfg;
;;;254    	TIM_COUNTERCFG_Type *pCounterCfg;
;;;255    
;;;256    	//set power
;;;257    	if (TIMx== LPC_TIM0)
00007a  f1b42f40          CMP      r4,#0x40004000
00007e  d104              BNE      |L1.138|
;;;258    	{
;;;259    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, ENABLE);
000080  2101              MOVS     r1,#1
000082  2002              MOVS     r0,#2
000084  f7fffffe          BL       CLKPWR_ConfigPPWR
000088  e016              B        |L1.184|
                  |L1.138|
;;;260    	}
;;;261    	else if (TIMx== LPC_TIM1)
00008a  4878              LDR      r0,|L1.620|
00008c  4284              CMP      r4,r0
00008e  d104              BNE      |L1.154|
;;;262    	{
;;;263    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, ENABLE);
000090  2101              MOVS     r1,#1
000092  2004              MOVS     r0,#4
000094  f7fffffe          BL       CLKPWR_ConfigPPWR
000098  e00e              B        |L1.184|
                  |L1.154|
;;;264    	}
;;;265    
;;;266    	else if (TIMx== LPC_TIM2)
00009a  4875              LDR      r0,|L1.624|
00009c  4284              CMP      r4,r0
00009e  d104              BNE      |L1.170|
;;;267    	{
;;;268    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, ENABLE);
0000a0  2101              MOVS     r1,#1
0000a2  0588              LSLS     r0,r1,#22
0000a4  f7fffffe          BL       CLKPWR_ConfigPPWR
0000a8  e006              B        |L1.184|
                  |L1.170|
;;;269    	}
;;;270    	else if (TIMx== LPC_TIM3)
0000aa  4872              LDR      r0,|L1.628|
0000ac  4284              CMP      r4,r0
0000ae  d103              BNE      |L1.184|
;;;271    	{
;;;272    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM3, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  05c8              LSLS     r0,r1,#23
0000b4  f7fffffe          BL       CLKPWR_ConfigPPWR
                  |L1.184|
;;;273    	}
;;;274    
;;;275    	TIMx->CCR &= ~TIM_CTCR_MODE_MASK;
0000b8  6aa0              LDR      r0,[r4,#0x28]
0000ba  f0200003          BIC      r0,r0,#3
0000be  62a0              STR      r0,[r4,#0x28]
;;;276    	TIMx->CCR |= TIM_TIMER_MODE;
0000c0  6aa0              LDR      r0,[r4,#0x28]
0000c2  62a0              STR      r0,[r4,#0x28]
;;;277    
;;;278    	TIMx->TC =0;
0000c4  2000              MOVS     r0,#0
0000c6  60a0              STR      r0,[r4,#8]
;;;279    	TIMx->PC =0;
0000c8  6120              STR      r0,[r4,#0x10]
;;;280    	TIMx->PR =0;
0000ca  60e0              STR      r0,[r4,#0xc]
;;;281    	TIMx->TCR |= (1<<1); //Reset Counter
0000cc  6860              LDR      r0,[r4,#4]
0000ce  f0400002          ORR      r0,r0,#2
0000d2  6060              STR      r0,[r4,#4]
;;;282    	TIMx->TCR &= ~(1<<1); //release reset
0000d4  6860              LDR      r0,[r4,#4]
0000d6  f0200002          BIC      r0,r0,#2
0000da  6060              STR      r0,[r4,#4]
;;;283    	if (TimerCounterMode == TIM_TIMER_MODE )
0000dc  b987              CBNZ     r7,|L1.256|
;;;284    	{
;;;285    		pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
0000de  462e              MOV      r6,r5
;;;286    		if (pTimeCfg->PrescaleOption  == TIM_PRESCALE_TICKVAL)
0000e0  7830              LDRB     r0,[r6,#0]
0000e2  b918              CBNZ     r0,|L1.236|
;;;287    		{
;;;288    			TIMx->PR   = pTimeCfg->PrescaleValue -1  ;
0000e4  6870              LDR      r0,[r6,#4]
0000e6  1e40              SUBS     r0,r0,#1
0000e8  60e0              STR      r0,[r4,#0xc]
0000ea  e017              B        |L1.284|
                  |L1.236|
;;;289    		}
;;;290    		else
;;;291    		{
;;;292    			TIMx->PR   = converUSecToVal (converPtrToTimeNum(TIMx),pTimeCfg->PrescaleValue)-1;
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       converPtrToTimeNum
0000f2  4681              MOV      r9,r0
0000f4  6871              LDR      r1,[r6,#4]
0000f6  f7fffffe          BL       converUSecToVal
0000fa  1e40              SUBS     r0,r0,#1
0000fc  60e0              STR      r0,[r4,#0xc]
0000fe  e00d              B        |L1.284|
                  |L1.256|
;;;293    		}
;;;294    	}
;;;295    	else
;;;296    	{
;;;297    
;;;298    		pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
000100  46a8              MOV      r8,r5
;;;299    		TIMx->CCR  &= ~TIM_CTCR_INPUT_MASK;
000102  6aa0              LDR      r0,[r4,#0x28]
000104  f020000c          BIC      r0,r0,#0xc
000108  62a0              STR      r0,[r4,#0x28]
;;;300    		if (pCounterCfg->CountInputSelect == TIM_COUNTER_INCAP1)
00010a  4645              MOV      r5,r8
00010c  f8980001          LDRB     r0,[r8,#1]
000110  2801              CMP      r0,#1
000112  d103              BNE      |L1.284|
;;;301    			TIMx->CCR |= _BIT(2);
000114  6aa0              LDR      r0,[r4,#0x28]
000116  f0400004          ORR      r0,r0,#4
00011a  62a0              STR      r0,[r4,#0x28]
                  |L1.284|
;;;302    	}
;;;303    
;;;304    	// Clear interrupt pending
;;;305    	TIMx->IR = 0xFFFFFFFF;
00011c  f04f30ff          MOV      r0,#0xffffffff
000120  6020              STR      r0,[r4,#0]
;;;306    
;;;307    }
000122  e8bd87f0          POP      {r4-r10,pc}
;;;308    
                          ENDP

                  TIM_Cmd PROC
;;;349     **********************************************************************/
;;;350    void TIM_Cmd(LPC_TIM_TypeDef *TIMx, FunctionalState NewState)
000126  2901              CMP      r1,#1
;;;351    {
;;;352    	if (NewState == ENABLE)
000128  d104              BNE      |L1.308|
;;;353    	{
;;;354    		TIMx->TCR	|=  TIM_ENABLE;
00012a  6842              LDR      r2,[r0,#4]
00012c  f0420201          ORR      r2,r2,#1
000130  6042              STR      r2,[r0,#4]
000132  e003              B        |L1.316|
                  |L1.308|
;;;355    	}
;;;356    	else
;;;357    	{
;;;358    		TIMx->TCR &= ~TIM_ENABLE;
000134  6842              LDR      r2,[r0,#4]
000136  f0220201          BIC      r2,r2,#1
00013a  6042              STR      r2,[r0,#4]
                  |L1.316|
;;;359    	}
;;;360    }
00013c  4770              BX       lr
;;;361    
                          ENDP

                  TIM_ResetCounter PROC
;;;372     **********************************************************************/
;;;373    void TIM_ResetCounter(LPC_TIM_TypeDef *TIMx)
00013e  6841              LDR      r1,[r0,#4]
;;;374    {
;;;375    	TIMx->TCR |= TIM_RESET;
000140  f0410102          ORR      r1,r1,#2
000144  6041              STR      r1,[r0,#4]
;;;376    	TIMx->TCR &= ~TIM_RESET;
000146  6841              LDR      r1,[r0,#4]
000148  f0210102          BIC      r1,r1,#2
00014c  6041              STR      r1,[r0,#4]
;;;377    }
00014e  4770              BX       lr
;;;378    
                          ENDP

                  TIM_ConfigMatch PROC
;;;401     **********************************************************************/
;;;402    void TIM_ConfigMatch(LPC_TIM_TypeDef *TIMx, TIM_MATCHCFG_Type *TIM_MatchConfigStruct)
000150  b510              PUSH     {r4,lr}
;;;403    {
;;;404    	switch(TIM_MatchConfigStruct->MatchChannel)
000152  780a              LDRB     r2,[r1,#0]
000154  b132              CBZ      r2,|L1.356|
000156  2a01              CMP      r2,#1
000158  d007              BEQ      |L1.362|
00015a  2a02              CMP      r2,#2
00015c  d008              BEQ      |L1.368|
00015e  2a03              CMP      r2,#3
000160  d10c              BNE      |L1.380|
000162  e008              B        |L1.374|
                  |L1.356|
;;;405    	{
;;;406    	case 0:
;;;407    		TIMx->MR0 = TIM_MatchConfigStruct->MatchValue;
000164  688a              LDR      r2,[r1,#8]
000166  6182              STR      r2,[r0,#0x18]
;;;408    		break;
000168  e00a              B        |L1.384|
                  |L1.362|
;;;409    	case 1:
;;;410    		TIMx->MR1 = TIM_MatchConfigStruct->MatchValue;
00016a  688a              LDR      r2,[r1,#8]
00016c  61c2              STR      r2,[r0,#0x1c]
;;;411    		break;
00016e  e007              B        |L1.384|
                  |L1.368|
;;;412    	case 2:
;;;413    		TIMx->MR2 = TIM_MatchConfigStruct->MatchValue;
000170  688a              LDR      r2,[r1,#8]
000172  6202              STR      r2,[r0,#0x20]
;;;414    		break;
000174  e004              B        |L1.384|
                  |L1.374|
;;;415    	case 3:
;;;416    		TIMx->MR3 = TIM_MatchConfigStruct->MatchValue;
000176  688a              LDR      r2,[r1,#8]
000178  6242              STR      r2,[r0,#0x24]
;;;417    		break;
00017a  e001              B        |L1.384|
                  |L1.380|
;;;418    	default:
;;;419    		//Error match value
;;;420    		//Error loop
;;;421    		while(1);
00017c  bf00              NOP      
                  |L1.382|
00017e  e7fe              B        |L1.382|
                  |L1.384|
000180  bf00              NOP                            ;408
;;;422    	}
;;;423    	//interrupt on MRn
;;;424    	TIMx->MCR &= ~ TIM_MCR_CHANNEL_MASKBIT(TIM_MatchConfigStruct->MatchChannel);
000182  6942              LDR      r2,[r0,#0x14]
000184  780b              LDRB     r3,[r1,#0]
000186  eb030443          ADD      r4,r3,r3,LSL #1
00018a  2307              MOVS     r3,#7
00018c  40a3              LSLS     r3,r3,r4
00018e  439a              BICS     r2,r2,r3
000190  6142              STR      r2,[r0,#0x14]
;;;425    
;;;426    	if (TIM_MatchConfigStruct->IntOnMatch)
000192  784a              LDRB     r2,[r1,#1]
000194  b13a              CBZ      r2,|L1.422|
;;;427    		TIMx->MCR |= TIM_INT_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
000196  6942              LDR      r2,[r0,#0x14]
000198  780b              LDRB     r3,[r1,#0]
00019a  eb030443          ADD      r4,r3,r3,LSL #1
00019e  2301              MOVS     r3,#1
0001a0  40a3              LSLS     r3,r3,r4
0001a2  431a              ORRS     r2,r2,r3
0001a4  6142              STR      r2,[r0,#0x14]
                  |L1.422|
;;;428    
;;;429    	//reset on MRn
;;;430    	if (TIM_MatchConfigStruct->ResetOnMatch)
0001a6  78ca              LDRB     r2,[r1,#3]
0001a8  b142              CBZ      r2,|L1.444|
;;;431    		TIMx->MCR |= TIM_RESET_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
0001aa  6942              LDR      r2,[r0,#0x14]
0001ac  780b              LDRB     r3,[r1,#0]
0001ae  eb030343          ADD      r3,r3,r3,LSL #1
0001b2  1c5b              ADDS     r3,r3,#1
0001b4  2401              MOVS     r4,#1
0001b6  409c              LSLS     r4,r4,r3
0001b8  4322              ORRS     r2,r2,r4
0001ba  6142              STR      r2,[r0,#0x14]
                  |L1.444|
;;;432    
;;;433    	//stop on MRn
;;;434    	if (TIM_MatchConfigStruct->StopOnMatch)
0001bc  788a              LDRB     r2,[r1,#2]
0001be  b142              CBZ      r2,|L1.466|
;;;435    		TIMx->MCR |= TIM_STOP_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
0001c0  6942              LDR      r2,[r0,#0x14]
0001c2  780b              LDRB     r3,[r1,#0]
0001c4  eb030343          ADD      r3,r3,r3,LSL #1
0001c8  1c9b              ADDS     r3,r3,#2
0001ca  2401              MOVS     r4,#1
0001cc  409c              LSLS     r4,r4,r3
0001ce  4322              ORRS     r2,r2,r4
0001d0  6142              STR      r2,[r0,#0x14]
                  |L1.466|
;;;436    
;;;437    	// match output type
;;;438    
;;;439    	TIMx->EMR 	&= ~ TIM_EM_MASK(TIM_MatchConfigStruct->MatchChannel);
0001d2  6bc2              LDR      r2,[r0,#0x3c]
0001d4  780b              LDRB     r3,[r1,#0]
0001d6  2404              MOVS     r4,#4
0001d8  eb040443          ADD      r4,r4,r3,LSL #1
0001dc  2303              MOVS     r3,#3
0001de  40a3              LSLS     r3,r3,r4
0001e0  439a              BICS     r2,r2,r3
0001e2  63c2              STR      r2,[r0,#0x3c]
;;;440    	TIMx->EMR   |= TIM_EM_SET(TIM_MatchConfigStruct->MatchChannel,TIM_MatchConfigStruct->ExtMatchOutputType);
0001e4  790a              LDRB     r2,[r1,#4]
0001e6  f0020203          AND      r2,r2,#3
0001ea  780b              LDRB     r3,[r1,#0]
0001ec  2404              MOVS     r4,#4
0001ee  eb040343          ADD      r3,r4,r3,LSL #1
0001f2  409a              LSLS     r2,r2,r3
0001f4  6bc3              LDR      r3,[r0,#0x3c]
0001f6  431a              ORRS     r2,r2,r3
0001f8  63c2              STR      r2,[r0,#0x3c]
;;;441    }
0001fa  bd10              POP      {r4,pc}
;;;442    /*********************************************************************//**
                          ENDP

                  TIM_Waitus PROC
;;;528     **********************************************************************/
;;;529    void TIM_Waitus(uint32_t time)
0001fc  b51e              PUSH     {r1-r4,lr}
;;;530    {
0001fe  4604              MOV      r4,r0
;;;531    	TIM_MATCHCFG_Type MatchConfigStruct;
;;;532    	LPC_TIM0->IR = 0xFFFFFFFF;
000200  f04f30ff          MOV      r0,#0xffffffff
000204  f04f2140          MOV      r1,#0x40004000
000208  6008              STR      r0,[r1,#0]
;;;533    
;;;534    	MatchConfigStruct.MatchChannel = 0;
00020a  2000              MOVS     r0,#0
00020c  f88d0000          STRB     r0,[sp,#0]
;;;535    	MatchConfigStruct.IntOnMatch = ENABLE;
000210  2001              MOVS     r0,#1
000212  f88d0001          STRB     r0,[sp,#1]
;;;536    	MatchConfigStruct.ResetOnMatch = ENABLE;
000216  f88d0003          STRB     r0,[sp,#3]
;;;537    	MatchConfigStruct.StopOnMatch = ENABLE;
00021a  f88d0002          STRB     r0,[sp,#2]
;;;538    	MatchConfigStruct.ExtMatchOutputType = 0;
00021e  2000              MOVS     r0,#0
000220  f88d0004          STRB     r0,[sp,#4]
;;;539    	MatchConfigStruct.MatchValue = time;
000224  9402              STR      r4,[sp,#8]
;;;540    
;;;541    	TIM_ConfigMatch(LPC_TIM0, &MatchConfigStruct);
000226  4669              MOV      r1,sp
000228  f04f2040          MOV      r0,#0x40004000
00022c  f7fffffe          BL       TIM_ConfigMatch
;;;542    	TIM_Cmd(LPC_TIM0,ENABLE);
000230  2101              MOVS     r1,#1
000232  f04f2040          MOV      r0,#0x40004000
000236  f7fffffe          BL       TIM_Cmd
;;;543    	//wait until interrupt flag occur
;;;544    	while(!(LPC_TIM0->IR & 0x01));
00023a  bf00              NOP      
                  |L1.572|
00023c  f04f2040          MOV      r0,#0x40004000
000240  6800              LDR      r0,[r0,#0]
000242  f0000001          AND      r0,r0,#1
000246  2800              CMP      r0,#0
000248  d0f8              BEQ      |L1.572|
;;;545    	TIM_ResetCounter(LPC_TIM0);
00024a  f04f2040          MOV      r0,#0x40004000
00024e  f7fffffe          BL       TIM_ResetCounter
;;;546    }
000252  bd1e              POP      {r1-r4,pc}
;;;547    /*********************************************************************//**
                          ENDP

                  TIM_Waitms PROC
;;;551     **********************************************************************/
;;;552    void TIM_Waitms(uint32_t time)
000254  b510              PUSH     {r4,lr}
;;;553    {
000256  4604              MOV      r4,r0
;;;554    	TIM_Waitus(time * 1000);
000258  f44f717a          MOV      r1,#0x3e8
00025c  fb04f001          MUL      r0,r4,r1
000260  f7fffffe          BL       TIM_Waitus
;;;555    }
000264  bd10              POP      {r4,pc}
;;;556    /**
                          ENDP

000266  0000              DCW      0x0000
                  |L1.616|
                          DCD      0x000f4240
                  |L1.620|
                          DCD      0x40008000
                  |L1.624|
                          DCD      0x40090000
                  |L1.628|
                          DCD      0x40094000

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.2||, ||.text||
                  TIM_GetIntStatus PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  b510              PUSH     {r4,lr}
;;;44     {
000002  4602              MOV      r2,r0
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  6810              LDR      r0,[r2,#0]
000006  2401              MOVS     r4,#1
000008  408c              LSLS     r4,r4,r1
00000a  4020              ANDS     r0,r0,r4
;;;47     	return clkdlycnt;
00000c  b2c3              UXTB     r3,r0
;;;48     }
00000e  b10b              CBZ      r3,|L2.20|
000010  2001              MOVS     r0,#1
                  |L2.18|
000012  bd10              POP      {r4,pc}
                  |L2.20|
000014  2000              MOVS     r0,#0
000016  e7fc              B        |L2.18|
;;;49     
                          ENDP


                          AREA ||area_number.3||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.3||, ||.text||
                  TIM_GetIntCaptureStatus PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  b530              PUSH     {r4,r5,lr}
;;;44     {
000002  4602              MOV      r2,r0
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  6810              LDR      r0,[r2,#0]
000006  1d0c              ADDS     r4,r1,#4
000008  2501              MOVS     r5,#1
00000a  40a5              LSLS     r5,r5,r4
;;;47     	return clkdlycnt;
00000c  4028              ANDS     r0,r0,r5
;;;48     }
00000e  b2c3              UXTB     r3,r0
000010  b10b              CBZ      r3,|L3.22|
000012  2001              MOVS     r0,#1
                  |L3.20|
000014  bd30              POP      {r4,r5,pc}
                  |L3.22|
000016  2000              MOVS     r0,#0
000018  e7fc              B        |L3.20|
;;;49     
                          ENDP


                          AREA ||area_number.4||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.4||, ||.text||
                  TIM_ClearIntPending PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  2201              MOVS     r2,#1
;;;44     {
000002  408a              LSLS     r2,r2,r1
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  6002              STR      r2,[r0,#0]
000006  4770              BX       lr
;;;47     	return clkdlycnt;
;;;48     }
;;;49     
                          ENDP


                          AREA ||area_number.5||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.5||, ||.text||
                  TIM_ClearIntCapturePending PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  1d0a              ADDS     r2,r1,#4
;;;44     {
000002  2301              MOVS     r3,#1
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  4093              LSLS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
000008  4770              BX       lr
;;;47     	return clkdlycnt;
;;;48     }
;;;49     
                          ENDP


                          AREA ||area_number.6||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.6||, ||.text||
                  TIM_ConfigStructInit PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  b920              CBNZ     r0,|L6.12|
;;;44     {
000002  460a              MOV      r2,r1
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  2301              MOVS     r3,#1
000006  7013              STRB     r3,[r2,#0]
000008  6053              STR      r3,[r2,#4]
00000a  e003              B        |L6.20|
                  |L6.12|
;;;47     	return clkdlycnt;
00000c  460a              MOV      r2,r1
;;;48     }
00000e  2300              MOVS     r3,#0
000010  7053              STRB     r3,[r2,#1]
000012  bf00              NOP      
                  |L6.20|
000014  4770              BX       lr
;;;49     
                          ENDP


                          AREA ||area_number.7||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.text||
                  TIM_DeInit PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  b510              PUSH     {r4,lr}
;;;44     {
000002  4604              MOV      r4,r0
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  2000              MOVS     r0,#0
000006  6060              STR      r0,[r4,#4]
000008  f1b42f40          CMP      r4,#0x40004000
;;;47     	return clkdlycnt;
00000c  d104              BNE      |L7.24|
;;;48     }
00000e  2100              MOVS     r1,#0
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       CLKPWR_ConfigPPWR
000016  e018              B        |L7.74|
                  |L7.24|
000018  480c              LDR      r0,|L7.76|
00001a  4284              CMP      r4,r0
00001c  d104              BNE      |L7.40|
00001e  2100              MOVS     r1,#0
000020  2004              MOVS     r0,#4
000022  f7fffffe          BL       CLKPWR_ConfigPPWR
000026  e010              B        |L7.74|
                  |L7.40|
000028  4809              LDR      r0,|L7.80|
00002a  4284              CMP      r4,r0
00002c  d105              BNE      |L7.58|
00002e  2100              MOVS     r1,#0
000030  f44f0080          MOV      r0,#0x400000
000034  f7fffffe          BL       CLKPWR_ConfigPPWR
000038  e007              B        |L7.74|
                  |L7.58|
00003a  4806              LDR      r0,|L7.84|
00003c  4284              CMP      r4,r0
00003e  d104              BNE      |L7.74|
000040  2100              MOVS     r1,#0
000042  f44f0080          MOV      r0,#0x400000
000046  f7fffffe          BL       CLKPWR_ConfigPPWR
                  |L7.74|
00004a  bd10              POP      {r4,pc}
;;;49     
                          ENDP

                  |L7.76|
                          DCD      0x40008000
                  |L7.80|
                          DCD      0x40090000
                  |L7.84|
                          DCD      0x40094000

                          AREA ||area_number.8||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.8||, ||.text||
                  TIM_UpdateMatchValue PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  b131              CBZ      r1,|L8.16|
;;;44     {
000002  2901              CMP      r1,#1
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  d006              BEQ      |L8.20|
000006  2902              CMP      r1,#2
000008  d006              BEQ      |L8.24|
00000a  2903              CMP      r1,#3
;;;47     	return clkdlycnt;
00000c  d108              BNE      |L8.32|
;;;48     }
00000e  e005              B        |L8.28|
                  |L8.16|
000010  6182              STR      r2,[r0,#0x18]
000012  e007              B        |L8.36|
                  |L8.20|
000014  61c2              STR      r2,[r0,#0x1c]
000016  e005              B        |L8.36|
                  |L8.24|
000018  6202              STR      r2,[r0,#0x20]
00001a  e003              B        |L8.36|
                  |L8.28|
00001c  6242              STR      r2,[r0,#0x24]
00001e  e001              B        |L8.36|
                  |L8.32|
000020  bf00              NOP      
                  |L8.34|
000022  e7fe              B        |L8.34|
                  |L8.36|
000024  bf00              NOP      
000026  4770              BX       lr
;;;49     
                          ENDP


                          AREA ||area_number.9||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.text||
                  TIM_ConfigCapture PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  b510              PUSH     {r4,lr}
;;;44     {
000002  6a82              LDR      r2,[r0,#0x28]
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  780b              LDRB     r3,[r1,#0]
000006  eb030443          ADD      r4,r3,r3,LSL #1
00000a  2307              MOVS     r3,#7
;;;47     	return clkdlycnt;
00000c  40a3              LSLS     r3,r3,r4
;;;48     }
00000e  439a              BICS     r2,r2,r3
000010  6282              STR      r2,[r0,#0x28]
000012  784a              LDRB     r2,[r1,#1]
000014  b13a              CBZ      r2,|L9.38|
000016  6a82              LDR      r2,[r0,#0x28]
000018  780b              LDRB     r3,[r1,#0]
00001a  eb030443          ADD      r4,r3,r3,LSL #1
00001e  2301              MOVS     r3,#1
000020  40a3              LSLS     r3,r3,r4
000022  431a              ORRS     r2,r2,r3
000024  6282              STR      r2,[r0,#0x28]
                  |L9.38|
000026  788a              LDRB     r2,[r1,#2]
000028  b142              CBZ      r2,|L9.60|
00002a  6a82              LDR      r2,[r0,#0x28]
00002c  780b              LDRB     r3,[r1,#0]
00002e  eb030343          ADD      r3,r3,r3,LSL #1
000032  1c5b              ADDS     r3,r3,#1
000034  2401              MOVS     r4,#1
000036  409c              LSLS     r4,r4,r3
000038  4322              ORRS     r2,r2,r4
00003a  6282              STR      r2,[r0,#0x28]
                  |L9.60|
00003c  78ca              LDRB     r2,[r1,#3]
00003e  b142              CBZ      r2,|L9.82|
000040  6a82              LDR      r2,[r0,#0x28]
000042  780b              LDRB     r3,[r1,#0]
000044  eb030343          ADD      r3,r3,r3,LSL #1
000048  1c9b              ADDS     r3,r3,#2
00004a  2401              MOVS     r4,#1
00004c  409c              LSLS     r4,r4,r3
00004e  4322              ORRS     r2,r2,r4
000050  6282              STR      r2,[r0,#0x28]
                  |L9.82|
000052  bd10              POP      {r4,pc}
;;;49     
                          ENDP


                          AREA ||area_number.10||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.text||
                  TIM_GetCaptureValue PROC
;;;42      **********************************************************************/
;;;43     static uint32_t getPClock (uint32_t timernum)
000000  4602              MOV      r2,r0
;;;44     {
000002  b909              CBNZ     r1,|L10.8|
;;;45     	uint32_t clkdlycnt;
;;;46     	clkdlycnt = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
000004  6ad0              LDR      r0,[r2,#0x2c]
                  |L10.6|
000006  4770              BX       lr
                  |L10.8|
000008  6b10              LDR      r0,[r2,#0x30]
00000a  e7fc              B        |L10.6|
;;;47     	return clkdlycnt;
;;;48     }
;;;49     
                          ENDP


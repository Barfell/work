L 1 "..\Startup\system_LPC177x_8x.c"
N/**************************************************************************//**
N * @file     system_LPC177x_8x.c
N * @brief    CMSIS Cortex-M3 Device Peripheral Access Layer Source File
N *           for the NXP LPC177x_8x Device Series
N * @version  V1.11
N * @date     10. November. 2010
N *
N * @note
N * Copyright (C) 2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#include <stdint.h>
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 27 "..\Startup\system_LPC177x_8x.c" 2
N#include "LPC177x_8x.h"
L 1 "..\Startup\LPC177x_8x.h" 1
N/***********************************************************************
N * $Id: LPC177x_8x.h 6698 2011-03-03 21:20:50Z nxp21346 $
N *
N * Project: LPC177x_8x CMSIS Package
N *
N * Description: Cortex-M3 Core Peripheral Access Layer Header File for
N *              NXP LPC177x_8x Series.
N *
N * Copyright(C) 2011, NXP Semiconductor
N * All rights reserved.
N *
N ***********************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **********************************************************************/
N
N
N#ifndef __LPC177x_8x_H__
N#define __LPC177x_8x_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC177x_8x Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  Reserved0_IRQn                = 13,       /*!< Reserved                                         */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  MCI_IRQn                      = 29,       /*!< SD/MMC card I/F Interrupt                        */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /*!< USB Activity interrupt                           */
N  CANActivity_IRQn              = 34,       /*!< CAN Activity interrupt                           */
N  UART4_IRQn                    = 35,       /*!< UART4 Interrupt                                  */
N  SSP2_IRQn                     = 36,       /*!< SSP2 Interrupt                                   */
N  LCD_IRQn                      = 37,       /*!< LCD Interrupt                                    */
N  GPIO_IRQn                     = 38,       /*!< GPIO Interrupt                                   */
N  PWM0_IRQn                     = 39,       /*!< PWM0 Interrupt                                   */
N  EEPROM_IRQn                   = 40,       /*!< EEPROM Interrupt                           */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
L 1 "..\CM3_lib\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N/** @addtogroup CMSIS
N * @{
N */
N
N/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - Error 10: \n
N *     register uint32_t __regBasePri         __asm("basepri"); \n
N *     Error 10: Expecting ';'
N * .
N *   - Error 530: \n
N *     return(__regBasePri); \n
N *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
N * .
N *   - Error 550: \n
N *     __regBasePri = (basePri & 0x1ff); \n
N *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
N * .
N *   - Error 754: \n
N *     uint32_t RESERVED0[24]; \n
N *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced
N * .
N *   - Error 750: \n
N *     #define __CM3_CORE_H__ \n
N *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced
N * .
N *   - Error 528: \n
N *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced
N * .
N *   - Error 751: \n
N *     } InterruptType_Type; \n
N *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N/** @addtogroup CMSIS_CM3_core_definitions CMSIS CM3 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
N/** @brief  Nested Vectored Interrupt Controller (NVIC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM3_NVIC */
N
N
N/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
N/** @brief  System Control Block (SCB) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM3_SCB */
N
N
N/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
N  memory mapped structure for SysTick
N  @{
N */
N/** @brief  System Tick Timer (SysTick) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RELOAD;                       /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t RELOAD;                        
N  __IO uint32_t CURR;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t CURR;                           
N  __IO uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM3_SysTick */
N
N
N/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM
N  memory mapped structure for Instrumentation Trace Macrocell (ITM)
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                          
N  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                          
N  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                          
N  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                          
N  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                          
N  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                          
N  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                          
N  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                          
N  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                          
N  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                          
N  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                          
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N/*@}*/ /* end of group CMSIS_CM3_ITM */
N
N
N/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type
N  memory mapped structure for Interrupt Type
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */
N#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */
N#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */
N
N#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
N#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */
N
N#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */
N#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */
N/*@}*/ /* end of group CMSIS_CM3_InterruptType */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU
N  memory mapped structure for Memory Protection Unit (MPU)
N  @{
N */
N/** @brief   Memory Protection Unit (MPU) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */
N#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */
N#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */
N#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */
N#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */
N#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */
N#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@}*/ /* end of group CMSIS_CM3_MPU */
N#endif
N
N
N/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
N/** @brief   Core Debug register structure definition */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM3_CoreDebug */
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5040049 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S *
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @return BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  basePri  BasePriority
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @return FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  faultMask  faultMask value
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N *
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit values)
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask  faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S*
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit value
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N
N/* ##########################   NVIC functions  #################################### */
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  PriorityGroup is priority grouping field
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFul << 16) | (7ul << 8));              
N  reg_value  =  (reg_value                       |
N                (0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                (0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR =  reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @return priority grouping field
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) >> 8);    
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N *
N * @param  IRQn   The positive number of the external interrupt to disable
N *
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N *
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending,
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for read active bit
N * @return         1 = interrupt active, 0 = interrupt not active
N *
N * Read the active register in NVIC and returns 1 if its status is active,
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  PriorityGroup    The used priority group
N * @param  PreemptPriority  The preemptive priority value (starting from 0)
N * @param  SubPriority      The sub priority value (starting from 0)
N * @return                  The encoded priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  Priority           The priority for the interrupt
N * @param  PriorityGroup      The used priority group
N * @param  pPreemptPriority   The preemptive priority value (starting from 0)
N * @param  pSubPriority       The sub priority value (starting from 0)
N *
N * Decode an interrupt priority value with the given priority group to
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N
N  SysTick->RELOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->RELOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);   
N  SysTick->CURR   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CURR   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1ul << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1ul << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N
N/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface
N  Core Debug Interface containing:
N  - Core Debug Receive / Transmit Functions
N  - Core Debug Defines
N  - Core Debug Variables
N*/
N/*@{*/
N
Nextern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */
N#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param  ch   character to output
N * @return      character to output
N *
N * The function outputs a character via the ITM channel 0.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1ul << 24))  &&       
N      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X      (((ITM_Type *) (0xE0000000))->TCR & (1ul << 0))                  &&       
N      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000))->TER & (1ul << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/**
N * @brief  Inputs a character via variable ITM_RxBuffer
N *
N * @return      received character, -1 = no character received
N *
N * The function inputs a character via variable ITM_RxBuffer.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE int ITM_ReceiveChar (void) {
Xstatic __inline int ITM_ReceiveChar (void) {
N  int ch = -1;                               /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/**
N * @brief  Check if a character via variable ITM_RxBuffer is available
N *
N * @return      1 = character available, 0 = no character available
N *
N * The function checks  variable ITM_RxBuffer whether a character is available or not.
N * The function returns '1' if a character is available and '0' if no character is available.
N */
Nstatic __INLINE int ITM_CheckChar (void) {
Xstatic __inline int ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_definitions */
N
N#endif /* __CM3_CORE_H__ */
N
N /**
N  * @}
N  */
N
N/*lint -restore */
L 105 "..\Startup\LPC177x_8x.h" 2
N//#include "system_LPC177x_8x.h"                 /* System Header                                      */
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;                   /*!< Offset: 0x000 (R/W)  Flash Accelerator Configuration Register */
X  volatile uint32_t FLASHCFG;                    
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                    /*!< Offset: 0x080 (R/W)  PLL0 Control Register */
X  volatile uint32_t PLL0CON;                     
N  __IO uint32_t PLL0CFG;                    /*!< Offset: 0x084 (R/W)  PLL0 Configuration Register */
X  volatile uint32_t PLL0CFG;                     
N  __I  uint32_t PLL0STAT;                   /*!< Offset: 0x088 (R/ )  PLL0 Status Register */
X  volatile const  uint32_t PLL0STAT;                    
N  __O  uint32_t PLL0FEED;                   /*!< Offset: 0x08C ( /W)  PLL0 Feed Register */
X  volatile  uint32_t PLL0FEED;                    
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;                    /*!< Offset: 0x0A0 (R/W)  PLL1 Control Register */
X  volatile uint32_t PLL1CON;                     
N  __IO uint32_t PLL1CFG;                    /*!< Offset: 0x0A4 (R/W)  PLL1 Configuration Register */
X  volatile uint32_t PLL1CFG;                     
N  __I  uint32_t PLL1STAT;                   /*!< Offset: 0x0A8 (R/ )  PLL1 Status Register */
X  volatile const  uint32_t PLL1STAT;                    
N  __O  uint32_t PLL1FEED;                   /*!< Offset: 0x0AC ( /W)  PLL1 Feed Register */
X  volatile  uint32_t PLL1FEED;                    
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;                       /*!< Offset: 0x0C0 (R/W)  Power Control Register */
X  volatile uint32_t PCON;                        
N  __IO uint32_t PCONP;                      /*!< Offset: 0x0C4 (R/W)  Power Control for Peripherals Register */
X  volatile uint32_t PCONP;                       
N       uint32_t RESERVED3[14];
N  __IO uint32_t EMCCLKSEL;                  /*!< Offset: 0x100 (R/W)  External Memory Controller Clock Selection Register */
X  volatile uint32_t EMCCLKSEL;                   
N  __IO uint32_t CCLKSEL;                    /*!< Offset: 0x104 (R/W)  CPU Clock Selection Register */
X  volatile uint32_t CCLKSEL;                     
N  __IO uint32_t USBCLKSEL;                  /*!< Offset: 0x108 (R/W)  USB Clock Selection Register */
X  volatile uint32_t USBCLKSEL;                   
N  __IO uint32_t CLKSRCSEL;                  /*!< Offset: 0x10C (R/W)  Clock Source Select Register */
X  volatile uint32_t CLKSRCSEL;                   
N  __IO uint32_t	CANSLEEPCLR;                /*!< Offset: 0x110 (R/W)  CAN Sleep Clear Register */
X  volatile uint32_t	CANSLEEPCLR;                 
N  __IO uint32_t	CANWAKEFLAGS;               /*!< Offset: 0x114 (R/W)  CAN Wake-up Flags Register */
X  volatile uint32_t	CANWAKEFLAGS;                
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                     /*!< Offset: 0x140 (R/W)  External Interrupt Flag Register */
X  volatile uint32_t EXTINT;                      
N       uint32_t RESERVED5[1];
N  __IO uint32_t EXTMODE;                    /*!< Offset: 0x148 (R/W)  External Interrupt Mode Register */
X  volatile uint32_t EXTMODE;                     
N  __IO uint32_t EXTPOLAR;                   /*!< Offset: 0x14C (R/W)  External Interrupt Polarity Register */
X  volatile uint32_t EXTPOLAR;                    
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                       /*!< Offset: 0x180 (R/W)  Reset Source Identification Register */
X  volatile uint32_t RSID;                        
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                        /*!< Offset: 0x1A0 (R/W)  System Controls and Status Register */
X  volatile uint32_t SCS;                         
N  __IO uint32_t IRCTRIM;                    /*!< Offset: 0x1A4 (R/W) Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                     
N  __IO uint32_t PCLKSEL;                    /*!< Offset: 0x1A8 (R/W)  Peripheral Clock Selection Register */
X  volatile uint32_t PCLKSEL;                     
N       uint32_t RESERVED8[3];
N  __IO uint32_t LCD_CFG;                    /*!< Offset: 0x1B8 (R/W)  LCD Configuration and clocking control Register */
X  volatile uint32_t LCD_CFG;                     
N       uint32_t RESERVED9[1];
N  __IO uint32_t USBIntSt;                   /*!< Offset: 0x1C0 (R/W)  USB Interrupt Status Register */
X  volatile uint32_t USBIntSt;                    
N  __IO uint32_t DMAREQSEL;                  /*!< Offset: 0x1C4 (R/W)  DMA Request Select Register */
X  volatile uint32_t DMAREQSEL;                   
N  __IO uint32_t CLKOUTCFG;                  /*!< Offset: 0x1C8 (R/W)  Clock Output Configuration Register */
X  volatile uint32_t CLKOUTCFG;                   
N  __IO uint32_t RSTCON0;                    /*!< Offset: 0x1CC (R/W)  RESET Control0 Register */
X  volatile uint32_t RSTCON0;                     
N  __IO uint32_t RSTCON1;                    /*!< Offset: 0x1D0 (R/W)  RESET Control1 Register */
X  volatile uint32_t RSTCON1;                     
N       uint32_t RESERVED10[2];
N  __IO uint32_t EMCDLYCTL;                  /*!< Offset: 0x1DC (R/W) SDRAM programmable delays          */
X  volatile uint32_t EMCDLYCTL;                   
N  __IO uint32_t EMCCAL;                     /*!< Offset: 0x1E0 (R/W) Calibration of programmable delays */
X  volatile uint32_t EMCCAL;                      
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t P0_0;				/* 0x000 */
X  volatile uint32_t P0_0;				 
N  __IO uint32_t P0_1;
X  volatile uint32_t P0_1;
N  __IO uint32_t P0_2;
X  volatile uint32_t P0_2;
N  __IO uint32_t P0_3;
X  volatile uint32_t P0_3;
N  __IO uint32_t P0_4;
X  volatile uint32_t P0_4;
N  __IO uint32_t P0_5;
X  volatile uint32_t P0_5;
N  __IO uint32_t P0_6;
X  volatile uint32_t P0_6;
N  __IO uint32_t P0_7;
X  volatile uint32_t P0_7;
N
N  __IO uint32_t P0_8;				/* 0x020 */
X  volatile uint32_t P0_8;				 
N  __IO uint32_t P0_9;
X  volatile uint32_t P0_9;
N  __IO uint32_t P0_10;
X  volatile uint32_t P0_10;
N  __IO uint32_t P0_11;
X  volatile uint32_t P0_11;
N  __IO uint32_t P0_12;
X  volatile uint32_t P0_12;
N  __IO uint32_t P0_13;
X  volatile uint32_t P0_13;
N  __IO uint32_t P0_14;
X  volatile uint32_t P0_14;
N  __IO uint32_t P0_15;
X  volatile uint32_t P0_15;
N
N  __IO uint32_t P0_16;				/* 0x040 */
X  volatile uint32_t P0_16;				 
N  __IO uint32_t P0_17;
X  volatile uint32_t P0_17;
N  __IO uint32_t P0_18;
X  volatile uint32_t P0_18;
N  __IO uint32_t P0_19;
X  volatile uint32_t P0_19;
N  __IO uint32_t P0_20;
X  volatile uint32_t P0_20;
N  __IO uint32_t P0_21;
X  volatile uint32_t P0_21;
N  __IO uint32_t P0_22;
X  volatile uint32_t P0_22;
N  __IO uint32_t P0_23;
X  volatile uint32_t P0_23;
N
N  __IO uint32_t P0_24;				/* 0x060 */
X  volatile uint32_t P0_24;				 
N  __IO uint32_t P0_25;
X  volatile uint32_t P0_25;
N  __IO uint32_t P0_26;
X  volatile uint32_t P0_26;
N  __IO uint32_t P0_27;
X  volatile uint32_t P0_27;
N  __IO uint32_t P0_28;
X  volatile uint32_t P0_28;
N  __IO uint32_t P0_29;
X  volatile uint32_t P0_29;
N  __IO uint32_t P0_30;
X  volatile uint32_t P0_30;
N  __IO uint32_t P0_31;
X  volatile uint32_t P0_31;
N
N  __IO uint32_t P1_0;				/* 0x080 */
X  volatile uint32_t P1_0;				 
N  __IO uint32_t P1_1;
X  volatile uint32_t P1_1;
N  __IO uint32_t P1_2;
X  volatile uint32_t P1_2;
N  __IO uint32_t P1_3;
X  volatile uint32_t P1_3;
N  __IO uint32_t P1_4;
X  volatile uint32_t P1_4;
N  __IO uint32_t P1_5;
X  volatile uint32_t P1_5;
N  __IO uint32_t P1_6;
X  volatile uint32_t P1_6;
N  __IO uint32_t P1_7;
X  volatile uint32_t P1_7;
N
N  __IO uint32_t P1_8;				/* 0x0A0 */
X  volatile uint32_t P1_8;				 
N  __IO uint32_t P1_9;
X  volatile uint32_t P1_9;
N  __IO uint32_t P1_10;
X  volatile uint32_t P1_10;
N  __IO uint32_t P1_11;
X  volatile uint32_t P1_11;
N  __IO uint32_t P1_12;
X  volatile uint32_t P1_12;
N  __IO uint32_t P1_13;
X  volatile uint32_t P1_13;
N  __IO uint32_t P1_14;
X  volatile uint32_t P1_14;
N  __IO uint32_t P1_15;
X  volatile uint32_t P1_15;
N
N  __IO uint32_t P1_16;				/* 0x0C0 */
X  volatile uint32_t P1_16;				 
N  __IO uint32_t P1_17;
X  volatile uint32_t P1_17;
N  __IO uint32_t P1_18;
X  volatile uint32_t P1_18;
N  __IO uint32_t P1_19;
X  volatile uint32_t P1_19;
N  __IO uint32_t P1_20;
X  volatile uint32_t P1_20;
N  __IO uint32_t P1_21;
X  volatile uint32_t P1_21;
N  __IO uint32_t P1_22;
X  volatile uint32_t P1_22;
N  __IO uint32_t P1_23;
X  volatile uint32_t P1_23;
N
N  __IO uint32_t P1_24;				/* 0x0E0 */
X  volatile uint32_t P1_24;				 
N  __IO uint32_t P1_25;
X  volatile uint32_t P1_25;
N  __IO uint32_t P1_26;
X  volatile uint32_t P1_26;
N  __IO uint32_t P1_27;
X  volatile uint32_t P1_27;
N  __IO uint32_t P1_28;
X  volatile uint32_t P1_28;
N  __IO uint32_t P1_29;
X  volatile uint32_t P1_29;
N  __IO uint32_t P1_30;
X  volatile uint32_t P1_30;
N  __IO uint32_t P1_31;
X  volatile uint32_t P1_31;
N
N  __IO uint32_t P2_0;				/* 0x100 */
X  volatile uint32_t P2_0;				 
N  __IO uint32_t P2_1;
X  volatile uint32_t P2_1;
N  __IO uint32_t P2_2;
X  volatile uint32_t P2_2;
N  __IO uint32_t P2_3;
X  volatile uint32_t P2_3;
N  __IO uint32_t P2_4;
X  volatile uint32_t P2_4;
N  __IO uint32_t P2_5;
X  volatile uint32_t P2_5;
N  __IO uint32_t P2_6;
X  volatile uint32_t P2_6;
N  __IO uint32_t P2_7;
X  volatile uint32_t P2_7;
N
N  __IO uint32_t P2_8;				/* 0x120 */
X  volatile uint32_t P2_8;				 
N  __IO uint32_t P2_9;
X  volatile uint32_t P2_9;
N  __IO uint32_t P2_10;
X  volatile uint32_t P2_10;
N  __IO uint32_t P2_11;
X  volatile uint32_t P2_11;
N  __IO uint32_t P2_12;
X  volatile uint32_t P2_12;
N  __IO uint32_t P2_13;
X  volatile uint32_t P2_13;
N  __IO uint32_t P2_14;
X  volatile uint32_t P2_14;
N  __IO uint32_t P2_15;
X  volatile uint32_t P2_15;
N
N  __IO uint32_t P2_16;				/* 0x140 */
X  volatile uint32_t P2_16;				 
N  __IO uint32_t P2_17;
X  volatile uint32_t P2_17;
N  __IO uint32_t P2_18;
X  volatile uint32_t P2_18;
N  __IO uint32_t P2_19;
X  volatile uint32_t P2_19;
N  __IO uint32_t P2_20;
X  volatile uint32_t P2_20;
N  __IO uint32_t P2_21;
X  volatile uint32_t P2_21;
N  __IO uint32_t P2_22;
X  volatile uint32_t P2_22;
N  __IO uint32_t P2_23;
X  volatile uint32_t P2_23;
N
N  __IO uint32_t P2_24;				/* 0x160 */
X  volatile uint32_t P2_24;				 
N  __IO uint32_t P2_25;
X  volatile uint32_t P2_25;
N  __IO uint32_t P2_26;
X  volatile uint32_t P2_26;
N  __IO uint32_t P2_27;
X  volatile uint32_t P2_27;
N  __IO uint32_t P2_28;
X  volatile uint32_t P2_28;
N  __IO uint32_t P2_29;
X  volatile uint32_t P2_29;
N  __IO uint32_t P2_30;
X  volatile uint32_t P2_30;
N  __IO uint32_t P2_31;
X  volatile uint32_t P2_31;
N
N  __IO uint32_t P3_0;				/* 0x180 */
X  volatile uint32_t P3_0;				 
N  __IO uint32_t P3_1;
X  volatile uint32_t P3_1;
N  __IO uint32_t P3_2;
X  volatile uint32_t P3_2;
N  __IO uint32_t P3_3;
X  volatile uint32_t P3_3;
N  __IO uint32_t P3_4;
X  volatile uint32_t P3_4;
N  __IO uint32_t P3_5;
X  volatile uint32_t P3_5;
N  __IO uint32_t P3_6;
X  volatile uint32_t P3_6;
N  __IO uint32_t P3_7;
X  volatile uint32_t P3_7;
N
N  __IO uint32_t P3_8;				/* 0x1A0 */
X  volatile uint32_t P3_8;				 
N  __IO uint32_t P3_9;
X  volatile uint32_t P3_9;
N  __IO uint32_t P3_10;
X  volatile uint32_t P3_10;
N  __IO uint32_t P3_11;
X  volatile uint32_t P3_11;
N  __IO uint32_t P3_12;
X  volatile uint32_t P3_12;
N  __IO uint32_t P3_13;
X  volatile uint32_t P3_13;
N  __IO uint32_t P3_14;
X  volatile uint32_t P3_14;
N  __IO uint32_t P3_15;
X  volatile uint32_t P3_15;
N
N  __IO uint32_t P3_16;				/* 0x1C0 */
X  volatile uint32_t P3_16;				 
N  __IO uint32_t P3_17;
X  volatile uint32_t P3_17;
N  __IO uint32_t P3_18;
X  volatile uint32_t P3_18;
N  __IO uint32_t P3_19;
X  volatile uint32_t P3_19;
N  __IO uint32_t P3_20;
X  volatile uint32_t P3_20;
N  __IO uint32_t P3_21;
X  volatile uint32_t P3_21;
N  __IO uint32_t P3_22;
X  volatile uint32_t P3_22;
N  __IO uint32_t P3_23;
X  volatile uint32_t P3_23;
N
N  __IO uint32_t P3_24;				/* 0x1E0 */
X  volatile uint32_t P3_24;				 
N  __IO uint32_t P3_25;
X  volatile uint32_t P3_25;
N  __IO uint32_t P3_26;
X  volatile uint32_t P3_26;
N  __IO uint32_t P3_27;
X  volatile uint32_t P3_27;
N  __IO uint32_t P3_28;
X  volatile uint32_t P3_28;
N  __IO uint32_t P3_29;
X  volatile uint32_t P3_29;
N  __IO uint32_t P3_30;
X  volatile uint32_t P3_30;
N  __IO uint32_t P3_31;
X  volatile uint32_t P3_31;
N
N  __IO uint32_t P4_0;				/* 0x200 */
X  volatile uint32_t P4_0;				 
N  __IO uint32_t P4_1;
X  volatile uint32_t P4_1;
N  __IO uint32_t P4_2;
X  volatile uint32_t P4_2;
N  __IO uint32_t P4_3;
X  volatile uint32_t P4_3;
N  __IO uint32_t P4_4;
X  volatile uint32_t P4_4;
N  __IO uint32_t P4_5;
X  volatile uint32_t P4_5;
N  __IO uint32_t P4_6;
X  volatile uint32_t P4_6;
N  __IO uint32_t P4_7;
X  volatile uint32_t P4_7;
N
N  __IO uint32_t P4_8;				/* 0x220 */
X  volatile uint32_t P4_8;				 
N  __IO uint32_t P4_9;
X  volatile uint32_t P4_9;
N  __IO uint32_t P4_10;
X  volatile uint32_t P4_10;
N  __IO uint32_t P4_11;
X  volatile uint32_t P4_11;
N  __IO uint32_t P4_12;
X  volatile uint32_t P4_12;
N  __IO uint32_t P4_13;
X  volatile uint32_t P4_13;
N  __IO uint32_t P4_14;
X  volatile uint32_t P4_14;
N  __IO uint32_t P4_15;
X  volatile uint32_t P4_15;
N
N  __IO uint32_t P4_16;				/* 0x240 */
X  volatile uint32_t P4_16;				 
N  __IO uint32_t P4_17;
X  volatile uint32_t P4_17;
N  __IO uint32_t P4_18;
X  volatile uint32_t P4_18;
N  __IO uint32_t P4_19;
X  volatile uint32_t P4_19;
N  __IO uint32_t P4_20;
X  volatile uint32_t P4_20;
N  __IO uint32_t P4_21;
X  volatile uint32_t P4_21;
N  __IO uint32_t P4_22;
X  volatile uint32_t P4_22;
N  __IO uint32_t P4_23;
X  volatile uint32_t P4_23;
N
N  __IO uint32_t P4_24;				/* 0x260 */
X  volatile uint32_t P4_24;				 
N  __IO uint32_t P4_25;
X  volatile uint32_t P4_25;
N  __IO uint32_t P4_26;
X  volatile uint32_t P4_26;
N  __IO uint32_t P4_27;
X  volatile uint32_t P4_27;
N  __IO uint32_t P4_28;
X  volatile uint32_t P4_28;
N  __IO uint32_t P4_29;
X  volatile uint32_t P4_29;
N  __IO uint32_t P4_30;
X  volatile uint32_t P4_30;
N  __IO uint32_t P4_31;
X  volatile uint32_t P4_31;
N
N  __IO uint32_t P5_0;				/* 0x280 */
X  volatile uint32_t P5_0;				 
N  __IO uint32_t P5_1;
X  volatile uint32_t P5_1;
N  __IO uint32_t P5_2;
X  volatile uint32_t P5_2;
N  __IO uint32_t P5_3;
X  volatile uint32_t P5_3;
N  __IO uint32_t P5_4;				/* 0x290 */
X  volatile uint32_t P5_4;				 
N} LPC_IOCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DIR;
X  volatile uint32_t DIR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t PIN;
X  volatile uint32_t PIN;
N  __IO uint32_t SET;
X  volatile uint32_t SET;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;                    /*!< Offset: 0x03C External Match Register (R/W) */
X  volatile uint32_t EMR;                     
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;                   /*!< Offset: 0x070 Count Control Register (R/W) */
X  volatile uint32_t CTCR;                    
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N  __I  uint32_t CR2;					/*!< Offset: 0x034 Capture Register 2 (R/ ) */
X  volatile const  uint32_t CR2;					 
N  __I  uint32_t CR3;					/*!< Offset: 0x038 Capture Register 3 (R/ ) */
X  volatile const  uint32_t CR3;					 
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;					/*!< Offset: 0x040 Match Register 4 (R/W) */
X  volatile uint32_t MR4;					 
N  __IO uint32_t MR5;					/*!< Offset: 0x044 Match Register 5 (R/W) */
X  volatile uint32_t MR5;					 
N  __IO uint32_t MR6;					/*!< Offset: 0x048 Match Register 6 (R/W) */
X  volatile uint32_t MR6;					 
N  __IO uint32_t PCR;					/*!< Offset: 0x04C PWM Control Register (R/W) */
X  volatile uint32_t PCR;					 
N  __IO uint32_t LER;					/*!< Offset: 0x050 Load Enable Register (R/W) */
X  volatile uint32_t LER;					 
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;					/*!< Offset: 0x070 Counter Control Register (R/W) */
X  volatile uint32_t CTCR;					 
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UARTx) -----------*/
N/* There are three types of UARTs on the chip:
N(1) UART0,UART2, and UART3 are the standard UART.
N(2) UART1 is the standard with modem capability.
N(3) USART(UART4) is the sync/async UART with smart card capability.
NMore details can be found on the Users Manual. */
N
N#if 0
Stypedef struct
S{
S  union {
S  __I  uint8_t  RBR;
S  __O  uint8_t  THR;
S  __IO uint8_t  DLL;
S       uint32_t RESERVED0;
S  };
S  union {
S  __IO uint8_t  DLM;
S  __IO uint32_t IER;
S  };
S  union {
S  __I  uint32_t IIR;
S  __O  uint8_t  FCR;
S  };
S  __IO uint8_t  LCR;
S       uint8_t  RESERVED1[7];
S  __I  uint8_t  LSR;
S       uint8_t  RESERVED2[7];
S  __IO uint8_t  SCR;
S       uint8_t  RESERVED3[3];
S  __IO uint32_t ACR;
S  __IO uint8_t  ICR;
S       uint8_t  RESERVED4[3];
S  __IO uint8_t  FDR;
S       uint8_t  RESERVED5[7];
S  __IO uint8_t  TER;
S       uint8_t  RESERVED6[39];
S  __I  uint8_t  FIFOLVL;
S} LPC_UART_TypeDef;
N#else
Ntypedef struct
N{
N	union
N	{
N		__I  uint8_t  RBR;
X		volatile const  uint8_t  RBR;
N		__O  uint8_t  THR;
X		volatile  uint8_t  THR;
N		__IO uint8_t  DLL;
X		volatile uint8_t  DLL;
N		uint32_t RESERVED0;
N	};
N	union
N	{
N		__IO uint8_t  DLM;
X		volatile uint8_t  DLM;
N		__IO uint32_t IER;
X		volatile uint32_t IER;
N	};
N	union
N	{
N		__I  uint32_t IIR;
X		volatile const  uint32_t IIR;
N		__O  uint8_t  FCR;
X		volatile  uint8_t  FCR;
N	};
N	__IO uint8_t  LCR;
X	volatile uint8_t  LCR;
N	uint8_t  RESERVED1[7];//Reserved
N	__I  uint8_t  LSR;
X	volatile const  uint8_t  LSR;
N	uint8_t  RESERVED2[7];//Reserved
N	__IO uint8_t  SCR;
X	volatile uint8_t  SCR;
N	uint8_t  RESERVED3[3];//Reserved
N	__IO uint32_t ACR;
X	volatile uint32_t ACR;
N	__IO uint8_t  ICR;
X	volatile uint8_t  ICR;
N	uint8_t  RESERVED4[3];//Reserved
N	__IO uint8_t  FDR;
X	volatile uint8_t  FDR;
N	uint8_t  RESERVED5[7];//Reserved
N	__IO uint8_t  TER;
X	volatile uint8_t  TER;
N	uint8_t  RESERVED8[27];//Reserved
N	__IO uint8_t  RS485CTRL;
X	volatile uint8_t  RS485CTRL;
N	uint8_t  RESERVED9[3];//Reserved
N	__IO uint8_t  ADRMATCH;
X	volatile uint8_t  ADRMATCH;
N	uint8_t  RESERVED10[3];//Reserved
N	__IO uint8_t  RS485DLY;
X	volatile uint8_t  RS485DLY;
N	uint8_t  RESERVED11[3];//Reserved
N	__I  uint8_t  FIFOLVL;
X	volatile const  uint8_t  FIFOLVL;
N}LPC_UART_TypeDef;
N#endif
N
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART1_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;                   /*!< Offset: 0x000 Receiver Buffer  Register (R/ ) */
X  volatile const  uint32_t  RBR;                    
N  __O  uint32_t  THR;                   /*!< Offset: 0x000 Transmit Holding Register ( /W) */
X  volatile  uint32_t  THR;                    
N  __IO uint32_t  DLL;                   /*!< Offset: 0x000 Divisor Latch LSB (R/W) */
X  volatile uint32_t  DLL;                    
N  };
N  union {
N  __IO uint32_t  DLM;                   /*!< Offset: 0x004 Divisor Latch MSB (R/W) */
X  volatile uint32_t  DLM;                    
N  __IO uint32_t  IER;                   /*!< Offset: 0x000 Interrupt Enable Register (R/W) */
X  volatile uint32_t  IER;                    
N  };
N  union {
N  __I  uint32_t  IIR;                   /*!< Offset: 0x008 Interrupt ID Register (R/ ) */
X  volatile const  uint32_t  IIR;                    
N  __O  uint32_t  FCR;                   /*!< Offset: 0x008 FIFO Control Register ( /W) */
X  volatile  uint32_t  FCR;                    
N  };
N  __IO uint32_t  LCR;                   /*!< Offset: 0x00C Line Control Register (R/W) */
X  volatile uint32_t  LCR;                    
N  __IO uint32_t  MCR;                   /*!< Offset: 0x010 Modem control Register (R/W) */
X  volatile uint32_t  MCR;                    
N  __I  uint32_t  LSR;                   /*!< Offset: 0x014 Line Status Register (R/ ) */
X  volatile const  uint32_t  LSR;                    
N  __I  uint32_t  MSR;                   /*!< Offset: 0x018 Modem status Register (R/ ) */
X  volatile const  uint32_t  MSR;                    
N  __IO uint32_t  SCR;                   /*!< Offset: 0x01C Scratch Pad Register (R/W) */
X  volatile uint32_t  SCR;                    
N  __IO uint32_t  ACR;                   /*!< Offset: 0x020 Auto-baud Control Register (R/W) */
X  volatile uint32_t  ACR;                    
N  __IO uint32_t  ICR;                   /*!< Offset: 0x024 irDA Control Register (R/W) */
X  volatile uint32_t  ICR;                    
N  __IO uint32_t  FDR;                   /*!< Offset: 0x028 Fractional Divider Register (R/W) */
X  volatile uint32_t  FDR;                    
N  __IO uint32_t  OSR;                   /*!< Offset: 0x02C Over sampling Register (R/W) */
X  volatile uint32_t  OSR;                    
N  __O  uint32_t  POP;                   /*!< Offset: 0x030 NHP Pop Register (W) */
X  volatile  uint32_t  POP;                    
N  __IO uint32_t  MODE;                  /*!< Offset: 0x034 NHP Mode selection Register (W) */
X  volatile uint32_t  MODE;                   
N       uint32_t  RESERVED0[2];
N  __IO uint32_t  HDEN;                  /*!< Offset: 0x040 Half duplex Enable Register (R/W) */
X  volatile uint32_t  HDEN;                   
N       uint32_t  RESERVED1;
N  __IO uint32_t  SCI_CTRL;				/*!< Offset: 0x048 Smart card Interface Control Register (R/W) */
X  volatile uint32_t  SCI_CTRL;				 
N  __IO uint32_t  RS485CTRL;             /*!< Offset: 0x04C RS-485/EIA-485 Control Register (R/W) */
X  volatile uint32_t  RS485CTRL;              
N  __IO uint32_t  ADRMATCH;              /*!< Offset: 0x050 RS-485/EIA-485 address match Register (R/W) */
X  volatile uint32_t  ADRMATCH;               
N  __IO uint32_t  RS485DLY;              /*!< Offset: 0x054 RS-485/EIA-485 direction control delay Register (R/W) */
X  volatile uint32_t  RS485DLY;               
N  __IO uint32_t  SYNCCTRL;              /*!< Offset: 0x058 Synchronous Mode Control Register (R/W ) */
X  volatile uint32_t  SYNCCTRL;               
N  __IO uint32_t  TER;                   /*!< Offset: 0x05C Transmit Enable Register (R/W) */
X  volatile uint32_t  TER;                    
N       uint32_t  RESERVED2[989];
N  __I  uint32_t  CFG;                   /*!< Offset: 0xFD4 Configuration Register (R) */
X  volatile const  uint32_t  CFG;                    
N  __O  uint32_t  INTCE;                 /*!< Offset: 0xFD8 Interrupt Clear Enable Register (W) */
X  volatile  uint32_t  INTCE;                  
N  __O  uint32_t  INTSE;                 /*!< Offset: 0xFDC Interrupt Set Enable Register (W) */
X  volatile  uint32_t  INTSE;                  
N  __I  uint32_t  INTS;                  /*!< Offset: 0xFE0 Interrupt Status Register (R) */
X  volatile const  uint32_t  INTS;                   
N  __I  uint32_t  INTE;                  /*!< Offset: 0xFE4 Interrupt Enable Register (R) */
X  volatile const  uint32_t  INTE;                   
N  __O  uint32_t  INTCS;                 /*!< Offset: 0xFE8 Interrupt Clear Status Register (W) */
X  volatile  uint32_t  INTCS;                  
N  __O  uint32_t  INTSS;                 /*!< Offset: 0xFEC Interrupt Set Status Register (W) */
X  volatile  uint32_t  INTSS;                  
N       uint32_t  RESERVED3[3];
N  __I  uint32_t  MID;                   /*!< Offset: 0xFFC Module Identification Register (R) */
X  volatile const  uint32_t  MID;                    
N} LPC_UART4_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;                    /*!< Offset: 0x000 Control Register 0 (R/W) */
X  volatile uint32_t CR0;                     
N  __IO uint32_t CR1;                    /*!< Offset: 0x004 Control Register 1 (R/W) */
X  volatile uint32_t CR1;                     
N  __IO uint32_t DR;                     /*!< Offset: 0x008 Data Register (R/W) */
X  volatile uint32_t DR;                      
N  __I  uint32_t SR;                     /*!< Offset: 0x00C Status Registe (R/ ) */
X  volatile const  uint32_t SR;                      
N  __IO uint32_t CPSR;                   /*!< Offset: 0x010 Clock Prescale Register (R/W) */
X  volatile uint32_t CPSR;                    
N  __IO uint32_t IMSC;                   /*!< Offset: 0x014 Interrupt Mask Set and Clear Register (R/W) */
X  volatile uint32_t IMSC;                    
N  __IO uint32_t RIS;                    /*!< Offset: 0x018 Raw Interrupt Status Register (R/W) */
X  volatile uint32_t RIS;                     
N  __IO uint32_t MIS;                    /*!< Offset: 0x01C Masked Interrupt Status Register (R/W) */
X  volatile uint32_t MIS;                     
N  __IO uint32_t ICR;                    /*!< Offset: 0x020 SSPICR Interrupt Clear Register (R/W) */
X  volatile uint32_t ICR;                     
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CONSET;                 /*!< Offset: 0x000 I2C Control Set Register (R/W) */
X  volatile uint32_t CONSET;                  
N  __I  uint32_t STAT;                   /*!< Offset: 0x004 I2C Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t DAT;                    /*!< Offset: 0x008 I2C Data Register (R/W) */
X  volatile uint32_t DAT;                     
N  __IO uint32_t ADR0;                   /*!< Offset: 0x00C I2C Slave Address Register 0 (R/W) */
X  volatile uint32_t ADR0;                    
N  __IO uint32_t SCLH;                   /*!< Offset: 0x010 SCH Duty Cycle Register High Half Word (R/W) */
X  volatile uint32_t SCLH;                    
N  __IO uint32_t SCLL;                   /*!< Offset: 0x014 SCL Duty Cycle Register Low Half Word (R/W) */
X  volatile uint32_t SCLL;                    
N  __O  uint32_t CONCLR;                 /*!< Offset: 0x018 I2C Control Clear Register ( /W) */
X  volatile  uint32_t CONCLR;                  
N  __IO uint32_t MMCTRL;                 /*!< Offset: 0x01C Monitor mode control register (R/W) */
X  volatile uint32_t MMCTRL;                  
N  __IO uint32_t ADR1;                   /*!< Offset: 0x020 I2C Slave Address Register 1 (R/W) */
X  volatile uint32_t ADR1;                    
N  __IO uint32_t ADR2;                   /*!< Offset: 0x024 I2C Slave Address Register 2 (R/W) */
X  volatile uint32_t ADR2;                    
N  __IO uint32_t ADR3;                   /*!< Offset: 0x028 I2C Slave Address Register 3 (R/W) */
X  volatile uint32_t ADR3;                    
N  __I  uint32_t DATA_BUFFER;            /*!< Offset: 0x02C Data buffer register ( /W) */
X  volatile const  uint32_t DATA_BUFFER;             
N  __IO uint32_t MASK0;                  /*!< Offset: 0x030 I2C Slave address mask register 0 (R/W) */
X  volatile uint32_t MASK0;                   
N  __IO uint32_t MASK1;                  /*!< Offset: 0x034 I2C Slave address mask register 1 (R/W) */
X  volatile uint32_t MASK1;                   
N  __IO uint32_t MASK2;                  /*!< Offset: 0x038 I2C Slave address mask register 2 (R/W) */
X  volatile uint32_t MASK2;                   
N  __IO uint32_t MASK3;                  /*!< Offset: 0x03C I2C Slave address mask register 3 (R/W) */
X  volatile uint32_t MASK3;                   
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DAO;
X  volatile uint32_t DAO;
N  __IO uint32_t DAI;
X  volatile uint32_t DAI;
N  __O  uint32_t TXFIFO;
X  volatile  uint32_t TXFIFO;
N  __I  uint32_t RXFIFO;
X  volatile const  uint32_t RXFIFO;
N  __I  uint32_t STATE;
X  volatile const  uint32_t STATE;
N  __IO uint32_t DMA1;
X  volatile uint32_t DMA1;
N  __IO uint32_t DMA2;
X  volatile uint32_t DMA2;
N  __IO uint32_t IRQ;
X  volatile uint32_t IRQ;
N  __IO uint32_t TXRATE;
X  volatile uint32_t TXRATE;
N  __IO uint32_t RXRATE;
X  volatile uint32_t RXRATE;
N  __IO uint32_t TXBITRATE;
X  volatile uint32_t TXBITRATE;
N  __IO uint32_t RXBITRATE;
X  volatile uint32_t RXBITRATE;
N  __IO uint32_t TXMODE;
X  volatile uint32_t TXMODE;
N  __IO uint32_t RXMODE;
X  volatile uint32_t RXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N  __IO uint32_t ERSTATUS;
X  volatile uint32_t ERSTATUS;
N  __IO uint32_t ERCONTROL;
X  volatile uint32_t ERCONTROL;
N  __IO uint32_t ERCOUNTERS;
X  volatile uint32_t ERCOUNTERS;
N       uint32_t RESERVED22;
N  __IO uint32_t ERFIRSTSTAMP0;
X  volatile uint32_t ERFIRSTSTAMP0;
N  __IO uint32_t ERFIRSTSTAMP1;
X  volatile uint32_t ERFIRSTSTAMP1;
N  __IO uint32_t ERFIRSTSTAMP2;
X  volatile uint32_t ERFIRSTSTAMP2;
N       uint32_t RESERVED23;
N  __IO uint32_t ERLASTSTAMP0;
X  volatile uint32_t ERLASTSTAMP0;
N  __IO uint32_t ERLASTSTAMP1;
X  volatile uint32_t ERLASTSTAMP1;
N  __IO uint32_t ERLASTSTAMP2;
X  volatile uint32_t ERLASTSTAMP2;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  MOD;
X  volatile uint8_t  MOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __O  uint8_t  FEED;
X  volatile  uint8_t  FEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t TV;
X  volatile const  uint32_t TV;
N       uint32_t RESERVED2;
N  __IO uint32_t WARNINT;
X  volatile uint32_t WARNINT;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;                     /*!< Offset: 0x000       A/D Control Register (R/W) */
X  volatile uint32_t CR;                      
N  __IO uint32_t GDR;                    /*!< Offset: 0x004       A/D Global Data Register (R/W) */
X  volatile uint32_t GDR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t INTEN;                  /*!< Offset: 0x00C       A/D Interrupt Enable Register (R/W) */
X  volatile uint32_t INTEN;                   
N  __IO uint32_t DR[8];                  /*!< Offset: 0x010-0x02C A/D Channel 0..7 Data Register (R/W) */
X  volatile uint32_t DR[8];                   
N  __I  uint32_t STAT;                   /*!< Offset: 0x030       A/D Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t CNTVAL;
X  volatile uint32_t CNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t CON;
X  volatile const  uint32_t CON;
N  __O  uint32_t CON_SET;
X  volatile  uint32_t CON_SET;
N  __O  uint32_t CON_CLR;
X  volatile  uint32_t CON_CLR;
N  __I  uint32_t CAPCON;
X  volatile const  uint32_t CAPCON;
N  __O  uint32_t CAPCON_SET;
X  volatile  uint32_t CAPCON_SET;
N  __O  uint32_t CAPCON_CLR;
X  volatile  uint32_t CAPCON_CLR;
N  __IO uint32_t TC0;
X  volatile uint32_t TC0;
N  __IO uint32_t TC1;
X  volatile uint32_t TC1;
N  __IO uint32_t TC2;
X  volatile uint32_t TC2;
N  __IO uint32_t LIM0;
X  volatile uint32_t LIM0;
N  __IO uint32_t LIM1;
X  volatile uint32_t LIM1;
N  __IO uint32_t LIM2;
X  volatile uint32_t LIM2;
N  __IO uint32_t MAT0;
X  volatile uint32_t MAT0;
N  __IO uint32_t MAT1;
X  volatile uint32_t MAT1;
N  __IO uint32_t MAT2;
X  volatile uint32_t MAT2;
N  __IO uint32_t DT;
X  volatile uint32_t DT;
N  __IO uint32_t CP;
X  volatile uint32_t CP;
N  __IO uint32_t CAP0;
X  volatile uint32_t CAP0;
N  __IO uint32_t CAP1;
X  volatile uint32_t CAP1;
N  __IO uint32_t CAP2;
X  volatile uint32_t CAP2;
N  __I  uint32_t INTEN;
X  volatile const  uint32_t INTEN;
N  __O  uint32_t INTEN_SET;
X  volatile  uint32_t INTEN_SET;
N  __O  uint32_t INTEN_CLR;
X  volatile  uint32_t INTEN_CLR;
N  __I  uint32_t CNTCON;
X  volatile const  uint32_t CNTCON;
N  __O  uint32_t CNTCON_SET;
X  volatile  uint32_t CNTCON_SET;
N  __O  uint32_t CNTCON_CLR;
X  volatile  uint32_t CNTCON_CLR;
N  __I  uint32_t INTF;
X  volatile const  uint32_t INTF;
N  __O  uint32_t INTF_SET;
X  volatile  uint32_t INTF_SET;
N  __O  uint32_t INTF_CLR;
X  volatile  uint32_t INTF_CLR;
N  __O  uint32_t CAP_CLR;
X  volatile  uint32_t CAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t CON;
X  volatile  uint32_t CON;
N  __I  uint32_t STAT;
X  volatile const  uint32_t STAT;
N  __IO uint32_t CONF;
X  volatile uint32_t CONF;
N  __I  uint32_t POS;
X  volatile const  uint32_t POS;
N  __IO uint32_t MAXPOS;
X  volatile uint32_t MAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP0;
X  volatile uint32_t INXCMP0;
N  __IO uint32_t LOAD;
X  volatile uint32_t LOAD;
N  __I  uint32_t TIME;
X  volatile const  uint32_t TIME;
N  __I  uint32_t VEL;
X  volatile const  uint32_t VEL;
N  __I  uint32_t CAP;
X  volatile const  uint32_t CAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTERPHA;
X  volatile uint32_t FILTERPHA;
N  __IO uint32_t FILTERPHB;
X  volatile uint32_t FILTERPHB;
N  __IO uint32_t FILTERINX;
X  volatile uint32_t FILTERINX;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N  __IO uint32_t INXCMP1;
X  volatile uint32_t INXCMP1;
N  __IO uint32_t INXCMP2;
X  volatile uint32_t INXCMP2;
N       uint32_t RESERVED0[993];
N  __O  uint32_t IEC;
X  volatile  uint32_t IEC;
N  __O  uint32_t IES;
X  volatile  uint32_t IES;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __I  uint32_t IE;
X  volatile const  uint32_t IE;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N  __O  uint32_t SET;
X  volatile  uint32_t SET;
N} LPC_QEI_TypeDef;
N
N/*------------- SD/MMC card Interface (MCI)-----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t POWER;
X  volatile uint32_t POWER;
N  __IO uint32_t CLOCK;
X  volatile uint32_t CLOCK;
N  __IO uint32_t ARGUMENT;
X  volatile uint32_t ARGUMENT;
N  __IO uint32_t COMMAND;
X  volatile uint32_t COMMAND;
N  __I  uint32_t RESP_CMD;
X  volatile const  uint32_t RESP_CMD;
N  __I  uint32_t RESP0;
X  volatile const  uint32_t RESP0;
N  __I  uint32_t RESP1;
X  volatile const  uint32_t RESP1;
N  __I  uint32_t RESP2;
X  volatile const  uint32_t RESP2;
N  __I  uint32_t RESP3;
X  volatile const  uint32_t RESP3;
N  __IO uint32_t DATATMR;
X  volatile uint32_t DATATMR;
N  __IO uint32_t DATALEN;
X  volatile uint32_t DATALEN;
N  __IO uint32_t DATACTRL;
X  volatile uint32_t DATACTRL;
N  __I  uint32_t DATACNT;
X  volatile const  uint32_t DATACNT;
N  __I  uint32_t STATUS;
X  volatile const  uint32_t STATUS;
N  __O  uint32_t CLEAR;
X  volatile  uint32_t CLEAR;
N  __IO uint32_t MASK0;
X  volatile uint32_t MASK0;
N       uint32_t RESERVED0[2];
N  __I  uint32_t FIFOCNT;
X  volatile const  uint32_t FIFOCNT;
N       uint32_t RESERVED1[13];
N  __IO uint32_t FIFO;
X  volatile uint32_t FIFO;
N} LPC_MCI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t TxSR;
X  volatile const  uint32_t TxSR;
N  __I  uint32_t RxSR;
X  volatile const  uint32_t RxSR;
N  __I  uint32_t MSR;
X  volatile const  uint32_t MSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t IntStat;
X  volatile const  uint32_t IntStat;
N  __I  uint32_t IntTCStat;
X  volatile const  uint32_t IntTCStat;
N  __O  uint32_t IntTCClear;
X  volatile  uint32_t IntTCClear;
N  __I  uint32_t IntErrStat;
X  volatile const  uint32_t IntErrStat;
N  __O  uint32_t IntErrClr;
X  volatile  uint32_t IntErrClr;
N  __I  uint32_t RawIntTCStat;
X  volatile const  uint32_t RawIntTCStat;
N  __I  uint32_t RawIntErrStat;
X  volatile const  uint32_t RawIntErrStat;
N  __I  uint32_t EnbldChns;
X  volatile const  uint32_t EnbldChns;
N  __IO uint32_t SoftBReq;
X  volatile uint32_t SoftBReq;
N  __IO uint32_t SoftSReq;
X  volatile uint32_t SoftSReq;
N  __IO uint32_t SoftLBReq;
X  volatile uint32_t SoftLBReq;
N  __IO uint32_t SoftLSReq;
X  volatile uint32_t SoftLSReq;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N  __IO uint32_t Sync;
X  volatile uint32_t Sync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t CSrcAddr;
X  volatile uint32_t CSrcAddr;
N  __IO uint32_t CDestAddr;
X  volatile uint32_t CDestAddr;
N  __IO uint32_t CLLI;
X  volatile uint32_t CLLI;
N  __IO uint32_t CControl;
X  volatile uint32_t CControl;
N  __IO uint32_t CConfig;
X  volatile uint32_t CConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t Revision;             /* USB Host Registers                 */
X  volatile const  uint32_t Revision;              
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __IO uint32_t CommandStatus;
X  volatile uint32_t CommandStatus;
N  __IO uint32_t InterruptStatus;
X  volatile uint32_t InterruptStatus;
N  __IO uint32_t InterruptEnable;
X  volatile uint32_t InterruptEnable;
N  __IO uint32_t InterruptDisable;
X  volatile uint32_t InterruptDisable;
N  __IO uint32_t HCCA;
X  volatile uint32_t HCCA;
N  __I  uint32_t PeriodCurrentED;
X  volatile const  uint32_t PeriodCurrentED;
N  __IO uint32_t ControlHeadED;
X  volatile uint32_t ControlHeadED;
N  __IO uint32_t ControlCurrentED;
X  volatile uint32_t ControlCurrentED;
N  __IO uint32_t BulkHeadED;
X  volatile uint32_t BulkHeadED;
N  __IO uint32_t BulkCurrentED;
X  volatile uint32_t BulkCurrentED;
N  __I  uint32_t DoneHead;
X  volatile const  uint32_t DoneHead;
N  __IO uint32_t FmInterval;
X  volatile uint32_t FmInterval;
N  __I  uint32_t FmRemaining;
X  volatile const  uint32_t FmRemaining;
N  __I  uint32_t FmNumber;
X  volatile const  uint32_t FmNumber;
N  __IO uint32_t PeriodicStart;
X  volatile uint32_t PeriodicStart;
N  __IO uint32_t LSTreshold;
X  volatile uint32_t LSTreshold;
N  __IO uint32_t RhDescriptorA;
X  volatile uint32_t RhDescriptorA;
N  __IO uint32_t RhDescriptorB;
X  volatile uint32_t RhDescriptorB;
N  __IO uint32_t RhStatus;
X  volatile uint32_t RhStatus;
N  __IO uint32_t RhPortStatus1;
X  volatile uint32_t RhPortStatus1;
N  __IO uint32_t RhPortStatus2;
X  volatile uint32_t RhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t IntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t IntSt;                
N  __IO uint32_t IntEn;
X  volatile uint32_t IntEn;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N  __O  uint32_t IntClr;
X  volatile  uint32_t IntClr;
N  __IO uint32_t StCtrl;
X  volatile uint32_t StCtrl;
N  __IO uint32_t Tmr;
X  volatile uint32_t Tmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t DevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t DevIntSt;             
N  __IO uint32_t DevIntEn;
X  volatile uint32_t DevIntEn;
N  __O  uint32_t DevIntClr;
X  volatile  uint32_t DevIntClr;
N  __O  uint32_t DevIntSet;
X  volatile  uint32_t DevIntSet;
N
N  __O  uint32_t CmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t CmdCode;              
N  __I  uint32_t CmdData;
X  volatile const  uint32_t CmdData;
N
N  __I  uint32_t RxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t RxData;               
N  __O  uint32_t TxData;
X  volatile  uint32_t TxData;
N  __I  uint32_t RxPLen;
X  volatile const  uint32_t RxPLen;
N  __O  uint32_t TxPLen;
X  volatile  uint32_t TxPLen;
N  __IO uint32_t Ctrl;
X  volatile uint32_t Ctrl;
N  __O  uint32_t DevIntPri;
X  volatile  uint32_t DevIntPri;
N
N  __I  uint32_t EpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t EpIntSt;              
N  __IO uint32_t EpIntEn;
X  volatile uint32_t EpIntEn;
N  __O  uint32_t EpIntClr;
X  volatile  uint32_t EpIntClr;
N  __O  uint32_t EpIntSet;
X  volatile  uint32_t EpIntSet;
N  __O  uint32_t EpIntPri;
X  volatile  uint32_t EpIntPri;
N
N  __IO uint32_t ReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t ReEp;                 
N  __O  uint32_t EpInd;
X  volatile  uint32_t EpInd;
N  __IO uint32_t MaxPSize;
X  volatile uint32_t MaxPSize;
N
N  __I  uint32_t DMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t DMARSt;               
N  __O  uint32_t DMARClr;
X  volatile  uint32_t DMARClr;
N  __O  uint32_t DMARSet;
X  volatile  uint32_t DMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t UDCAH;
X  volatile uint32_t UDCAH;
N  __I  uint32_t EpDMASt;
X  volatile const  uint32_t EpDMASt;
N  __O  uint32_t EpDMAEn;
X  volatile  uint32_t EpDMAEn;
N  __O  uint32_t EpDMADis;
X  volatile  uint32_t EpDMADis;
N  __I  uint32_t DMAIntSt;
X  volatile const  uint32_t DMAIntSt;
N  __IO uint32_t DMAIntEn;
X  volatile uint32_t DMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t EoTIntSt;
X  volatile const  uint32_t EoTIntSt;
N  __O  uint32_t EoTIntClr;
X  volatile  uint32_t EoTIntClr;
N  __O  uint32_t EoTIntSet;
X  volatile  uint32_t EoTIntSet;
N  __I  uint32_t NDDRIntSt;
X  volatile const  uint32_t NDDRIntSt;
N  __O  uint32_t NDDRIntClr;
X  volatile  uint32_t NDDRIntClr;
N  __O  uint32_t NDDRIntSet;
X  volatile  uint32_t NDDRIntSet;
N  __I  uint32_t SysErrIntSt;
X  volatile const  uint32_t SysErrIntSt;
N  __O  uint32_t SysErrIntClr;
X  volatile  uint32_t SysErrIntClr;
N  __O  uint32_t SysErrIntSet;
X  volatile  uint32_t SysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __IO  uint32_t I2C_STS;
X  volatile  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __I  uint32_t RxFilterWoLStatus;
X  volatile const  uint32_t RxFilterWoLStatus;
N  __O  uint32_t RxFilterWoLClear;
X  volatile  uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N/*------------- LCD controller (LCD) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t TIMH;                   /* LCD Registers                      */
X  volatile uint32_t TIMH;                    
N  __IO uint32_t TIMV;
X  volatile uint32_t TIMV;
N  __IO uint32_t POL;
X  volatile uint32_t POL;
N  __IO uint32_t LE;
X  volatile uint32_t LE;
N  __IO uint32_t UPBASE;
X  volatile uint32_t UPBASE;
N  __IO uint32_t LPBASE;
X  volatile uint32_t LPBASE;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t INTMSK;
X  volatile uint32_t INTMSK;
N  __I  uint32_t INTRAW;
X  volatile const  uint32_t INTRAW;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __O  uint32_t INTCLR;
X  volatile  uint32_t INTCLR;
N  __I  uint32_t UPCURR;
X  volatile const  uint32_t UPCURR;
N  __I  uint32_t LPCURR;
X  volatile const  uint32_t LPCURR;
N       uint32_t RESERVED0[115];
N  __IO uint32_t PAL[128];
X  volatile uint32_t PAL[128];
N       uint32_t RESERVED1[256];
N  __IO uint32_t CRSR_IMG[256];
X  volatile uint32_t CRSR_IMG[256];
N  __IO uint32_t CRSR_CTRL;
X  volatile uint32_t CRSR_CTRL;
N  __IO uint32_t CRSR_CFG;
X  volatile uint32_t CRSR_CFG;
N  __IO uint32_t CRSR_PAL0;
X  volatile uint32_t CRSR_PAL0;
N  __IO uint32_t CRSR_PAL1;
X  volatile uint32_t CRSR_PAL1;
N  __IO uint32_t CRSR_XY;
X  volatile uint32_t CRSR_XY;
N  __IO uint32_t CRSR_CLIP;
X  volatile uint32_t CRSR_CLIP;
N       uint32_t RESERVED2[2];
N  __IO uint32_t CRSR_INTMSK;
X  volatile uint32_t CRSR_INTMSK;
N  __O  uint32_t CRSR_INTCLR;
X  volatile  uint32_t CRSR_INTCLR;
N  __I  uint32_t CRSR_INTRAW;
X  volatile const  uint32_t CRSR_INTRAW;
N  __I  uint32_t CRSR_INTSTAT;
X  volatile const  uint32_t CRSR_INTSTAT;
N} LPC_LCD_TypeDef;
N
N/*------------- External Memory Controller (EMC) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N       uint32_t RESERVED0[5];
N  __IO uint32_t DynamicControl;
X  volatile uint32_t DynamicControl;
N  __IO uint32_t DynamicRefresh;
X  volatile uint32_t DynamicRefresh;
N  __IO uint32_t DynamicReadConfig;
X  volatile uint32_t DynamicReadConfig;
N       uint32_t RESERVED1[1];
N  __IO uint32_t DynamicRP;
X  volatile uint32_t DynamicRP;
N  __IO uint32_t DynamicRAS;
X  volatile uint32_t DynamicRAS;
N  __IO uint32_t DynamicSREX;
X  volatile uint32_t DynamicSREX;
N  __IO uint32_t DynamicAPR;
X  volatile uint32_t DynamicAPR;
N  __IO uint32_t DynamicDAL;
X  volatile uint32_t DynamicDAL;
N  __IO uint32_t DynamicWR;
X  volatile uint32_t DynamicWR;
N  __IO uint32_t DynamicRC;
X  volatile uint32_t DynamicRC;
N  __IO uint32_t DynamicRFC;
X  volatile uint32_t DynamicRFC;
N  __IO uint32_t DynamicXSR;
X  volatile uint32_t DynamicXSR;
N  __IO uint32_t DynamicRRD;
X  volatile uint32_t DynamicRRD;
N  __IO uint32_t DynamicMRD;
X  volatile uint32_t DynamicMRD;
N       uint32_t RESERVED2[9];
N  __IO uint32_t StaticExtendedWait;
X  volatile uint32_t StaticExtendedWait;
N       uint32_t RESERVED3[31];
N  __IO uint32_t DynamicConfig0;
X  volatile uint32_t DynamicConfig0;
N  __IO uint32_t DynamicRasCas0;
X  volatile uint32_t DynamicRasCas0;
N       uint32_t RESERVED4[6];
N  __IO uint32_t DynamicConfig1;
X  volatile uint32_t DynamicConfig1;
N  __IO uint32_t DynamicRasCas1;
X  volatile uint32_t DynamicRasCas1;
N       uint32_t RESERVED5[6];
N  __IO uint32_t DynamicConfig2;
X  volatile uint32_t DynamicConfig2;
N  __IO uint32_t DynamicRasCas2;
X  volatile uint32_t DynamicRasCas2;
N       uint32_t RESERVED6[6];
N  __IO uint32_t DynamicConfig3;
X  volatile uint32_t DynamicConfig3;
N  __IO uint32_t DynamicRasCas3;
X  volatile uint32_t DynamicRasCas3;
N       uint32_t RESERVED7[38];
N  __IO uint32_t StaticConfig0;
X  volatile uint32_t StaticConfig0;
N  __IO uint32_t StaticWaitWen0;
X  volatile uint32_t StaticWaitWen0;
N  __IO uint32_t StaticWaitOen0;
X  volatile uint32_t StaticWaitOen0;
N  __IO uint32_t StaticWaitRd0;
X  volatile uint32_t StaticWaitRd0;
N  __IO uint32_t StaticWaitPage0;
X  volatile uint32_t StaticWaitPage0;
N  __IO uint32_t StaticWaitWr0;
X  volatile uint32_t StaticWaitWr0;
N  __IO uint32_t StaticWaitTurn0;
X  volatile uint32_t StaticWaitTurn0;
N       uint32_t RESERVED8[1];
N  __IO uint32_t StaticConfig1;
X  volatile uint32_t StaticConfig1;
N  __IO uint32_t StaticWaitWen1;
X  volatile uint32_t StaticWaitWen1;
N  __IO uint32_t StaticWaitOen1;
X  volatile uint32_t StaticWaitOen1;
N  __IO uint32_t StaticWaitRd1;
X  volatile uint32_t StaticWaitRd1;
N  __IO uint32_t StaticWaitPage1;
X  volatile uint32_t StaticWaitPage1;
N  __IO uint32_t StaticWaitWr1;
X  volatile uint32_t StaticWaitWr1;
N  __IO uint32_t StaticWaitTurn1;
X  volatile uint32_t StaticWaitTurn1;
N       uint32_t RESERVED9[1];
N  __IO uint32_t StaticConfig2;
X  volatile uint32_t StaticConfig2;
N  __IO uint32_t StaticWaitWen2;
X  volatile uint32_t StaticWaitWen2;
N  __IO uint32_t StaticWaitOen2;
X  volatile uint32_t StaticWaitOen2;
N  __IO uint32_t StaticWaitRd2;
X  volatile uint32_t StaticWaitRd2;
N  __IO uint32_t StaticWaitPage2;
X  volatile uint32_t StaticWaitPage2;
N  __IO uint32_t StaticWaitWr2;
X  volatile uint32_t StaticWaitWr2;
N  __IO uint32_t StaticWaitTurn2;
X  volatile uint32_t StaticWaitTurn2;
N       uint32_t RESERVED10[1];
N  __IO uint32_t StaticConfig3;
X  volatile uint32_t StaticConfig3;
N  __IO uint32_t StaticWaitWen3;
X  volatile uint32_t StaticWaitWen3;
N  __IO uint32_t StaticWaitOen3;
X  volatile uint32_t StaticWaitOen3;
N  __IO uint32_t StaticWaitRd3;
X  volatile uint32_t StaticWaitRd3;
N  __IO uint32_t StaticWaitPage3;
X  volatile uint32_t StaticWaitPage3;
N  __IO uint32_t StaticWaitWr3;
X  volatile uint32_t StaticWaitWr3;
N  __IO uint32_t StaticWaitTurn3;
X  volatile uint32_t StaticWaitTurn3;
N} LPC_EMC_TypeDef;
N
N/*------------- CRC Engine (CRC) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t MODE;
X  volatile uint32_t MODE;
N  __IO uint32_t SEED;
X  volatile uint32_t SEED;
N  union {
N  __I  uint32_t SUM;
X  volatile const  uint32_t SUM;
N  __O  uint32_t WR_DATA_DWORD;
X  volatile  uint32_t WR_DATA_DWORD;
N  __O  uint16_t WR_DATA_WORD;
X  volatile  uint16_t WR_DATA_WORD;
N       uint16_t RESERVED_WORD;
N  __O  uint8_t WR_DATA_BYTE;
X  volatile  uint8_t WR_DATA_BYTE;
N       uint8_t RESERVED_BYTE[3];
N  };
N} LPC_CRC_TypeDef;
N
N/*------------- EEPROM Controller (EEPROM) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CMD;			/* 0x0080 */
X  volatile uint32_t CMD;			 
N  __IO uint32_t ADDR;
X  volatile uint32_t ADDR;
N  __IO uint32_t WDATA;
X  volatile uint32_t WDATA;
N  __IO uint32_t RDATA;
X  volatile uint32_t RDATA;
N  __IO uint32_t WSTATE;			/* 0x0090 */
X  volatile uint32_t WSTATE;			 
N  __IO uint32_t CLKDIV;
X  volatile uint32_t CLKDIV;
N  __IO uint32_t PWRDWN;			/* 0x0098 */
X  volatile uint32_t PWRDWN;			 
N       uint32_t RESERVED0[975];
N  __IO uint32_t INT_CLR_ENABLE;	/* 0x0FD8 */
X  volatile uint32_t INT_CLR_ENABLE;	 
N  __IO uint32_t INT_SET_ENABLE;
X  volatile uint32_t INT_SET_ENABLE;
N  __IO uint32_t INT_STATUS;		/* 0x0FE0 */
X  volatile uint32_t INT_STATUS;		 
N  __IO uint32_t INT_ENABLE;
X  volatile uint32_t INT_ENABLE;
N  __IO uint32_t INT_CLR_STATUS;
X  volatile uint32_t INT_CLR_STATUS;
N  __IO uint32_t INT_SET_STATUS;
X  volatile uint32_t INT_SET_STATUS;
N} LPC_EEPROM_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_PERI_RAM_BASE     (0x20000000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHBRAM1_BASE      (0x20004000UL)
N#define LPC_AHB_BASE          (0x20080000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM0_BASE         (LPC_APB0_BASE + 0x14000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_IOCON_BASE        (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_UART4_BASE        (LPC_APB1_BASE + 0x24000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_SSP2_BASE         (LPC_APB1_BASE + 0x2C000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_MCI_BASE          (LPC_APB1_BASE + 0x40000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x00100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x00120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x00140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x00160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x00180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x001A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x001C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x001E0)
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x04000)
N#define LPC_LCD_BASE          (LPC_AHB_BASE  + 0x08000)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N#define LPC_CRC_BASE          (LPC_AHB_BASE  + 0x10000)
N#define LPC_GPIO0_BASE        (LPC_AHB_BASE  + 0x18000)
N#define LPC_GPIO1_BASE        (LPC_AHB_BASE  + 0x18020)
N#define LPC_GPIO2_BASE        (LPC_AHB_BASE  + 0x18040)
N#define LPC_GPIO3_BASE        (LPC_AHB_BASE  + 0x18060)
N#define LPC_GPIO4_BASE        (LPC_AHB_BASE  + 0x18080)
N#define LPC_GPIO5_BASE        (LPC_AHB_BASE  + 0x180A0)
N#define LPC_EMC_BASE          (LPC_AHB_BASE  + 0x1C000)
N
N#define LPC_EEPROM_BASE       (LPC_FLASH_BASE+ 0x200080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_UART0             ((LPC_UART_TypeDef      *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_UART4             ((LPC_UART4_TypeDef     *) LPC_UART4_BASE    )
N#define LPC_PWM0              ((LPC_PWM_TypeDef       *) LPC_PWM0_BASE     )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_IOCON             ((LPC_IOCON_TypeDef     *) LPC_IOCON_BASE    )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_SSP2              ((LPC_SSP_TypeDef       *) LPC_SSP2_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_MCI               ((LPC_MCI_TypeDef       *) LPC_MCI_BASE      )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_LCD               ((LPC_LCD_TypeDef       *) LPC_LCD_BASE      )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_GPIO5             ((LPC_GPIO_TypeDef      *) LPC_GPIO5_BASE    )
N#define LPC_EMC               ((LPC_EMC_TypeDef       *) LPC_EMC_BASE      )
N#define LPC_CRC               ((LPC_CRC_TypeDef       *) LPC_CRC_BASE      )
N#define LPC_EEPROM            ((LPC_EEPROM_TypeDef    *) LPC_EEPROM_BASE   )
N
N#endif  // __LPC177x_8x_H__
L 28 "..\Startup\system_LPC177x_8x.c" 2
N#include "system_LPC177x_8x.h"
L 1 "..\Startup\system_LPC177x_8x.h" 1
N/******************************************************************************
N * @file:    system_LPC177x_8x.h
N * @purpose: CMSIS Cortex-M3 Device Peripheral Access Layer Header File
N *           for the NXP LPC177x_8x Device Series
N * @version: V1.11
N * @date:    10. November. 2010
N *----------------------------------------------------------------------------
N *
N * @note
N * Copyright (C) 2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC177x_8x_H
N#define __SYSTEM_LPC177x_8x_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
Nextern uint32_t SystemCoreClock;      /*!< System Clock Frequency (Core Clock)  	*/
Nextern uint32_t PeripheralClock;	    /*!< Peripheral Clock Frequency (Pclk) 	    */
Nextern uint32_t EMCClock;			        /*!< EMC Clock                              */
Nextern uint32_t USBClock;			        /*!< USB Frequency 						              */
Nextern uint32_t SPIFIClock;			      /*!< SPI Flash Interface Frequency 		      */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N/*----------------------------------------------------------------------------
N  Define clocks
N *----------------------------------------------------------------------------*/
N#define XTAL        (12000000UL)        /* Oscillator frequency               */
N#define OSC_CLK     (      XTAL)        /* Main oscillator frequency          */
N#define RTC_CLK     (   32768UL)        /* RTC oscillator frequency           */
N#define IRC_OSC     (12000000UL)        /* Internal RC oscillator frequency   */
N#define WDT_OSC		  (  500000UL)		/* Internal WDT oscillator frequency  */
N
N
N
N/*
N//-------- <<< end of configuration section >>> ------------------------------
N*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_LPC177x_8x_H */
L 29 "..\Startup\system_LPC177x_8x.c" 2
N
N/*
N//-------- <<< Use Configuration Wizard in Context Menu >>> ------------------
N*/
N/*--------------------- Clock Configuration ----------------------------------
N//
N// <e> Clock Configuration
N//   <h> System Controls and Status Register (SCS)
N//     <o1.0>       EMC_SHIFT: EMC Shift enable
N//                     <0=> Static CS addresses match bus width; AD[1] = 0 for 32 bit, AD[0] = 0 for 16+32 bit
N//                     <1=> Static CS addresses start at LSB 0 regardless of memory width
N//     <o1.1>       EMC_RESET: EMC Reset disable
N//                     <0=> EMC will be reset by any chip reset
N//                     <1=> Portions of EMC will only be reset by POR or BOR
N//     <o1.2>       EMC_BURST: EMC Burst disable
N//     <o1.3>       MCIPWR_LEVEL: SD card interface signal SD_PWR Active Level selection
N//                     <0=> SD_PWR is active low
N//                     <1=> SD_PWR is active high
N//     <o1.4>       OSCRANGE: Main Oscillator Range Select
N//                     <0=>  1 MHz to 20 MHz
N//                     <1=> 15 MHz to 25 MHz
N//     <o1.5>       OSCEN: Main Oscillator enable
N//   </h>
N//
N//   <h> Clock Source Select Register (CLKSRCSEL)
N//     <o2.0>       CLKSRC: sysclk and PLL0 clock source selection
N//                     <0=> Internal RC oscillator
N//                     <1=> Main oscillator
N//   </h>
N//
N//   <e3> PLL0 Configuration (Main PLL)
N//     <h> PLL0 Configuration Register (PLL0CFG)
N//                     <i> PLL out clock = (F_cco / (2 * P))
N//                     <i> F_cco = (F_in * M * 2 * P)
N//                     <i> F_in  must be in the range of 1 MHz to 25 MHz
N//                     <i> F_cco must be in the range of 9.75 MHz to 160 MHz
N//       <o4.0..4>   MSEL: PLL Multiplier Selection
N//                     <i> M Value
N//                     <1-32><#-1>
N//       <o4.5..6> PSEL: PLL Divider Selection
N//                     <i> P Value
N//                     <0=> 1
N//                     <1=> 2
N//                     <2=> 4
N//                     <3=> 8
N//     </h>
N//   </e>
N//
N//   <e5> PLL1 Configuration (Alt PLL)
N//     <h> PLL1 Configuration Register (PLL1CFG)
N//                     <i> PLL out clock = (F_cco / (2 * P))
N//                     <i> F_cco = (F_in * M * 2 * P)
N//                     <i> F_in  must be in the range of 1 MHz to 25 MHz
N//                     <i> F_cco must be in the range of 9.75 MHz to 160 MHz
N//       <o6.0..4>   MSEL: PLL Multiplier Selection
N//                     <i> M Value
N//                     <1-32><#-1>
N//       <o6.5..6> PSEL: PLL Divider Selection
N//                     <i> P Value
N//                     <0=> 1
N//                     <1=> 2
N//                     <2=> 4
N//                     <3=> 8
N//     </h>
N//   </e>
N//
N//   <h> CPU Clock Selection Register (CCLKSEL)
N//     <o7.0..4>    CCLKDIV: CPU clock (CCLK) divider
N//                     <i> 0: The divider is turned off. No clock will be provided to the CPU
N//                     <i> n: The input clock is divided by n to produce the CPU clock
N//                     <0-31>
N//     <o7.8>       CCLKSEL: CPU clock divider input clock selection
N//                     <0=> sysclk clock
N//                     <1=> PLL0 clock
N//   </h>
N//
N//   <h> USB Clock Selection Register (USBCLKSEL)
N//     <o8.0..4>    USBDIV: USB clock (source PLL0) divider selection
N//                     <0=> USB clock off
N//                     <4=> PLL0 / 4 (PLL0 must be 192Mhz)
N//                     <6=> PLL0 / 6 (PLL0 must be 288Mhz)
N//     <o8.8..9>    USBSEL: USB clock divider input clock selection
N//                     <i> When CPU clock is selected, the USB can be accessed
N//                     <i> by software but cannot perform USB functions
N//                     <0=> CPU clock
N//                     <1=> PLL0 clock
N//                     <2=> PLL1 clock
N//   </h>
N//
N//   <h> EMC Clock Selection Register (EMCCLKSEL)
N//     <o9.0>       EMCDIV: EMC clock selection
N//                     <0=> CPU clock
N//                     <1=> CPU clock / 2
N//   </h>
N//
N//   <h> Peripheral Clock Selection Register (PCLKSEL)
N//     <o10.0..4>   PCLKDIV: APB Peripheral clock divider
N//                     <i> 0: The divider is turned off. No clock will be provided to APB peripherals
N//                     <i> n: The input clock is divided by n to produce the APB peripheral clock
N//                     <0-31>
N//   </h>
N//
N//   <h> Power Control for Peripherals Register (PCONP)
N//     <o11.0>      PCLCD: LCD controller power/clock enable
N//     <o11.1>      PCTIM0: Timer/Counter 0 power/clock enable
N//     <o11.2>      PCTIM1: Timer/Counter 1 power/clock enable
N//     <o11.3>      PCUART0: UART 0 power/clock enable
N//     <o11.4>      PCUART1: UART 1 power/clock enable
N//     <o11.5>      PCPWM0: PWM0 power/clock enable
N//     <o11.6>      PCPWM1: PWM1 power/clock enable
N//     <o11.7>      PCI2C0: I2C 0 interface power/clock enable
N//     <o11.8>      PCUART4: UART 4 power/clock enable
N//     <o11.9>      PCRTC: RTC and Event Recorder power/clock enable
N//     <o11.10>     PCSSP1: SSP 1 interface power/clock enable
N//     <o11.11>     PCEMC: External Memory Controller power/clock enable
N//     <o11.12>     PCADC: A/D converter power/clock enable
N//     <o11.13>     PCCAN1: CAN controller 1 power/clock enable
N//     <o11.14>     PCCAN2: CAN controller 2 power/clock enable
N//     <o11.15>     PCGPIO: IOCON, GPIO, and GPIO interrupts power/clock enable
N//     <o11.17>     PCMCPWM: Motor Control PWM power/clock enable
N//     <o11.18>     PCQEI: Quadrature encoder interface power/clock enable
N//     <o11.19>     PCI2C1: I2C 1 interface power/clock enable
N//     <o11.20>     PCSSP2: SSP 2 interface power/clock enable
N//     <o11.21>     PCSSP0: SSP 0 interface power/clock enable
N//     <o11.22>     PCTIM2: Timer 2 power/clock enable
N//     <o11.23>     PCTIM3: Timer 3 power/clock enable
N//     <o11.24>     PCUART2: UART 2 power/clock enable
N//     <o11.25>     PCUART3: UART 3 power/clock enable
N//     <o11.26>     PCI2C2: I2C 2 interface power/clock enable
N//     <o11.27>     PCI2S: I2S interface power/clock enable
N//     <o11.28>     PCSDC: SD Card interface power/clock enable
N//     <o11.29>     PCGPDMA: GPDMA function power/clock enable
N//     <o11.30>     PCENET: Ethernet block power/clock enable
N//     <o11.31>     PCUSB: USB interface power/clock enable
N//   </h>
N//
N//   <h> Clock Output Configuration Register (CLKOUTCFG)
N//     <o12.0..3>   CLKOUTSEL: Clock Source for CLKOUT Selection
N//                     <0=> CPU clock
N//                     <1=> Main Oscillator
N//                     <2=> Internal RC Oscillator
N//                     <3=> USB clock
N//                     <4=> RTC Oscillator
N//                     <5=> unused
N//                     <6=> Watchdog Oscillator
N//     <o12.4..7>   CLKOUTDIV: Output Clock Divider
N//                     <1-16><#-1>
N//     <o12.8>      CLKOUT_EN: CLKOUT enable
N//   </h>
N//
N// </e>
N*/
N#define CLOCK_SETUP           1
N#define SCS_Val               0x00000020
N#define CLKSRCSEL_Val         0x00000001
N#define PLL0_SETUP            1
N#define PLL0CFG_Val           0x00000009
N#define PLL1_SETUP            1
N#define PLL1CFG_Val           0x00000023
N#define CCLKSEL_Val           (0x00000001|(1<<8))
N#define USBCLK_SETUP		  1
N#define USBCLKSEL_Val         (0x00000001|(0x02<<8))
N#define EMCCLKSEL_Val         0x00000001
N#define PCLKSEL_Val           0x00000002
N#define PCONP_Val             0x042887DE
N#define CLKOUTCFG_Val         0x00000100
N
N
N/*--------------------- Flash Accelerator Configuration ----------------------
N//
N// <e> Flash Accelerator Configuration
N//   <o1.12..15> FLASHTIM: Flash Access Time
N//               <0=> 1 CPU clock (for CPU clock up to 20 MHz)
N//               <1=> 2 CPU clocks (for CPU clock up to 40 MHz)
N//               <2=> 3 CPU clocks (for CPU clock up to 60 MHz)
N//               <3=> 4 CPU clocks (for CPU clock up to 80 MHz)
N//               <4=> 5 CPU clocks (for CPU clock up to 100 MHz)
N//               <5=> 6 CPU clocks (for any CPU clock)
N// </e>
N*/
N#define FLASH_SETUP           1
N#define FLASHCFG_Val          0x00005000
N
N/*----------------------------------------------------------------------------
N  Check the register settings
N *----------------------------------------------------------------------------*/
N#define CHECK_RANGE(val, min, max)                ((val < min) || (val > max))
N#define CHECK_RSVD(val, mask)                     (val & mask)
N
N/* Clock Configuration -------------------------------------------------------*/
N#if (CHECK_RSVD((SCS_Val),       ~0x0000003F))
X#if (((0x00000020) & ~0x0000003F))
S   #error "SCS: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RANGE((CLKSRCSEL_Val), 0, 1))
X#if ((((0x00000001) < 0) || ((0x00000001) > 1)))
S   #error "CLKSRCSEL: Value out of range!"
N#endif
N
N#if (CHECK_RSVD((PLL0CFG_Val),   ~0x0000007F))
X#if (((0x00000009) & ~0x0000007F))
S   #error "PLL0CFG: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RSVD((PLL1CFG_Val),   ~0x0000007F))
X#if (((0x00000023) & ~0x0000007F))
S   #error "PLL1CFG: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RSVD((CCLKSEL_Val),   ~0x0000011F))
X#if ((((0x00000001|(1<<8))) & ~0x0000011F))
S   #error "CCLKSEL: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RSVD((USBCLKSEL_Val), ~0x0000031F))
X#if ((((0x00000001|(0x02<<8))) & ~0x0000031F))
S   #error "USBCLKSEL: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RSVD((EMCCLKSEL_Val), ~0x00000001))
X#if (((0x00000001) & ~0x00000001))
S   #error "EMCCLKSEL: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RSVD((PCLKSEL_Val), ~0x0000001F))
X#if (((0x00000002) & ~0x0000001F))
S   #error "PCLKSEL: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RSVD((PCONP_Val), ~0xFFFEFFFF))
X#if (((0x042887DE) & ~0xFFFEFFFF))
S   #error "PCONP: Invalid values of reserved bits!"
N#endif
N
N#if (CHECK_RSVD((CLKOUTCFG_Val), ~0x000001FF))
X#if (((0x00000100) & ~0x000001FF))
S   #error "CLKOUTCFG: Invalid values of reserved bits!"
N#endif
N
N/* Flash Accelerator Configuration -------------------------------------------*/
N#if (CHECK_RSVD((FLASHCFG_Val), ~0x0000F000))
X#if (((0x00005000) & ~0x0000F000))
S   #warning "FLASHCFG: Invalid values of reserved bits!"
N#endif
N
N
N/*----------------------------------------------------------------------------
N  DEFINES
N *----------------------------------------------------------------------------*/
N/* pll_out_clk = F_cco / (2  P)
N   F_cco = pll_in_clk  M  2  P */
N#define __M                   ((PLL0CFG_Val & 0x1F) + 1)
N#define __PLL0_CLK(__F_IN)    (__F_IN * __M)
N#define __CCLK_DIV            (CCLKSEL_Val & 0x1F)
N#define __PCLK_DIV			  (PCLKSEL_Val & 0x1F)
N#define __ECLK_DIV			  ((EMCCLKSEL_Val & 0x01) + 1)
N
N/* Determine core clock frequency according to settings */
N#if (CLOCK_SETUP)                       /* Clock Setup                        */
X#if (1)                        
N
N  #if ((CLKSRCSEL_Val & 0x01) == 1) && ((SCS_Val & 0x20)== 0)
X  #if ((0x00000001 & 0x01) == 1) && ((0x00000020 & 0x20)== 0)
S   #error "Main Oscillator is selected as clock source but is not enabled!"
N  #endif
N
N  #if ((CCLKSEL_Val & 0x100) == 0x100) && (PLL0_SETUP == 0)
X  #if (((0x00000001|(1<<8)) & 0x100) == 0x100) && (1 == 0)
S   #error "Main PLL is selected as clock source but is not enabled!"
N  #endif
N
N  #if ((CCLKSEL_Val & 0x100) == 0)      /* cclk = sysclk */
X  #if (((0x00000001|(1<<8)) & 0x100) == 0)       
S    #if ((CLKSRCSEL_Val & 0x01) == 0)   /* sysclk = irc_clk */
S        #define __CORE_CLK (IRC_OSC / __CCLK_DIV)
S		#define __PER_CLK  (IRC_OSC/  __PCLK_DIV)
S        #define __EMC_CLK  (IRC_OSC/  __ECLK_DIV)
S    #else                               /* sysclk = osc_clk */
S        #define __CORE_CLK (OSC_CLK / __CCLK_DIV)
S        #define __PER_CLK  (OSC_CLK/  __PCLK_DIV)
S        #define __EMC_CLK  (OSC_CLK/  __ECLK_DIV)
S    #endif
N  #else                                 /* cclk = pll_clk */
N    #if ((CLKSRCSEL_Val & 0x01) == 0)   /* sysclk = irc_clk */
X    #if ((0x00000001 & 0x01) == 0)    
S        #define __CORE_CLK (__PLL0_CLK(IRC_OSC) / __CCLK_DIV)
S        #define __PER_CLK  (__PLL0_CLK(IRC_OSC) / __PCLK_DIV)
S        #define __EMC_CLK  (__PLL0_CLK(IRC_OSC) / __ECLK_DIV)
N    #else                               /* sysclk = osc_clk */
N        #define __CORE_CLK (__PLL0_CLK(OSC_CLK) / __CCLK_DIV)// 
N        #define __PER_CLK  (__PLL0_CLK(OSC_CLK) / __PCLK_DIV)
N		#define __EMC_CLK  (__PLL0_CLK(OSC_CLK) / __ECLK_DIV)
N    #endif
N  #endif
N
N#else
S        #define __CORE_CLK (IRC_OSC)
S        #define __PER_CLK  (IRC_OSC)
S        #define __EMC_CLK  (IRC_OSC)
N#endif
N
N/*----------------------------------------------------------------------------
N  Clock Variable definitions
N *----------------------------------------------------------------------------*/
Nuint32_t SystemCoreClock = __CORE_CLK;/*!< System Clock Frequency (Core Clock)*/
Xuint32_t SystemCoreClock = ((( (12000000UL)) * ((0x00000009 & 0x1F) + 1)) / ((0x00000001|(1<<8)) & 0x1F)); 
Nuint32_t PeripheralClock = __PER_CLK; /*!< Peripheral Clock Frequency (Pclk)  */
Xuint32_t PeripheralClock = ((( (12000000UL)) * ((0x00000009 & 0x1F) + 1)) / (0x00000002 & 0x1F));  
Nuint32_t EMCClock		 = __EMC_CLK; /*!< EMC Clock Frequency 				  */
Xuint32_t EMCClock		 = ((( (12000000UL)) * ((0x00000009 & 0x1F) + 1)) / ((0x00000001 & 0x01) + 1));  
Nuint32_t USBClock 		 = (48000000UL);		  /*!< USB Clock Frequency - this value will
N									be updated after call SystemCoreClockUpdate, should be 48MHz*/
Nuint32_t SPIFIClock 	 = 0;		  /*!< SPIFI Clock Frequency - this value will be updated
N									after call SystemCoreClockUpdate */
N
N
N/*----------------------------------------------------------------------------
N  Clock functions
N *----------------------------------------------------------------------------*/
Nvoid SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
N{
N  /* Determine clock frequency according to clock register values             */
N  if ((LPC_SC->CCLKSEL &0x100) == 0) {            /* cclk = sysclk    */
X  if ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CCLKSEL &0x100) == 0) {             
N    if ((LPC_SC->CLKSRCSEL & 0x01) == 0) {    /* sysclk = irc_clk */
X    if ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CLKSRCSEL & 0x01) == 0) {     
N          SystemCoreClock = (IRC_OSC / (LPC_SC->CCLKSEL & 0x1F));
X          SystemCoreClock = ((12000000UL) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CCLKSEL & 0x1F));
N          PeripheralClock = (IRC_OSC / (LPC_SC->PCLKSEL & 0x1F));
X          PeripheralClock = ((12000000UL) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCLKSEL & 0x1F));
N          EMCClock        = (IRC_OSC / ((LPC_SC->EMCCLKSEL & 0x01)+1));
X          EMCClock        = ((12000000UL) / ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->EMCCLKSEL & 0x01)+1));
N    }
N    else {                                        /* sysclk = osc_clk */
N      if ((LPC_SC->SCS & 0x40) == 0) {
X      if ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->SCS & 0x40) == 0) {
N          SystemCoreClock = 0;                      /* this should never happen! */
N          PeripheralClock = 0;
N          EMCClock        = 0;
N      }
N      else {
N          SystemCoreClock = (OSC_CLK / (LPC_SC->CCLKSEL & 0x1F));
X          SystemCoreClock = (( (12000000UL)) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CCLKSEL & 0x1F));
N          PeripheralClock = (OSC_CLK / (LPC_SC->PCLKSEL & 0x1F));
X          PeripheralClock = (( (12000000UL)) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCLKSEL & 0x1F));
N          EMCClock        = (OSC_CLK / ((LPC_SC->EMCCLKSEL & 0x01)+1));
X          EMCClock        = (( (12000000UL)) / ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->EMCCLKSEL & 0x01)+1));
N      }
N    }
N  }
N  else {                                          /* cclk = pll_clk */
N    if ((LPC_SC->PLL0STAT & 0x100) == 0) {        /* PLL0 not enabled */
X    if ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x100) == 0) {         
N          SystemCoreClock = 0;                      /* this should never happen! */
N          PeripheralClock = 0;
N          EMCClock 		  = 0;
N    }
N    else {
N      if ((LPC_SC->CLKSRCSEL & 0x01) == 0) {    /* sysclk = irc_clk */
X      if ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CLKSRCSEL & 0x01) == 0) {     
N          SystemCoreClock = (IRC_OSC * ((LPC_SC->PLL0STAT & 0x1F) + 1) / (LPC_SC->CCLKSEL & 0x1F));
X          SystemCoreClock = ((12000000UL) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CCLKSEL & 0x1F));
N          PeripheralClock = (IRC_OSC * ((LPC_SC->PLL0STAT & 0x1F) + 1) / (LPC_SC->PCLKSEL & 0x1F));
X          PeripheralClock = ((12000000UL) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCLKSEL & 0x1F));
N          EMCClock        = (IRC_OSC * ((LPC_SC->PLL0STAT & 0x1F) + 1) / ((LPC_SC->EMCCLKSEL & 0x01)+1));
X          EMCClock        = ((12000000UL) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->EMCCLKSEL & 0x01)+1));
N      }
N      else {                                        /* sysclk = osc_clk */
N        if ((LPC_SC->SCS & 0x40) == 0) {
X        if ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->SCS & 0x40) == 0) {
N          SystemCoreClock = 0;                      /* this should never happen! */
N          PeripheralClock = 0;
N          EMCClock 		  = 0;
N        }
N        else {
N          SystemCoreClock = (OSC_CLK * ((LPC_SC->PLL0STAT & 0x1F) + 1) / (LPC_SC->CCLKSEL & 0x1F));
X          SystemCoreClock = (( (12000000UL)) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CCLKSEL & 0x1F));
N          PeripheralClock = (OSC_CLK * ((LPC_SC->PLL0STAT & 0x1F) + 1) / (LPC_SC->PCLKSEL & 0x1F));
X          PeripheralClock = (( (12000000UL)) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCLKSEL & 0x1F));
N          EMCClock        = (OSC_CLK * ((LPC_SC->PLL0STAT & 0x1F) + 1) / ((LPC_SC->EMCCLKSEL & 0x01)+1));
X          EMCClock        = (( (12000000UL)) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->EMCCLKSEL & 0x01)+1));
N        }
N      }
N    }
N  }
N  /* ---update USBClock------------------*/
N  if(LPC_SC->USBCLKSEL & (0x01<<8))//Use PLL0 as the input to the USB clock divider
X  if(((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->USBCLKSEL & (0x01<<8))
N  {
N	  switch (LPC_SC->USBCLKSEL & 0x1F)
X	  switch (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->USBCLKSEL & 0x1F)
N	  {
N	  case 0:
N		  USBClock = 0; //no clock will be provided to the USB subsystem
N		  break;
N	  case 4:
N	  case 6:
N		  if(LPC_SC->CLKSRCSEL & 0x01)	//pll_clk_in = main_osc
X		  if(((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CLKSRCSEL & 0x01)	
N			  USBClock = (OSC_CLK * ((LPC_SC->PLL0STAT & 0x1F) + 1) / (LPC_SC->USBCLKSEL & 0x1F));
X			  USBClock = (( (12000000UL)) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->USBCLKSEL & 0x1F));
N		  else //pll_clk_in = irc_clk
N			  USBClock = (IRC_OSC * ((LPC_SC->PLL0STAT & 0x1F) + 1) / (LPC_SC->USBCLKSEL & 0x1F));
X			  USBClock = ((12000000UL) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1) / (((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->USBCLKSEL & 0x1F));
N		  break;
N	  default:
N		  USBClock = 0;  /* this should never happen! */
N	  }
N  }
N  else if(LPC_SC->USBCLKSEL & (0x02<<8))//usb_input_clk = alt_pll (pll1)
X  else if(((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->USBCLKSEL & (0x02<<8))
N  {
N	  if(LPC_SC->CLKSRCSEL & 0x01)	//pll1_clk_in = main_osc
X	  if(((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CLKSRCSEL & 0x01)	
N	  		USBClock = (OSC_CLK * ((LPC_SC->PLL1STAT & 0x1F) + 1));
X	  		USBClock = (( (12000000UL)) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL1STAT & 0x1F) + 1));
N	  else //pll1_clk_in = irc_clk
N	  		USBClock = (IRC_OSC * ((LPC_SC->PLL0STAT & 0x1F) + 1));
X	  		USBClock = ((12000000UL) * ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & 0x1F) + 1));
N  }
N  else
N	  USBClock = 0; /* this should never happen! */
N
N  /* ------update SPIFIClock ----------*/
N  /*--- <tbd>------*/
N}
N
N  /* Determine clock frequency according to clock register values             */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System.
N */
Nvoid SystemInit (void)
N{
N#if (CLOCK_SETUP)                       /* Clock Setup                        */
X#if (1)                        
N  LPC_SC->SCS       = SCS_Val;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->SCS       = 0x00000020;
N  if (SCS_Val & (1 << 5)) {             /* If Main Oscillator is enabled      */
X  if (0x00000020 & (1 << 5)) {              
N    while ((LPC_SC->SCS & (1<<6)) == 0);/* Wait for Oscillator to be ready    */
X    while ((((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->SCS & (1<<6)) == 0); 
N  }
N
N  LPC_SC->CLKSRCSEL = CLKSRCSEL_Val;    /* Select Clock Source for sysclk/PLL0*/
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CLKSRCSEL = 0x00000001;     
N
N#if (PLL0_SETUP)
X#if (1)
N  LPC_SC->PLL0CFG   = PLL0CFG_Val;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0CFG   = 0x00000009;
N  LPC_SC->PLL0CON   = 0x01;             /* PLL0 Enable                        */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0CON   = 0x01;              
N  LPC_SC->PLL0FEED  = 0xAA;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0FEED  = 0xAA;
N  LPC_SC->PLL0FEED  = 0x55;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0FEED  = 0x55;
N  while (!(LPC_SC->PLL0STAT & (1<<10)));/* Wait for PLOCK0                    */
X  while (!(((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL0STAT & (1<<10))); 
N#endif
N
N#if (PLL1_SETUP)
X#if (1)
N  LPC_SC->PLL1CFG   = PLL1CFG_Val;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL1CFG   = 0x00000023;
N  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL1CON   = 0x01;              
N  LPC_SC->PLL1FEED  = 0xAA;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL1FEED  = 0xAA;
N  LPC_SC->PLL1FEED  = 0x55;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL1FEED  = 0x55;
N  while (!(LPC_SC->PLL1STAT & (1<<10)));/* Wait for PLOCK1                    */
X  while (!(((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PLL1STAT & (1<<10))); 
N#endif
N
N  LPC_SC->CCLKSEL   = CCLKSEL_Val;      /* Setup Clock Divider                */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CCLKSEL   = (0x00000001|(1<<8));       
N  LPC_SC->USBCLKSEL = USBCLKSEL_Val;    /* Setup USB Clock Divider            */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->USBCLKSEL = (0x00000001|(0x02<<8));     
N  LPC_SC->EMCCLKSEL = EMCCLKSEL_Val;    /* EMC Clock Selection                */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->EMCCLKSEL = 0x00000001;     
N  LPC_SC->PCLKSEL   = PCLKSEL_Val;      /* Peripheral Clock Selection         */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCLKSEL   = 0x00000002;       
N  LPC_SC->PCONP     = PCONP_Val;        /* Power Control for Peripherals      */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCONP     = 0x042887DE;         
N  LPC_SC->CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->CLKOUTCFG = 0x00000100;     
N#endif
N
N#if (FLASH_SETUP == 1)                  /* Flash Accelerator Setup            */
X#if (1 == 1)                   
N  LPC_SC->FLASHCFG  = FLASHCFG_Val|0x03A;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->FLASHCFG  = 0x00005000|0x03A;
N#endif
N#ifdef  __RAM_MODE__
S  SCB->VTOR  = 0x10000000 & 0x3FFFFF80;
N#else
N  SCB->VTOR  = 0x00000000 & 0x3FFFFF80;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->VTOR  = 0x00000000 & 0x3FFFFF80;
N#endif
N}

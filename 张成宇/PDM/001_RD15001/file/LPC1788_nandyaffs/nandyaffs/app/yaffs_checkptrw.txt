; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\yaffs_checkptrw.o --asm_dir=.\ --list_dir=.\ --depend=.\flash\yaffs_checkptrw.d --feedback=.\Flash\YL_LPC1788_Test.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\app -I..\CM3_lib -I..\Drivers -I..\Startup -I.\Easy_web -I.\Lcd_Drv -I.\IIC_Test -I.\USU_Host -I.\Nand_Test -I.\FATFS_R0.08 -I..\fs -I"D:\Program Files\mdk\ARM\RV31\INC" -I"D:\Program Files\mdk\pack\ARM\CMSIS\4.1.1\CMSIS\Include" -I"D:\Program Files\mdk\ARM\Inc\NXP\LPC177x_8x" -D__MICROLIB --omf_browse=.\flash\yaffs_checkptrw.crf ..\fs\yaffs_checkptrw.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  yaffs_GetBlockInfo PROC
;;;21     /* Function to manipulate block info */
;;;22     static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
000000  4602              MOV      r2,r0
;;;23     {
;;;24     	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
000002  f8d2009c          LDR      r0,[r2,#0x9c]
000006  4288              CMP      r0,r1
000008  dc03              BGT      |L1.18|
00000a  f8d200a0          LDR      r0,[r2,#0xa0]
00000e  4288              CMP      r0,r1
000010  da01              BGE      |L1.22|
                  |L1.18|
;;;25     		T(YAFFS_TRACE_ERROR,
000012  bf00              NOP      
000014  bf00              NOP      
                  |L1.22|
;;;26     		  (TSTR
;;;27     		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
;;;28     		   blk));
;;;29     		YBUG();
;;;30     	}
;;;31     	return &dev->blockInfo[blk - dev->internalStartBlock];
000016  f8d2309c          LDR      r3,[r2,#0x9c]
00001a  1acb              SUBS     r3,r1,r3
00001c  f8d200e4          LDR      r0,[r2,#0xe4]
000020  eb0000c3          ADD      r0,r0,r3,LSL #3
;;;32     }
000024  4770              BX       lr
;;;33     
                          ENDP

                  yaffs_CheckpointSpaceOk PROC
;;;21     
;;;22     static int yaffs_CheckpointSpaceOk(yaffs_Device *dev)
000026  4601              MOV      r1,r0
;;;23     {
;;;24     
;;;25     	int blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;
000028  6a0b              LDR      r3,[r1,#0x20]
00002a  f8d100f4          LDR      r0,[r1,#0xf4]
00002e  1ac2              SUBS     r2,r0,r3
;;;26     
;;;27     	T(YAFFS_TRACE_CHECKPOINT,
000030  bf00              NOP      
000032  bf00              NOP      
;;;28     		(TSTR("checkpt blocks available = %d" TENDSTR),
;;;29     		blocksAvailable));
;;;30     
;;;31     
;;;32     	return (blocksAvailable <= 0) ? 0 : 1;
000034  2a00              CMP      r2,#0
000036  dd01              BLE      |L1.60|
000038  2001              MOVS     r0,#1
                  |L1.58|
;;;33     }
00003a  4770              BX       lr
                  |L1.60|
00003c  2000              MOVS     r0,#0                 ;32
00003e  e7fc              B        |L1.58|
;;;34     
                          ENDP

                  yaffs_CheckpointErase PROC
;;;35     
;;;36     static int yaffs_CheckpointErase(yaffs_Device *dev)
000040  b570              PUSH     {r4-r6,lr}
;;;37     {
000042  4604              MOV      r4,r0
;;;38     
;;;39     	int i;
;;;40     
;;;41     
;;;42     	if(!dev->eraseBlockInNAND)
000044  6c20              LDR      r0,[r4,#0x40]
000046  b908              CBNZ     r0,|L1.76|
;;;43     		return 0;
000048  2000              MOVS     r0,#0
                  |L1.74|
;;;44     	T(YAFFS_TRACE_CHECKPOINT,(TSTR("checking blocks %d to %d"TENDSTR),
;;;45     		dev->internalStartBlock,dev->internalEndBlock));
;;;46     
;;;47     	for(i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
;;;48     		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);
;;;49     		if(bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT){
;;;50     			T(YAFFS_TRACE_CHECKPOINT,(TSTR("erasing checkpt block %d"TENDSTR),i));
;;;51     			if(dev->eraseBlockInNAND(dev,i- dev->blockOffset /* realign */)){
;;;52     				bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
;;;53     				dev->nErasedBlocks++;
;;;54     				dev->nFreeChunks += dev->nChunksPerBlock;
;;;55     			}
;;;56     			else {
;;;57     				dev->markNANDBlockBad(dev,i);
;;;58     				bi->blockState = YAFFS_BLOCK_STATE_DEAD;
;;;59     			}
;;;60     		}
;;;61     	}
;;;62     
;;;63     	dev->blocksInCheckpoint = 0;
;;;64     
;;;65     	return 1;
;;;66     }
00004a  bd70              POP      {r4-r6,pc}
                  |L1.76|
00004c  bf00              NOP                            ;44
00004e  bf00              NOP                            ;44
000050  f8d4509c          LDR      r5,[r4,#0x9c]         ;47
000054  e02f              B        |L1.182|
                  |L1.86|
000056  4629              MOV      r1,r5                 ;48
000058  4620              MOV      r0,r4                 ;48
00005a  f7fffffe          BL       yaffs_GetBlockInfo
00005e  4606              MOV      r6,r0                 ;48
000060  6830              LDR      r0,[r6,#0]            ;49
000062  f3c05003          UBFX     r0,r0,#20,#4          ;49
000066  2807              CMP      r0,#7                 ;49
000068  d124              BNE      |L1.180|
00006a  bf00              NOP                            ;50
00006c  bf00              NOP                            ;50
00006e  f8d400a4          LDR      r0,[r4,#0xa4]         ;51
000072  1a29              SUBS     r1,r5,r0              ;51
000074  4620              MOV      r0,r4                 ;51
000076  6c22              LDR      r2,[r4,#0x40]         ;51
000078  4790              BLX      r2                    ;51
00007a  b188              CBZ      r0,|L1.160|
00007c  6830              LDR      r0,[r6,#0]            ;52
00007e  f4200070          BIC      r0,r0,#0xf00000       ;52
000082  f5001040          ADD      r0,r0,#0x300000       ;52
000086  6030              STR      r0,[r6,#0]            ;52
000088  f8d400f4          LDR      r0,[r4,#0xf4]         ;53
00008c  1c40              ADDS     r0,r0,#1              ;53
00008e  f8c400f4          STR      r0,[r4,#0xf4]         ;53
000092  6921              LDR      r1,[r4,#0x10]         ;54
000094  f8d40d34          LDR      r0,[r4,#0xd34]        ;54
000098  4408              ADD      r0,r0,r1              ;54
00009a  f8c40d34          STR      r0,[r4,#0xd34]        ;54
00009e  e009              B        |L1.180|
                  |L1.160|
0000a0  4629              MOV      r1,r5                 ;57
0000a2  4620              MOV      r0,r4                 ;57
0000a4  6d62              LDR      r2,[r4,#0x54]         ;57
0000a6  4790              BLX      r2                    ;57
0000a8  6830              LDR      r0,[r6,#0]            ;58
0000aa  f4200070          BIC      r0,r0,#0xf00000       ;58
0000ae  f5000010          ADD      r0,r0,#0x900000       ;58
0000b2  6030              STR      r0,[r6,#0]            ;58
                  |L1.180|
0000b4  1c6d              ADDS     r5,r5,#1              ;47
                  |L1.182|
0000b6  f8d400a0          LDR      r0,[r4,#0xa0]         ;47
0000ba  42a8              CMP      r0,r5                 ;47
0000bc  dacb              BGE      |L1.86|
0000be  2000              MOVS     r0,#0                 ;63
0000c0  f8c400c0          STR      r0,[r4,#0xc0]         ;63
0000c4  2001              MOVS     r0,#1                 ;65
0000c6  e7c0              B        |L1.74|
;;;67     
                          ENDP

                  yaffs_CheckpointFindNextErasedBlock PROC
;;;68     
;;;69     static void yaffs_CheckpointFindNextErasedBlock(yaffs_Device *dev)
0000c8  e92d41f0          PUSH     {r4-r8,lr}
;;;70     {
0000cc  4604              MOV      r4,r0
;;;71     	int  i;
;;;72     	int blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;
0000ce  6a21              LDR      r1,[r4,#0x20]
0000d0  f8d400f4          LDR      r0,[r4,#0xf4]
0000d4  1a46              SUBS     r6,r0,r1
;;;73     	T(YAFFS_TRACE_CHECKPOINT,
0000d6  bf00              NOP      
0000d8  bf00              NOP      
;;;74     		(TSTR("allocating checkpt block: erased %d reserved %d avail %d next %d "TENDSTR),
;;;75     		dev->nErasedBlocks,dev->nReservedBlocks,blocksAvailable,dev->checkpointNextBlock));
;;;76     
;;;77     	if(dev->checkpointNextBlock >= 0 &&
0000da  f8d400cc          LDR      r0,[r4,#0xcc]
0000de  2800              CMP      r0,#0
0000e0  db22              BLT      |L1.296|
;;;78     	   dev->checkpointNextBlock <= dev->internalEndBlock &&
0000e2  f8d410a0          LDR      r1,[r4,#0xa0]
0000e6  f8d400cc          LDR      r0,[r4,#0xcc]
0000ea  4288              CMP      r0,r1
0000ec  dc1c              BGT      |L1.296|
;;;79     	   blocksAvailable > 0){
0000ee  2e00              CMP      r6,#0
0000f0  dd1a              BLE      |L1.296|
;;;80     
;;;81     		for(i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++){
0000f2  f8d450cc          LDR      r5,[r4,#0xcc]
0000f6  e013              B        |L1.288|
                  |L1.248|
;;;82     			yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);
0000f8  4629              MOV      r1,r5
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       yaffs_GetBlockInfo
000100  4607              MOV      r7,r0
;;;83     			if(bi->blockState == YAFFS_BLOCK_STATE_EMPTY){
000102  6838              LDR      r0,[r7,#0]
000104  f3c05003          UBFX     r0,r0,#20,#4
000108  2803              CMP      r0,#3
00010a  d108              BNE      |L1.286|
;;;84     				dev->checkpointNextBlock = i + 1;
00010c  1c68              ADDS     r0,r5,#1
00010e  f8c400cc          STR      r0,[r4,#0xcc]
;;;85     				dev->checkpointCurrentBlock = i;
000112  f8c450c8          STR      r5,[r4,#0xc8]
;;;86     				T(YAFFS_TRACE_CHECKPOINT,(TSTR("allocating checkpt block %d"TENDSTR),i));
000116  bf00              NOP      
000118  bf00              NOP      
                  |L1.282|
;;;87     				return;
;;;88     			}
;;;89     		}
;;;90     	}
;;;91     	T(YAFFS_TRACE_CHECKPOINT,(TSTR("out of checkpt blocks"TENDSTR)));
;;;92     
;;;93     	dev->checkpointNextBlock = -1;
;;;94     	dev->checkpointCurrentBlock = -1;
;;;95     }
00011a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.286|
00011e  1c6d              ADDS     r5,r5,#1              ;81
                  |L1.288|
000120  f8d400a0          LDR      r0,[r4,#0xa0]         ;81
000124  42a8              CMP      r0,r5                 ;81
000126  dae7              BGE      |L1.248|
                  |L1.296|
000128  bf00              NOP                            ;91
00012a  bf00              NOP                            ;91
00012c  f04f30ff          MOV      r0,#0xffffffff        ;93
000130  f8c400cc          STR      r0,[r4,#0xcc]         ;93
000134  f8c400c8          STR      r0,[r4,#0xc8]         ;94
000138  bf00              NOP      
00013a  e7ee              B        |L1.282|
;;;96     
                          ENDP

                  yaffs_CheckpointFindNextCheckpointBlock PROC
;;;97     static void yaffs_CheckpointFindNextCheckpointBlock(yaffs_Device *dev)
00013c  b5f0              PUSH     {r4-r7,lr}
;;;98     {
00013e  b093              SUB      sp,sp,#0x4c
000140  4604              MOV      r4,r0
;;;99     	int  i;
;;;100    	yaffs_ExtendedTags tags;
;;;101    
;;;102    	T(YAFFS_TRACE_CHECKPOINT,(TSTR("find next checkpt block: start:  blocks %d next %d" TENDSTR),
000142  bf00              NOP      
000144  bf00              NOP      
;;;103    		dev->blocksInCheckpoint, dev->checkpointNextBlock));
;;;104                
;;;105    	if(dev->blocksInCheckpoint < dev->checkpointMaxBlocks)
000146  f8d410d4          LDR      r1,[r4,#0xd4]
00014a  f8d400c0          LDR      r0,[r4,#0xc0]
00014e  4288              CMP      r0,r1
000150  da29              BGE      |L1.422|
;;;106    		for(i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++)
000152  f8d450cc          LDR      r5,[r4,#0xcc]
000156  e022              B        |L1.414|
                  |L1.344|
;;;107    		{
;;;108    			int chunk = i * dev->nChunksPerBlock;
000158  6920              LDR      r0,[r4,#0x10]
00015a  fb00f605          MUL      r6,r0,r5
;;;109    			int realignedChunk = chunk - dev->chunkOffset;
00015e  f8d400a8          LDR      r0,[r4,#0xa8]
000162  1a37              SUBS     r7,r6,r0
;;;110                
;;;111    			dev->readChunkWithTagsFromNAND(dev,realignedChunk,NULL,&tags);
000164  ab01              ADD      r3,sp,#4
000166  2200              MOVS     r2,#0
000168  4639              MOV      r1,r7
00016a  4620              MOV      r0,r4
00016c  f8d4c050          LDR      r12,[r4,#0x50]
000170  47e0              BLX      r12
;;;112                // zjy
;;;113    			T(YAFFS_TRACE_CHECKPOINT,(TSTR("find next checkpt block: search: block %d oid %d seq %d eccr %d" TENDSTR),
000172  bf00              NOP      
000174  bf00              NOP      
;;;114    				i, tags.objectId,tags.sequenceNumber,tags.eccResult));
;;;115    
;;;116    			if(tags.sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA){
000176  980a              LDR      r0,[sp,#0x28]
000178  2821              CMP      r0,#0x21
00017a  d10f              BNE      |L1.412|
;;;117    				/* Right kind of block */
;;;118    				dev->checkpointNextBlock = tags.objectId;
00017c  34c0              ADDS     r4,r4,#0xc0
00017e  9803              LDR      r0,[sp,#0xc]
000180  60e0              STR      r0,[r4,#0xc]
;;;119    				dev->checkpointCurrentBlock = i;
000182  60a5              STR      r5,[r4,#8]
;;;120    				dev->checkpointBlockList[dev->blocksInCheckpoint] = i;
000184  6821              LDR      r1,[r4,#0]
000186  6920              LDR      r0,[r4,#0x10]
000188  f8405021          STR      r5,[r0,r1,LSL #2]
;;;121    				dev->blocksInCheckpoint++;
00018c  6820              LDR      r0,[r4,#0]
00018e  1c40              ADDS     r0,r0,#1
000190  f84409c0          STR      r0,[r4],#-0xc0
;;;122    				T(YAFFS_TRACE_CHECKPOINT,(TSTR("found checkpt block %d"TENDSTR),i));
000194  bf00              NOP      
000196  bf00              NOP      
                  |L1.408|
;;;123    				return;
;;;124    			}
;;;125    		}
;;;126    
;;;127    	T(YAFFS_TRACE_CHECKPOINT,(TSTR("found no more checkpt blocks"TENDSTR)));
;;;128    
;;;129    	dev->checkpointNextBlock = -1;
;;;130    	dev->checkpointCurrentBlock = -1;
;;;131    }
000198  b013              ADD      sp,sp,#0x4c
00019a  bdf0              POP      {r4-r7,pc}
                  |L1.412|
00019c  1c6d              ADDS     r5,r5,#1              ;106
                  |L1.414|
00019e  f8d400a0          LDR      r0,[r4,#0xa0]         ;106
0001a2  42a8              CMP      r0,r5                 ;106
0001a4  dad8              BGE      |L1.344|
                  |L1.422|
0001a6  bf00              NOP                            ;127
0001a8  bf00              NOP                            ;127
0001aa  f04f30ff          MOV      r0,#0xffffffff        ;129
0001ae  f8c400cc          STR      r0,[r4,#0xcc]         ;129
0001b2  f8c400c8          STR      r0,[r4,#0xc8]         ;130
0001b6  bf00              NOP      
0001b8  e7ee              B        |L1.408|
;;;132    
                          ENDP

                  yaffs_CheckpointOpen PROC
;;;133    
;;;134    int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting)
0001ba  b570              PUSH     {r4-r6,lr}
;;;135    {
0001bc  4604              MOV      r4,r0
0001be  460d              MOV      r5,r1
;;;136    
;;;137    	/* Got the functions we need? */
;;;138    	if (!dev->writeChunkWithTagsToNAND ||
0001c0  6ce0              LDR      r0,[r4,#0x4c]
0001c2  b128              CBZ      r0,|L1.464|
;;;139    	    !dev->readChunkWithTagsFromNAND ||
0001c4  6d20              LDR      r0,[r4,#0x50]
0001c6  b118              CBZ      r0,|L1.464|
;;;140    	    !dev->eraseBlockInNAND ||
0001c8  6c20              LDR      r0,[r4,#0x40]
0001ca  b108              CBZ      r0,|L1.464|
;;;141    	    !dev->markNANDBlockBad)
0001cc  6d60              LDR      r0,[r4,#0x54]
0001ce  b908              CBNZ     r0,|L1.468|
                  |L1.464|
;;;142    		return 0;
0001d0  2000              MOVS     r0,#0
                  |L1.466|
;;;143    
;;;144    	if(forWriting && !yaffs_CheckpointSpaceOk(dev))
;;;145    		return 0;
;;;146    
;;;147    	if(!dev->checkpointBuffer)
;;;148    		dev->checkpointBuffer = YMALLOC_DMA(dev->totalBytesPerChunk);
;;;149    	if(!dev->checkpointBuffer)
;;;150    		return 0;
;;;151    
;;;152    
;;;153    	dev->checkpointPageSequence = 0;
;;;154    
;;;155    	dev->checkpointOpenForWrite = forWriting;
;;;156    
;;;157    	dev->checkpointByteCount = 0;
;;;158    	dev->checkpointSum = 0;
;;;159    	dev->checkpointXor = 0;
;;;160    	dev->checkpointCurrentBlock = -1;
;;;161    	dev->checkpointCurrentChunk = -1;
;;;162    	dev->checkpointNextBlock = dev->internalStartBlock;
;;;163    
;;;164    	/* Erase all the blocks in the checkpoint area */
;;;165    	if(forWriting){
;;;166    		memset(dev->checkpointBuffer,0,dev->nDataBytesPerChunk);
;;;167    		dev->checkpointByteOffset = 0;
;;;168    		return yaffs_CheckpointErase(dev);
;;;169    
;;;170    
;;;171    	} else {
;;;172    		int i;
;;;173    		/* Set to a value that will kick off a read */
;;;174    		dev->checkpointByteOffset = dev->nDataBytesPerChunk;
;;;175    		/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)
;;;176    		 * going to be way more than we need */
;;;177    		dev->blocksInCheckpoint = 0;
;;;178    		dev->checkpointMaxBlocks = (dev->internalEndBlock - dev->internalStartBlock)/16 + 2;
;;;179    		dev->checkpointBlockList = YMALLOC(sizeof(int) * dev->checkpointMaxBlocks);
;;;180    		for(i = 0; i < dev->checkpointMaxBlocks; i++)
;;;181    			dev->checkpointBlockList[i] = -1;
;;;182    	}
;;;183    
;;;184    	return 1;
;;;185    }
0001d2  bd70              POP      {r4-r6,pc}
                  |L1.468|
0001d4  b12d              CBZ      r5,|L1.482|
0001d6  4620              MOV      r0,r4                 ;144
0001d8  f7fffffe          BL       yaffs_CheckpointSpaceOk
0001dc  b908              CBNZ     r0,|L1.482|
0001de  2000              MOVS     r0,#0                 ;145
0001e0  e7f7              B        |L1.466|
                  |L1.482|
0001e2  f8d400b8          LDR      r0,[r4,#0xb8]         ;147
0001e6  b928              CBNZ     r0,|L1.500|
0001e8  f8d40090          LDR      r0,[r4,#0x90]         ;148
0001ec  f7fffffe          BL       yaffs_malloc
0001f0  f8c400b8          STR      r0,[r4,#0xb8]         ;148
                  |L1.500|
0001f4  f8d400b8          LDR      r0,[r4,#0xb8]         ;149
0001f8  b908              CBNZ     r0,|L1.510|
0001fa  2000              MOVS     r0,#0                 ;150
0001fc  e7e9              B        |L1.466|
                  |L1.510|
0001fe  2000              MOVS     r0,#0                 ;153
000200  349c              ADDS     r4,r4,#0x9c           ;153
000202  6120              STR      r0,[r4,#0x10]         ;153
000204  6225              STR      r5,[r4,#0x20]         ;155
000206  6160              STR      r0,[r4,#0x14]         ;157
000208  63e0              STR      r0,[r4,#0x3c]         ;158
00020a  6420              STR      r0,[r4,#0x40]         ;159
00020c  1e40              SUBS     r0,r0,#1              ;160
00020e  62e0              STR      r0,[r4,#0x2c]         ;160
000210  62a0              STR      r0,[r4,#0x28]         ;161
000212  6820              LDR      r0,[r4,#0]            ;162
000214  6320              STR      r0,[r4,#0x30]         ;162
000216  3c9c              SUBS     r4,r4,#0x9c           ;162
000218  b15d              CBZ      r5,|L1.562|
00021a  68e1              LDR      r1,[r4,#0xc]          ;166
00021c  f8d400b8          LDR      r0,[r4,#0xb8]         ;166
000220  f7fffffe          BL       __aeabi_memclr
000224  2000              MOVS     r0,#0                 ;167
000226  f8c400b4          STR      r0,[r4,#0xb4]         ;167
00022a  4620              MOV      r0,r4                 ;168
00022c  f7fffffe          BL       yaffs_CheckpointErase
000230  e7cf              B        |L1.466|
                  |L1.562|
000232  3458              ADDS     r4,r4,#0x58           ;174
000234  f8540c4c          LDR      r0,[r4,#-0x4c]        ;174
000238  65e0              STR      r0,[r4,#0x5c]         ;174
00023a  2000              MOVS     r0,#0                 ;177
00023c  66a0              STR      r0,[r4,#0x68]         ;177
00023e  e9d42111          LDRD     r2,r1,[r4,#0x44]      ;178
000242  1a88              SUBS     r0,r1,r2              ;178
000244  17c1              ASRS     r1,r0,#31             ;178
000246  eb007111          ADD      r1,r0,r1,LSR #28      ;178
00024a  1109              ASRS     r1,r1,#4              ;178
00024c  1c89              ADDS     r1,r1,#2              ;178
00024e  67e1              STR      r1,[r4,#0x7c]         ;178
000250  6fe1              LDR      r1,[r4,#0x7c]         ;179
000252  0088              LSLS     r0,r1,#2              ;179
000254  f7fffffe          BL       yaffs_malloc
000258  67a0              STR      r0,[r4,#0x78]         ;179
00025a  3c58              SUBS     r4,r4,#0x58           ;179
00025c  2600              MOVS     r6,#0                 ;180
00025e  e006              B        |L1.622|
                  |L1.608|
000260  f04f30ff          MOV      r0,#0xffffffff        ;181
000264  f8d410d0          LDR      r1,[r4,#0xd0]         ;181
000268  f8410026          STR      r0,[r1,r6,LSL #2]     ;181
00026c  1c76              ADDS     r6,r6,#1              ;180
                  |L1.622|
00026e  f8d400d4          LDR      r0,[r4,#0xd4]         ;180
000272  42b0              CMP      r0,r6                 ;180
000274  dcf4              BGT      |L1.608|
000276  bf00              NOP                            ;182
000278  2001              MOVS     r0,#1                 ;184
00027a  e7aa              B        |L1.466|
;;;186    
                          ENDP

                  yaffs_GetCheckpointSum PROC
;;;187    int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum)
00027c  b510              PUSH     {r4,lr}
;;;188    {
00027e  4602              MOV      r2,r0
;;;189    	__u32 compositeSum;
;;;190    	compositeSum =  (dev->checkpointSum << 8) | (dev->checkpointXor & 0xFF);
000280  e9d24036          LDRD     r4,r0,[r2,#0xd8]
000284  f364201f          BFI      r0,r4,#8,#24
000288  4603              MOV      r3,r0
;;;191    	*sum = compositeSum;
00028a  600b              STR      r3,[r1,#0]
;;;192    	return 1;
00028c  2001              MOVS     r0,#1
;;;193    }
00028e  bd10              POP      {r4,pc}
;;;194    
                          ENDP

                  yaffs_CheckpointFlushBuffer PROC
;;;195    static int yaffs_CheckpointFlushBuffer(yaffs_Device *dev)
000290  b5f0              PUSH     {r4-r7,lr}
;;;196    {
000292  b093              SUB      sp,sp,#0x4c
000294  4604              MOV      r4,r0
;;;197    
;;;198    	int chunk;
;;;199    	int realignedChunk;
;;;200    
;;;201    	yaffs_ExtendedTags tags;
;;;202    
;;;203    	if(dev->checkpointCurrentBlock < 0){
000296  f8d400c8          LDR      r0,[r4,#0xc8]
00029a  2800              CMP      r0,#0
00029c  da05              BGE      |L1.682|
;;;204    		yaffs_CheckpointFindNextErasedBlock(dev);
00029e  4620              MOV      r0,r4
0002a0  f7fffffe          BL       yaffs_CheckpointFindNextErasedBlock
;;;205    		dev->checkpointCurrentChunk = 0;
0002a4  2000              MOVS     r0,#0
0002a6  f8c400c4          STR      r0,[r4,#0xc4]
                  |L1.682|
;;;206    	}
;;;207    
;;;208    	if(dev->checkpointCurrentBlock < 0)
0002aa  f8d400c8          LDR      r0,[r4,#0xc8]
0002ae  2800              CMP      r0,#0
0002b0  da02              BGE      |L1.696|
;;;209    		return 0;
0002b2  2000              MOVS     r0,#0
                  |L1.692|
;;;210    
;;;211    	tags.chunkDeleted = 0;
;;;212    	tags.objectId = dev->checkpointNextBlock; /* Hint to next place to look */
;;;213    	tags.chunkId = dev->checkpointPageSequence + 1;
;;;214    	tags.sequenceNumber =  YAFFS_SEQUENCE_CHECKPOINT_DATA;
;;;215    	tags.byteCount = dev->nDataBytesPerChunk;
;;;216    	if(dev->checkpointCurrentChunk == 0){
;;;217    		/* First chunk we write for the block? Set block state to
;;;218    		   checkpoint */
;;;219    		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,dev->checkpointCurrentBlock);
;;;220    		bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
;;;221    		dev->blocksInCheckpoint++;
;;;222    	}
;;;223    
;;;224    	chunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock + dev->checkpointCurrentChunk;
;;;225    
;;;226    
;;;227    	T(YAFFS_TRACE_CHECKPOINT,(TSTR("checkpoint wite buffer nand %d(%d:%d) objid %d chId %d" TENDSTR),
;;;228    		chunk, dev->checkpointCurrentBlock, dev->checkpointCurrentChunk,tags.objectId,tags.chunkId));
;;;229    
;;;230    	realignedChunk = chunk - dev->chunkOffset;
;;;231    
;;;232    	dev->writeChunkWithTagsToNAND(dev,realignedChunk,dev->checkpointBuffer,&tags);
;;;233    	dev->checkpointByteOffset = 0;
;;;234    	dev->checkpointPageSequence++;
;;;235    	dev->checkpointCurrentChunk++;
;;;236    	if(dev->checkpointCurrentChunk >= dev->nChunksPerBlock){
;;;237    		dev->checkpointCurrentChunk = 0;
;;;238    		dev->checkpointCurrentBlock = -1;
;;;239    	}
;;;240    	memset(dev->checkpointBuffer,0,dev->nDataBytesPerChunk);
;;;241    
;;;242    	return 1;
;;;243    }
0002b4  b013              ADD      sp,sp,#0x4c
0002b6  bdf0              POP      {r4-r7,pc}
                  |L1.696|
0002b8  2000              MOVS     r0,#0                 ;211
0002ba  9008              STR      r0,[sp,#0x20]         ;211
0002bc  f8d400cc          LDR      r0,[r4,#0xcc]         ;212
0002c0  9003              STR      r0,[sp,#0xc]          ;212
0002c2  f8d400ac          LDR      r0,[r4,#0xac]         ;213
0002c6  1c40              ADDS     r0,r0,#1              ;213
0002c8  9004              STR      r0,[sp,#0x10]         ;213
0002ca  2021              MOVS     r0,#0x21              ;214
0002cc  900a              STR      r0,[sp,#0x28]         ;214
0002ce  68e0              LDR      r0,[r4,#0xc]          ;215
0002d0  9005              STR      r0,[sp,#0x14]         ;215
0002d2  f8d400c4          LDR      r0,[r4,#0xc4]         ;216
0002d6  b988              CBNZ     r0,|L1.764|
0002d8  4620              MOV      r0,r4                 ;219
0002da  f8d410c8          LDR      r1,[r4,#0xc8]         ;219
0002de  f7fffffe          BL       yaffs_GetBlockInfo
0002e2  4607              MOV      r7,r0                 ;219
0002e4  6838              LDR      r0,[r7,#0]            ;220
0002e6  f4200070          BIC      r0,r0,#0xf00000       ;220
0002ea  f50000e0          ADD      r0,r0,#0x700000       ;220
0002ee  6038              STR      r0,[r7,#0]            ;220
0002f0  f8d400c0          LDR      r0,[r4,#0xc0]         ;221
0002f4  1c40              ADDS     r0,r0,#1              ;221
0002f6  f8c400c0          STR      r0,[r4,#0xc0]         ;221
0002fa  bf00              NOP                            ;222
                  |L1.764|
0002fc  6922              LDR      r2,[r4,#0x10]         ;224
0002fe  e9d40131          LDRD     r0,r1,[r4,#0xc4]      ;224
000302  fb010502          MLA      r5,r1,r2,r0           ;224
000306  bf00              NOP                            ;227
000308  bf00              NOP                            ;227
00030a  f8d400a8          LDR      r0,[r4,#0xa8]         ;230
00030e  1a2e              SUBS     r6,r5,r0              ;230
000310  ab01              ADD      r3,sp,#4              ;232
000312  4631              MOV      r1,r6                 ;232
000314  4620              MOV      r0,r4                 ;232
000316  6ce7              LDR      r7,[r4,#0x4c]         ;232
000318  f8d420b8          LDR      r2,[r4,#0xb8]         ;232
00031c  47b8              BLX      r7                    ;232
00031e  2000              MOVS     r0,#0                 ;233
000320  3448              ADDS     r4,r4,#0x48           ;233
000322  66e0              STR      r0,[r4,#0x6c]         ;233
000324  6e60              LDR      r0,[r4,#0x64]         ;234
000326  1c40              ADDS     r0,r0,#1              ;234
000328  6660              STR      r0,[r4,#0x64]         ;234
00032a  6fe0              LDR      r0,[r4,#0x7c]         ;235
00032c  1c40              ADDS     r0,r0,#1              ;235
00032e  67e0              STR      r0,[r4,#0x7c]         ;235
000330  f8541c38          LDR      r1,[r4,#-0x38]        ;236
000334  6fe0              LDR      r0,[r4,#0x7c]         ;236
000336  3c48              SUBS     r4,r4,#0x48           ;236
000338  4288              CMP      r0,r1                 ;236
00033a  db05              BLT      |L1.840|
00033c  2000              MOVS     r0,#0                 ;237
00033e  f8c400c4          STR      r0,[r4,#0xc4]         ;237
000342  1e40              SUBS     r0,r0,#1              ;238
000344  f8c400c8          STR      r0,[r4,#0xc8]         ;238
                  |L1.840|
000348  68e1              LDR      r1,[r4,#0xc]          ;240
00034a  f8d400b8          LDR      r0,[r4,#0xb8]         ;240
00034e  f7fffffe          BL       __aeabi_memclr
000352  2001              MOVS     r0,#1                 ;242
000354  e7ae              B        |L1.692|
;;;244    
                          ENDP

                  yaffs_CheckpointRead PROC
;;;284    
;;;285    int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes)
000356  e92d4ff0          PUSH     {r4-r11,lr}
;;;286    {
00035a  b093              SUB      sp,sp,#0x4c
00035c  4604              MOV      r4,r0
00035e  460f              MOV      r7,r1
000360  4690              MOV      r8,r2
;;;287    	int i=0;
000362  2600              MOVS     r6,#0
;;;288    	int ok = 1;
000364  f04f0901          MOV      r9,#1
;;;289    	yaffs_ExtendedTags tags;
;;;290    
;;;291    
;;;292    	int chunk;
;;;293    	int realignedChunk;
;;;294    
;;;295    	__u8 *dataBytes = (__u8 *)data;
000368  463d              MOV      r5,r7
;;;296    
;;;297    	if(!dev->checkpointBuffer)
00036a  f8d400b8          LDR      r0,[r4,#0xb8]
00036e  b918              CBNZ     r0,|L1.888|
;;;298    		return 0;
000370  2000              MOVS     r0,#0
                  |L1.882|
;;;299    
;;;300    	if(dev->checkpointOpenForWrite)
;;;301    		return -1;
;;;302        
;;;303    	while(i < nBytes && ok) {
;;;304     
;;;305    
;;;306    		if(dev->checkpointByteOffset < 0 || dev->checkpointByteOffset >= dev->nDataBytesPerChunk) 
;;;307    		  {
;;;308    
;;;309    		   	if(dev->checkpointCurrentBlock < 0)
;;;310    		   	{
;;;311    				yaffs_CheckpointFindNextCheckpointBlock(dev);
;;;312    				dev->checkpointCurrentChunk = 0;
;;;313    			}
;;;314                
;;;315    			if(dev->checkpointCurrentBlock < 0)
;;;316    				ok = 0;
;;;317    			else {
;;;318    
;;;319    				chunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock +
;;;320    				          dev->checkpointCurrentChunk;
;;;321    
;;;322    				realignedChunk = chunk - dev->chunkOffset;
;;;323    
;;;324    	   			/* read in the next chunk */
;;;325    	   			/* printf("read checkpoint page %d\n",dev->checkpointPage); */
;;;326    				dev->readChunkWithTagsFromNAND(dev, realignedChunk,
;;;327    							       dev->checkpointBuffer,
;;;328    							      &tags);
;;;329    
;;;330    				if(tags.chunkId != (dev->checkpointPageSequence + 1) ||
;;;331    				   tags.eccResult > YAFFS_ECC_RESULT_FIXED ||
;;;332    				   tags.sequenceNumber != YAFFS_SEQUENCE_CHECKPOINT_DATA)
;;;333    				   ok = 0;
;;;334    
;;;335    				dev->checkpointByteOffset = 0;
;;;336    				dev->checkpointPageSequence++;
;;;337    				dev->checkpointCurrentChunk++;
;;;338    
;;;339    				if(dev->checkpointCurrentChunk >= dev->nChunksPerBlock)
;;;340    					dev->checkpointCurrentBlock = -1;
;;;341    			}
;;;342    		}
;;;343    
;;;344    		if(ok){
;;;345    			*dataBytes = dev->checkpointBuffer[dev->checkpointByteOffset];
;;;346    			dev->checkpointSum += *dataBytes;
;;;347    			dev->checkpointXor ^= *dataBytes;
;;;348    			dev->checkpointByteOffset++;
;;;349    			i++;
;;;350    			dataBytes++;
;;;351    			dev->checkpointByteCount++;
;;;352                
;;;353    		}
;;;354    	}
;;;355    
;;;356    	return 	i;
;;;357    }
000372  b013              ADD      sp,sp,#0x4c
000374  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.888|
000378  f8d400bc          LDR      r0,[r4,#0xbc]         ;300
00037c  b110              CBZ      r0,|L1.900|
00037e  f04f30ff          MOV      r0,#0xffffffff        ;301
000382  e7f6              B        |L1.882|
                  |L1.900|
000384  e066              B        |L1.1108|
                  |L1.902|
000386  f8d400b4          LDR      r0,[r4,#0xb4]         ;306
00038a  2800              CMP      r0,#0                 ;306
00038c  db04              BLT      |L1.920|
00038e  68e1              LDR      r1,[r4,#0xc]          ;306
000390  f8d400b4          LDR      r0,[r4,#0xb4]         ;306
000394  4288              CMP      r0,r1                 ;306
000396  db44              BLT      |L1.1058|
                  |L1.920|
000398  f8d400c8          LDR      r0,[r4,#0xc8]         ;309
00039c  2800              CMP      r0,#0                 ;309
00039e  da05              BGE      |L1.940|
0003a0  4620              MOV      r0,r4                 ;311
0003a2  f7fffffe          BL       yaffs_CheckpointFindNextCheckpointBlock
0003a6  2000              MOVS     r0,#0                 ;312
0003a8  f8c400c4          STR      r0,[r4,#0xc4]         ;312
                  |L1.940|
0003ac  f8d400c8          LDR      r0,[r4,#0xc8]         ;315
0003b0  2800              CMP      r0,#0                 ;315
0003b2  da02              BGE      |L1.954|
0003b4  f04f0900          MOV      r9,#0                 ;316
0003b8  e033              B        |L1.1058|
                  |L1.954|
0003ba  344c              ADDS     r4,r4,#0x4c           ;319
0003bc  f8542c3c          LDR      r2,[r4,#-0x3c]        ;319
0003c0  e9d4011e          LDRD     r0,r1,[r4,#0x78]      ;319
0003c4  fb010a02          MLA      r10,r1,r2,r0          ;319
0003c8  6de0              LDR      r0,[r4,#0x5c]         ;322
0003ca  ebaa0b00          SUB      r11,r10,r0            ;322
0003ce  f8d4c004          LDR      r12,[r4,#4]           ;326
0003d2  6ee2              LDR      r2,[r4,#0x6c]         ;326
0003d4  3c4c              SUBS     r4,r4,#0x4c           ;326
0003d6  ab01              ADD      r3,sp,#4              ;326
0003d8  4659              MOV      r1,r11                ;326
0003da  4620              MOV      r0,r4                 ;326
0003dc  47e0              BLX      r12                   ;326
0003de  9904              LDR      r1,[sp,#0x10]         ;330
0003e0  f8d400ac          LDR      r0,[r4,#0xac]         ;330
0003e4  1c40              ADDS     r0,r0,#1              ;330
0003e6  4281              CMP      r1,r0                 ;330
0003e8  d106              BNE      |L1.1016|
0003ea  f89d0018          LDRB     r0,[sp,#0x18]         ;331
0003ee  2802              CMP      r0,#2                 ;331
0003f0  dc02              BGT      |L1.1016|
0003f2  980a              LDR      r0,[sp,#0x28]         ;332
0003f4  2821              CMP      r0,#0x21              ;332
0003f6  d001              BEQ      |L1.1020|
                  |L1.1016|
0003f8  f04f0900          MOV      r9,#0                 ;333
                  |L1.1020|
0003fc  2000              MOVS     r0,#0                 ;335
0003fe  3448              ADDS     r4,r4,#0x48           ;335
000400  66e0              STR      r0,[r4,#0x6c]         ;335
000402  6e60              LDR      r0,[r4,#0x64]         ;336
000404  1c40              ADDS     r0,r0,#1              ;336
000406  6660              STR      r0,[r4,#0x64]         ;336
000408  6fe0              LDR      r0,[r4,#0x7c]         ;337
00040a  1c40              ADDS     r0,r0,#1              ;337
00040c  67e0              STR      r0,[r4,#0x7c]         ;337
00040e  f8541c38          LDR      r1,[r4,#-0x38]        ;339
000412  6fe0              LDR      r0,[r4,#0x7c]         ;339
000414  3c48              SUBS     r4,r4,#0x48           ;339
000416  4288              CMP      r0,r1                 ;339
000418  db03              BLT      |L1.1058|
00041a  f04f30ff          MOV      r0,#0xffffffff        ;340
00041e  f8c400c8          STR      r0,[r4,#0xc8]         ;340
                  |L1.1058|
000422  f1b90f00          CMP      r9,#0                 ;344
000426  d015              BEQ      |L1.1108|
000428  34b0              ADDS     r4,r4,#0xb0           ;345
00042a  e9d41001          LDRD     r1,r0,[r4,#4]         ;345
00042e  5c40              LDRB     r0,[r0,r1]            ;345
000430  7028              STRB     r0,[r5,#0]            ;345
000432  7829              LDRB     r1,[r5,#0]            ;346
000434  6aa0              LDR      r0,[r4,#0x28]         ;346
000436  4408              ADD      r0,r0,r1              ;346
000438  62a0              STR      r0,[r4,#0x28]         ;346
00043a  7829              LDRB     r1,[r5,#0]            ;347
00043c  6ae0              LDR      r0,[r4,#0x2c]         ;347
00043e  4048              EORS     r0,r0,r1              ;347
000440  62e0              STR      r0,[r4,#0x2c]         ;347
000442  6860              LDR      r0,[r4,#4]            ;348
000444  1c40              ADDS     r0,r0,#1              ;348
000446  6060              STR      r0,[r4,#4]            ;348
000448  1c76              ADDS     r6,r6,#1              ;349
00044a  1c6d              ADDS     r5,r5,#1              ;350
00044c  6820              LDR      r0,[r4,#0]            ;351
00044e  1c40              ADDS     r0,r0,#1              ;351
000450  f84409b0          STR      r0,[r4],#-0xb0        ;351
                  |L1.1108|
000454  4546              CMP      r6,r8                 ;303
000456  da02              BGE      |L1.1118|
000458  f1b90f00          CMP      r9,#0                 ;303
00045c  d193              BNE      |L1.902|
                  |L1.1118|
00045e  4630              MOV      r0,r6                 ;356
000460  e787              B        |L1.882|
;;;358    
                          ENDP

                  yaffs_CheckpointClose PROC
;;;359    int yaffs_CheckpointClose(yaffs_Device *dev)
000462  b570              PUSH     {r4-r6,lr}
;;;360    {
000464  4604              MOV      r4,r0
;;;361    
;;;362    	if(dev->checkpointOpenForWrite){
000466  f8d400bc          LDR      r0,[r4,#0xbc]
00046a  b130              CBZ      r0,|L1.1146|
;;;363    		if(dev->checkpointByteOffset != 0)
00046c  f8d400b4          LDR      r0,[r4,#0xb4]
000470  b358              CBZ      r0,|L1.1226|
;;;364    			yaffs_CheckpointFlushBuffer(dev);
000472  4620              MOV      r0,r4
000474  f7fffffe          BL       yaffs_CheckpointFlushBuffer
000478  e027              B        |L1.1226|
                  |L1.1146|
;;;365    	} else {
;;;366    		int i;
;;;367    		for(i = 0; i < dev->blocksInCheckpoint && dev->checkpointBlockList[i] >= 0; i++){
00047a  2500              MOVS     r5,#0
00047c  e013              B        |L1.1190|
                  |L1.1150|
;;;368    			yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,dev->checkpointBlockList[i]);
00047e  f8d400d0          LDR      r0,[r4,#0xd0]
000482  f8501025          LDR      r1,[r0,r5,LSL #2]
000486  4620              MOV      r0,r4
000488  f7fffffe          BL       yaffs_GetBlockInfo
00048c  4606              MOV      r6,r0
;;;369    			if(bi->blockState == YAFFS_BLOCK_STATE_EMPTY)
00048e  6830              LDR      r0,[r6,#0]
000490  f3c05003          UBFX     r0,r0,#20,#4
000494  2803              CMP      r0,#3
000496  d105              BNE      |L1.1188|
;;;370    				bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
000498  6830              LDR      r0,[r6,#0]
00049a  f4200070          BIC      r0,r0,#0xf00000
00049e  f50000e0          ADD      r0,r0,#0x700000
0004a2  6030              STR      r0,[r6,#0]
                  |L1.1188|
0004a4  1c6d              ADDS     r5,r5,#1              ;367
                  |L1.1190|
0004a6  f8d400c0          LDR      r0,[r4,#0xc0]         ;367
0004aa  42a8              CMP      r0,r5                 ;367
0004ac  dd05              BLE      |L1.1210|
0004ae  f8d400d0          LDR      r0,[r4,#0xd0]         ;367
0004b2  f8500025          LDR      r0,[r0,r5,LSL #2]     ;367
0004b6  2800              CMP      r0,#0                 ;367
0004b8  dae1              BGE      |L1.1150|
                  |L1.1210|
;;;371    			else {
;;;372    				// Todo this looks odd...
;;;373    			}
;;;374    		}
;;;375    		YFREE(dev->checkpointBlockList);
0004ba  f8d400d0          LDR      r0,[r4,#0xd0]
0004be  f7fffffe          BL       free
;;;376    		dev->checkpointBlockList = NULL;
0004c2  2000              MOVS     r0,#0
0004c4  f8c400d0          STR      r0,[r4,#0xd0]
;;;377    	}
0004c8  bf00              NOP      
                  |L1.1226|
;;;378    
;;;379    	dev->nFreeChunks -= dev->blocksInCheckpoint * dev->nChunksPerBlock;
0004ca  3478              ADDS     r4,r4,#0x78
0004cc  f8542c68          LDR      r2,[r4,#-0x68]
0004d0  6ca1              LDR      r1,[r4,#0x48]
0004d2  f8d40cbc          LDR      r0,[r4,#0xcbc]
0004d6  fb010012          MLS      r0,r1,r2,r0
0004da  f8c40cbc          STR      r0,[r4,#0xcbc]
;;;380    	dev->nErasedBlocks -= dev->blocksInCheckpoint;
0004de  6ca1              LDR      r1,[r4,#0x48]
0004e0  6fe0              LDR      r0,[r4,#0x7c]
0004e2  1a40              SUBS     r0,r0,r1
0004e4  67e0              STR      r0,[r4,#0x7c]
0004e6  3c78              SUBS     r4,r4,#0x78
;;;381    
;;;382    
;;;383    	T(YAFFS_TRACE_CHECKPOINT,(TSTR("checkpoint byte count %d" TENDSTR),
0004e8  bf00              NOP      
0004ea  bf00              NOP      
;;;384    			dev->checkpointByteCount));
;;;385    
;;;386    	if(dev->checkpointBuffer){
0004ec  f8d400b8          LDR      r0,[r4,#0xb8]
0004f0  b140              CBZ      r0,|L1.1284|
;;;387    		/* free the buffer */
;;;388    		YFREE(dev->checkpointBuffer);
0004f2  f8d400b8          LDR      r0,[r4,#0xb8]
0004f6  f7fffffe          BL       free
;;;389    		dev->checkpointBuffer = NULL;
0004fa  2000              MOVS     r0,#0
0004fc  f8c400b8          STR      r0,[r4,#0xb8]
;;;390    		return 1;
000500  2001              MOVS     r0,#1
                  |L1.1282|
;;;391    	}
;;;392    	else
;;;393    		return 0;
;;;394    
;;;395    }
000502  bd70              POP      {r4-r6,pc}
                  |L1.1284|
000504  2000              MOVS     r0,#0                 ;393
000506  e7fc              B        |L1.1282|
;;;396    
                          ENDP

                  yaffs_CheckpointInvalidateStream PROC
;;;397    int yaffs_CheckpointInvalidateStream(yaffs_Device *dev)
000508  b510              PUSH     {r4,lr}
;;;398    {
00050a  4604              MOV      r4,r0
;;;399    	/* Erase the first checksum block */
;;;400    
;;;401    	T(YAFFS_TRACE_CHECKPOINT,(TSTR("checkpoint invalidate"TENDSTR)));
00050c  bf00              NOP      
00050e  bf00              NOP      
;;;402    
;;;403    	if(!yaffs_CheckpointSpaceOk(dev))
000510  4620              MOV      r0,r4
000512  f7fffffe          BL       yaffs_CheckpointSpaceOk
000516  b908              CBNZ     r0,|L1.1308|
;;;404    		return 0;
000518  2000              MOVS     r0,#0
                  |L1.1306|
;;;405    
;;;406    	return yaffs_CheckpointErase(dev);
;;;407    }
00051a  bd10              POP      {r4,pc}
                  |L1.1308|
00051c  4620              MOV      r0,r4                 ;406
00051e  f7fffffe          BL       yaffs_CheckpointErase
000522  e7fa              B        |L1.1306|
;;;408    
                          ENDP


                          AREA ||area_number.2||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.2||, ||.text||
                  yaffs_CheckpointWrite PROC
;;;21     /* Function to manipulate block info */
;;;22     static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;23     {
;;;24     	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  2600              MOVS     r6,#0
00000c  f04f0901          MOV      r9,#1
000010  463d              MOV      r5,r7
;;;25     		T(YAFFS_TRACE_ERROR,
000012  f8d400b8          LDR      r0,[r4,#0xb8]
;;;26     		  (TSTR
;;;27     		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
;;;28     		   blk));
;;;29     		YBUG();
;;;30     	}
;;;31     	return &dev->blockInfo[blk - dev->internalStartBlock];
000016  b910              CBNZ     r0,|L2.30|
000018  2000              MOVS     r0,#0
                  |L2.26|
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L2.30|
00001e  f8d400bc          LDR      r0,[r4,#0xbc]
000022  b910              CBNZ     r0,|L2.42|
;;;32     }
000024  f04f30ff          MOV      r0,#0xffffffff
000028  e7f7              B        |L2.26|
                  |L2.42|
00002a  e021              B        |L2.112|
                  |L2.44|
00002c  7828              LDRB     r0,[r5,#0]
00002e  34b0              ADDS     r4,r4,#0xb0
000030  e9d42101          LDRD     r2,r1,[r4,#4]
000034  5488              STRB     r0,[r1,r2]
000036  7829              LDRB     r1,[r5,#0]
000038  6aa0              LDR      r0,[r4,#0x28]
00003a  4408              ADD      r0,r0,r1
00003c  62a0              STR      r0,[r4,#0x28]
00003e  7829              LDRB     r1,[r5,#0]
000040  6ae0              LDR      r0,[r4,#0x2c]
000042  4048              EORS     r0,r0,r1
000044  62e0              STR      r0,[r4,#0x2c]
000046  6860              LDR      r0,[r4,#4]
000048  1c40              ADDS     r0,r0,#1
00004a  6060              STR      r0,[r4,#4]
00004c  1c76              ADDS     r6,r6,#1
00004e  1c6d              ADDS     r5,r5,#1
000050  6820              LDR      r0,[r4,#0]
000052  1c40              ADDS     r0,r0,#1
000054  6020              STR      r0,[r4,#0]
000056  6860              LDR      r0,[r4,#4]
000058  3cb0              SUBS     r4,r4,#0xb0
00005a  2800              CMP      r0,#0
00005c  db04              BLT      |L2.104|
00005e  68e1              LDR      r1,[r4,#0xc]
000060  f8d400b4          LDR      r0,[r4,#0xb4]
000064  4288              CMP      r0,r1
000066  db03              BLT      |L2.112|
                  |L2.104|
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       yaffs_CheckpointFlushBuffer
00006e  4681              MOV      r9,r0
                  |L2.112|
000070  4546              CMP      r6,r8
000072  da02              BGE      |L2.122|
000074  f1b90f00          CMP      r9,#0
000078  d1d8              BNE      |L2.44|
                  |L2.122|
00007a  4630              MOV      r0,r6
00007c  e7cd              B        |L2.26|
;;;33     
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2449643a          DCB      "$$Id: yaffs_checkptrw.c,v 1.17 2008/08/12 22:51:57 char"
000004  20796166
000008  66735f63
00000c  6865636b
000010  70747277
000014  2e632c76
000018  20312e31
00001c  37203230
000020  30382f30
000024  382f3132
000028  2032323a
00002c  35313a35
000030  37206368
000034  6172    
000036  6c657320          DCB      "les Exp $$",0
00003a  45787020
00003e  2400    

                          AREA ||.data||, DATA, ALIGN=2

                  yaffs_checkptrw_c_version
                          DCD      ||.conststring||

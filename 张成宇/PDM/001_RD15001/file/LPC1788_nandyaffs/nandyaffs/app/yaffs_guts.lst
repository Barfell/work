L 1 "..\fs\yaffs_guts.c"
N/*
N * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N */
N
Nconst char *yaffs_guts_c_version =
N    "$Id: yaffs_guts.c,v 1.78 2009/01/27 02:52:45 charles Exp $";
N
N#include "yportenv.h"
L 1 "..\fs\yportenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N
N#ifndef __YPORTENV_H__
N#define __YPORTENV_H__
N
N//#include "2440lib.h"
N//#include <stdio.h>
N
N#define CONFIG_YAFFS_DIRECT
N/*
N * Define the MTD version in terms of Linux Kernel versions
N * This allows yaffs to be used independantly of the kernel
N * as well as with it.
N */
Ntypedef int off_t;
Ntypedef int dev_t;
Ntypedef unsigned int mode_t;
Ntypedef unsigned long loff_t;
N
N#define MTD_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
N
N#if defined CONFIG_YAFFS_WINCE
X#if 0L
S
S#include "ywinceenv.h"
S
S#elif  defined __KERNEL__
X#elif  0L
S
S#include "moduleconfig.h"
S
S/* Linux kernel */
S
S#include <linux/version.h>
S#define MTD_VERSION_CODE LINUX_VERSION_CODE
S
S#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
S#include <linux/config.h>
S#endif
S#include <linux/kernel.h>
S#include <linux/mm.h>
S#include <linux/sched.h>
S#include <linux/string.h>
S#include <linux/slab.h>
S#include <linux/vmalloc.h>
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S
S/* #define YPRINTF(x) printk x */
S#define YMALLOC(x) kmalloc(x,GFP_NOFS)
S#define YFREE(x)   kfree(x)
S#define YMALLOC_ALT(x) vmalloc(x)
S#define YFREE_ALT(x)   vfree(x)
S#define YMALLOC_DMA(x) YMALLOC(x)
S
S// KR - added for use in scan so processes aren't blocked indefinitely.
S#define YYIELD() schedule()
S
S#define YAFFS_ROOT_MODE			0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
S#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
S#define Y_TIME_CONVERT(x) (x).tv_sec
S#else
S#define Y_CURRENT_TIME CURRENT_TIME
S#define Y_TIME_CONVERT(x) (x)
S#endif
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#define TENDSTR "\n"
S#define TSTR(x) KERN_WARNING x
S#define TCONT(x) x
S#define TOUT(p) printk p
S
S#define yaffs_trace(mask, fmt, args...) \
S	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \
S		printk(KERN_WARNING "yaffs: " fmt, ## args); \
S	} while (0)
X#define yaffs_trace(mask, fmt, args...) 	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) 		printk(KERN_WARNING "yaffs: " fmt, ## args); 	} while (0)
S
S#define compile_time_assertion(assertion) \
S	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
X#define compile_time_assertion(assertion) 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
S
N#elif defined CONFIG_YAFFS_DIRECT
X#elif 1L
N
N#define MTD_VERSION_CODE MTD_VERSION(2,6,22)
N
N/* Direct interface */
N#include "ydirectenv.h"
L 1 "..\fs\ydirectenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * ydirectenv.h: Environment wrappers for YAFFS direct.
N */
N
N#ifndef __YDIRECTENV_H__
N#define __YDIRECTENV_H__
N
N// Direct interface
N
N#include "devextras.h"
L 1 "..\fs\devextras.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * This file is just holds extra declarations of macros that would normally
N * be providesd in the Linux kernel. These macros have been written from
N * scratch but are functionally equivalent to the Linux ones.
N *
N */
N
N
N
N#ifndef __EXTRAS_H__
N#define __EXTRAS_H__
N#define    __inline__    __inline
N
N#define  CONFIG_YAFFS_PROVIDE_DEFS
N
N#if !(defined __KERNEL__) 
X#if !(0L) 
N
N/* Definition of types */
Ntypedef unsigned char __u8;
Ntypedef unsigned short __u16;
Ntypedef unsigned __u32;
N
N#endif
N
N/*
N * This is a simple doubly linked list implementation that matches the 
N * way the Linux kernel doubly linked list implementation works.
N */
N
Nstruct ylist_head {
N	struct ylist_head *next; /* next in chain */
N	struct ylist_head *prev; /* previous in chain */
N};
N
N
N/* Initialise a static list */
N#define YLIST_HEAD(name) \
Nstruct ylist_head name = { &(name),&(name)}
X#define YLIST_HEAD(name) struct ylist_head name = { &(name),&(name)}
N
N
N
N/* Initialise a list head to an empty list */
N#define YINIT_LIST_HEAD(p) \
Ndo { \
N (p)->next = (p);\
N (p)->prev = (p); \
N} while(0)
X#define YINIT_LIST_HEAD(p) do {  (p)->next = (p); (p)->prev = (p); } while(0)
N
N
N/* Add an element to a list */
Nstatic __inline__ void ylist_add(struct ylist_head *newEntry, 
Xstatic __inline void ylist_add(struct ylist_head *newEntry, 
N                                 struct ylist_head *list)
N{
N        struct ylist_head *listNext = list->next;
N        
N        list->next = newEntry;
N        newEntry->prev = list;
N	newEntry->next = listNext;
N	listNext->prev = newEntry;
N	
N}
N
Nstatic __inline__ void ylist_add_tail(struct ylist_head *newEntry, 
Xstatic __inline void ylist_add_tail(struct ylist_head *newEntry, 
N				 struct ylist_head *list)
N{
N	struct ylist_head *listPrev = list->prev;
N	
N	list->prev = newEntry;
N	newEntry->next = list;
N	newEntry->prev = listPrev;
N	listPrev->next = newEntry;
N	
N}
N
N
N/* Take an element out of its current list, with or without
N * reinitialising the links.of the entry*/
Nstatic __inline__ void ylist_del(struct ylist_head *entry)
Xstatic __inline void ylist_del(struct ylist_head *entry)
N{
N        struct ylist_head *listNext = entry->next;
N        struct ylist_head *listPrev = entry->prev;
N        
N        listNext->prev = listPrev;
N        listPrev->next = listNext;
N        
N}
N
Nstatic __inline__ void ylist_del_init(struct ylist_head *entry)
Xstatic __inline void ylist_del_init(struct ylist_head *entry)
N{
N        ylist_del(entry);
N        entry->next = entry->prev = entry;
N}
N
N
N/* Test if the list is empty */
Nstatic __inline__ int ylist_empty(struct ylist_head *entry)
Xstatic __inline int ylist_empty(struct ylist_head *entry)
N{
N        return (entry->next == entry);
N}
N
N
N/* ylist_entry takes a pointer to a list entry and offsets it to that
N * we can find a pointer to the object it is embedded in.
N */
N 
N 
N#define ylist_entry(entry, type, member) \
N        ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
X#define ylist_entry(entry, type, member)         ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
N
N
N/* ylist_for_each and list_for_each_safe  iterate over lists.
N * ylist_for_each_safe uses temporary storage to make the list delete safe
N */
N
N#define ylist_for_each(itervar, list) \
N        for (itervar = (list)->next; itervar != (list); itervar = itervar->next )
X#define ylist_for_each(itervar, list)         for (itervar = (list)->next; itervar != (list); itervar = itervar->next )
N
N#define ylist_for_each_safe(itervar,saveVar, list) \
N        for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list); \
N         itervar = saveVar, saveVar = saveVar->next)
X#define ylist_for_each_safe(itervar,saveVar, list)         for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list);          itervar = saveVar, saveVar = saveVar->next)
N
N
N#if !(defined __KERNEL__)
X#if !(0L)
N
N
N#ifdef WIN32
S#include <sys/stat.h>
N#endif
N
N
N#ifdef CONFIG_YAFFS_PROVIDE_DEFS
N/* File types */
N
N
N#define DT_UNKNOWN      0
N#define DT_FIFO         1
N#define DT_CHR          2
N#define DT_DIR		4
N#define DT_BLK		6
N#define DT_REG          8
N#define DT_LNK          10
N#define DT_SOCK         12
N#define DT_WHT          14
N
N
N#ifdef WIN32
S#include <sys/stat.h>
N#endif
N
N/*
N * Attribute flags.  These should be or-ed together to figure out what
N * has been changed!
N */
N#define ATTR_MODE       1
N#define ATTR_UID        2
N#define ATTR_GID	4
N#define ATTR_SIZE	8
N#define ATTR_ATIME	16
N#define ATTR_MTIME	32
N#define ATTR_CTIME	64
N
Nstruct iattr {
N	unsigned int ia_valid;
N	unsigned ia_mode;
N	unsigned ia_uid;
N	unsigned ia_gid;
N	unsigned ia_size;
N	unsigned ia_atime;
N	unsigned ia_mtime;
N	unsigned ia_ctime;
N        unsigned int ia_attr_flags;
N};
N
N#endif
N
N
N#define KERN_DEBUG
N
N#else
S
S#include <linux/types.h>
S#include <linux/fs.h>
S#include <linux/stat.h>
S
N#endif
N
N
N#endif
L 26 "..\fs\ydirectenv.h" 2
N
N#include "stdlib.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 180254 $
N * Checkin $Date: 2013-06-03 17:00:28 +0100 (Mon, 03 Jun 2013) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_REALTIME_DIVIDE)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 28 "..\fs\ydirectenv.h" 2
N#include "stdio.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 29 "..\fs\ydirectenv.h" 2
N#include "string.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5040049
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "..\fs\ydirectenv.h" 2
N#include "yaffs_malloc.h"
L 1 "..\fs\yaffs_malloc.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N 
N#ifndef __YAFFS_MALLOC_H__
N#define __YAFFS_MALLOC_H__
N
N#include <stdlib.h>
N 
Nvoid *yaffs_malloc(size_t size); 
Nvoid yaffs_free(void *ptr);
N 
N#endif
N
L 31 "..\fs\ydirectenv.h" 2
N
N#include "assert.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5040049
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 33 "..\fs\ydirectenv.h" 2
N#define YBUG() //assert(0)
N//#define YBUG() do { *((int *)0) =1;} while(0)
N
N
N#define YCHAR char
N#define YUCHAR unsigned char
N#define _Y(x) x
N#define yaffs_strcat(a,b)    strcat(a,b)
N#define yaffs_strcpy(a,b)    strcpy(a,b)
N#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
N#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
N#define yaffs_strlen(s)	     strlen(s)
N#define yaffs_sprintf	     //sprintf
N#define yaffs_toupper(a)     toupper(a)
N
N#define YAFFS_PATH_DIVIDERS  "/"
N
N#ifdef NO_Y_INLINE
S#define Y_INLINE
N#else
N#define Y_INLINE  __inline
N#endif
N
N#define YMALLOC(x) yaffs_malloc(x)
N#define YFREE(x)   free(x)
N#define YMALLOC_ALT(x) yaffs_malloc(x)
N#define YFREE_ALT(x)   free(x)
N
N#define YMALLOC_DMA(x) yaffs_malloc(x)
N
N#define YYIELD()  do {} while(0)
N
N
N
N//#define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s))
N//#define YALERT(s) YINFO(s)
N
N
N#define TENDSTR "\n"
N#define TSTR(x) x
N#define TCONT(x) x
N#define TOUT(p) //printf p
N
N
N#define YAFFS_LOSTNFOUND_NAME		"lost+found"
N#define YAFFS_LOSTNFOUND_PREFIX		"obj"
N//#define YPRINTF(x) printf x
N
N#include "yaffscfg.h"
L 1 "..\fs\yaffscfg.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * Header file for using yaffs in an application via
N * a direct interface.
N */
N
N
N#ifndef __YAFFSCFG_H__
N#define __YAFFSCFG_H__
N
N
N#include "yportenv.h"
L 1 "..\fs\yportenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N
N#ifndef __YPORTENV_H__
S#define __YPORTENV_H__
S
S//#include "2440lib.h"
S//#include <stdio.h>
S
S#define CONFIG_YAFFS_DIRECT
S/*
S * Define the MTD version in terms of Linux Kernel versions
S * This allows yaffs to be used independantly of the kernel
S * as well as with it.
S */
Stypedef int off_t;
Stypedef int dev_t;
Stypedef unsigned int mode_t;
Stypedef unsigned long loff_t;
S
S#define MTD_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
S
S#if defined CONFIG_YAFFS_WINCE
S
S#include "ywinceenv.h"
S
S#elif  defined __KERNEL__
S
S#include "moduleconfig.h"
S
S/* Linux kernel */
S
S#include <linux/version.h>
S#define MTD_VERSION_CODE LINUX_VERSION_CODE
S
S#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
S#include <linux/config.h>
S#endif
S#include <linux/kernel.h>
S#include <linux/mm.h>
S#include <linux/sched.h>
S#include <linux/string.h>
S#include <linux/slab.h>
S#include <linux/vmalloc.h>
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S
S/* #define YPRINTF(x) printk x */
S#define YMALLOC(x) kmalloc(x,GFP_NOFS)
S#define YFREE(x)   kfree(x)
S#define YMALLOC_ALT(x) vmalloc(x)
S#define YFREE_ALT(x)   vfree(x)
S#define YMALLOC_DMA(x) YMALLOC(x)
S
S// KR - added for use in scan so processes aren't blocked indefinitely.
S#define YYIELD() schedule()
S
S#define YAFFS_ROOT_MODE			0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
S#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
S#define Y_TIME_CONVERT(x) (x).tv_sec
S#else
S#define Y_CURRENT_TIME CURRENT_TIME
S#define Y_TIME_CONVERT(x) (x)
S#endif
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#define TENDSTR "\n"
S#define TSTR(x) KERN_WARNING x
S#define TCONT(x) x
S#define TOUT(p) printk p
S
S#define yaffs_trace(mask, fmt, args...) \
S	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \
S		printk(KERN_WARNING "yaffs: " fmt, ## args); \
S	} while (0)
X#define yaffs_trace(mask, fmt, args...) 	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) 		printk(KERN_WARNING "yaffs: " fmt, ## args); 	} while (0)
S
S#define compile_time_assertion(assertion) \
S	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
X#define compile_time_assertion(assertion) 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
S
S#elif defined CONFIG_YAFFS_DIRECT
S
S#define MTD_VERSION_CODE MTD_VERSION(2,6,22)
S
S/* Direct interface */
S#include "ydirectenv.h"
S
S#elif defined CONFIG_YAFFS_UTIL
S
S/* Stuff for YAFFS utilities */
S
S#include "stdlib.h"
S#include "stdio.h"
S#include "string.h"
S
S#include "devextras.h"
S
S#define YMALLOC(x) malloc(x)
S#define YFREE(x)   free(x)
S#define YMALLOC_ALT(x) malloc(x)
S#define YFREE_ALT(x) free(x)
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
S/* #define YALERT(s) YINFO(s) */
S
S#define TENDSTR "\n"
S#define TSTR(x) x
S#define TOUT(p) printf p
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S/* #define YPRINTF(x) printf x */
S
S#define YAFFS_ROOT_MODE				0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#else
S/* Should have specified a configuration type */
S#error Unknown configuration
S
S#endif
S
S/* see yaffs_fs.c */
Sextern unsigned int yaffs_traceMask;
Sextern unsigned int yaffs_wr_attempts;
S
S/*
S * Tracing flags.
S * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
S */
S
S#define YAFFS_TRACE_OS			0x00000002
S#define YAFFS_TRACE_ALLOCATE		0x00000004
S#define YAFFS_TRACE_SCAN		0x00000008
S#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
S#define YAFFS_TRACE_ERASE		0x00000020
S#define YAFFS_TRACE_GC			0x00000040
S#define YAFFS_TRACE_WRITE		0x00000080
S#define YAFFS_TRACE_TRACING		0x00000100
S#define YAFFS_TRACE_DELETION		0x00000200
S#define YAFFS_TRACE_BUFFERS		0x00000400
S#define YAFFS_TRACE_NANDACCESS		0x00000800
S#define YAFFS_TRACE_GC_DETAIL		0x00001000
S#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
S#define YAFFS_TRACE_MTD			0x00004000
S#define YAFFS_TRACE_CHECKPOINT		0x00008000
S
S#define YAFFS_TRACE_VERIFY		0x00010000
S#define YAFFS_TRACE_VERIFY_NAND		0x00020000
S#define YAFFS_TRACE_VERIFY_FULL		0x00040000
S#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
S
S
S#define YAFFS_TRACE_ERROR		0x40000000
S#define YAFFS_TRACE_BUG			0x80000000
S#define YAFFS_TRACE_ALWAYS		0xF0000000
S
S
S#define T(mask,p) do{ if((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p);} while(0)
S
S#ifndef YBUG
S#define YBUG() do {T(YAFFS_TRACE_BUG,(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),__LINE__));} while(0)
S#endif
S
N#endif
L 27 "..\fs\yaffscfg.h" 2
N
N#define YAFFSFS_N_HANDLES 200
N
N
Ntypedef struct {
N	const YCHAR *prefix;
X	const char *prefix;
N	struct yaffs_DeviceStruct *dev;
N} yaffsfs_DeviceConfiguration;
N
N
Nvoid yaffsfs_Lock(void);
Nvoid yaffsfs_Unlock(void);
N__u32 yaffsfs_CurrentTime(void);
Nvoid yaffsfs_SetError(int err);
N
N#endif
N
L 82 "..\fs\ydirectenv.h" 2
N
N#define Y_CURRENT_TIME yaffsfs_CurrentTime()
N#define Y_TIME_CONVERT(x) x
N
N#define YAFFS_ROOT_MODE				0666
N#define YAFFS_LOSTNFOUND_MODE		0666
N
N#define yaffs_SumCompare(x,y) ((x) == (y))
N#define yaffs_strcmp(a,b) strcmp(a,b)
N
N#endif
N
N
L 118 "..\fs\yportenv.h" 2
N
N#elif defined CONFIG_YAFFS_UTIL
S
S/* Stuff for YAFFS utilities */
S
S#include "stdlib.h"
S#include "stdio.h"
S#include "string.h"
S
S#include "devextras.h"
S
S#define YMALLOC(x) malloc(x)
S#define YFREE(x)   free(x)
S#define YMALLOC_ALT(x) malloc(x)
S#define YFREE_ALT(x) free(x)
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
S/* #define YALERT(s) YINFO(s) */
S
S#define TENDSTR "\n"
S#define TSTR(x) x
S#define TOUT(p) printf p
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S/* #define YPRINTF(x) printf x */
S
S#define YAFFS_ROOT_MODE				0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#else
S/* Should have specified a configuration type */
S#error Unknown configuration
S
N#endif
N
N/* see yaffs_fs.c */
Nextern unsigned int yaffs_traceMask;
Nextern unsigned int yaffs_wr_attempts;
N
N/*
N * Tracing flags.
N * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
N */
N
N#define YAFFS_TRACE_OS			0x00000002
N#define YAFFS_TRACE_ALLOCATE		0x00000004
N#define YAFFS_TRACE_SCAN		0x00000008
N#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
N#define YAFFS_TRACE_ERASE		0x00000020
N#define YAFFS_TRACE_GC			0x00000040
N#define YAFFS_TRACE_WRITE		0x00000080
N#define YAFFS_TRACE_TRACING		0x00000100
N#define YAFFS_TRACE_DELETION		0x00000200
N#define YAFFS_TRACE_BUFFERS		0x00000400
N#define YAFFS_TRACE_NANDACCESS		0x00000800
N#define YAFFS_TRACE_GC_DETAIL		0x00001000
N#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
N#define YAFFS_TRACE_MTD			0x00004000
N#define YAFFS_TRACE_CHECKPOINT		0x00008000
N
N#define YAFFS_TRACE_VERIFY		0x00010000
N#define YAFFS_TRACE_VERIFY_NAND		0x00020000
N#define YAFFS_TRACE_VERIFY_FULL		0x00040000
N#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
N
N
N#define YAFFS_TRACE_ERROR		0x40000000
N#define YAFFS_TRACE_BUG			0x80000000
N#define YAFFS_TRACE_ALWAYS		0xF0000000
N
N
N#define T(mask,p) do{ if((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p);} while(0)
N
N#ifndef YBUG
S#define YBUG() do {T(YAFFS_TRACE_BUG,(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),__LINE__));} while(0)
N#endif
N
N#endif
L 18 "..\fs\yaffs_guts.c" 2
N
N#include "yaffsfs.h"
L 1 "..\fs\yaffsfs.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * Header file for using yaffs in an application via
N * a direct interface.
N */
N
N
N#ifndef __YAFFSFS_H__
N#define __YAFFSFS_H__
N
N#include "yaffscfg.h"
N#include "yportenv.h"
N
N#define   CONFIG_YAFFSFS_PROVIDE_VALUES  1
N//typedef long off_t;
N//typedef long dev_t;
N//typedef unsigned long mode_t;
N
N
N#ifndef NAME_MAX
N#define NAME_MAX	256
N#endif
N
N
N#ifdef CONFIG_YAFFSFS_PROVIDE_VALUES
N
N#ifndef O_RDONLY
N#define O_RDONLY        00
N#endif
N
N#ifndef O_WRONLY
N#define O_WRONLY	01
N#endif
N
N#ifndef O_RDWR
N#define O_RDWR		02
N#endif
N
N#ifndef O_CREAT		
N#define O_CREAT 	0100
N#endif
N
N#ifndef O_EXCL
N#define O_EXCL		0200
N#endif
N
N#ifndef O_TRUNC
N#define O_TRUNC		01000
N#endif
N
N#ifndef O_APPEND
N#define O_APPEND	      02000
N#endif
N
N#ifndef SEEK_SET
S#define SEEK_SET	0
N#endif
N
N#ifndef SEEK_CUR
S#define SEEK_CUR	1
N#endif
N
N#ifndef SEEK_END
S#define SEEK_END	2
N#endif
N
N#ifndef EBUSY
N#define EBUSY	16
N#endif
N
N#ifndef ENODEV
N#define ENODEV	19
N#endif
N
N#ifndef EINVAL
N#define EINVAL	22
N#endif
N
N#ifndef EBADF
N#define EBADF	9
N#endif
N
N#ifndef EACCES
N#define EACCES	13
N#endif
N
N#ifndef EXDEV	
N#define EXDEV	18
N#endif
N
N#ifndef ENOENT
N#define ENOENT	2
N#endif
N
N#ifndef ENOSPC
N#define ENOSPC	28
N#endif
N
N#ifndef ENOTEMPTY
N#define ENOTEMPTY 39
N#endif
N
N#ifndef ENOMEM
N#define ENOMEM 12
N#endif
N
N#ifndef EEXIST
N#define EEXIST 17
N#endif
N
N#ifndef ENOTDIR
N#define ENOTDIR 20
N#endif
N
N#ifndef EISDIR
N#define EISDIR 21
N#endif
N
N
N// Mode flags
N
N#ifndef S_IFMT
N#define S_IFMT		0170000
N#endif
N
N#ifndef S_IFLNK
N#define S_IFLNK		0120000
N#endif
N
N#ifndef S_IFDIR
N#define S_IFDIR		0040000
N#endif
N
N#ifndef S_IFREG
N#define S_IFREG		0100000
N#endif
N
N#ifndef S_IREAD 
N#define S_IREAD		0000400
N#endif
N
N#ifndef S_IWRITE
N#define	S_IWRITE	0000200
N#endif
N
N#ifndef S_IEXEC
N#define	S_IEXEC	0000100
N#endif
N
N#ifndef R_OK
N#define R_OK	4
N#define W_OK	2
N#define X_OK	1
N#define F_OK	0
N#endif
N
N#else
S#include <errno.h>
S#include <sys/stat.h>
S#include <fcntl.h>
N#endif
N
N
Nstruct yaffs_dirent{
N    long d_ino;                 /* inode number */
N    off_t d_off;                /* offset to this dirent */
N    unsigned short d_reclen;    /* length of this d_name */
N    YUCHAR  d_type;	/* type of this record */
X    unsigned char  d_type;	 
N    YCHAR d_name [NAME_MAX+1];   /* file name (null-terminated) */
X    char d_name [256+1];    
N    unsigned d_dont_use;	/* debug pointer, not for public consumption */
N};
N
Ntypedef struct yaffs_dirent yaffs_dirent;
N
N
Ntypedef struct __opaque yaffs_DIR;
N
N
N
Nstruct yaffs_stat{
N    int		      st_dev;      /* device */
N    int           st_ino;      /* inode */
N    unsigned      st_mode;     /* protection */
N    int           st_nlink;    /* number of hard links */
N    int           st_uid;      /* user ID of owner */
N    int           st_gid;      /* group ID of owner */
N    unsigned      st_rdev;     /* device type (if inode device) */
N    off_t         st_size;     /* total size, in bytes */
N    unsigned long st_blksize;  /* blocksize for filesystem I/O */
N    unsigned long st_blocks;   /* number of blocks allocated */
N#ifdef CONFIG_YAFFS_WINCE
S	/* Special 64-bit times for WinCE */
S	unsigned long yst_wince_atime[2];
S	unsigned long yst_wince_mtime[2];
S	unsigned long yst_wince_ctime[2];
N#else
N	unsigned long yst_atime;    /* time of last access */
N    unsigned long yst_mtime;    /* time of last modification */
N    unsigned long yst_ctime;    /* time of last change */
N#endif
N};
N
Nint yaffs_open(const YCHAR *path, int oflag, int mode) ;
Xint yaffs_open(const char *path, int oflag, int mode) ;
Nint yaffs_close(int fd) ;
Nint yaffs_flush(int fd) ;
N
Nint yaffs_access(const YCHAR *path, int amode);
Xint yaffs_access(const char *path, int amode);
N
Nint yaffs_dup(int fd);
N
Nint yaffs_read(int fd, void *buf, unsigned int nbyte) ;
Nint yaffs_write(int fd, const void *buf, unsigned int nbyte) ;
N
Nint yaffs_pread(int fd, void *buf, unsigned int nbyte, unsigned int offset);
Nint yaffs_pwrite(int fd, const void *buf, unsigned int nbyte, unsigned int offset);
N
Noff_t yaffs_lseek(int fd, off_t offset, int whence) ;
N
Nint yaffs_truncate(const YCHAR *path, off_t newSize);
Xint yaffs_truncate(const char *path, off_t newSize);
Nint yaffs_ftruncate(int fd, off_t newSize);
N
Nint yaffs_unlink(const YCHAR *path) ;
Xint yaffs_unlink(const char *path) ;
Nint yaffs_rename(const YCHAR *oldPath, const YCHAR *newPath) ;
Xint yaffs_rename(const char *oldPath, const char *newPath) ;
N
Nint yaffs_stat(const YCHAR *path, struct yaffs_stat *buf) ;
Xint yaffs_stat(const char *path, struct yaffs_stat *buf) ;
Nint yaffs_lstat(const YCHAR *path, struct yaffs_stat *buf) ;
Xint yaffs_lstat(const char *path, struct yaffs_stat *buf) ;
Nint yaffs_fstat(int fd, struct yaffs_stat *buf) ;
N
N#ifdef CONFIG_YAFFS_WINCE
S
Sint yaffs_set_wince_times(int fd, const unsigned *wctime, const unsigned *watime, const unsigned *wmtime);
Sint yaffs_get_wince_times(int fd, unsigned *wctime, unsigned *watime, unsigned *wmtime);
S
N#endif
N
Nint yaffs_chmod(const YCHAR *path, mode_t mode); 
Xint yaffs_chmod(const char *path, mode_t mode); 
Nint yaffs_fchmod(int fd, mode_t mode); 
N
Nint yaffs_mkdir(const YCHAR *path, mode_t mode) ;
Xint yaffs_mkdir(const char *path, mode_t mode) ;
Nint yaffs_rmdir(const YCHAR *path) ;
Xint yaffs_rmdir(const char *path) ;
N
Nyaffs_DIR *yaffs_opendir(const YCHAR *dirname) ;
Xyaffs_DIR *yaffs_opendir(const char *dirname) ;
Nstruct yaffs_dirent *yaffs_readdir(yaffs_DIR *dirp) ;
Nvoid yaffs_rewinddir(yaffs_DIR *dirp) ;
Nint yaffs_closedir(yaffs_DIR *dirp) ;
N
Nint yaffs_mount(const YCHAR *path) ;
Xint yaffs_mount(const char *path) ;
Nint yaffs_unmount(const YCHAR *path) ;
Xint yaffs_unmount(const char *path) ;
N
Nint yaffs_sync(const YCHAR *path) ;
Xint yaffs_sync(const char *path) ;
N
Nint yaffs_symlink(const YCHAR *oldpath, const YCHAR *newpath); 
Xint yaffs_symlink(const char *oldpath, const char *newpath); 
Nint yaffs_readlink(const YCHAR *path, YCHAR *buf, int bufsiz); 
Xint yaffs_readlink(const char *path, char *buf, int bufsiz); 
N
Nint yaffs_link(const YCHAR *oldpath, const YCHAR *newpath); 
Xint yaffs_link(const char *oldpath, const char *newpath); 
Nint yaffs_mknod(const YCHAR *pathname, mode_t mode, dev_t dev);
Xint yaffs_mknod(const char *pathname, mode_t mode, dev_t dev);
N
Nloff_t yaffs_freespace(const YCHAR *path);
Xloff_t yaffs_freespace(const char *path);
Nloff_t yaffs_totalspace(const YCHAR *path);
Xloff_t yaffs_totalspace(const char *path);
N
Nint yaffs_inodecount(const YCHAR *path);
Xint yaffs_inodecount(const char *path);
N
N
Nvoid yaffs_initialise(yaffsfs_DeviceConfiguration *configList);
N
Nint yaffs_StartUp(void);
N
N#endif
N
N
L 20 "..\fs\yaffs_guts.c" 2
N#include "yaffs_guts.h"
L 1 "..\fs\yaffs_guts.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_GUTS_H__
N#define __YAFFS_GUTS_H__
N
N#include "devextras.h"
N#include "yportenv.h"
N
N#define YAFFS_OK	1
N#define YAFFS_FAIL  0
N#define CONFIG_YAFFS_YAFFS2  1
N/* Give us a  Y=0x59, 
N * Give us an A=0x41, 
N * Give us an FF=0xFF 
N * Give us an S=0x53
N * And what have we got... 
N */
N#define YAFFS_MAGIC			0x5941FF53
N
N#define YAFFS_NTNODES_LEVEL0	  	16
N#define YAFFS_TNODES_LEVEL0_BITS	4
N#define YAFFS_TNODES_LEVEL0_MASK	0xf
N
N#define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
N#define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
N#define YAFFS_TNODES_INTERNAL_MASK	0x7
N#define YAFFS_TNODES_MAX_LEVEL		6
N
N#ifndef CONFIG_YAFFS_NO_YAFFS1
N#define YAFFS_BYTES_PER_SPARE		16
N#define YAFFS_BYTES_PER_CHUNK		512
N#define YAFFS_CHUNK_SIZE_SHIFT		9
N#define YAFFS_CHUNKS_PER_BLOCK		32
N#define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
N#endif
N
N#define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
N#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
N
N#define YAFFS_MAX_CHUNK_ID		0x000FFFFF
N
N#define YAFFS_UNUSED_OBJECT_ID		0x0003FFFF
N
N#define YAFFS_ALLOCATION_NOBJECTS	100
N#define YAFFS_ALLOCATION_NTNODES	100
N#define YAFFS_ALLOCATION_NLINKS		100
N
N#define YAFFS_NOBJECT_BUCKETS		256
N
N
N#define YAFFS_OBJECT_SPACE		0x40000
N
N#define YAFFS_CHECKPOINT_VERSION 	3
N
N#ifdef CONFIG_YAFFS_UNICODE
S#define YAFFS_MAX_NAME_LENGTH		127
S#define YAFFS_MAX_ALIAS_LENGTH		79
N#else
N#define YAFFS_MAX_NAME_LENGTH		255
N#define YAFFS_MAX_ALIAS_LENGTH		159
N#endif
N
N#define YAFFS_SHORT_NAME_LENGTH		15
N
N/* Some special object ids for pseudo objects */
N#define YAFFS_OBJECTID_ROOT		1
N#define YAFFS_OBJECTID_LOSTNFOUND	2
N#define YAFFS_OBJECTID_UNLINKED		3
N#define YAFFS_OBJECTID_DELETED		4
N
N/* Sseudo object ids for checkpointing */
N#define YAFFS_OBJECTID_SB_HEADER	0x10
N#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
N#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
N
N/* */
N
N#define YAFFS_MAX_SHORT_OP_CACHES	20
N
N#define YAFFS_N_TEMP_BUFFERS		6
N
N/* We limit the number attempts at sucessfully saving a chunk of data.
N * Small-page devices have 32 pages per block; large-page devices have 64.
N * Default to something in the order of 5 to 10 blocks worth of chunks.
N */
N#define YAFFS_WR_ATTEMPTS		(5*64)
N
N/* Sequence numbers are used in YAFFS2 to determine block allocation order.
N * The range is limited slightly to help distinguish bad numbers from good.
N * This also allows us to perhaps in the future use special numbers for
N * special purposes.
N * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years, 
N * and is a larger number than the lifetime of a 2GB device.
N */
N#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
N#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
N
N/* Special sequence number for bad block that failed to be marked bad */
N#define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
N
N/* ChunkCache is used for short read/write operations.*/
Ntypedef struct {
N	struct yaffs_ObjectStruct *object;
N	int chunkId;
N	int lastUse;
N	int dirty;
N	int nBytes;		/* Only valid if the cache is dirty */
N	int locked;		/* Can't push out or flush while locked. */
N#ifdef CONFIG_YAFFS_YAFFS2
N	__u8 *data;
N#else
S	__u8 data[YAFFS_BYTES_PER_CHUNK];
N#endif
N} yaffs_ChunkCache;
N
N
N
N/* Tags structures in RAM
N * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
N * the structure size will get blown out.
N */
N
N#ifndef CONFIG_YAFFS_NO_YAFFS1
Ntypedef struct {
N        unsigned chunkId:20;
N        unsigned serialNumber:2;
N        unsigned byteCountLSB:10;
N        unsigned objectId:18;
N        unsigned ecc:12;
N        unsigned byteCountMSB:2;
N
N} yaffs_Tags;
N
Ntypedef union {
N	yaffs_Tags asTags;
N	__u8 asBytes[8];
N} yaffs_TagsUnion;
N
N#endif
N
N/* Stuff used for extended tags in YAFFS2 */
N
Ntypedef enum {
N	YAFFS_ECC_RESULT_UNKNOWN,
N	YAFFS_ECC_RESULT_NO_ERROR,
N	YAFFS_ECC_RESULT_FIXED,
N	YAFFS_ECC_RESULT_UNFIXED
N} yaffs_ECCResult;
N
Ntypedef enum {
N	YAFFS_OBJECT_TYPE_UNKNOWN,
N	YAFFS_OBJECT_TYPE_FILE,
N	YAFFS_OBJECT_TYPE_SYMLINK,
N	YAFFS_OBJECT_TYPE_DIRECTORY,
N	YAFFS_OBJECT_TYPE_HARDLINK,
N	YAFFS_OBJECT_TYPE_SPECIAL
N} yaffs_ObjectType;
N
N#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
N
Ntypedef struct {
N
N	unsigned validMarker0;
N	unsigned chunkUsed;	/*  Status of the chunk: used or unused */
N	unsigned objectId;	/* If 0 then this is not part of an object (unused) */
N	unsigned chunkId;	/* If 0 then this is a header, else a data chunk */
N	unsigned byteCount;	/* Only valid for data chunks */
N
N	/* The following stuff only has meaning when we read */
N	yaffs_ECCResult eccResult;
N	unsigned blockBad;	
N
N	/* YAFFS 1 stuff */
N	unsigned chunkDeleted;	/* The chunk is marked deleted */
N	unsigned serialNumber;	/* Yaffs1 2-bit serial number */
N
N	/* YAFFS2 stuff */
N	unsigned sequenceNumber;	/* The sequence number of this block */
N
N	/* Extra info if this is an object header (YAFFS2 only) */
N
N	unsigned extraHeaderInfoAvailable;	/* There is extra info available if this is not zero */
N	unsigned extraParentObjectId;	/* The parent object */
N	unsigned extraIsShrinkHeader;	/* Is it a shrink header? */
N	unsigned extraShadows;		/* Does this shadow another object? */
N
N	yaffs_ObjectType extraObjectType;	/* What object type? */
N
N	unsigned extraFileLength;		/* Length if it is a file */
N	unsigned extraEquivalentObjectId;	/* Equivalent object Id if it is a hard link */
N
N	unsigned validMarker1;
N
N} yaffs_ExtendedTags;
N
N/* Spare structure for YAFFS1 */
Ntypedef struct {
N	__u8 tagByte0;
N	__u8 tagByte1;
N	__u8 tagByte2;
N	__u8 tagByte3;
N	__u8 pageStatus;	/* set to 0 to delete the chunk */
N	__u8 blockStatus;
N	__u8 tagByte4;
N	__u8 tagByte5;
N	__u8 ecc1[3];
N	__u8 tagByte6;
N	__u8 tagByte7;
N	__u8 ecc2[3];
N} yaffs_Spare;
N
N/*Special structure for passing through to mtd */
Nstruct yaffs_NANDSpare {
N	yaffs_Spare spare;
N	int eccres1;
N	int eccres2;
N};
N
N/* Block data in RAM */
N
Ntypedef enum {
N	YAFFS_BLOCK_STATE_UNKNOWN = 0,
N
N	YAFFS_BLOCK_STATE_SCANNING,
N	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
N	/* The block might have something on it (ie it is allocating or full, perhaps empty)
N	 * but it needs to be scanned to determine its true state.
N	 * This state is only valid during yaffs_Scan.
N	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
N	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
N	 */
N
N	YAFFS_BLOCK_STATE_EMPTY,
N	/* This block is empty */
N
N	YAFFS_BLOCK_STATE_ALLOCATING,
N	/* This block is partially allocated. 
N	 * At least one page holds valid data.
N	 * This is the one currently being used for page
N	 * allocation. Should never be more than one of these
N	 */
N
N	YAFFS_BLOCK_STATE_FULL,	
N	/* All the pages in this block have been allocated.
N	 */
N
N	YAFFS_BLOCK_STATE_DIRTY,
N	/* All pages have been allocated and deleted. 
N	 * Erase me, reuse me.
N	 */
N
N	YAFFS_BLOCK_STATE_CHECKPOINT,	
N	/* This block is assigned to holding checkpoint data.
N	 */
N
N	YAFFS_BLOCK_STATE_COLLECTING,	
N	/* This block is being garbage collected */
N
N	YAFFS_BLOCK_STATE_DEAD	
N	/* This block has failed and is not in use */
N} yaffs_BlockState;
N
N#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
N
N
Ntypedef struct {
N
N	int softDeletions:10;	/* number of soft deleted pages */
N	int pagesInUse:10;	/* number of pages in use */
N	unsigned blockState:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
N	__u32 needsRetiring:1;	/* Data has failed on this block, need to get valid data off */
N                        	/* and retire the block. */
N	__u32 skipErasedCheck: 1; /* If this is set we can skip the erased check on this block */
N	__u32 gcPrioritise: 1; 	/* An ECC check or blank check has failed on this block. 
N				   It should be prioritised for GC */
N        __u32 chunkErrorStrikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */
N
N#ifdef CONFIG_YAFFS_YAFFS2
N	__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */
N	__u32 sequenceNumber;	 /* block sequence number for yaffs2 */
N#endif
N
N} yaffs_BlockInfo;
N
N/* -------------------------- Object structure -------------------------------*/
N/* This is the object structure as stored on NAND */
N
Ntypedef struct {
N	yaffs_ObjectType type;
N
N	/* Apply to everything  */
N	int parentObjectId;
N        __u16 sum__NoLongerUsed;        /* checksum of name. No longer used */
N        YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
X        char name[255 + 1];
N
N        /* The following apply to directories, files, symlinks - not hard links */
N        __u32 yst_mode;         /* protection */
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 notForWinCE[5];
N#else
N	__u32 yst_uid;
N	__u32 yst_gid;
N	__u32 yst_atime;
N	__u32 yst_mtime;
N	__u32 yst_ctime;
N#endif
N
N	/* File size  applies to files only */
N	int fileSize;
N
N	/* Equivalent object id applies to hard links only. */
N	int equivalentObjectId;
N
N	/* Alias is for symlinks only. */
N	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
X	char alias[159 + 1];
N
N	__u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 win_ctime[2];
S	__u32 win_atime[2];
S	__u32 win_mtime[2];
N#else
N	__u32 roomToGrow[6];
N
N#endif
N	__u32 inbandShadowsObject;
N	__u32 inbandIsShrink;
N
N	__u32 reservedSpace[2];
N	int shadowsObject;	/* This object header shadows the specified object if > 0 */
N
N	/* isShrink applies to object headers written when we shrink the file (ie resize) */
N	__u32 isShrink;
N
N} yaffs_ObjectHeader;
N
N/*--------------------------- Tnode -------------------------- */
N
Nunion yaffs_Tnode_union {
N#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
S	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];
N#else
N	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];
X	union yaffs_Tnode_union *internal[(16 / 2)];
N#endif
N/*	__u16 level0[YAFFS_NTNODES_LEVEL0]; */
N
N};
N
Ntypedef union yaffs_Tnode_union yaffs_Tnode;
N
Nstruct yaffs_TnodeList_struct {
N	struct yaffs_TnodeList_struct *next;
N	yaffs_Tnode *tnodes;
N};
N
Ntypedef struct yaffs_TnodeList_struct yaffs_TnodeList;
N
N/*------------------------  Object -----------------------------*/
N/* An object can be one of:
N * - a directory (no data, has children links
N * - a regular file (data.... not prunes :->).
N * - a symlink [symbolic link] (the alias).
N * - a hard link
N */
N
Ntypedef struct {
N	__u32 fileSize;
N	__u32 scannedFileSize;
N	__u32 shrinkSize;
N	int topLevel;
N	yaffs_Tnode *top;
N} yaffs_FileStructure;
N
Ntypedef struct {
N        struct ylist_head children;     /* list of child links */
N} yaffs_DirectoryStructure;
N
Ntypedef struct {
N	YCHAR *alias;
X	char *alias;
N} yaffs_SymLinkStructure;
N
Ntypedef struct {
N	struct yaffs_ObjectStruct *equivalentObject;
N	__u32 equivalentObjectId;
N} yaffs_HardLinkStructure;
N
Ntypedef union {
N	yaffs_FileStructure fileVariant;
N	yaffs_DirectoryStructure directoryVariant;
N	yaffs_SymLinkStructure symLinkVariant;
N	yaffs_HardLinkStructure hardLinkVariant;
N} yaffs_ObjectVariant;
N
Nstruct yaffs_ObjectStruct {
N	__u8 deleted:1;		/* This should only apply to unlinked files. */
N	__u8 softDeleted:1;	/* it has also been soft deleted */
N	__u8 unlinked:1;	/* An unlinked file. The file should be in the unlinked directory.*/
N	__u8 fake:1;		/* A fake object has no presence on NAND. */
N	__u8 renameAllowed:1;	/* Some objects are not allowed to be renamed. */
N	__u8 unlinkAllowed:1;
N	__u8 dirty:1;		/* the object needs to be written to flash */
N	__u8 valid:1;		/* When the file system is being loaded up, this 
N				 * object might be created before the data
N				 * is available (ie. file data records appear before the header).
N				 */
N	__u8 lazyLoaded:1;	/* This object has been lazy loaded and is missing some detail */
N
N	__u8 deferedFree:1;	/* For Linux kernel. Object is removed from NAND, but is
N				 * still in the inode cache. Free of object is defered.
N				 * until the inode is released.
N                                 */
N        __u8 beingCreated:1;	/* This object is still being created so skip some checks. */
N
N	__u8 serial;		/* serial number of chunk in NAND. Cached here */
N	__u16 sum;		/* sum of the name to speed searching */
N
N        struct yaffs_DeviceStruct *myDev;       /* The device I'm on */
N
N        struct ylist_head hashLink;     /* list of objects in this hash bucket */
N
N        struct ylist_head hardLinks;    /* all the equivalent hard linked objects */
N
N        /* directory structure stuff */
N        /* also used for linking up the free list */
N        struct yaffs_ObjectStruct *parent; 
N        struct ylist_head siblings;
N
N	/* Where's my object header in NAND? */
N	int hdrChunk;
N
N	int nDataChunks;	/* Number of data chunks attached to the file. */
N
N	__u32 objectId;		/* the object id value */
N
N	__u32 yst_mode;
N
N#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
S	YCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];
N#endif
N
N#ifndef __KERNEL__
N	__u32 inUse;
N#endif
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 win_ctime[2];
S	__u32 win_mtime[2];
S	__u32 win_atime[2];
N#else
N	__u32 yst_uid;
N	__u32 yst_gid;
N	__u32 yst_atime;
N	__u32 yst_mtime;
N	__u32 yst_ctime;
N#endif
N
N	__u32 yst_rdev;
N
N#ifdef __KERNEL__
S	struct inode *myInode;
S
N#endif
N
N	yaffs_ObjectType variantType;
N
N	yaffs_ObjectVariant variant;
N
N};
N
Ntypedef struct yaffs_ObjectStruct yaffs_Object;
N
Nstruct yaffs_ObjectList_struct {
N	yaffs_Object *objects;
N	struct yaffs_ObjectList_struct *next;
N};
N
Ntypedef struct yaffs_ObjectList_struct yaffs_ObjectList;
N
Ntypedef struct {
N        struct ylist_head list;
N        int count;
N} yaffs_ObjectBucket;
N
N
N/* yaffs_CheckpointObject holds the definition of an object as dumped 
N * by checkpointing.
N */
N
Ntypedef struct {
N        int structType;
N	__u32 objectId;		
N	__u32 parentId;
N	int hdrChunk;
N	yaffs_ObjectType variantType:3;
N	__u8 deleted:1;		
N	__u8 softDeleted:1;	
N	__u8 unlinked:1;	
N	__u8 fake:1;		
N	__u8 renameAllowed:1;
N	__u8 unlinkAllowed:1;
N	__u8 serial;		
N	
N	int nDataChunks;	
N	__u32 fileSizeOrEquivalentObjectId;
N
N}yaffs_CheckpointObject;
N
N/*--------------------- Temporary buffers ----------------
N *
N * These are chunk-sized working buffers. Each device has a few
N */
N
Ntypedef struct {
N	__u8 *buffer;
N	int line;	/* track from whence this buffer was allocated */
N	int maxLine;
N} yaffs_TempBuffer;
N
N/*----------------- Device ---------------------------------*/
N
Nstruct yaffs_DeviceStruct {
N        struct ylist_head devList;
N        const char *name;
N
N        /* Entry parameters set up way early. Yaffs sets up the rest.*/
N        int nDataBytesPerChunk; /* Should be a power of 2 >= 512 */
N        int nChunksPerBlock;    /* does not need to be a power of 2 */
N        int spareBytesPerChunk;/* spare area size */
N        int startBlock;         /* Start block we're allowed to use */
N        int endBlock;           /* End block we're allowed to use */
N        int nReservedBlocks;    /* We want this tuneable so that we can reduce */
N				/* reserved blocks on NOR and RAM. */
N	
N	
N	/* Stuff used by the shared space checkpointing mechanism */
N	/* If this value is zero, then this mechanism is disabled */
N	
N//	int nCheckpointReservedBlocks; /* Blocks to reserve for checkpoint data */
N
N	
N
N
N	int nShortOpCaches;	/* If <= 0, then short op caching is disabled, else
N				 * the number of short op caches (don't use too many)
N				 */
N
N	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
N
N	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
N
N	void *genericDevice;	/* Pointer to device context
N				 * On an mtd this holds the mtd pointer.
N				 */
N        void *superBlock;
N        
N	/* NAND access functions (Must be set before calling YAFFS)*/
N
N	int (*writeChunkToNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, const __u8 * data,const yaffs_Spare * spare);
N 	int (*readChunkFromNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, __u8 * data,yaffs_Spare * spare);
N        int (*eraseBlockInNAND) (struct yaffs_DeviceStruct * dev, int blockInNAND);                               
N        int (*initialiseNAND) (struct yaffs_DeviceStruct * dev);
N        int (*deinitialiseNAND) (struct yaffs_DeviceStruct * dev);
N        int (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct * dev, int chunkInNAND, const __u8 * data,const yaffs_ExtendedTags * tags);					 
N        int (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, __u8 * data,yaffs_ExtendedTags * tags);
N        int (*markNANDBlockBad) (struct yaffs_DeviceStruct * dev, int blockNo);
N        int (*queryNANDBlock) (struct yaffs_DeviceStruct * dev, int blockNo,yaffs_BlockState * state, __u32 *sequenceNumber);
N        //////////////////////////////////////////////
N        int isYaffs2;
N	
N	/* The removeObjectCallback function must be supplied by OS flavours that 
N	 * need it. The Linux kernel does not use this, but yaffs direct does use
N	 * it to implement the faster readdir
N	 */
N	void (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);
N	
N	/* Callback to mark the superblock dirsty */
N	void (*markSuperBlockDirty)(void * superblock);
N	
N	int wideTnodesDisabled; /* Set to disable wide tnodes */
N	
N	YCHAR *pathDividers;	/* String of legal path dividers */
X	char *pathDividers;	 
N	
N
N	/* End of stuff that must be set before initialisation. */
N	
N	/* Checkpoint control. Can be set before or after initialisation */
N	__u8 skipCheckpointRead;
N	__u8 skipCheckpointWrite;
N
N	/* Runtime parameters. Set up by YAFFS. */
N
N	__u16 chunkGroupBits;	/* 0 for devices <= 32MB. else log2(nchunks) - 16 */
N	__u16 chunkGroupSize;	/* == 2^^chunkGroupBits */
N	
N	/* Stuff to support wide tnodes */
N	__u32 tnodeWidth;
N	__u32 tnodeMask;
N	
N	/* Stuff for figuring out file offset to chunk conversions */
N	__u32 chunkShift; /* Shift value */
N	__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */
N	__u32 chunkMask;  /* Mask to use for power-of-2 case */
N
N	/* Stuff to handle inband tags */
N	int inbandTags;
N	__u32 totalBytesPerChunk;
N
N#ifdef __KERNEL__
S
S	struct semaphore sem;	/* Semaphore for waiting on erasure.*/
S	struct semaphore grossLock;	/* Gross locking semaphore */
S	__u8 *spareBuffer;	/* For mtdif2 use. Don't know the size of the buffer 
S				 * at compile time so we have to allocate it.
S				 */
S	void (*putSuperFunc) (struct super_block * sb);
N#endif
N
N	int isMounted;
N	
N	int isCheckpointed;
N
N
N	/* Stuff to support block offsetting to support start block zero */
N	int internalStartBlock;
N	int internalEndBlock;
N	int blockOffset;
N	int chunkOffset;
N	
N
N	/* Runtime checkpointing stuff */
N	int checkpointPageSequence;   /* running sequence number of checkpoint pages */
N	int checkpointByteCount;
N	int checkpointByteOffset;
N	__u8 *checkpointBuffer;
N	int checkpointOpenForWrite;
N	int blocksInCheckpoint;
N	int checkpointCurrentChunk;
N	int checkpointCurrentBlock;
N	int checkpointNextBlock;
N	int *checkpointBlockList;
N	int checkpointMaxBlocks;
N	__u32 checkpointSum;
N	__u32 checkpointXor;
N	
N	int nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */
N	
N	/* Block Info */
N	yaffs_BlockInfo *blockInfo;
N	__u8 *chunkBits;	/* bitmap of chunks in use */
N	unsigned blockInfoAlt:1;	/* was allocated using alternative strategy */
N	unsigned chunkBitsAlt:1;	/* was allocated using alternative strategy */
N	int chunkBitmapStride;	/* Number of bytes of chunkBits per block. 
N				 * Must be consistent with nChunksPerBlock.
N				 */
N
N	int nErasedBlocks;
N	int allocationBlock;	/* Current block being allocated off */
N	__u32 allocationPage;
N	int allocationBlockFinder;	/* Used to search for next allocation block */
N
N	/* Runtime state */
N	int nTnodesCreated;
N	yaffs_Tnode *freeTnodes;
N	int nFreeTnodes;
N	yaffs_TnodeList *allocatedTnodeList;
N
N	int isDoingGC;
N	int gcBlock;
N	int gcChunk;
N
N	int nObjectsCreated;
N	yaffs_Object *freeObjects;
N	int nFreeObjects;
N	
N	int nHardLinks;
N
N	yaffs_ObjectList *allocatedObjectList;
N
N	yaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];
X	yaffs_ObjectBucket objectBucket[256];
N
N	int nFreeChunks;
N
N	int currentDirtyChecker;	/* Used to find current dirtiest block */
N
N	__u32 *gcCleanupList;	/* objects to delete at the end of a GC. */
N	int nonAggressiveSkip;	/* GC state/mode */
N
N	/* Statistcs */
N	int nPageWrites;
N	int nPageReads;
N	int nBlockErasures;
N	int nErasureFailures;
N	int nGCCopies;
N	int garbageCollections;
N	int passiveGarbageCollections;
N	int nRetriedWrites;
N	int nRetiredBlocks;
N	int eccFixed;
N	int eccUnfixed;
N	int tagsEccFixed;
N	int tagsEccUnfixed;
N	int nDeletions;
N	int nUnmarkedDeletions;
N	
N	int hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */
N
N	/* Special directories */
N	yaffs_Object *rootDir;
N	yaffs_Object *lostNFoundDir;
N
N	/* Buffer areas for storing data to recover from write failures TODO
N	 *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
N	 *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];
N	 */
N	
N	int bufferedBlock;	/* Which block is buffered here? */
N	int doingBufferedBlockRewrite;
N
N	yaffs_ChunkCache *srCache;
N	int srLastUse;
N
N	int cacheHits;
N
N	/* Stuff for background deletion and unlinked files.*/
N	yaffs_Object *unlinkedDir;	/* Directory where unlinked and deleted files live. */
N	yaffs_Object *deletedDir;	/* Directory where deleted objects are sent to disappear. */
N	yaffs_Object *unlinkedDeletion;	/* Current file being background deleted.*/
N	int nDeletedFiles;		/* Count of files awaiting deletion;*/
N	int nUnlinkedFiles;		/* Count of unlinked files. */
N	int nBackgroundDeletions;	/* Count of background deletions. */
N
N	
N	/* Temporary buffer management */
N	yaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];
X	yaffs_TempBuffer tempBuffer[6];
N	int maxTemp;
N	int tempInUse;
N	int unmanagedTempAllocations;
N	int unmanagedTempDeallocations;
N
N	/* yaffs2 runtime stuff */
N	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
N	unsigned oldestDirtySequence;
N
N};
N
Ntypedef struct yaffs_DeviceStruct yaffs_Device;
N
N/* The static layout of block usage etc is stored in the super block header */
Ntypedef struct {
N        int StructType;
N        int version;
N	int checkpointStartBlock;
N	int checkpointEndBlock;
N	int startBlock;
N	int endBlock;
N	int rfu[100];
N} yaffs_SuperBlockHeader;
N	
N/* The CheckpointDevice structure holds the device information that changes at runtime and
N * must be preserved over unmount/mount cycles.
N */
Ntypedef struct {
N        int structType;
N	int nErasedBlocks;
N	int allocationBlock;	/* Current block being allocated off */
N	__u32 allocationPage;
N	int nFreeChunks;
N
N	int nDeletedFiles;		/* Count of files awaiting deletion;*/
N	int nUnlinkedFiles;		/* Count of unlinked files. */
N	int nBackgroundDeletions;	/* Count of background deletions. */
N
N	/* yaffs2 runtime stuff */
N	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
N	unsigned oldestDirtySequence;
N
N} yaffs_CheckpointDevice;
N
N
Ntypedef struct {
N    int structType;
N    __u32 magic;
N    __u32 version;
N    __u32 head;
N} yaffs_CheckpointValidity;
N
N
N/*----------------------- YAFFS Functions -----------------------*/
N
Nint yaffs_GutsInitialise(yaffs_Device * dev);
Nvoid yaffs_Deinitialise(yaffs_Device * dev);
N
Nint yaffs_GetNumberOfFreeChunks(yaffs_Device * dev);
N
Nint yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,
Xint yaffs_RenameObject(yaffs_Object * oldDir, const char * oldName,
N		       yaffs_Object * newDir, const YCHAR * newName);
X		       yaffs_Object * newDir, const char * newName);
N
Nint yaffs_Unlink(yaffs_Object * dir, const YCHAR * name);
Xint yaffs_Unlink(yaffs_Object * dir, const char * name);
Nint yaffs_DeleteFile(yaffs_Object * obj);
N
Nint yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize);
Xint yaffs_GetObjectName(yaffs_Object * obj, char * name, int buffSize);
Nint yaffs_GetObjectFileLength(yaffs_Object * obj);
Nint yaffs_GetObjectInode(yaffs_Object * obj);
Nunsigned yaffs_GetObjectType(yaffs_Object * obj);
Nint yaffs_GetObjectLinkCount(yaffs_Object * obj);
N
Nint yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr);
Nint yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr);
N
N/* File operations */
Nint yaffs_ReadDataFromFile(yaffs_Object * obj, __u8 * buffer, loff_t offset,
N                           int nBytes);
Nint yaffs_WriteDataToFile(yaffs_Object * obj, const __u8 * buffer, loff_t offset,
N                          int nBytes, int writeThrough);
Nint yaffs_ResizeFile(yaffs_Object * obj, loff_t newSize);
N
Nyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const char * name,
N                              __u32 mode, __u32 uid, __u32 gid);
Nint yaffs_FlushFile(yaffs_Object * obj, int updateTime);
N
N/* Flushing and checkpointing */
Nvoid yaffs_FlushEntireDeviceCache(yaffs_Device *dev);
N
Nint yaffs_CheckpointSave(yaffs_Device *dev);
Nint yaffs_CheckpointRestore(yaffs_Device *dev);
N
N/* Directory operations */
Nyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const char * name,
N				   __u32 mode, __u32 uid, __u32 gid);
Nyaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const YCHAR * name);
Xyaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const char * name);
Nint yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,
N				   int (*fn) (yaffs_Object *));
N
Nyaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number);
N
N/* Link operations */
Nyaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_Link(yaffs_Object * parent, const char * name,
N			 yaffs_Object * equivalentObject);
N
Nyaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj);
N
N/* Symlink operations */
Nyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid,
N				 const YCHAR * alias);
X				 const char * alias);
NYCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj);
Xchar *yaffs_GetSymlinkAlias(yaffs_Object * obj);
N
N/* Special inodes (fifos, sockets and devices) */
Nyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev);
N
N/* Special directories */
Nyaffs_Object *yaffs_Root(yaffs_Device * dev);
Nyaffs_Object *yaffs_LostNFound(yaffs_Device * dev);
N
N#ifdef CONFIG_YAFFS_WINCE
S/* CONFIG_YAFFS_WINCE special stuff */
Svoid yfsd_WinFileTimeNow(__u32 target[2]);
N#endif
N
N#ifdef __KERNEL__
S
Svoid yaffs_HandleDeferedFree(yaffs_Object * obj);
N#endif
N
N/* Debug dump  */
Nint yaffs_DumpObject(yaffs_Object * obj);
N
Nvoid yaffs_GutsTest(yaffs_Device * dev);
N
N/* A few useful functions */
Nvoid yaffs_InitialiseTags(yaffs_ExtendedTags * tags);
Nvoid yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn);
Nint yaffs_CheckFF(__u8 * buffer, int nBytes);
Nvoid yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);
N
N__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo);
Nvoid yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer, int lineNo);
N
N#endif
L 21 "..\fs\yaffs_guts.c" 2
N#include "yaffs_tagsvalidity.h"
L 1 "..\fs\yaffs_tagsvalidity.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N
N#ifndef __YAFFS_TAGS_VALIDITY_H__
N#define __YAFFS_TAGS_VALIDITY_H__
N
N#include "yaffs_guts.h"
N
Nvoid yaffs_InitialiseTags(yaffs_ExtendedTags * tags);
Nint yaffs_ValidateTags(yaffs_ExtendedTags * tags);
N#endif
L 22 "..\fs\yaffs_guts.c" 2
N#include "yaffs_getblockinfo.h"
L 1 "..\fs\yaffs_getblockinfo.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_GETBLOCKINFO_H__
N#define __YAFFS_GETBLOCKINFO_H__
N
N#include "yaffs_guts.h"
N
N/* Function to manipulate block info */
Nstatic Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
Xstatic __inline yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
N{
N	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
N		T(YAFFS_TRACE_ERROR,
N		  (TSTR
N		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
N		   blk));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	return &dev->blockInfo[blk - dev->internalStartBlock];
N}
N
N#endif
L 23 "..\fs\yaffs_guts.c" 2
N
N#include "yaffs_tagscompat.h"
L 1 "..\fs\yaffs_tagscompat.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_TAGSCOMPAT_H__
N#define __YAFFS_TAGSCOMPAT_H__
N
N#include "yaffs_guts.h"
Nint yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,
N						    int chunkInNAND,
N						    const __u8 * data,
N						    const yaffs_ExtendedTags *
N						    tags);
Nint yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,
N						     int chunkInNAND,
N						     __u8 * data,
N						     yaffs_ExtendedTags *
N						     tags);
Nint yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
N					    int blockNo);
Nint yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
N					  int blockNo, 
N					  yaffs_BlockState *state,
N					  __u32 *sequenceNumber);
N
Nvoid yaffs_CalcTagsECC(yaffs_Tags * tags);
Nint yaffs_CheckECCOnTags(yaffs_Tags * tags);
Nint yaffs_CountBits(__u8 byte);
N
N#endif
L 25 "..\fs\yaffs_guts.c" 2
N#ifndef  CONFIG_YAFFS_USE_OWN_SORT
N#include "yaffs_qsort.h"
L 1 "..\fs\yaffs_qsort.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N
N#ifndef __YAFFS_QSORT_H__
N#define __YAFFS_QSORT_H__
N
Nextern void yaffs_qsort (void *const base, size_t total_elems, size_t size,
N                   int (*cmp)(const void *, const void *));
N
N#endif
L 27 "..\fs\yaffs_guts.c" 2
N#endif
N//#include "yaffs_nand.h"
N
N#include "yaffs_checkptrw.h"
L 1 "..\fs\yaffs_checkptrw.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_CHECKPTRW_H__
N#define __YAFFS_CHECKPTRW_H__
N
N#include "yaffs_guts.h"
N
Nint yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting);
N
Nint yaffs_CheckpointWrite(yaffs_Device *dev,const void *data, int nBytes);
N
Nint yaffs_CheckpointRead(yaffs_Device *dev,void *data, int nBytes);
N
Nint yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum);
N
Nint yaffs_CheckpointClose(yaffs_Device *dev);
N
Nint yaffs_CheckpointInvalidateStream(yaffs_Device *dev);
N
N
N#endif
N
L 31 "..\fs\yaffs_guts.c" 2
N
N//#include "yaffs_nand.h"
N#include "yaffs_packedtags2.h"
L 1 "..\fs\yaffs_packedtags2.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/* This is used to pack YAFFS2 tags, not YAFFS1tags. */
N
N#ifndef __YAFFS_PACKEDTAGS2_H__
N#define __YAFFS_PACKEDTAGS2_H__
N
N#include "yaffs_guts.h"
N#include "yaffs_ecc.h"
L 1 "..\fs\yaffs_ecc.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N /*
N  * This code implements the ECC algorithm used in SmartMedia.
N  *
N  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
N  * The two unused bit are set to 1.
N  * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
N  * blocks are used on a 512-byte NAND page.
N  *
N  */
N
N#ifndef __YAFFS_ECC_H__
N#define __YAFFS_ECC_H__
N
Ntypedef struct {
N	unsigned char colParity;
N	unsigned lineParity;
N	unsigned lineParityPrime;
N} yaffs_ECCOther;
N
Nvoid yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc);
Nint yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
N		     const unsigned char *test_ecc);
N
Nvoid yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
N			     yaffs_ECCOther * ecc);
Nint yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
N			  yaffs_ECCOther * read_ecc,
N			  const yaffs_ECCOther * test_ecc);
N#endif
L 23 "..\fs\yaffs_packedtags2.h" 2
N
Ntypedef struct {
N	unsigned sequenceNumber;
N	unsigned objectId;
N	unsigned chunkId;
N	unsigned byteCount;
N} yaffs_PackedTags2TagsPart;
N
Ntypedef struct {
N	yaffs_PackedTags2TagsPart t;
N	yaffs_ECCOther ecc;
N} yaffs_PackedTags2;
N
N/* Full packed tags with ECC, used for oob tags */
Nvoid yaffs_PackTags2(yaffs_PackedTags2 * pt, const yaffs_ExtendedTags * t);
Nvoid yaffs_UnpackTags2(yaffs_ExtendedTags * t, yaffs_PackedTags2 * pt);
N
N/* Only the tags part (no ECC for use with inband tags */
Nvoid yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart * pt, const yaffs_ExtendedTags * t);
Nvoid yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags * t, yaffs_PackedTags2TagsPart * pt);
N#endif
L 34 "..\fs\yaffs_guts.c" 2
N
N
N#define YAFFS_PASSIVE_GC_CHUNKS 2
N
N#include "yaffs_ecc.h"
N#include "debug_frmwrk.h"
L 1 "..\Drivers\debug_frmwrk.h" 1
N/***********************************************************************//**
N * @file		debug_frmwrk.h
N * @brief		Contains some utilities that used for debugging through UART
N * @version		1.0
N * @date		18. September. 2010
N * @author		NXP MCU SW Application Team
N *----------------------------------------------------------------------------
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **********************************************************************/
N
N#ifndef DEBUG_FRMWRK_H_
N#define DEBUG_FRMWRK_H_
N
N#include "lpc177x_8x_uart.h"
L 1 "..\Drivers\lpc177x_8x_uart.h" 1
N/***********************************************************************//**
N * @file		lpc177x_8x_uart.h
N * @brief		Contains all macro definitions and function prototypes
N * 				support for UART firmware library on LPC177x_8x
N * @version		1.0
N * @date		18. September. 2010
N * @author		NXP MCU SW Application Team
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N/* Peripheral group ----------------------------------------------------------- */
N#ifndef __LPC178X_UART_H
N#define __LPC178X_UART_H
N
N/* Includes ------------------------------------------------------------------- */
N#include "LPC177x_8x.h"
L 1 "..\Startup\LPC177x_8x.h" 1
N/***********************************************************************
N * $Id: LPC177x_8x.h 6698 2011-03-03 21:20:50Z nxp21346 $
N *
N * Project: LPC177x_8x CMSIS Package
N *
N * Description: Cortex-M3 Core Peripheral Access Layer Header File for
N *              NXP LPC177x_8x Series.
N *
N * Copyright(C) 2011, NXP Semiconductor
N * All rights reserved.
N *
N ***********************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **********************************************************************/
N
N
N#ifndef __LPC177x_8x_H__
N#define __LPC177x_8x_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC177x_8x Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  Reserved0_IRQn                = 13,       /*!< Reserved                                         */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  MCI_IRQn                      = 29,       /*!< SD/MMC card I/F Interrupt                        */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /*!< USB Activity interrupt                           */
N  CANActivity_IRQn              = 34,       /*!< CAN Activity interrupt                           */
N  UART4_IRQn                    = 35,       /*!< UART4 Interrupt                                  */
N  SSP2_IRQn                     = 36,       /*!< SSP2 Interrupt                                   */
N  LCD_IRQn                      = 37,       /*!< LCD Interrupt                                    */
N  GPIO_IRQn                     = 38,       /*!< GPIO Interrupt                                   */
N  PWM0_IRQn                     = 39,       /*!< PWM0 Interrupt                                   */
N  EEPROM_IRQn                   = 40,       /*!< EEPROM Interrupt                           */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
L 1 "..\CM3_lib\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N/** @addtogroup CMSIS
N * @{
N */
N
N/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - Error 10: \n
N *     register uint32_t __regBasePri         __asm("basepri"); \n
N *     Error 10: Expecting ';'
N * .
N *   - Error 530: \n
N *     return(__regBasePri); \n
N *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
N * .
N *   - Error 550: \n
N *     __regBasePri = (basePri & 0x1ff); \n
N *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
N * .
N *   - Error 754: \n
N *     uint32_t RESERVED0[24]; \n
N *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced
N * .
N *   - Error 750: \n
N *     #define __CM3_CORE_H__ \n
N *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced
N * .
N *   - Error 528: \n
N *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced
N * .
N *   - Error 751: \n
N *     } InterruptType_Type; \n
N *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N/** @addtogroup CMSIS_CM3_core_definitions CMSIS CM3 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 95 "..\CM3_lib\core_cm3.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
N/** @brief  Nested Vectored Interrupt Controller (NVIC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM3_NVIC */
N
N
N/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
N/** @brief  System Control Block (SCB) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM3_SCB */
N
N
N/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
N  memory mapped structure for SysTick
N  @{
N */
N/** @brief  System Tick Timer (SysTick) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RELOAD;                       /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t RELOAD;                        
N  __IO uint32_t CURR;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t CURR;                           
N  __IO uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM3_SysTick */
N
N
N/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM
N  memory mapped structure for Instrumentation Trace Macrocell (ITM)
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                          
N  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                          
N  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                          
N  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                          
N  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                          
N  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                          
N  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                          
N  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                          
N  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                          
N  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                          
N  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                          
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N/*@}*/ /* end of group CMSIS_CM3_ITM */
N
N
N/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type
N  memory mapped structure for Interrupt Type
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */
N#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */
N#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */
N
N#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
N#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */
N
N#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */
N#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */
N/*@}*/ /* end of group CMSIS_CM3_InterruptType */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU
N  memory mapped structure for Memory Protection Unit (MPU)
N  @{
N */
N/** @brief   Memory Protection Unit (MPU) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */
N#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */
N#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */
N#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */
N#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */
N#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */
N#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@}*/ /* end of group CMSIS_CM3_MPU */
N#endif
N
N
N/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
N/** @brief   Core Debug register structure definition */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM3_CoreDebug */
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5040049 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S *
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @return BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  basePri  BasePriority
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @return FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  faultMask  faultMask value
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N *
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit values)
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask  faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S*
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit value
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N
N/* ##########################   NVIC functions  #################################### */
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  PriorityGroup is priority grouping field
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFul << 16) | (7ul << 8));              
N  reg_value  =  (reg_value                       |
N                (0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                (0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR =  reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @return priority grouping field
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) >> 8);    
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N *
N * @param  IRQn   The positive number of the external interrupt to disable
N *
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N *
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending,
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for read active bit
N * @return         1 = interrupt active, 0 = interrupt not active
N *
N * Read the active register in NVIC and returns 1 if its status is active,
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  PriorityGroup    The used priority group
N * @param  PreemptPriority  The preemptive priority value (starting from 0)
N * @param  SubPriority      The sub priority value (starting from 0)
N * @return                  The encoded priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  Priority           The priority for the interrupt
N * @param  PriorityGroup      The used priority group
N * @param  pPreemptPriority   The preemptive priority value (starting from 0)
N * @param  pSubPriority       The sub priority value (starting from 0)
N *
N * Decode an interrupt priority value with the given priority group to
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N
N  SysTick->RELOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->RELOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);   
N  SysTick->CURR   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CURR   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1ul << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1ul << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N
N/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface
N  Core Debug Interface containing:
N  - Core Debug Receive / Transmit Functions
N  - Core Debug Defines
N  - Core Debug Variables
N*/
N/*@{*/
N
Nextern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */
N#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param  ch   character to output
N * @return      character to output
N *
N * The function outputs a character via the ITM channel 0.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1ul << 24))  &&       
N      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X      (((ITM_Type *) (0xE0000000))->TCR & (1ul << 0))                  &&       
N      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000))->TER & (1ul << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/**
N * @brief  Inputs a character via variable ITM_RxBuffer
N *
N * @return      received character, -1 = no character received
N *
N * The function inputs a character via variable ITM_RxBuffer.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE int ITM_ReceiveChar (void) {
Xstatic __inline int ITM_ReceiveChar (void) {
N  int ch = -1;                               /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/**
N * @brief  Check if a character via variable ITM_RxBuffer is available
N *
N * @return      1 = character available, 0 = no character available
N *
N * The function checks  variable ITM_RxBuffer whether a character is available or not.
N * The function returns '1' if a character is available and '0' if no character is available.
N */
Nstatic __INLINE int ITM_CheckChar (void) {
Xstatic __inline int ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_definitions */
N
N#endif /* __CM3_CORE_H__ */
N
N /**
N  * @}
N  */
N
N/*lint -restore */
L 105 "..\Startup\LPC177x_8x.h" 2
N//#include "system_LPC177x_8x.h"                 /* System Header                                      */
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;                   /*!< Offset: 0x000 (R/W)  Flash Accelerator Configuration Register */
X  volatile uint32_t FLASHCFG;                    
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                    /*!< Offset: 0x080 (R/W)  PLL0 Control Register */
X  volatile uint32_t PLL0CON;                     
N  __IO uint32_t PLL0CFG;                    /*!< Offset: 0x084 (R/W)  PLL0 Configuration Register */
X  volatile uint32_t PLL0CFG;                     
N  __I  uint32_t PLL0STAT;                   /*!< Offset: 0x088 (R/ )  PLL0 Status Register */
X  volatile const  uint32_t PLL0STAT;                    
N  __O  uint32_t PLL0FEED;                   /*!< Offset: 0x08C ( /W)  PLL0 Feed Register */
X  volatile  uint32_t PLL0FEED;                    
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;                    /*!< Offset: 0x0A0 (R/W)  PLL1 Control Register */
X  volatile uint32_t PLL1CON;                     
N  __IO uint32_t PLL1CFG;                    /*!< Offset: 0x0A4 (R/W)  PLL1 Configuration Register */
X  volatile uint32_t PLL1CFG;                     
N  __I  uint32_t PLL1STAT;                   /*!< Offset: 0x0A8 (R/ )  PLL1 Status Register */
X  volatile const  uint32_t PLL1STAT;                    
N  __O  uint32_t PLL1FEED;                   /*!< Offset: 0x0AC ( /W)  PLL1 Feed Register */
X  volatile  uint32_t PLL1FEED;                    
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;                       /*!< Offset: 0x0C0 (R/W)  Power Control Register */
X  volatile uint32_t PCON;                        
N  __IO uint32_t PCONP;                      /*!< Offset: 0x0C4 (R/W)  Power Control for Peripherals Register */
X  volatile uint32_t PCONP;                       
N       uint32_t RESERVED3[14];
N  __IO uint32_t EMCCLKSEL;                  /*!< Offset: 0x100 (R/W)  External Memory Controller Clock Selection Register */
X  volatile uint32_t EMCCLKSEL;                   
N  __IO uint32_t CCLKSEL;                    /*!< Offset: 0x104 (R/W)  CPU Clock Selection Register */
X  volatile uint32_t CCLKSEL;                     
N  __IO uint32_t USBCLKSEL;                  /*!< Offset: 0x108 (R/W)  USB Clock Selection Register */
X  volatile uint32_t USBCLKSEL;                   
N  __IO uint32_t CLKSRCSEL;                  /*!< Offset: 0x10C (R/W)  Clock Source Select Register */
X  volatile uint32_t CLKSRCSEL;                   
N  __IO uint32_t	CANSLEEPCLR;                /*!< Offset: 0x110 (R/W)  CAN Sleep Clear Register */
X  volatile uint32_t	CANSLEEPCLR;                 
N  __IO uint32_t	CANWAKEFLAGS;               /*!< Offset: 0x114 (R/W)  CAN Wake-up Flags Register */
X  volatile uint32_t	CANWAKEFLAGS;                
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                     /*!< Offset: 0x140 (R/W)  External Interrupt Flag Register */
X  volatile uint32_t EXTINT;                      
N       uint32_t RESERVED5[1];
N  __IO uint32_t EXTMODE;                    /*!< Offset: 0x148 (R/W)  External Interrupt Mode Register */
X  volatile uint32_t EXTMODE;                     
N  __IO uint32_t EXTPOLAR;                   /*!< Offset: 0x14C (R/W)  External Interrupt Polarity Register */
X  volatile uint32_t EXTPOLAR;                    
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                       /*!< Offset: 0x180 (R/W)  Reset Source Identification Register */
X  volatile uint32_t RSID;                        
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                        /*!< Offset: 0x1A0 (R/W)  System Controls and Status Register */
X  volatile uint32_t SCS;                         
N  __IO uint32_t IRCTRIM;                    /*!< Offset: 0x1A4 (R/W) Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                     
N  __IO uint32_t PCLKSEL;                    /*!< Offset: 0x1A8 (R/W)  Peripheral Clock Selection Register */
X  volatile uint32_t PCLKSEL;                     
N       uint32_t RESERVED8[3];
N  __IO uint32_t LCD_CFG;                    /*!< Offset: 0x1B8 (R/W)  LCD Configuration and clocking control Register */
X  volatile uint32_t LCD_CFG;                     
N       uint32_t RESERVED9[1];
N  __IO uint32_t USBIntSt;                   /*!< Offset: 0x1C0 (R/W)  USB Interrupt Status Register */
X  volatile uint32_t USBIntSt;                    
N  __IO uint32_t DMAREQSEL;                  /*!< Offset: 0x1C4 (R/W)  DMA Request Select Register */
X  volatile uint32_t DMAREQSEL;                   
N  __IO uint32_t CLKOUTCFG;                  /*!< Offset: 0x1C8 (R/W)  Clock Output Configuration Register */
X  volatile uint32_t CLKOUTCFG;                   
N  __IO uint32_t RSTCON0;                    /*!< Offset: 0x1CC (R/W)  RESET Control0 Register */
X  volatile uint32_t RSTCON0;                     
N  __IO uint32_t RSTCON1;                    /*!< Offset: 0x1D0 (R/W)  RESET Control1 Register */
X  volatile uint32_t RSTCON1;                     
N       uint32_t RESERVED10[2];
N  __IO uint32_t EMCDLYCTL;                  /*!< Offset: 0x1DC (R/W) SDRAM programmable delays          */
X  volatile uint32_t EMCDLYCTL;                   
N  __IO uint32_t EMCCAL;                     /*!< Offset: 0x1E0 (R/W) Calibration of programmable delays */
X  volatile uint32_t EMCCAL;                      
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t P0_0;				/* 0x000 */
X  volatile uint32_t P0_0;				 
N  __IO uint32_t P0_1;
X  volatile uint32_t P0_1;
N  __IO uint32_t P0_2;
X  volatile uint32_t P0_2;
N  __IO uint32_t P0_3;
X  volatile uint32_t P0_3;
N  __IO uint32_t P0_4;
X  volatile uint32_t P0_4;
N  __IO uint32_t P0_5;
X  volatile uint32_t P0_5;
N  __IO uint32_t P0_6;
X  volatile uint32_t P0_6;
N  __IO uint32_t P0_7;
X  volatile uint32_t P0_7;
N
N  __IO uint32_t P0_8;				/* 0x020 */
X  volatile uint32_t P0_8;				 
N  __IO uint32_t P0_9;
X  volatile uint32_t P0_9;
N  __IO uint32_t P0_10;
X  volatile uint32_t P0_10;
N  __IO uint32_t P0_11;
X  volatile uint32_t P0_11;
N  __IO uint32_t P0_12;
X  volatile uint32_t P0_12;
N  __IO uint32_t P0_13;
X  volatile uint32_t P0_13;
N  __IO uint32_t P0_14;
X  volatile uint32_t P0_14;
N  __IO uint32_t P0_15;
X  volatile uint32_t P0_15;
N
N  __IO uint32_t P0_16;				/* 0x040 */
X  volatile uint32_t P0_16;				 
N  __IO uint32_t P0_17;
X  volatile uint32_t P0_17;
N  __IO uint32_t P0_18;
X  volatile uint32_t P0_18;
N  __IO uint32_t P0_19;
X  volatile uint32_t P0_19;
N  __IO uint32_t P0_20;
X  volatile uint32_t P0_20;
N  __IO uint32_t P0_21;
X  volatile uint32_t P0_21;
N  __IO uint32_t P0_22;
X  volatile uint32_t P0_22;
N  __IO uint32_t P0_23;
X  volatile uint32_t P0_23;
N
N  __IO uint32_t P0_24;				/* 0x060 */
X  volatile uint32_t P0_24;				 
N  __IO uint32_t P0_25;
X  volatile uint32_t P0_25;
N  __IO uint32_t P0_26;
X  volatile uint32_t P0_26;
N  __IO uint32_t P0_27;
X  volatile uint32_t P0_27;
N  __IO uint32_t P0_28;
X  volatile uint32_t P0_28;
N  __IO uint32_t P0_29;
X  volatile uint32_t P0_29;
N  __IO uint32_t P0_30;
X  volatile uint32_t P0_30;
N  __IO uint32_t P0_31;
X  volatile uint32_t P0_31;
N
N  __IO uint32_t P1_0;				/* 0x080 */
X  volatile uint32_t P1_0;				 
N  __IO uint32_t P1_1;
X  volatile uint32_t P1_1;
N  __IO uint32_t P1_2;
X  volatile uint32_t P1_2;
N  __IO uint32_t P1_3;
X  volatile uint32_t P1_3;
N  __IO uint32_t P1_4;
X  volatile uint32_t P1_4;
N  __IO uint32_t P1_5;
X  volatile uint32_t P1_5;
N  __IO uint32_t P1_6;
X  volatile uint32_t P1_6;
N  __IO uint32_t P1_7;
X  volatile uint32_t P1_7;
N
N  __IO uint32_t P1_8;				/* 0x0A0 */
X  volatile uint32_t P1_8;				 
N  __IO uint32_t P1_9;
X  volatile uint32_t P1_9;
N  __IO uint32_t P1_10;
X  volatile uint32_t P1_10;
N  __IO uint32_t P1_11;
X  volatile uint32_t P1_11;
N  __IO uint32_t P1_12;
X  volatile uint32_t P1_12;
N  __IO uint32_t P1_13;
X  volatile uint32_t P1_13;
N  __IO uint32_t P1_14;
X  volatile uint32_t P1_14;
N  __IO uint32_t P1_15;
X  volatile uint32_t P1_15;
N
N  __IO uint32_t P1_16;				/* 0x0C0 */
X  volatile uint32_t P1_16;				 
N  __IO uint32_t P1_17;
X  volatile uint32_t P1_17;
N  __IO uint32_t P1_18;
X  volatile uint32_t P1_18;
N  __IO uint32_t P1_19;
X  volatile uint32_t P1_19;
N  __IO uint32_t P1_20;
X  volatile uint32_t P1_20;
N  __IO uint32_t P1_21;
X  volatile uint32_t P1_21;
N  __IO uint32_t P1_22;
X  volatile uint32_t P1_22;
N  __IO uint32_t P1_23;
X  volatile uint32_t P1_23;
N
N  __IO uint32_t P1_24;				/* 0x0E0 */
X  volatile uint32_t P1_24;				 
N  __IO uint32_t P1_25;
X  volatile uint32_t P1_25;
N  __IO uint32_t P1_26;
X  volatile uint32_t P1_26;
N  __IO uint32_t P1_27;
X  volatile uint32_t P1_27;
N  __IO uint32_t P1_28;
X  volatile uint32_t P1_28;
N  __IO uint32_t P1_29;
X  volatile uint32_t P1_29;
N  __IO uint32_t P1_30;
X  volatile uint32_t P1_30;
N  __IO uint32_t P1_31;
X  volatile uint32_t P1_31;
N
N  __IO uint32_t P2_0;				/* 0x100 */
X  volatile uint32_t P2_0;				 
N  __IO uint32_t P2_1;
X  volatile uint32_t P2_1;
N  __IO uint32_t P2_2;
X  volatile uint32_t P2_2;
N  __IO uint32_t P2_3;
X  volatile uint32_t P2_3;
N  __IO uint32_t P2_4;
X  volatile uint32_t P2_4;
N  __IO uint32_t P2_5;
X  volatile uint32_t P2_5;
N  __IO uint32_t P2_6;
X  volatile uint32_t P2_6;
N  __IO uint32_t P2_7;
X  volatile uint32_t P2_7;
N
N  __IO uint32_t P2_8;				/* 0x120 */
X  volatile uint32_t P2_8;				 
N  __IO uint32_t P2_9;
X  volatile uint32_t P2_9;
N  __IO uint32_t P2_10;
X  volatile uint32_t P2_10;
N  __IO uint32_t P2_11;
X  volatile uint32_t P2_11;
N  __IO uint32_t P2_12;
X  volatile uint32_t P2_12;
N  __IO uint32_t P2_13;
X  volatile uint32_t P2_13;
N  __IO uint32_t P2_14;
X  volatile uint32_t P2_14;
N  __IO uint32_t P2_15;
X  volatile uint32_t P2_15;
N
N  __IO uint32_t P2_16;				/* 0x140 */
X  volatile uint32_t P2_16;				 
N  __IO uint32_t P2_17;
X  volatile uint32_t P2_17;
N  __IO uint32_t P2_18;
X  volatile uint32_t P2_18;
N  __IO uint32_t P2_19;
X  volatile uint32_t P2_19;
N  __IO uint32_t P2_20;
X  volatile uint32_t P2_20;
N  __IO uint32_t P2_21;
X  volatile uint32_t P2_21;
N  __IO uint32_t P2_22;
X  volatile uint32_t P2_22;
N  __IO uint32_t P2_23;
X  volatile uint32_t P2_23;
N
N  __IO uint32_t P2_24;				/* 0x160 */
X  volatile uint32_t P2_24;				 
N  __IO uint32_t P2_25;
X  volatile uint32_t P2_25;
N  __IO uint32_t P2_26;
X  volatile uint32_t P2_26;
N  __IO uint32_t P2_27;
X  volatile uint32_t P2_27;
N  __IO uint32_t P2_28;
X  volatile uint32_t P2_28;
N  __IO uint32_t P2_29;
X  volatile uint32_t P2_29;
N  __IO uint32_t P2_30;
X  volatile uint32_t P2_30;
N  __IO uint32_t P2_31;
X  volatile uint32_t P2_31;
N
N  __IO uint32_t P3_0;				/* 0x180 */
X  volatile uint32_t P3_0;				 
N  __IO uint32_t P3_1;
X  volatile uint32_t P3_1;
N  __IO uint32_t P3_2;
X  volatile uint32_t P3_2;
N  __IO uint32_t P3_3;
X  volatile uint32_t P3_3;
N  __IO uint32_t P3_4;
X  volatile uint32_t P3_4;
N  __IO uint32_t P3_5;
X  volatile uint32_t P3_5;
N  __IO uint32_t P3_6;
X  volatile uint32_t P3_6;
N  __IO uint32_t P3_7;
X  volatile uint32_t P3_7;
N
N  __IO uint32_t P3_8;				/* 0x1A0 */
X  volatile uint32_t P3_8;				 
N  __IO uint32_t P3_9;
X  volatile uint32_t P3_9;
N  __IO uint32_t P3_10;
X  volatile uint32_t P3_10;
N  __IO uint32_t P3_11;
X  volatile uint32_t P3_11;
N  __IO uint32_t P3_12;
X  volatile uint32_t P3_12;
N  __IO uint32_t P3_13;
X  volatile uint32_t P3_13;
N  __IO uint32_t P3_14;
X  volatile uint32_t P3_14;
N  __IO uint32_t P3_15;
X  volatile uint32_t P3_15;
N
N  __IO uint32_t P3_16;				/* 0x1C0 */
X  volatile uint32_t P3_16;				 
N  __IO uint32_t P3_17;
X  volatile uint32_t P3_17;
N  __IO uint32_t P3_18;
X  volatile uint32_t P3_18;
N  __IO uint32_t P3_19;
X  volatile uint32_t P3_19;
N  __IO uint32_t P3_20;
X  volatile uint32_t P3_20;
N  __IO uint32_t P3_21;
X  volatile uint32_t P3_21;
N  __IO uint32_t P3_22;
X  volatile uint32_t P3_22;
N  __IO uint32_t P3_23;
X  volatile uint32_t P3_23;
N
N  __IO uint32_t P3_24;				/* 0x1E0 */
X  volatile uint32_t P3_24;				 
N  __IO uint32_t P3_25;
X  volatile uint32_t P3_25;
N  __IO uint32_t P3_26;
X  volatile uint32_t P3_26;
N  __IO uint32_t P3_27;
X  volatile uint32_t P3_27;
N  __IO uint32_t P3_28;
X  volatile uint32_t P3_28;
N  __IO uint32_t P3_29;
X  volatile uint32_t P3_29;
N  __IO uint32_t P3_30;
X  volatile uint32_t P3_30;
N  __IO uint32_t P3_31;
X  volatile uint32_t P3_31;
N
N  __IO uint32_t P4_0;				/* 0x200 */
X  volatile uint32_t P4_0;				 
N  __IO uint32_t P4_1;
X  volatile uint32_t P4_1;
N  __IO uint32_t P4_2;
X  volatile uint32_t P4_2;
N  __IO uint32_t P4_3;
X  volatile uint32_t P4_3;
N  __IO uint32_t P4_4;
X  volatile uint32_t P4_4;
N  __IO uint32_t P4_5;
X  volatile uint32_t P4_5;
N  __IO uint32_t P4_6;
X  volatile uint32_t P4_6;
N  __IO uint32_t P4_7;
X  volatile uint32_t P4_7;
N
N  __IO uint32_t P4_8;				/* 0x220 */
X  volatile uint32_t P4_8;				 
N  __IO uint32_t P4_9;
X  volatile uint32_t P4_9;
N  __IO uint32_t P4_10;
X  volatile uint32_t P4_10;
N  __IO uint32_t P4_11;
X  volatile uint32_t P4_11;
N  __IO uint32_t P4_12;
X  volatile uint32_t P4_12;
N  __IO uint32_t P4_13;
X  volatile uint32_t P4_13;
N  __IO uint32_t P4_14;
X  volatile uint32_t P4_14;
N  __IO uint32_t P4_15;
X  volatile uint32_t P4_15;
N
N  __IO uint32_t P4_16;				/* 0x240 */
X  volatile uint32_t P4_16;				 
N  __IO uint32_t P4_17;
X  volatile uint32_t P4_17;
N  __IO uint32_t P4_18;
X  volatile uint32_t P4_18;
N  __IO uint32_t P4_19;
X  volatile uint32_t P4_19;
N  __IO uint32_t P4_20;
X  volatile uint32_t P4_20;
N  __IO uint32_t P4_21;
X  volatile uint32_t P4_21;
N  __IO uint32_t P4_22;
X  volatile uint32_t P4_22;
N  __IO uint32_t P4_23;
X  volatile uint32_t P4_23;
N
N  __IO uint32_t P4_24;				/* 0x260 */
X  volatile uint32_t P4_24;				 
N  __IO uint32_t P4_25;
X  volatile uint32_t P4_25;
N  __IO uint32_t P4_26;
X  volatile uint32_t P4_26;
N  __IO uint32_t P4_27;
X  volatile uint32_t P4_27;
N  __IO uint32_t P4_28;
X  volatile uint32_t P4_28;
N  __IO uint32_t P4_29;
X  volatile uint32_t P4_29;
N  __IO uint32_t P4_30;
X  volatile uint32_t P4_30;
N  __IO uint32_t P4_31;
X  volatile uint32_t P4_31;
N
N  __IO uint32_t P5_0;				/* 0x280 */
X  volatile uint32_t P5_0;				 
N  __IO uint32_t P5_1;
X  volatile uint32_t P5_1;
N  __IO uint32_t P5_2;
X  volatile uint32_t P5_2;
N  __IO uint32_t P5_3;
X  volatile uint32_t P5_3;
N  __IO uint32_t P5_4;				/* 0x290 */
X  volatile uint32_t P5_4;				 
N} LPC_IOCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DIR;
X  volatile uint32_t DIR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t PIN;
X  volatile uint32_t PIN;
N  __IO uint32_t SET;
X  volatile uint32_t SET;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;                    /*!< Offset: 0x03C External Match Register (R/W) */
X  volatile uint32_t EMR;                     
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;                   /*!< Offset: 0x070 Count Control Register (R/W) */
X  volatile uint32_t CTCR;                    
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N  __I  uint32_t CR2;					/*!< Offset: 0x034 Capture Register 2 (R/ ) */
X  volatile const  uint32_t CR2;					 
N  __I  uint32_t CR3;					/*!< Offset: 0x038 Capture Register 3 (R/ ) */
X  volatile const  uint32_t CR3;					 
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;					/*!< Offset: 0x040 Match Register 4 (R/W) */
X  volatile uint32_t MR4;					 
N  __IO uint32_t MR5;					/*!< Offset: 0x044 Match Register 5 (R/W) */
X  volatile uint32_t MR5;					 
N  __IO uint32_t MR6;					/*!< Offset: 0x048 Match Register 6 (R/W) */
X  volatile uint32_t MR6;					 
N  __IO uint32_t PCR;					/*!< Offset: 0x04C PWM Control Register (R/W) */
X  volatile uint32_t PCR;					 
N  __IO uint32_t LER;					/*!< Offset: 0x050 Load Enable Register (R/W) */
X  volatile uint32_t LER;					 
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;					/*!< Offset: 0x070 Counter Control Register (R/W) */
X  volatile uint32_t CTCR;					 
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UARTx) -----------*/
N/* There are three types of UARTs on the chip:
N(1) UART0,UART2, and UART3 are the standard UART.
N(2) UART1 is the standard with modem capability.
N(3) USART(UART4) is the sync/async UART with smart card capability.
NMore details can be found on the Users Manual. */
N
N#if 0
Stypedef struct
S{
S  union {
S  __I  uint8_t  RBR;
S  __O  uint8_t  THR;
S  __IO uint8_t  DLL;
S       uint32_t RESERVED0;
S  };
S  union {
S  __IO uint8_t  DLM;
S  __IO uint32_t IER;
S  };
S  union {
S  __I  uint32_t IIR;
S  __O  uint8_t  FCR;
S  };
S  __IO uint8_t  LCR;
S       uint8_t  RESERVED1[7];
S  __I  uint8_t  LSR;
S       uint8_t  RESERVED2[7];
S  __IO uint8_t  SCR;
S       uint8_t  RESERVED3[3];
S  __IO uint32_t ACR;
S  __IO uint8_t  ICR;
S       uint8_t  RESERVED4[3];
S  __IO uint8_t  FDR;
S       uint8_t  RESERVED5[7];
S  __IO uint8_t  TER;
S       uint8_t  RESERVED6[39];
S  __I  uint8_t  FIFOLVL;
S} LPC_UART_TypeDef;
N#else
Ntypedef struct
N{
N	union
N	{
N		__I  uint8_t  RBR;
X		volatile const  uint8_t  RBR;
N		__O  uint8_t  THR;
X		volatile  uint8_t  THR;
N		__IO uint8_t  DLL;
X		volatile uint8_t  DLL;
N		uint32_t RESERVED0;
N	};
N	union
N	{
N		__IO uint8_t  DLM;
X		volatile uint8_t  DLM;
N		__IO uint32_t IER;
X		volatile uint32_t IER;
N	};
N	union
N	{
N		__I  uint32_t IIR;
X		volatile const  uint32_t IIR;
N		__O  uint8_t  FCR;
X		volatile  uint8_t  FCR;
N	};
N	__IO uint8_t  LCR;
X	volatile uint8_t  LCR;
N	uint8_t  RESERVED1[7];//Reserved
N	__I  uint8_t  LSR;
X	volatile const  uint8_t  LSR;
N	uint8_t  RESERVED2[7];//Reserved
N	__IO uint8_t  SCR;
X	volatile uint8_t  SCR;
N	uint8_t  RESERVED3[3];//Reserved
N	__IO uint32_t ACR;
X	volatile uint32_t ACR;
N	__IO uint8_t  ICR;
X	volatile uint8_t  ICR;
N	uint8_t  RESERVED4[3];//Reserved
N	__IO uint8_t  FDR;
X	volatile uint8_t  FDR;
N	uint8_t  RESERVED5[7];//Reserved
N	__IO uint8_t  TER;
X	volatile uint8_t  TER;
N	uint8_t  RESERVED8[27];//Reserved
N	__IO uint8_t  RS485CTRL;
X	volatile uint8_t  RS485CTRL;
N	uint8_t  RESERVED9[3];//Reserved
N	__IO uint8_t  ADRMATCH;
X	volatile uint8_t  ADRMATCH;
N	uint8_t  RESERVED10[3];//Reserved
N	__IO uint8_t  RS485DLY;
X	volatile uint8_t  RS485DLY;
N	uint8_t  RESERVED11[3];//Reserved
N	__I  uint8_t  FIFOLVL;
X	volatile const  uint8_t  FIFOLVL;
N}LPC_UART_TypeDef;
N#endif
N
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART1_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;                   /*!< Offset: 0x000 Receiver Buffer  Register (R/ ) */
X  volatile const  uint32_t  RBR;                    
N  __O  uint32_t  THR;                   /*!< Offset: 0x000 Transmit Holding Register ( /W) */
X  volatile  uint32_t  THR;                    
N  __IO uint32_t  DLL;                   /*!< Offset: 0x000 Divisor Latch LSB (R/W) */
X  volatile uint32_t  DLL;                    
N  };
N  union {
N  __IO uint32_t  DLM;                   /*!< Offset: 0x004 Divisor Latch MSB (R/W) */
X  volatile uint32_t  DLM;                    
N  __IO uint32_t  IER;                   /*!< Offset: 0x000 Interrupt Enable Register (R/W) */
X  volatile uint32_t  IER;                    
N  };
N  union {
N  __I  uint32_t  IIR;                   /*!< Offset: 0x008 Interrupt ID Register (R/ ) */
X  volatile const  uint32_t  IIR;                    
N  __O  uint32_t  FCR;                   /*!< Offset: 0x008 FIFO Control Register ( /W) */
X  volatile  uint32_t  FCR;                    
N  };
N  __IO uint32_t  LCR;                   /*!< Offset: 0x00C Line Control Register (R/W) */
X  volatile uint32_t  LCR;                    
N  __IO uint32_t  MCR;                   /*!< Offset: 0x010 Modem control Register (R/W) */
X  volatile uint32_t  MCR;                    
N  __I  uint32_t  LSR;                   /*!< Offset: 0x014 Line Status Register (R/ ) */
X  volatile const  uint32_t  LSR;                    
N  __I  uint32_t  MSR;                   /*!< Offset: 0x018 Modem status Register (R/ ) */
X  volatile const  uint32_t  MSR;                    
N  __IO uint32_t  SCR;                   /*!< Offset: 0x01C Scratch Pad Register (R/W) */
X  volatile uint32_t  SCR;                    
N  __IO uint32_t  ACR;                   /*!< Offset: 0x020 Auto-baud Control Register (R/W) */
X  volatile uint32_t  ACR;                    
N  __IO uint32_t  ICR;                   /*!< Offset: 0x024 irDA Control Register (R/W) */
X  volatile uint32_t  ICR;                    
N  __IO uint32_t  FDR;                   /*!< Offset: 0x028 Fractional Divider Register (R/W) */
X  volatile uint32_t  FDR;                    
N  __IO uint32_t  OSR;                   /*!< Offset: 0x02C Over sampling Register (R/W) */
X  volatile uint32_t  OSR;                    
N  __O  uint32_t  POP;                   /*!< Offset: 0x030 NHP Pop Register (W) */
X  volatile  uint32_t  POP;                    
N  __IO uint32_t  MODE;                  /*!< Offset: 0x034 NHP Mode selection Register (W) */
X  volatile uint32_t  MODE;                   
N       uint32_t  RESERVED0[2];
N  __IO uint32_t  HDEN;                  /*!< Offset: 0x040 Half duplex Enable Register (R/W) */
X  volatile uint32_t  HDEN;                   
N       uint32_t  RESERVED1;
N  __IO uint32_t  SCI_CTRL;				/*!< Offset: 0x048 Smart card Interface Control Register (R/W) */
X  volatile uint32_t  SCI_CTRL;				 
N  __IO uint32_t  RS485CTRL;             /*!< Offset: 0x04C RS-485/EIA-485 Control Register (R/W) */
X  volatile uint32_t  RS485CTRL;              
N  __IO uint32_t  ADRMATCH;              /*!< Offset: 0x050 RS-485/EIA-485 address match Register (R/W) */
X  volatile uint32_t  ADRMATCH;               
N  __IO uint32_t  RS485DLY;              /*!< Offset: 0x054 RS-485/EIA-485 direction control delay Register (R/W) */
X  volatile uint32_t  RS485DLY;               
N  __IO uint32_t  SYNCCTRL;              /*!< Offset: 0x058 Synchronous Mode Control Register (R/W ) */
X  volatile uint32_t  SYNCCTRL;               
N  __IO uint32_t  TER;                   /*!< Offset: 0x05C Transmit Enable Register (R/W) */
X  volatile uint32_t  TER;                    
N       uint32_t  RESERVED2[989];
N  __I  uint32_t  CFG;                   /*!< Offset: 0xFD4 Configuration Register (R) */
X  volatile const  uint32_t  CFG;                    
N  __O  uint32_t  INTCE;                 /*!< Offset: 0xFD8 Interrupt Clear Enable Register (W) */
X  volatile  uint32_t  INTCE;                  
N  __O  uint32_t  INTSE;                 /*!< Offset: 0xFDC Interrupt Set Enable Register (W) */
X  volatile  uint32_t  INTSE;                  
N  __I  uint32_t  INTS;                  /*!< Offset: 0xFE0 Interrupt Status Register (R) */
X  volatile const  uint32_t  INTS;                   
N  __I  uint32_t  INTE;                  /*!< Offset: 0xFE4 Interrupt Enable Register (R) */
X  volatile const  uint32_t  INTE;                   
N  __O  uint32_t  INTCS;                 /*!< Offset: 0xFE8 Interrupt Clear Status Register (W) */
X  volatile  uint32_t  INTCS;                  
N  __O  uint32_t  INTSS;                 /*!< Offset: 0xFEC Interrupt Set Status Register (W) */
X  volatile  uint32_t  INTSS;                  
N       uint32_t  RESERVED3[3];
N  __I  uint32_t  MID;                   /*!< Offset: 0xFFC Module Identification Register (R) */
X  volatile const  uint32_t  MID;                    
N} LPC_UART4_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;                    /*!< Offset: 0x000 Control Register 0 (R/W) */
X  volatile uint32_t CR0;                     
N  __IO uint32_t CR1;                    /*!< Offset: 0x004 Control Register 1 (R/W) */
X  volatile uint32_t CR1;                     
N  __IO uint32_t DR;                     /*!< Offset: 0x008 Data Register (R/W) */
X  volatile uint32_t DR;                      
N  __I  uint32_t SR;                     /*!< Offset: 0x00C Status Registe (R/ ) */
X  volatile const  uint32_t SR;                      
N  __IO uint32_t CPSR;                   /*!< Offset: 0x010 Clock Prescale Register (R/W) */
X  volatile uint32_t CPSR;                    
N  __IO uint32_t IMSC;                   /*!< Offset: 0x014 Interrupt Mask Set and Clear Register (R/W) */
X  volatile uint32_t IMSC;                    
N  __IO uint32_t RIS;                    /*!< Offset: 0x018 Raw Interrupt Status Register (R/W) */
X  volatile uint32_t RIS;                     
N  __IO uint32_t MIS;                    /*!< Offset: 0x01C Masked Interrupt Status Register (R/W) */
X  volatile uint32_t MIS;                     
N  __IO uint32_t ICR;                    /*!< Offset: 0x020 SSPICR Interrupt Clear Register (R/W) */
X  volatile uint32_t ICR;                     
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CONSET;                 /*!< Offset: 0x000 I2C Control Set Register (R/W) */
X  volatile uint32_t CONSET;                  
N  __I  uint32_t STAT;                   /*!< Offset: 0x004 I2C Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t DAT;                    /*!< Offset: 0x008 I2C Data Register (R/W) */
X  volatile uint32_t DAT;                     
N  __IO uint32_t ADR0;                   /*!< Offset: 0x00C I2C Slave Address Register 0 (R/W) */
X  volatile uint32_t ADR0;                    
N  __IO uint32_t SCLH;                   /*!< Offset: 0x010 SCH Duty Cycle Register High Half Word (R/W) */
X  volatile uint32_t SCLH;                    
N  __IO uint32_t SCLL;                   /*!< Offset: 0x014 SCL Duty Cycle Register Low Half Word (R/W) */
X  volatile uint32_t SCLL;                    
N  __O  uint32_t CONCLR;                 /*!< Offset: 0x018 I2C Control Clear Register ( /W) */
X  volatile  uint32_t CONCLR;                  
N  __IO uint32_t MMCTRL;                 /*!< Offset: 0x01C Monitor mode control register (R/W) */
X  volatile uint32_t MMCTRL;                  
N  __IO uint32_t ADR1;                   /*!< Offset: 0x020 I2C Slave Address Register 1 (R/W) */
X  volatile uint32_t ADR1;                    
N  __IO uint32_t ADR2;                   /*!< Offset: 0x024 I2C Slave Address Register 2 (R/W) */
X  volatile uint32_t ADR2;                    
N  __IO uint32_t ADR3;                   /*!< Offset: 0x028 I2C Slave Address Register 3 (R/W) */
X  volatile uint32_t ADR3;                    
N  __I  uint32_t DATA_BUFFER;            /*!< Offset: 0x02C Data buffer register ( /W) */
X  volatile const  uint32_t DATA_BUFFER;             
N  __IO uint32_t MASK0;                  /*!< Offset: 0x030 I2C Slave address mask register 0 (R/W) */
X  volatile uint32_t MASK0;                   
N  __IO uint32_t MASK1;                  /*!< Offset: 0x034 I2C Slave address mask register 1 (R/W) */
X  volatile uint32_t MASK1;                   
N  __IO uint32_t MASK2;                  /*!< Offset: 0x038 I2C Slave address mask register 2 (R/W) */
X  volatile uint32_t MASK2;                   
N  __IO uint32_t MASK3;                  /*!< Offset: 0x03C I2C Slave address mask register 3 (R/W) */
X  volatile uint32_t MASK3;                   
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DAO;
X  volatile uint32_t DAO;
N  __IO uint32_t DAI;
X  volatile uint32_t DAI;
N  __O  uint32_t TXFIFO;
X  volatile  uint32_t TXFIFO;
N  __I  uint32_t RXFIFO;
X  volatile const  uint32_t RXFIFO;
N  __I  uint32_t STATE;
X  volatile const  uint32_t STATE;
N  __IO uint32_t DMA1;
X  volatile uint32_t DMA1;
N  __IO uint32_t DMA2;
X  volatile uint32_t DMA2;
N  __IO uint32_t IRQ;
X  volatile uint32_t IRQ;
N  __IO uint32_t TXRATE;
X  volatile uint32_t TXRATE;
N  __IO uint32_t RXRATE;
X  volatile uint32_t RXRATE;
N  __IO uint32_t TXBITRATE;
X  volatile uint32_t TXBITRATE;
N  __IO uint32_t RXBITRATE;
X  volatile uint32_t RXBITRATE;
N  __IO uint32_t TXMODE;
X  volatile uint32_t TXMODE;
N  __IO uint32_t RXMODE;
X  volatile uint32_t RXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N  __IO uint32_t ERSTATUS;
X  volatile uint32_t ERSTATUS;
N  __IO uint32_t ERCONTROL;
X  volatile uint32_t ERCONTROL;
N  __IO uint32_t ERCOUNTERS;
X  volatile uint32_t ERCOUNTERS;
N       uint32_t RESERVED22;
N  __IO uint32_t ERFIRSTSTAMP0;
X  volatile uint32_t ERFIRSTSTAMP0;
N  __IO uint32_t ERFIRSTSTAMP1;
X  volatile uint32_t ERFIRSTSTAMP1;
N  __IO uint32_t ERFIRSTSTAMP2;
X  volatile uint32_t ERFIRSTSTAMP2;
N       uint32_t RESERVED23;
N  __IO uint32_t ERLASTSTAMP0;
X  volatile uint32_t ERLASTSTAMP0;
N  __IO uint32_t ERLASTSTAMP1;
X  volatile uint32_t ERLASTSTAMP1;
N  __IO uint32_t ERLASTSTAMP2;
X  volatile uint32_t ERLASTSTAMP2;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  MOD;
X  volatile uint8_t  MOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __O  uint8_t  FEED;
X  volatile  uint8_t  FEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t TV;
X  volatile const  uint32_t TV;
N       uint32_t RESERVED2;
N  __IO uint32_t WARNINT;
X  volatile uint32_t WARNINT;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;                     /*!< Offset: 0x000       A/D Control Register (R/W) */
X  volatile uint32_t CR;                      
N  __IO uint32_t GDR;                    /*!< Offset: 0x004       A/D Global Data Register (R/W) */
X  volatile uint32_t GDR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t INTEN;                  /*!< Offset: 0x00C       A/D Interrupt Enable Register (R/W) */
X  volatile uint32_t INTEN;                   
N  __IO uint32_t DR[8];                  /*!< Offset: 0x010-0x02C A/D Channel 0..7 Data Register (R/W) */
X  volatile uint32_t DR[8];                   
N  __I  uint32_t STAT;                   /*!< Offset: 0x030       A/D Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t CNTVAL;
X  volatile uint32_t CNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t CON;
X  volatile const  uint32_t CON;
N  __O  uint32_t CON_SET;
X  volatile  uint32_t CON_SET;
N  __O  uint32_t CON_CLR;
X  volatile  uint32_t CON_CLR;
N  __I  uint32_t CAPCON;
X  volatile const  uint32_t CAPCON;
N  __O  uint32_t CAPCON_SET;
X  volatile  uint32_t CAPCON_SET;
N  __O  uint32_t CAPCON_CLR;
X  volatile  uint32_t CAPCON_CLR;
N  __IO uint32_t TC0;
X  volatile uint32_t TC0;
N  __IO uint32_t TC1;
X  volatile uint32_t TC1;
N  __IO uint32_t TC2;
X  volatile uint32_t TC2;
N  __IO uint32_t LIM0;
X  volatile uint32_t LIM0;
N  __IO uint32_t LIM1;
X  volatile uint32_t LIM1;
N  __IO uint32_t LIM2;
X  volatile uint32_t LIM2;
N  __IO uint32_t MAT0;
X  volatile uint32_t MAT0;
N  __IO uint32_t MAT1;
X  volatile uint32_t MAT1;
N  __IO uint32_t MAT2;
X  volatile uint32_t MAT2;
N  __IO uint32_t DT;
X  volatile uint32_t DT;
N  __IO uint32_t CP;
X  volatile uint32_t CP;
N  __IO uint32_t CAP0;
X  volatile uint32_t CAP0;
N  __IO uint32_t CAP1;
X  volatile uint32_t CAP1;
N  __IO uint32_t CAP2;
X  volatile uint32_t CAP2;
N  __I  uint32_t INTEN;
X  volatile const  uint32_t INTEN;
N  __O  uint32_t INTEN_SET;
X  volatile  uint32_t INTEN_SET;
N  __O  uint32_t INTEN_CLR;
X  volatile  uint32_t INTEN_CLR;
N  __I  uint32_t CNTCON;
X  volatile const  uint32_t CNTCON;
N  __O  uint32_t CNTCON_SET;
X  volatile  uint32_t CNTCON_SET;
N  __O  uint32_t CNTCON_CLR;
X  volatile  uint32_t CNTCON_CLR;
N  __I  uint32_t INTF;
X  volatile const  uint32_t INTF;
N  __O  uint32_t INTF_SET;
X  volatile  uint32_t INTF_SET;
N  __O  uint32_t INTF_CLR;
X  volatile  uint32_t INTF_CLR;
N  __O  uint32_t CAP_CLR;
X  volatile  uint32_t CAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t CON;
X  volatile  uint32_t CON;
N  __I  uint32_t STAT;
X  volatile const  uint32_t STAT;
N  __IO uint32_t CONF;
X  volatile uint32_t CONF;
N  __I  uint32_t POS;
X  volatile const  uint32_t POS;
N  __IO uint32_t MAXPOS;
X  volatile uint32_t MAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP0;
X  volatile uint32_t INXCMP0;
N  __IO uint32_t LOAD;
X  volatile uint32_t LOAD;
N  __I  uint32_t TIME;
X  volatile const  uint32_t TIME;
N  __I  uint32_t VEL;
X  volatile const  uint32_t VEL;
N  __I  uint32_t CAP;
X  volatile const  uint32_t CAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTERPHA;
X  volatile uint32_t FILTERPHA;
N  __IO uint32_t FILTERPHB;
X  volatile uint32_t FILTERPHB;
N  __IO uint32_t FILTERINX;
X  volatile uint32_t FILTERINX;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N  __IO uint32_t INXCMP1;
X  volatile uint32_t INXCMP1;
N  __IO uint32_t INXCMP2;
X  volatile uint32_t INXCMP2;
N       uint32_t RESERVED0[993];
N  __O  uint32_t IEC;
X  volatile  uint32_t IEC;
N  __O  uint32_t IES;
X  volatile  uint32_t IES;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __I  uint32_t IE;
X  volatile const  uint32_t IE;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N  __O  uint32_t SET;
X  volatile  uint32_t SET;
N} LPC_QEI_TypeDef;
N
N/*------------- SD/MMC card Interface (MCI)-----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t POWER;
X  volatile uint32_t POWER;
N  __IO uint32_t CLOCK;
X  volatile uint32_t CLOCK;
N  __IO uint32_t ARGUMENT;
X  volatile uint32_t ARGUMENT;
N  __IO uint32_t COMMAND;
X  volatile uint32_t COMMAND;
N  __I  uint32_t RESP_CMD;
X  volatile const  uint32_t RESP_CMD;
N  __I  uint32_t RESP0;
X  volatile const  uint32_t RESP0;
N  __I  uint32_t RESP1;
X  volatile const  uint32_t RESP1;
N  __I  uint32_t RESP2;
X  volatile const  uint32_t RESP2;
N  __I  uint32_t RESP3;
X  volatile const  uint32_t RESP3;
N  __IO uint32_t DATATMR;
X  volatile uint32_t DATATMR;
N  __IO uint32_t DATALEN;
X  volatile uint32_t DATALEN;
N  __IO uint32_t DATACTRL;
X  volatile uint32_t DATACTRL;
N  __I  uint32_t DATACNT;
X  volatile const  uint32_t DATACNT;
N  __I  uint32_t STATUS;
X  volatile const  uint32_t STATUS;
N  __O  uint32_t CLEAR;
X  volatile  uint32_t CLEAR;
N  __IO uint32_t MASK0;
X  volatile uint32_t MASK0;
N       uint32_t RESERVED0[2];
N  __I  uint32_t FIFOCNT;
X  volatile const  uint32_t FIFOCNT;
N       uint32_t RESERVED1[13];
N  __IO uint32_t FIFO;
X  volatile uint32_t FIFO;
N} LPC_MCI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t TxSR;
X  volatile const  uint32_t TxSR;
N  __I  uint32_t RxSR;
X  volatile const  uint32_t RxSR;
N  __I  uint32_t MSR;
X  volatile const  uint32_t MSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t IntStat;
X  volatile const  uint32_t IntStat;
N  __I  uint32_t IntTCStat;
X  volatile const  uint32_t IntTCStat;
N  __O  uint32_t IntTCClear;
X  volatile  uint32_t IntTCClear;
N  __I  uint32_t IntErrStat;
X  volatile const  uint32_t IntErrStat;
N  __O  uint32_t IntErrClr;
X  volatile  uint32_t IntErrClr;
N  __I  uint32_t RawIntTCStat;
X  volatile const  uint32_t RawIntTCStat;
N  __I  uint32_t RawIntErrStat;
X  volatile const  uint32_t RawIntErrStat;
N  __I  uint32_t EnbldChns;
X  volatile const  uint32_t EnbldChns;
N  __IO uint32_t SoftBReq;
X  volatile uint32_t SoftBReq;
N  __IO uint32_t SoftSReq;
X  volatile uint32_t SoftSReq;
N  __IO uint32_t SoftLBReq;
X  volatile uint32_t SoftLBReq;
N  __IO uint32_t SoftLSReq;
X  volatile uint32_t SoftLSReq;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N  __IO uint32_t Sync;
X  volatile uint32_t Sync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t CSrcAddr;
X  volatile uint32_t CSrcAddr;
N  __IO uint32_t CDestAddr;
X  volatile uint32_t CDestAddr;
N  __IO uint32_t CLLI;
X  volatile uint32_t CLLI;
N  __IO uint32_t CControl;
X  volatile uint32_t CControl;
N  __IO uint32_t CConfig;
X  volatile uint32_t CConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t Revision;             /* USB Host Registers                 */
X  volatile const  uint32_t Revision;              
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __IO uint32_t CommandStatus;
X  volatile uint32_t CommandStatus;
N  __IO uint32_t InterruptStatus;
X  volatile uint32_t InterruptStatus;
N  __IO uint32_t InterruptEnable;
X  volatile uint32_t InterruptEnable;
N  __IO uint32_t InterruptDisable;
X  volatile uint32_t InterruptDisable;
N  __IO uint32_t HCCA;
X  volatile uint32_t HCCA;
N  __I  uint32_t PeriodCurrentED;
X  volatile const  uint32_t PeriodCurrentED;
N  __IO uint32_t ControlHeadED;
X  volatile uint32_t ControlHeadED;
N  __IO uint32_t ControlCurrentED;
X  volatile uint32_t ControlCurrentED;
N  __IO uint32_t BulkHeadED;
X  volatile uint32_t BulkHeadED;
N  __IO uint32_t BulkCurrentED;
X  volatile uint32_t BulkCurrentED;
N  __I  uint32_t DoneHead;
X  volatile const  uint32_t DoneHead;
N  __IO uint32_t FmInterval;
X  volatile uint32_t FmInterval;
N  __I  uint32_t FmRemaining;
X  volatile const  uint32_t FmRemaining;
N  __I  uint32_t FmNumber;
X  volatile const  uint32_t FmNumber;
N  __IO uint32_t PeriodicStart;
X  volatile uint32_t PeriodicStart;
N  __IO uint32_t LSTreshold;
X  volatile uint32_t LSTreshold;
N  __IO uint32_t RhDescriptorA;
X  volatile uint32_t RhDescriptorA;
N  __IO uint32_t RhDescriptorB;
X  volatile uint32_t RhDescriptorB;
N  __IO uint32_t RhStatus;
X  volatile uint32_t RhStatus;
N  __IO uint32_t RhPortStatus1;
X  volatile uint32_t RhPortStatus1;
N  __IO uint32_t RhPortStatus2;
X  volatile uint32_t RhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t IntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t IntSt;                
N  __IO uint32_t IntEn;
X  volatile uint32_t IntEn;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N  __O  uint32_t IntClr;
X  volatile  uint32_t IntClr;
N  __IO uint32_t StCtrl;
X  volatile uint32_t StCtrl;
N  __IO uint32_t Tmr;
X  volatile uint32_t Tmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t DevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t DevIntSt;             
N  __IO uint32_t DevIntEn;
X  volatile uint32_t DevIntEn;
N  __O  uint32_t DevIntClr;
X  volatile  uint32_t DevIntClr;
N  __O  uint32_t DevIntSet;
X  volatile  uint32_t DevIntSet;
N
N  __O  uint32_t CmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t CmdCode;              
N  __I  uint32_t CmdData;
X  volatile const  uint32_t CmdData;
N
N  __I  uint32_t RxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t RxData;               
N  __O  uint32_t TxData;
X  volatile  uint32_t TxData;
N  __I  uint32_t RxPLen;
X  volatile const  uint32_t RxPLen;
N  __O  uint32_t TxPLen;
X  volatile  uint32_t TxPLen;
N  __IO uint32_t Ctrl;
X  volatile uint32_t Ctrl;
N  __O  uint32_t DevIntPri;
X  volatile  uint32_t DevIntPri;
N
N  __I  uint32_t EpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t EpIntSt;              
N  __IO uint32_t EpIntEn;
X  volatile uint32_t EpIntEn;
N  __O  uint32_t EpIntClr;
X  volatile  uint32_t EpIntClr;
N  __O  uint32_t EpIntSet;
X  volatile  uint32_t EpIntSet;
N  __O  uint32_t EpIntPri;
X  volatile  uint32_t EpIntPri;
N
N  __IO uint32_t ReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t ReEp;                 
N  __O  uint32_t EpInd;
X  volatile  uint32_t EpInd;
N  __IO uint32_t MaxPSize;
X  volatile uint32_t MaxPSize;
N
N  __I  uint32_t DMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t DMARSt;               
N  __O  uint32_t DMARClr;
X  volatile  uint32_t DMARClr;
N  __O  uint32_t DMARSet;
X  volatile  uint32_t DMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t UDCAH;
X  volatile uint32_t UDCAH;
N  __I  uint32_t EpDMASt;
X  volatile const  uint32_t EpDMASt;
N  __O  uint32_t EpDMAEn;
X  volatile  uint32_t EpDMAEn;
N  __O  uint32_t EpDMADis;
X  volatile  uint32_t EpDMADis;
N  __I  uint32_t DMAIntSt;
X  volatile const  uint32_t DMAIntSt;
N  __IO uint32_t DMAIntEn;
X  volatile uint32_t DMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t EoTIntSt;
X  volatile const  uint32_t EoTIntSt;
N  __O  uint32_t EoTIntClr;
X  volatile  uint32_t EoTIntClr;
N  __O  uint32_t EoTIntSet;
X  volatile  uint32_t EoTIntSet;
N  __I  uint32_t NDDRIntSt;
X  volatile const  uint32_t NDDRIntSt;
N  __O  uint32_t NDDRIntClr;
X  volatile  uint32_t NDDRIntClr;
N  __O  uint32_t NDDRIntSet;
X  volatile  uint32_t NDDRIntSet;
N  __I  uint32_t SysErrIntSt;
X  volatile const  uint32_t SysErrIntSt;
N  __O  uint32_t SysErrIntClr;
X  volatile  uint32_t SysErrIntClr;
N  __O  uint32_t SysErrIntSet;
X  volatile  uint32_t SysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __IO  uint32_t I2C_STS;
X  volatile  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __I  uint32_t RxFilterWoLStatus;
X  volatile const  uint32_t RxFilterWoLStatus;
N  __O  uint32_t RxFilterWoLClear;
X  volatile  uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N/*------------- LCD controller (LCD) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t TIMH;                   /* LCD Registers                      */
X  volatile uint32_t TIMH;                    
N  __IO uint32_t TIMV;
X  volatile uint32_t TIMV;
N  __IO uint32_t POL;
X  volatile uint32_t POL;
N  __IO uint32_t LE;
X  volatile uint32_t LE;
N  __IO uint32_t UPBASE;
X  volatile uint32_t UPBASE;
N  __IO uint32_t LPBASE;
X  volatile uint32_t LPBASE;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t INTMSK;
X  volatile uint32_t INTMSK;
N  __I  uint32_t INTRAW;
X  volatile const  uint32_t INTRAW;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __O  uint32_t INTCLR;
X  volatile  uint32_t INTCLR;
N  __I  uint32_t UPCURR;
X  volatile const  uint32_t UPCURR;
N  __I  uint32_t LPCURR;
X  volatile const  uint32_t LPCURR;
N       uint32_t RESERVED0[115];
N  __IO uint32_t PAL[128];
X  volatile uint32_t PAL[128];
N       uint32_t RESERVED1[256];
N  __IO uint32_t CRSR_IMG[256];
X  volatile uint32_t CRSR_IMG[256];
N  __IO uint32_t CRSR_CTRL;
X  volatile uint32_t CRSR_CTRL;
N  __IO uint32_t CRSR_CFG;
X  volatile uint32_t CRSR_CFG;
N  __IO uint32_t CRSR_PAL0;
X  volatile uint32_t CRSR_PAL0;
N  __IO uint32_t CRSR_PAL1;
X  volatile uint32_t CRSR_PAL1;
N  __IO uint32_t CRSR_XY;
X  volatile uint32_t CRSR_XY;
N  __IO uint32_t CRSR_CLIP;
X  volatile uint32_t CRSR_CLIP;
N       uint32_t RESERVED2[2];
N  __IO uint32_t CRSR_INTMSK;
X  volatile uint32_t CRSR_INTMSK;
N  __O  uint32_t CRSR_INTCLR;
X  volatile  uint32_t CRSR_INTCLR;
N  __I  uint32_t CRSR_INTRAW;
X  volatile const  uint32_t CRSR_INTRAW;
N  __I  uint32_t CRSR_INTSTAT;
X  volatile const  uint32_t CRSR_INTSTAT;
N} LPC_LCD_TypeDef;
N
N/*------------- External Memory Controller (EMC) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N       uint32_t RESERVED0[5];
N  __IO uint32_t DynamicControl;
X  volatile uint32_t DynamicControl;
N  __IO uint32_t DynamicRefresh;
X  volatile uint32_t DynamicRefresh;
N  __IO uint32_t DynamicReadConfig;
X  volatile uint32_t DynamicReadConfig;
N       uint32_t RESERVED1[1];
N  __IO uint32_t DynamicRP;
X  volatile uint32_t DynamicRP;
N  __IO uint32_t DynamicRAS;
X  volatile uint32_t DynamicRAS;
N  __IO uint32_t DynamicSREX;
X  volatile uint32_t DynamicSREX;
N  __IO uint32_t DynamicAPR;
X  volatile uint32_t DynamicAPR;
N  __IO uint32_t DynamicDAL;
X  volatile uint32_t DynamicDAL;
N  __IO uint32_t DynamicWR;
X  volatile uint32_t DynamicWR;
N  __IO uint32_t DynamicRC;
X  volatile uint32_t DynamicRC;
N  __IO uint32_t DynamicRFC;
X  volatile uint32_t DynamicRFC;
N  __IO uint32_t DynamicXSR;
X  volatile uint32_t DynamicXSR;
N  __IO uint32_t DynamicRRD;
X  volatile uint32_t DynamicRRD;
N  __IO uint32_t DynamicMRD;
X  volatile uint32_t DynamicMRD;
N       uint32_t RESERVED2[9];
N  __IO uint32_t StaticExtendedWait;
X  volatile uint32_t StaticExtendedWait;
N       uint32_t RESERVED3[31];
N  __IO uint32_t DynamicConfig0;
X  volatile uint32_t DynamicConfig0;
N  __IO uint32_t DynamicRasCas0;
X  volatile uint32_t DynamicRasCas0;
N       uint32_t RESERVED4[6];
N  __IO uint32_t DynamicConfig1;
X  volatile uint32_t DynamicConfig1;
N  __IO uint32_t DynamicRasCas1;
X  volatile uint32_t DynamicRasCas1;
N       uint32_t RESERVED5[6];
N  __IO uint32_t DynamicConfig2;
X  volatile uint32_t DynamicConfig2;
N  __IO uint32_t DynamicRasCas2;
X  volatile uint32_t DynamicRasCas2;
N       uint32_t RESERVED6[6];
N  __IO uint32_t DynamicConfig3;
X  volatile uint32_t DynamicConfig3;
N  __IO uint32_t DynamicRasCas3;
X  volatile uint32_t DynamicRasCas3;
N       uint32_t RESERVED7[38];
N  __IO uint32_t StaticConfig0;
X  volatile uint32_t StaticConfig0;
N  __IO uint32_t StaticWaitWen0;
X  volatile uint32_t StaticWaitWen0;
N  __IO uint32_t StaticWaitOen0;
X  volatile uint32_t StaticWaitOen0;
N  __IO uint32_t StaticWaitRd0;
X  volatile uint32_t StaticWaitRd0;
N  __IO uint32_t StaticWaitPage0;
X  volatile uint32_t StaticWaitPage0;
N  __IO uint32_t StaticWaitWr0;
X  volatile uint32_t StaticWaitWr0;
N  __IO uint32_t StaticWaitTurn0;
X  volatile uint32_t StaticWaitTurn0;
N       uint32_t RESERVED8[1];
N  __IO uint32_t StaticConfig1;
X  volatile uint32_t StaticConfig1;
N  __IO uint32_t StaticWaitWen1;
X  volatile uint32_t StaticWaitWen1;
N  __IO uint32_t StaticWaitOen1;
X  volatile uint32_t StaticWaitOen1;
N  __IO uint32_t StaticWaitRd1;
X  volatile uint32_t StaticWaitRd1;
N  __IO uint32_t StaticWaitPage1;
X  volatile uint32_t StaticWaitPage1;
N  __IO uint32_t StaticWaitWr1;
X  volatile uint32_t StaticWaitWr1;
N  __IO uint32_t StaticWaitTurn1;
X  volatile uint32_t StaticWaitTurn1;
N       uint32_t RESERVED9[1];
N  __IO uint32_t StaticConfig2;
X  volatile uint32_t StaticConfig2;
N  __IO uint32_t StaticWaitWen2;
X  volatile uint32_t StaticWaitWen2;
N  __IO uint32_t StaticWaitOen2;
X  volatile uint32_t StaticWaitOen2;
N  __IO uint32_t StaticWaitRd2;
X  volatile uint32_t StaticWaitRd2;
N  __IO uint32_t StaticWaitPage2;
X  volatile uint32_t StaticWaitPage2;
N  __IO uint32_t StaticWaitWr2;
X  volatile uint32_t StaticWaitWr2;
N  __IO uint32_t StaticWaitTurn2;
X  volatile uint32_t StaticWaitTurn2;
N       uint32_t RESERVED10[1];
N  __IO uint32_t StaticConfig3;
X  volatile uint32_t StaticConfig3;
N  __IO uint32_t StaticWaitWen3;
X  volatile uint32_t StaticWaitWen3;
N  __IO uint32_t StaticWaitOen3;
X  volatile uint32_t StaticWaitOen3;
N  __IO uint32_t StaticWaitRd3;
X  volatile uint32_t StaticWaitRd3;
N  __IO uint32_t StaticWaitPage3;
X  volatile uint32_t StaticWaitPage3;
N  __IO uint32_t StaticWaitWr3;
X  volatile uint32_t StaticWaitWr3;
N  __IO uint32_t StaticWaitTurn3;
X  volatile uint32_t StaticWaitTurn3;
N} LPC_EMC_TypeDef;
N
N/*------------- CRC Engine (CRC) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t MODE;
X  volatile uint32_t MODE;
N  __IO uint32_t SEED;
X  volatile uint32_t SEED;
N  union {
N  __I  uint32_t SUM;
X  volatile const  uint32_t SUM;
N  __O  uint32_t WR_DATA_DWORD;
X  volatile  uint32_t WR_DATA_DWORD;
N  __O  uint16_t WR_DATA_WORD;
X  volatile  uint16_t WR_DATA_WORD;
N       uint16_t RESERVED_WORD;
N  __O  uint8_t WR_DATA_BYTE;
X  volatile  uint8_t WR_DATA_BYTE;
N       uint8_t RESERVED_BYTE[3];
N  };
N} LPC_CRC_TypeDef;
N
N/*------------- EEPROM Controller (EEPROM) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CMD;			/* 0x0080 */
X  volatile uint32_t CMD;			 
N  __IO uint32_t ADDR;
X  volatile uint32_t ADDR;
N  __IO uint32_t WDATA;
X  volatile uint32_t WDATA;
N  __IO uint32_t RDATA;
X  volatile uint32_t RDATA;
N  __IO uint32_t WSTATE;			/* 0x0090 */
X  volatile uint32_t WSTATE;			 
N  __IO uint32_t CLKDIV;
X  volatile uint32_t CLKDIV;
N  __IO uint32_t PWRDWN;			/* 0x0098 */
X  volatile uint32_t PWRDWN;			 
N       uint32_t RESERVED0[975];
N  __IO uint32_t INT_CLR_ENABLE;	/* 0x0FD8 */
X  volatile uint32_t INT_CLR_ENABLE;	 
N  __IO uint32_t INT_SET_ENABLE;
X  volatile uint32_t INT_SET_ENABLE;
N  __IO uint32_t INT_STATUS;		/* 0x0FE0 */
X  volatile uint32_t INT_STATUS;		 
N  __IO uint32_t INT_ENABLE;
X  volatile uint32_t INT_ENABLE;
N  __IO uint32_t INT_CLR_STATUS;
X  volatile uint32_t INT_CLR_STATUS;
N  __IO uint32_t INT_SET_STATUS;
X  volatile uint32_t INT_SET_STATUS;
N} LPC_EEPROM_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_PERI_RAM_BASE     (0x20000000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHBRAM1_BASE      (0x20004000UL)
N#define LPC_AHB_BASE          (0x20080000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM0_BASE         (LPC_APB0_BASE + 0x14000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_IOCON_BASE        (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_UART4_BASE        (LPC_APB1_BASE + 0x24000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_SSP2_BASE         (LPC_APB1_BASE + 0x2C000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_MCI_BASE          (LPC_APB1_BASE + 0x40000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x00100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x00120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x00140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x00160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x00180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x001A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x001C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x001E0)
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x04000)
N#define LPC_LCD_BASE          (LPC_AHB_BASE  + 0x08000)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N#define LPC_CRC_BASE          (LPC_AHB_BASE  + 0x10000)
N#define LPC_GPIO0_BASE        (LPC_AHB_BASE  + 0x18000)
N#define LPC_GPIO1_BASE        (LPC_AHB_BASE  + 0x18020)
N#define LPC_GPIO2_BASE        (LPC_AHB_BASE  + 0x18040)
N#define LPC_GPIO3_BASE        (LPC_AHB_BASE  + 0x18060)
N#define LPC_GPIO4_BASE        (LPC_AHB_BASE  + 0x18080)
N#define LPC_GPIO5_BASE        (LPC_AHB_BASE  + 0x180A0)
N#define LPC_EMC_BASE          (LPC_AHB_BASE  + 0x1C000)
N
N#define LPC_EEPROM_BASE       (LPC_FLASH_BASE+ 0x200080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_UART0             ((LPC_UART_TypeDef      *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_UART4             ((LPC_UART4_TypeDef     *) LPC_UART4_BASE    )
N#define LPC_PWM0              ((LPC_PWM_TypeDef       *) LPC_PWM0_BASE     )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_IOCON             ((LPC_IOCON_TypeDef     *) LPC_IOCON_BASE    )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_SSP2              ((LPC_SSP_TypeDef       *) LPC_SSP2_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_MCI               ((LPC_MCI_TypeDef       *) LPC_MCI_BASE      )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_LCD               ((LPC_LCD_TypeDef       *) LPC_LCD_BASE      )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_GPIO5             ((LPC_GPIO_TypeDef      *) LPC_GPIO5_BASE    )
N#define LPC_EMC               ((LPC_EMC_TypeDef       *) LPC_EMC_BASE      )
N#define LPC_CRC               ((LPC_CRC_TypeDef       *) LPC_CRC_BASE      )
N#define LPC_EEPROM            ((LPC_EEPROM_TypeDef    *) LPC_EEPROM_BASE   )
N
N#endif  // __LPC177x_8x_H__
L 27 "..\Drivers\lpc177x_8x_uart.h" 2
N#include "lpc_types.h"
L 1 "..\Drivers\lpc_types.h" 1
N/***********************************************************************//**
N * @file		lpc_types.h
N * @brief		Contains the NXP ABL typedefs for C standard types.
N *     			It is intended to be used in ISO C conforming development
N *     			environments and checks for this insofar as it is possible
N *     			to do so.
N * @version		1.0
N * @date		18. September. 2010
N * @author		wellsk
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N/* Type group ----------------------------------------------------------- */
N#ifndef LPC_TYPES_H
N#define LPC_TYPES_H
N
N/* Includes ------------------------------------------------------------------- */
N#include <stdint.h>
N
N
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Types LPC_Types Public Types
N * @{
N */
N
N/**
N * @brief Boolean Type definition
N */
Ntypedef enum {FALSE = 0, TRUE = !FALSE} Bool;
N
N/**
N * @brief Flag Status and Interrupt Flag Status type definition
N */
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
N#define PARAM_SETSTATE(State) ((State==RESET) || (State==SET))
N
N/**
N * @brief Functional State Definition
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define PARAM_FUNCTIONALSTATE(State) ((State==DISABLE) || (State==ENABLE))
N
N/**
N * @ Status type definition
N */
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
N
N
N/**
N * Read/Write transfer type mode (Block or non-block)
N */
Ntypedef enum
N{
N	NONE_BLOCKING = 0,		/**< None Blocking type */
N	BLOCKING,				/**< Blocking type */
N} TRANSFER_BLOCK_Type;
N
N
N/** Pointer to Function returning Void (any number of parameters) */
Ntypedef void (*PFV)();
N
N/** Pointer to Function returning int32_t (any number of parameters) */
Ntypedef int32_t(*PFI)();
N
N/**
N * @}
N */
N
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Macros  LPC_Types Public Macros
N * @{
N */
N
N/* _BIT(n) sets the bit at position "n"
N * _BIT(n) is intended to be used in "OR" and "AND" expressions:
N * e.g., "(_BIT(3) | _BIT(7))".
N */
N#undef _BIT
N/* Set bit macro */
N#define _BIT(n)	(1<<n)
N
N/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
N * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
N * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
N */
N#undef _SBF
N/* Set bit field macro */
N#define _SBF(f,v) (v<<f)
N
N/* _BITMASK constructs a symbol with 'field_width' least significant
N * bits set.
N * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
N * The symbol is intended to be used to limit the bit field width
N * thusly:
N * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
N * If "any_expression" results in a value that is larger than can be
N * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
N * used with the _SBF example above, the example would be written:
N * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
N * This ensures that the value written to a_reg is no wider than
N * 16 bits, and makes the code easier to read and understand.
N */
N#undef _BITMASK
N/* Bitmask creation macro */
N#define _BITMASK(field_width) ( _BIT(field_width) - 1)
N
N/* NULL pointer */
N#ifndef NULL
S#define NULL ((void*) 0)
N#endif
N
N/* Number of elements in an array */
N#define NELEMENTS(array)  (sizeof (array) / sizeof (array[0]))
N
N/* Static data/function define */
N#define STATIC static
N/* External data/function define */
N#define EXTERN extern
N
N#define MAX(a, b) (((a) > (b)) ? (a) : (b))
N#define MIN(a, b) (((a) < (b)) ? (a) : (b))
N
N/**
N * @}
N */
N
N
N/* Old Type Definition compatibility ------------------------------------------ */
N/** @addtogroup LPC_Types_Public_Types LPC_Types Public Types
N * @{
N */
N
N/** SMA type for character type */
Ntypedef char CHAR;
N
N/** SMA type for 8 bit unsigned value */
Ntypedef uint8_t UNS_8;
N
N/** SMA type for 8 bit signed value */
Ntypedef int8_t INT_8;
N
N/** SMA type for 16 bit unsigned value */
Ntypedef	uint16_t UNS_16;
N
N/** SMA type for 16 bit signed value */
Ntypedef	int16_t INT_16;
N
N/** SMA type for 32 bit unsigned value */
Ntypedef	uint32_t UNS_32;
N
N/** SMA type for 32 bit signed value */
Ntypedef	int32_t INT_32;
N
N/** SMA type for 64 bit signed value */
Ntypedef int64_t INT_64;
N
N/** SMA type for 64 bit unsigned value */
Ntypedef uint64_t UNS_64;
N
N/** 32 bit boolean type */
Ntypedef Bool BOOL_32;
N
N/** 16 bit boolean type */
Ntypedef Bool BOOL_16;
N
N/** 8 bit boolean type */
Ntypedef Bool BOOL_8;
N
N/**
N * @}
N */
N
N
N#endif /* LPC_TYPES_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
L 28 "..\Drivers\lpc177x_8x_uart.h" 2
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup UART_Public_Macros  UART Public Macros
N * @{
N */
N
N/** UART time-out definitions in case of using Read() and Write function
N * with Blocking Flag mode
N */
N#define UART_BLOCKING_TIMEOUT			(0xFFFFFFUL)
N
N/**
N * @}
N */
N
N/* Private Macros ------------------------------------------------------------- */
N/** @defgroup UART_Private_Macros UART Private Macros
N * @{
N */
N
N/* Accepted Error baud rate value (in percent unit) */
N#define UART_ACCEPTED_BAUDRATE_ERROR	(3)			/*!< Acceptable UART baudrate error */
N
N
N/* --------------------- BIT DEFINITIONS -------------------------------------- */
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Receiver Buffer Register
N **********************************************************************/
N#define UART_RBR_MASKBIT   	((uint8_t)0xFF) 		/*!< UART Received Buffer mask bit (8 bits) */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Transmit Holding Register
N **********************************************************************/
N#define UART_THR_MASKBIT   	((uint8_t)0xFF) 		/*!< UART Transmit Holding mask bit (8 bits) */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Divisor Latch LSB register
N **********************************************************************/
N#define UART_LOAD_DLL(div)	((div) & 0xFF)	/**< Macro for loading least significant halfs of divisors */
N#define UART_DLL_MASKBIT	((uint8_t)0xFF)	/*!< Divisor latch LSB bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Divisor Latch MSB register
N **********************************************************************/
N#define UART_DLM_MASKBIT	((uint8_t)0xFF)			/*!< Divisor latch MSB bit mask */
N#define UART_LOAD_DLM(div)  (((div) >> 8) & 0xFF)	/**< Macro for loading most significant halfs of divisors */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART interrupt enable register
N **********************************************************************/
N#define UART_IER_RBRINT_EN		((uint32_t)(1<<0)) 	/*!< RBR Interrupt enable*/
N#define UART_IER_THREINT_EN		((uint32_t)(1<<1)) 	/*!< THR Interrupt enable*/
N#define UART_IER_RLSINT_EN		((uint32_t)(1<<2)) 	/*!< RX line status interrupt enable*/
N#define UART1_IER_MSINT_EN		((uint32_t)(1<<3))	/*!< Modem status interrupt enable */
N#define UART1_IER_CTSINT_EN		((uint32_t)(1<<7))	/*!< CTS1 signal transition interrupt enable */
N#define UART_IER_ABEOINT_EN		((uint32_t)(1<<8)) 	/*!< Enables the end of auto-baud interrupt */
N#define UART_IER_ABTOINT_EN		((uint32_t)(1<<9)) 	/*!< Enables the auto-baud time-out interrupt */
N#define UART_IER_BITMASK		((uint32_t)(0x307)) /*!< UART interrupt enable register bit mask */
N#define UART1_IER_BITMASK		((uint32_t)(0x38F)) /*!< UART1 interrupt enable register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART interrupt identification register
N **********************************************************************/
N#define UART_IIR_INTSTAT_PEND	((uint32_t)(1<<0))	/*!<Interrupt Status - Active low */
N#define UART_IIR_INTID_RLS		((uint32_t)(3<<1)) 	/*!<Interrupt identification: Receive line status*/
N#define UART_IIR_INTID_RDA		((uint32_t)(2<<1)) 	/*!<Interrupt identification: Receive data available*/
N#define UART_IIR_INTID_CTI		((uint32_t)(6<<1)) 	/*!<Interrupt identification: Character time-out indicator*/
N#define UART_IIR_INTID_THRE		((uint32_t)(1<<1)) 	/*!<Interrupt identification: THRE interrupt*/
N#define UART1_IIR_INTID_MODEM	((uint32_t)(0<<1)) 	/*!<Interrupt identification: Modem interrupt*/
N#define UART_IIR_INTID_MASK		((uint32_t)(7<<1))	/*!<Interrupt identification: Interrupt ID mask */
N#define UART_IIR_FIFO_EN		((uint32_t)(3<<6)) 	/*!<These bits are equivalent to UnFCR[0] */
N#define UART_IIR_ABEO_INT		((uint32_t)(1<<8)) 	/*!< End of auto-baud interrupt */
N#define UART_IIR_ABTO_INT		((uint32_t)(1<<9)) 	/*!< Auto-baud time-out interrupt */
N#define UART_IIR_BITMASK		((uint32_t)(0x3CF))	/*!< UART interrupt identification register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART FIFO control register
N **********************************************************************/
N#define UART_FCR_FIFO_EN		((uint8_t)(1<<0)) 	/*!< UART FIFO enable */
N#define UART_FCR_RX_RS			((uint8_t)(1<<1)) 	/*!< UART FIFO RX reset */
N#define UART_FCR_TX_RS			((uint8_t)(1<<2)) 	/*!< UART FIFO TX reset */
N#define UART_FCR_DMAMODE_SEL 	((uint8_t)(1<<3)) 	/*!< UART DMA mode selection */
N#define UART_FCR_TRG_LEV0		((uint8_t)(0)) 		/*!< UART FIFO trigger level 0: 1 character */
N#define UART_FCR_TRG_LEV1		((uint8_t)(1<<6)) 	/*!< UART FIFO trigger level 1: 4 character */
N#define UART_FCR_TRG_LEV2		((uint8_t)(2<<6)) 	/*!< UART FIFO trigger level 2: 8 character */
N#define UART_FCR_TRG_LEV3		((uint8_t)(3<<6)) 	/*!< UART FIFO trigger level 3: 14 character */
N#define UART_FCR_BITMASK		((uint8_t)(0xCF))	/*!< UART FIFO control bit mask */
N#define UART_TX_FIFO_SIZE		(16)
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART line control register
N **********************************************************************/
N#define UART_LCR_WLEN5     		((uint8_t)(0))   		/*!< UART 5 bit data mode */
N#define UART_LCR_WLEN6     		((uint8_t)(1<<0))   	/*!< UART 6 bit data mode */
N#define UART_LCR_WLEN7     		((uint8_t)(2<<0))   	/*!< UART 7 bit data mode */
N#define UART_LCR_WLEN8     		((uint8_t)(3<<0))   	/*!< UART 8 bit data mode */
N#define UART_LCR_STOPBIT_SEL	((uint8_t)(1<<2))   	/*!< UART Two Stop Bits Select */
N#define UART_LCR_PARITY_EN		((uint8_t)(1<<3))		/*!< UART Parity Enable */
N#define UART_LCR_PARITY_ODD		((uint8_t)(0))         	/*!< UART Odd Parity Select */
N#define UART_LCR_PARITY_EVEN	((uint8_t)(1<<4))		/*!< UART Even Parity Select */
N#define UART_LCR_PARITY_F_1		((uint8_t)(2<<4))		/*!< UART force 1 stick parity */
N#define UART_LCR_PARITY_F_0		((uint8_t)(3<<4))		/*!< UART force 0 stick parity */
N#define UART_LCR_BREAK_EN		((uint8_t)(1<<6))		/*!< UART Transmission Break enable */
N#define UART_LCR_DLAB_EN		((uint8_t)(1<<7))    	/*!< UART Divisor Latches Access bit enable */
N#define UART_LCR_BITMASK		((uint8_t)(0xFF))		/*!< UART line control bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 Modem Control Register
N **********************************************************************/
N#define UART1_MCR_DTR_CTRL		((uint8_t)(1<<0))		/*!< Source for modem output pin DTR */
N#define UART1_MCR_RTS_CTRL		((uint8_t)(1<<1))		/*!< Source for modem output pin RTS */
N#define UART1_MCR_LOOPB_EN		((uint8_t)(1<<4))		/*!< Loop back mode select */
N#define UART1_MCR_AUTO_RTS_EN	((uint8_t)(1<<6))		/*!< Enable Auto RTS flow-control */
N#define UART1_MCR_AUTO_CTS_EN	((uint8_t)(1<<7))		/*!< Enable Auto CTS flow-control */
N#define UART1_MCR_BITMASK		((uint8_t)(0x0F3))		/*!< UART1 bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART line status register
N **********************************************************************/
N#define UART_LSR_RDR		((uint8_t)(1<<0)) 	/*!<Line status register: Receive data ready*/
N#define UART_LSR_OE			((uint8_t)(1<<1)) 	/*!<Line status register: Overrun error*/
N#define UART_LSR_PE			((uint8_t)(1<<2)) 	/*!<Line status register: Parity error*/
N#define UART_LSR_FE			((uint8_t)(1<<3)) 	/*!<Line status register: Framing error*/
N#define UART_LSR_BI			((uint8_t)(1<<4)) 	/*!<Line status register: Break interrupt*/
N#define UART_LSR_THRE		((uint8_t)(1<<5)) 	/*!<Line status register: Transmit holding register empty*/
N#define UART_LSR_TEMT		((uint8_t)(1<<6)) 	/*!<Line status register: Transmitter empty*/
N#define UART_LSR_RXFE		((uint8_t)(1<<7)) 	/*!<Error in RX FIFO*/
N#define UART_LSR_BITMASK	((uint8_t)(0xFF)) 	/*!<UART Line status bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Modem (UART1 only) status register
N **********************************************************************/
N#define UART1_MSR_DELTA_CTS		((uint8_t)(1<<0))	/*!< Set upon state change of input CTS */
N#define UART1_MSR_DELTA_DSR		((uint8_t)(1<<1))	/*!< Set upon state change of input DSR */
N#define UART1_MSR_LO2HI_RI		((uint8_t)(1<<2))	/*!< Set upon low to high transition of input RI */
N#define UART1_MSR_DELTA_DCD		((uint8_t)(1<<3))	/*!< Set upon state change of input DCD */
N#define UART1_MSR_CTS			((uint8_t)(1<<4))	/*!< Clear To Send State */
N#define UART1_MSR_DSR			((uint8_t)(1<<5))	/*!< Data Set Ready State */
N#define UART1_MSR_RI			((uint8_t)(1<<6))	/*!< Ring Indicator State */
N#define UART1_MSR_DCD			((uint8_t)(1<<7))	/*!< Data Carrier Detect State */
N#define UART1_MSR_BITMASK		((uint8_t)(0xFF))	/*!< MSR register bit-mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Scratch Pad Register
N **********************************************************************/
N#define UART_SCR_BIMASK		((uint8_t)(0xFF))	/*!< UART Scratch Pad bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Auto baudrate control register
N **********************************************************************/
N#define UART_ACR_START				((uint32_t)(1<<0))	/**< UART Auto-baud start */
N#define UART_ACR_MODE				((uint32_t)(1<<1))	/**< UART Auto baudrate Mode 1 */
N#define UART_ACR_AUTO_RESTART		((uint32_t)(1<<2))	/**< UART Auto baudrate restart */
N#define UART_ACR_ABEOINT_CLR		((uint32_t)(1<<8))	/**< UART End of auto-baud interrupt clear */
N#define UART_ACR_ABTOINT_CLR		((uint32_t)(1<<9))	/**< UART Auto-baud time-out interrupt clear */
N#define UART_ACR_BITMASK			((uint32_t)(0x307))	/**< UART Auto Baudrate register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART IrDA control register
N **********************************************************************/
N#define UART_ICR_IRDAEN			((uint32_t)(1<<0))			/**< IrDA mode enable */
N#define UART_ICR_IRDAINV		((uint32_t)(1<<1))			/**< IrDA serial input inverted */
N#define UART_ICR_FIXPULSE_EN	((uint32_t)(1<<2))			/**< IrDA fixed pulse width mode */
N#define UART_ICR_PULSEDIV(n)	((uint32_t)((n&0x07)<<3))	/**< PulseDiv - Configures the pulse when FixPulseEn = 1 */
N#define UART_ICR_BITMASK		((uint32_t)(0x3F))			/*!< UART IRDA bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Fractional divider register
N **********************************************************************/
N#define UART_FDR_DIVADDVAL(n)	((uint32_t)(n&0x0F))		/**< Baud-rate generation pre-scaler divisor */
N#define UART_FDR_MULVAL(n)		((uint32_t)((n<<4)&0xF0))	/**< Baud-rate pre-scaler multiplier value */
N#define UART_FDR_BITMASK		((uint32_t)(0xFF))			/**< UART Fractional Divider register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Tx Enable register
N **********************************************************************/
N#define UART_TER_TXEN			((uint8_t)(1<<7)) 		/*!< Transmit enable bit */
N#define UART_TER_BITMASK		((uint8_t)(0x80))		/**< UART Transmit Enable Register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS485 Control register
N **********************************************************************/
N#define UART1_RS485CTRL_NMM_EN		((uint32_t)(1<<0))	/*!< RS-485/EIA-485 Normal Multi-drop Mode (NMM)
N														is disabled */
N#define UART1_RS485CTRL_RX_DIS		((uint32_t)(1<<1))	/*!< The receiver is disabled */
N#define UART1_RS485CTRL_AADEN		((uint32_t)(1<<2))	/*!< Auto Address Detect (AAD) is enabled */
N#define UART1_RS485CTRL_SEL_DTR		((uint32_t)(1<<3))	/*!< If direction control is enabled
N														(bit DCTRL = 1), pin DTR is used for direction control */
N#define UART1_RS485CTRL_DCTRL_EN	((uint32_t)(1<<4))	/*!< Enable Auto Direction Control */
N#define UART1_RS485CTRL_OINV_1		((uint32_t)(1<<5))	/*!< This bit reverses the polarity of the direction
N														control signal on the RTS (or DTR) pin. The direction control pin
N														will be driven to logic "1" when the transmitter has data to be sent */
N#define UART1_RS485CTRL_BITMASK		((uint32_t)(0x3F))	/**< RS485 control bit-mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS-485 Address Match register
N **********************************************************************/
N#define UART1_RS485ADRMATCH_BITMASK ((uint8_t)(0xFF)) 	/**< Bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS-485 Delay value register
N **********************************************************************/
N/* Macro defines for UART1 RS-485 Delay value register */
N#define UART1_RS485DLY_BITMASK		((uint8_t)(0xFF)) 	/** Bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART FIFO Level register
N **********************************************************************/
N#define UART_FIFOLVL_RXFIFOLVL(n)	((uint32_t)(n&0x0F))		/**< Reflects the current level of the UART receiver FIFO */
N#define UART_FIFOLVL_TXFIFOLVL(n)	((uint32_t)((n>>8)&0x0F))	/**< Reflects the current level of the UART transmitter FIFO */
N#define UART_FIFOLVL_BITMASK		((uint32_t)(0x0F0F))		/**< UART FIFO Level Register bit mask */
N
N
N/**
N * @}
N */
N
N
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup UART_Public_Types UART Public Types
N * @{
N */
N
N/**
N * @brief UART Databit type definitions
N */
Ntypedef enum {
N	UART_DATABIT_5		= 0,     		/*!< UART 5 bit data mode */
N	UART_DATABIT_6,		     			/*!< UART 6 bit data mode */
N	UART_DATABIT_7,		     			/*!< UART 7 bit data mode */
N	UART_DATABIT_8		     			/*!< UART 8 bit data mode */
N} UART_DATABIT_Type;
N
N/**
N * @brief UART Stop bit type definitions
N */
Ntypedef enum {
N	UART_STOPBIT_1		= (0),   					/*!< UART 1 Stop Bits Select */
N	UART_STOPBIT_2,		 							/*!< UART Two Stop Bits Select */
N} UART_STOPBIT_Type;
N
N/**
N * @brief UART Parity type definitions
N */
Ntypedef enum {
N	UART_PARITY_NONE 	= 0,					/*!< No parity */
N	UART_PARITY_ODD,	 						/*!< Odd parity */
N	UART_PARITY_EVEN, 							/*!< Even parity */
N	UART_PARITY_SP_1, 							/*!< Forced "1" stick parity */
N	UART_PARITY_SP_0 							/*!< Forced "0" stick parity */
N} UART_PARITY_Type;
N
N/**
N * @brief FIFO Level type definitions
N */
Ntypedef enum {
N	UART_FIFO_TRGLEV0 = 0,	/*!< UART FIFO trigger level 0: 1 character */
N	UART_FIFO_TRGLEV1, 		/*!< UART FIFO trigger level 1: 4 character */
N	UART_FIFO_TRGLEV2,		/*!< UART FIFO trigger level 2: 8 character */
N	UART_FIFO_TRGLEV3		/*!< UART FIFO trigger level 3: 14 character */
N} UART_FITO_LEVEL_Type;
N
N/********************************************************************//**
N* @brief UART Interrupt Type definitions
N**********************************************************************/
Ntypedef enum {
N	UART_INTCFG_RBR = 0,	/*!< RBR Interrupt enable*/
N	UART_INTCFG_THRE,		/*!< THR Interrupt enable*/
N	UART_INTCFG_RLS,		/*!< RX line status interrupt enable*/
N	UART1_INTCFG_MS,		/*!< Modem status interrupt enable (UART1 only) */
N	UART1_INTCFG_CTS,		/*!< CTS1 signal transition interrupt enable (UART1 only) */
N	UART_INTCFG_ABEO,		/*!< Enables the end of auto-baud interrupt */
N	UART_INTCFG_ABTO		/*!< Enables the auto-baud time-out interrupt */
N} UART_INT_Type;
N
N/**
N * @brief UART Line Status Type definition
N */
Ntypedef enum {
N	UART_LINESTAT_RDR	= UART_LSR_RDR,			/*!<Line status register: Receive data ready*/
X	UART_LINESTAT_RDR	= ((uint8_t)(1<<0)),			 
N	UART_LINESTAT_OE	= UART_LSR_OE,			/*!<Line status register: Overrun error*/
X	UART_LINESTAT_OE	= ((uint8_t)(1<<1)),			 
N	UART_LINESTAT_PE	= UART_LSR_PE,			/*!<Line status register: Parity error*/
X	UART_LINESTAT_PE	= ((uint8_t)(1<<2)),			 
N	UART_LINESTAT_FE	= UART_LSR_FE,			/*!<Line status register: Framing error*/
X	UART_LINESTAT_FE	= ((uint8_t)(1<<3)),			 
N	UART_LINESTAT_BI	= UART_LSR_BI,			/*!<Line status register: Break interrupt*/
X	UART_LINESTAT_BI	= ((uint8_t)(1<<4)),			 
N	UART_LINESTAT_THRE	= UART_LSR_THRE,		/*!<Line status register: Transmit holding register empty*/
X	UART_LINESTAT_THRE	= ((uint8_t)(1<<5)),		 
N	UART_LINESTAT_TEMT	= UART_LSR_TEMT,		/*!<Line status register: Transmitter empty*/
X	UART_LINESTAT_TEMT	= ((uint8_t)(1<<6)),		 
N	UART_LINESTAT_RXFE	= UART_LSR_RXFE			/*!<Error in RX FIFO*/
X	UART_LINESTAT_RXFE	= ((uint8_t)(1<<7))			 
N} UART_LS_Type;
N
N/**
N * @brief UART Auto-baudrate mode type definition
N */
Ntypedef enum {
N	UART_AUTOBAUD_MODE0				= 0,			/**< UART Auto baudrate Mode 0 */
N	UART_AUTOBAUD_MODE1,							/**< UART Auto baudrate Mode 1 */
N} UART_AB_MODE_Type;
N
N/**
N * @brief Auto Baudrate mode configuration type definition
N */
Ntypedef struct {
N	UART_AB_MODE_Type	ABMode;			/**< Autobaudrate mode */
N	FunctionalState		AutoRestart;	/**< Auto Restart state */
N} UART_AB_CFG_Type;
N
N/**
N * @brief UART End of Auto-baudrate type definition
N */
Ntypedef enum {
N	UART_AUTOBAUD_INTSTAT_ABEO		= UART_IIR_ABEO_INT,		/**< UART End of auto-baud interrupt  */
X	UART_AUTOBAUD_INTSTAT_ABEO		= ((uint32_t)(1<<8)),		 
N	UART_AUTOBAUD_INTSTAT_ABTO		= UART_IIR_ABTO_INT			/**< UART Auto-baud time-out interrupt  */
X	UART_AUTOBAUD_INTSTAT_ABTO		= ((uint32_t)(1<<9))			 
N}UART_ABEO_Type;
N
N/**
N * UART IrDA Control type Definition
N */
Ntypedef enum {
N	UART_IrDA_PULSEDIV2		= 0,		/**< Pulse width = 2 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV4,				/**< Pulse width = 4 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV8,				/**< Pulse width = 8 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV16,				/**< Pulse width = 16 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV32,				/**< Pulse width = 32 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV64,				/**< Pulse width = 64 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV128,				/**< Pulse width = 128 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV256				/**< Pulse width = 256 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N} UART_IrDA_PULSE_Type;
N
N/********************************************************************//**
N* @brief UART1 Full modem -  Signal states definition
N**********************************************************************/
Ntypedef enum {
N	INACTIVE = 0,			/* In-active state */
N	ACTIVE = !INACTIVE 		/* Active state */
N}UART1_SignalState;
N
N/**
N * @brief UART modem status type definition
N */
Ntypedef enum {
N	UART1_MODEM_STAT_DELTA_CTS	= UART1_MSR_DELTA_CTS,		/*!< Set upon state change of input CTS */
X	UART1_MODEM_STAT_DELTA_CTS	= ((uint8_t)(1<<0)),		 
N	UART1_MODEM_STAT_DELTA_DSR	= UART1_MSR_DELTA_DSR,		/*!< Set upon state change of input DSR */
X	UART1_MODEM_STAT_DELTA_DSR	= ((uint8_t)(1<<1)),		 
N	UART1_MODEM_STAT_LO2HI_RI	= UART1_MSR_LO2HI_RI,		/*!< Set upon low to high transition of input RI */
X	UART1_MODEM_STAT_LO2HI_RI	= ((uint8_t)(1<<2)),		 
N	UART1_MODEM_STAT_DELTA_DCD	= UART1_MSR_DELTA_DCD,		/*!< Set upon state change of input DCD */
X	UART1_MODEM_STAT_DELTA_DCD	= ((uint8_t)(1<<3)),		 
N	UART1_MODEM_STAT_CTS		= UART1_MSR_CTS,			/*!< Clear To Send State */
X	UART1_MODEM_STAT_CTS		= ((uint8_t)(1<<4)),			 
N	UART1_MODEM_STAT_DSR		= UART1_MSR_DSR,			/*!< Data Set Ready State */
X	UART1_MODEM_STAT_DSR		= ((uint8_t)(1<<5)),			 
N	UART1_MODEM_STAT_RI			= UART1_MSR_RI,				/*!< Ring Indicator State */
X	UART1_MODEM_STAT_RI			= ((uint8_t)(1<<6)),				 
N	UART1_MODEM_STAT_DCD		= UART1_MSR_DCD				/*!< Data Carrier Detect State */
X	UART1_MODEM_STAT_DCD		= ((uint8_t)(1<<7))				 
N} UART_MODEM_STAT_type;
N
N/**
N * @brief Modem output pin type definition
N */
Ntypedef enum {
N	UART1_MODEM_PIN_DTR			= 0,		/*!< Source for modem output pin DTR */
N	UART1_MODEM_PIN_RTS						/*!< Source for modem output pin RTS */
N} UART_MODEM_PIN_Type;
N
N/**
N * @brief UART Modem mode type definition
N */
Ntypedef enum {
N	UART1_MODEM_MODE_LOOPBACK	= 0,		/*!< Loop back mode select */
N	UART1_MODEM_MODE_AUTO_RTS,				/*!< Enable Auto RTS flow-control */
N	UART1_MODEM_MODE_AUTO_CTS 				/*!< Enable Auto CTS flow-control */
N} UART_MODEM_MODE_Type;
N
N/**
N * @brief UART Direction Control Pin type definition
N */
Ntypedef enum {
N	UART1_RS485_DIRCTRL_RTS = 0,	/**< Pin RTS is used for direction control */
N	UART1_RS485_DIRCTRL_DTR			/**< Pin DTR is used for direction control */
N} UART_RS485_DIRCTRL_PIN_Type;
N
N/********************************************************************//**
N* @brief UART Configuration Structure definition
N**********************************************************************/
Ntypedef struct {
N  uint32_t Baud_rate;   		/**< UART baud rate */
N  UART_PARITY_Type Parity;    	/**< Parity selection, should be:
N							   - UART_PARITY_NONE: No parity
N							   - UART_PARITY_ODD: Odd parity
N							   - UART_PARITY_EVEN: Even parity
N							   - UART_PARITY_SP_1: Forced "1" stick parity
N							   - UART_PARITY_SP_0: Forced "0" stick parity
N							   */
N  UART_DATABIT_Type Databits;   /**< Number of data bits, should be:
N							   - UART_DATABIT_5: UART 5 bit data mode
N							   - UART_DATABIT_6: UART 6 bit data mode
N							   - UART_DATABIT_7: UART 7 bit data mode
N							   - UART_DATABIT_8: UART 8 bit data mode
N							   */
N  UART_STOPBIT_Type Stopbits;   /**< Number of stop bits, should be:
N							   - UART_STOPBIT_1: UART 1 Stop Bits Select
N							   - UART_STOPBIT_2: UART 2 Stop Bits Select
N							   */
N} UART_CFG_Type;
N
N/********************************************************************//**
N* @brief UART FIFO Configuration Structure definition
N**********************************************************************/
N
Ntypedef struct {
N	FunctionalState FIFO_ResetRxBuf;	/**< Reset Rx FIFO command state , should be:
N										 - ENABLE: Reset Rx FIFO in UART
N										 - DISABLE: Do not reset Rx FIFO  in UART
N										 */
N	FunctionalState FIFO_ResetTxBuf;	/**< Reset Tx FIFO command state , should be:
N										 - ENABLE: Reset Tx FIFO in UART
N										 - DISABLE: Do not reset Tx FIFO  in UART
N										 */
N	FunctionalState FIFO_DMAMode;		/**< DMA mode, should be:
N										 - ENABLE: Enable DMA mode in UART
N										 - DISABLE: Disable DMA mode in UART
N										 */
N	UART_FITO_LEVEL_Type FIFO_Level;	/**< Rx FIFO trigger level, should be:
N										- UART_FIFO_TRGLEV0: UART FIFO trigger level 0: 1 character
N										- UART_FIFO_TRGLEV1: UART FIFO trigger level 1: 4 character
N										- UART_FIFO_TRGLEV2: UART FIFO trigger level 2: 8 character
N										- UART_FIFO_TRGLEV3: UART FIFO trigger level 3: 14 character
N										*/
N} UART_FIFO_CFG_Type;
N
N/********************************************************************//**
N* @brief UART1 Full modem -  RS485 Control configuration type
N**********************************************************************/
Ntypedef struct {
N	FunctionalState NormalMultiDropMode_State; /*!< Normal MultiDrop mode State:
N													- ENABLE: Enable this function.
N													- DISABLE: Disable this function. */
N	FunctionalState Rx_State;					/*!< Receiver State:
N													- ENABLE: Enable Receiver.
N													- DISABLE: Disable Receiver. */
N	FunctionalState AutoAddrDetect_State;		/*!< Auto Address Detect mode state:
N												- ENABLE: ENABLE this function.
N												- DISABLE: Disable this function. */
N	FunctionalState AutoDirCtrl_State;			/*!< Auto Direction Control State:
N												- ENABLE: Enable this function.
N												- DISABLE: Disable this function. */
N	UART_RS485_DIRCTRL_PIN_Type DirCtrlPin;		/*!< If direction control is enabled, state:
N												- UART1_RS485_DIRCTRL_RTS:
N												pin RTS is used for direction control.
N												- UART1_RS485_DIRCTRL_DTR:
N												pin DTR is used for direction control. */
N	 SetState DirCtrlPol_Level;					/*!< Polarity of the direction control signal on
N												the RTS (or DTR) pin:
N												- RESET: The direction control pin will be driven
N												to logic "0" when the transmitter has data to be sent.
N												- SET: The direction control pin will be driven
N												to logic "1" when the transmitter has data to be sent. */
N	uint8_t MatchAddrValue;					/*!< address match value for RS-485/EIA-485 mode, 8-bit long */
N	uint8_t DelayValue;						/*!< delay time is in periods of the baud clock, 8-bit long */
N} UART1_RS485_CTRLCFG_Type;
N
N/**
N * @}
N */
N
N
N/* Public Functions ----------------------------------------------------------- */
N/** @defgroup UART_Public_Functions UART Public Functions
N * @{
N */
N/* UART Init/DeInit functions --------------------------------------------------*/
Nvoid UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct);
Nvoid UART_DeInit(LPC_UART_TypeDef* UARTx);
Nvoid UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct);
N
N/* UART Send/Receive functions -------------------------------------------------*/
Nvoid UART_SendByte(LPC_UART_TypeDef* UARTx, uint8_t Data);
Nuint8_t UART_ReceiveByte(LPC_UART_TypeDef* UARTx);
Nuint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
N		uint32_t buflen, TRANSFER_BLOCK_Type flag);
Nuint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
N		uint32_t buflen, TRANSFER_BLOCK_Type flag);
Xuint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, 		uint32_t buflen, TRANSFER_BLOCK_Type flag);
N
N/* UART FIFO functions ----------------------------------------------------------*/
Nvoid UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg);
Nvoid UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct);
N
N/* UART get information functions -----------------------------------------------*/
Nuint32_t UART_GetIntId(LPC_UART_TypeDef* UARTx);
Nuint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx);
N
N/* UART operate functions -------------------------------------------------------*/
Nvoid UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, \
N				FunctionalState NewState);
Xvoid UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, 				FunctionalState NewState);
Nvoid UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState);
NFlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx);
Nvoid UART_ForceBreak(LPC_UART_TypeDef* UARTx);
N
N/* UART Auto-baud functions -----------------------------------------------------*/
Nvoid UART_ABClearIntPending(LPC_UART_TypeDef *UARTx, UART_ABEO_Type ABIntType);
Nvoid UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
N				FunctionalState NewState);
Xvoid UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, 				FunctionalState NewState);
N
N/* UART1 FullModem functions ----------------------------------------------------*/
Nvoid UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
N							UART1_SignalState NewState);
Xvoid UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, 							UART1_SignalState NewState);
Nvoid UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
N							FunctionalState NewState);
Xvoid UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, 							FunctionalState NewState);
Nuint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx);
N
N/* UART RS485 functions ----------------------------------------------------------*/
Nvoid UART_RS485Config(LPC_UART_TypeDef *UARTx,
N									UART1_RS485_CTRLCFG_Type *RS485ConfigStruct);
Nvoid UART_RS485ReceiverCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState);
Nvoid UART_RS485SendSlvAddr(LPC_UART_TypeDef *UARTx, uint8_t SlvAddr);
Nuint32_t UART_RS485SendData(LPC_UART_TypeDef *UARTx, uint8_t *pData, uint32_t size);
N
N/* UART IrDA functions-------------------------------------------------------------*/
Nvoid UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
Nvoid UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
Nvoid UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv);
N/**
N * @}
N */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __LPC178X_UART_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
L 24 "..\Drivers\debug_frmwrk.h" 2
N
N#define USED_UART_DEBUG_PORT	0// 1
N
N#define NUM_SKIPPED_ALLOWED			(10)
N
N#define DBG_GETVAL_IN_DEC			(0)
N#define DBG_GETVAL_IN_HEX			(1)
N//#define DBG_GETVAL_IN_CHARS			(2)
N
N#if (USED_UART_DEBUG_PORT == 0)
X#if (0 == 0)
N#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART0
N#elif (USED_UART_DEBUG_PORT == 1)
S#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART1
S#elif (USED_UART_DEBUG_PORT == 2)
S#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART2
N#endif
N
N#define put_str(x)							_db_msg(DEBUG_UART_PORT, x)
N#define put_str_(x)							_db_msg_(DEBUG_UART_PORT, x)
N
W "..\Drivers\debug_frmwrk.h" 44 10 incompatible redefinition of macro "putchar" (declared at line 681 of "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdio.h")
N#define  putchar(x)						    _db_char(DEBUG_UART_PORT, x)
N
N#define _DBD(x)								_db_dec(DEBUG_UART_PORT, x)
N#define _DBD16(x)							_db_dec_16(DEBUG_UART_PORT, x)
N#define _DBD32(x)							_db_dec_32(DEBUG_UART_PORT, x)
N
N#define _DBH(x)								_db_hex(DEBUG_UART_PORT, x)
N#define _DBH16(x)							_db_hex_16(DEBUG_UART_PORT, x)
N#define _DBH32(x)							_db_hex_32(DEBUG_UART_PORT, x)
N
N#define _DBH_(x)							_db_hex_(DEBUG_UART_PORT, x)
N#define _DBH16_(x)							_db_hex_16_(DEBUG_UART_PORT, x)
N#define _DBH32_(x)							_db_hex_32_(DEBUG_UART_PORT, x)
N
N#define getkey()							_db_get_key(DEBUG_UART_PORT)
W "..\Drivers\debug_frmwrk.h" 59 9 incompatible redefinition of macro "getchar" (declared at line 648 of "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdio.h")
N#define getchar()							_db_get_char(DEBUG_UART_PORT)
N#define _DGV(option, numCh, val)			_db_get_val(DEBUG_UART_PORT, option, numCh, val)
N
N//void  _printf (const  char *format, ...);
N
Nextern void (*_db_msg)(LPC_UART_TypeDef *UARTx, const void *s);
Nextern void (*_db_msg_)(LPC_UART_TypeDef *UARTx, const void *s);
Nextern void (*_db_char)(LPC_UART_TypeDef *UARTx, uint8_t ch);
Nextern void (*_db_dec)(LPC_UART_TypeDef *UARTx, uint8_t decn);
Nextern void (*_db_dec_16)(LPC_UART_TypeDef *UARTx, uint16_t decn);
Nextern void (*_db_dec_32)(LPC_UART_TypeDef *UARTx, uint32_t decn);
Nextern void (*_db_hex)(LPC_UART_TypeDef *UARTx, uint8_t hexn);
Nextern void (*_db_hex_16)(LPC_UART_TypeDef *UARTx, uint16_t hexn);
Nextern void (*_db_hex_32)(LPC_UART_TypeDef *UARTx, uint32_t hexn);
Nextern void (*_db_hex_)(LPC_UART_TypeDef *UARTx, uint8_t hexn);
Nextern void (*_db_hex_16_)(LPC_UART_TypeDef *UARTx, uint16_t hexn);
Nextern void (*_db_hex_32_)(LPC_UART_TypeDef *UARTx, uint32_t hexn);
N
Nextern uint8_t (*_db_get_key)(LPC_UART_TypeDef *UARTx);
Nextern uint8_t (*_db_get_char)(LPC_UART_TypeDef *UARTx);
Nextern uint8_t (*_db_get_val)(LPC_UART_TypeDef *UARTx, uint8_t option, uint8_t numCh, uint32_t * val);
N
Nuint8_t UARTGetValue (LPC_UART_TypeDef *UARTx, uint8_t option,
N											uint8_t numCh, uint32_t* val);
Nvoid UARTPutChar (LPC_UART_TypeDef *UARTx, uint8_t ch);
Nvoid UARTPuts(LPC_UART_TypeDef *UARTx, const void *str);
Nvoid UARTPuts_(LPC_UART_TypeDef *UARTx, const void *str);
Nvoid UARTPutDec(LPC_UART_TypeDef *UARTx, uint8_t decnum);
Nvoid UARTPutDec16(LPC_UART_TypeDef *UARTx, uint16_t decnum);
Nvoid UARTPutDec32(LPC_UART_TypeDef *UARTx, uint32_t decnum);
Nvoid UARTPutHex (LPC_UART_TypeDef *UARTx, uint8_t hexnum);
Nvoid UARTPutHex16 (LPC_UART_TypeDef *UARTx, uint16_t hexnum);
Nvoid UARTPutHex32 (LPC_UART_TypeDef *UARTx, uint32_t hexnum);
Nuint8_t UARTGetChar (LPC_UART_TypeDef *UARTx);
Nuint8_t UARTGetKey (LPC_UART_TypeDef *UARTx);
Nvoid debug_frmwrk_init(void);
N
N#endif /* DEBUG_FRMWRK_H_ */
L 40 "..\fs\yaffs_guts.c" 2
N
N/* Robustification (if it ever comes about...) */
Nstatic void yaffs_RetireBlock(yaffs_Device * dev, int blockInNAND);
Nstatic void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND, int erasedOk);
Nstatic void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,
N				     const __u8 * data,
N				     const yaffs_ExtendedTags * tags);
Nstatic void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,
N				    const yaffs_ExtendedTags * tags);
N
N/* Other local prototypes */
Nstatic int yaffs_UnlinkObject( yaffs_Object *obj);
Nstatic int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj);
N
Nstatic void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList);
N
Nstatic int yaffs_WriteNewChunkWithTagsToNAND(yaffs_Device * dev,
N					     const __u8 * buffer,
N					     yaffs_ExtendedTags * tags,
N					     int useReserve);
Nstatic int yaffs_PutChunkIntoFile(yaffs_Object * in, int chunkInInode,
N				  int chunkInNAND, int inScan);
N
Nstatic yaffs_Object *yaffs_CreateNewObject(yaffs_Device * dev, int number,
N					   yaffs_ObjectType type);
Nstatic void yaffs_AddObjectToDirectory(yaffs_Object * directory,
N				       yaffs_Object * obj);
Nstatic int yaffs_UpdateObjectHeader(yaffs_Object * in, const YCHAR * name,
Xstatic int yaffs_UpdateObjectHeader(yaffs_Object * in, const char * name,
N				    int force, int isShrink, int shadows);
Nstatic void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj);
Nstatic int yaffs_CheckStructures(void);
Nstatic int yaffs_DeleteWorker(yaffs_Object * in, yaffs_Tnode * tn, __u32 level,
N			      int chunkOffset, int *limit);
Nstatic int yaffs_DoGenericObjectDeletion(yaffs_Object * in);
N
Nstatic yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blockNo);
N
N
Nstatic int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
N				  int chunkInNAND);
N
Nstatic int yaffs_UnlinkWorker(yaffs_Object * obj);
Nstatic void yaffs_DestroyObject(yaffs_Object * obj);
N
Nstatic int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,
N			   int chunkInObject);
N
Nloff_t yaffs_GetFileSize(yaffs_Object * obj);
N
Nstatic int yaffs_AllocateChunk(yaffs_Device * dev, int useReserve, yaffs_BlockInfo **blockUsedPtr);
N
Nstatic void yaffs_VerifyFreeChunks(yaffs_Device * dev);
N
Nstatic void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in);
N
Nstatic void yaffs_VerifyDirectory(yaffs_Object *directory);
N#ifdef YAFFS_PARANOID
Sstatic int yaffs_CheckFileSanity(yaffs_Object * in);
N#else
N#define yaffs_CheckFileSanity(in)
N#endif
N
Nstatic void yaffs_InvalidateWholeChunkCache(yaffs_Object * in);
Nstatic void yaffs_InvalidateChunkCache(yaffs_Object * object, int chunkId);
N
Nstatic void yaffs_InvalidateCheckpoint(yaffs_Device *dev);
N
Nstatic int yaffs_FindChunkInFile(yaffs_Object * in, int chunkInInode,
N				 yaffs_ExtendedTags * tags);
N
Nstatic __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos);
Nstatic yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device * dev,
N					  yaffs_FileStructure * fStruct,
N					  __u32 chunkId);
N
N
N/* Function to calculate chunk and offset */
N
Nstatic void yaffs_AddrToChunk(yaffs_Device *dev, loff_t addr, int *chunkOut, __u32 *offsetOut)
N{
N	int chunk;
N	__u32 offset;
N	
N	chunk  = (__u32)(addr >> dev->chunkShift);
N		
N	if(dev->chunkDiv == 1)
N	{
N		/* easy power of 2 case */
N		offset = (__u32)(addr & dev->chunkMask);
N	}
N	else
N	{
N		/* Non power-of-2 case */
N		
N		loff_t chunkBase;
N		
N		chunk /= dev->chunkDiv;
N		
N		chunkBase = ((loff_t)chunk) * dev->nDataBytesPerChunk;
N		offset = (__u32)(addr - chunkBase);
N	}
N
N	*chunkOut = chunk;
N	*offsetOut = offset;
N}
N
N/* Function to return the number of shifts for a power of 2 greater than or equal 
N * to the given number
N * Note we don't try to cater for all possible numbers and this does not have to
N * be hellishly efficient.
N */
N 
Nstatic __u32 ShiftsGE(__u32 x)
N{
N	int extraBits;
N	int nShifts;
N	
N	nShifts = extraBits = 0;
N	
N	while(x>1){
N		if(x & 1) extraBits++;
N		x>>=1;
N		nShifts++;
N	}
N
N	if(extraBits) 
N		nShifts++;
N		
N	return nShifts;
N}
N
N/* Function to return the number of shifts to get a 1 in bit 0
N */
N 
Nstatic __u32 Shifts(__u32 x)
N{
N	int nShifts;
N	
N	nShifts =  0;
N	
N	if(!x) return 0;
N	
N	while( !(x&1)){
N		x>>=1;
N		nShifts++;
N	}
N		
N	return nShifts;
N}
N
N
N
N/* 
N * Temporary buffer manipulations.
N */
N
Nstatic int yaffs_InitialiseTempBuffers(yaffs_Device *dev)	
N{
N	int i;
N	__u8 *buf = (__u8 *)1;
N		
N	memset(dev->tempBuffer,0,sizeof(dev->tempBuffer));
N	
N	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
X	for (i = 0; buf && i < 6; i++) {
N		dev->tempBuffer[i].line = 0;	/* not in use */
N		dev->tempBuffer[i].buffer = buf =
N		    YMALLOC_DMA(dev->totalBytesPerChunk);
X		    yaffs_malloc(dev->totalBytesPerChunk);
N	}
N    
N    return buf ? YAFFS_OK : YAFFS_FAIL;
X    return buf ? 1 : 0;
N	
N}
N
N__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo)
N{
N	int i, j;
N
N	dev->tempInUse++;
N	if(dev->tempInUse > dev->maxTemp)
N		dev->maxTemp = dev->tempInUse;
N
N	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
X	for (i = 0; i < 6; i++) {
N		if (dev->tempBuffer[i].line == 0) {
N			dev->tempBuffer[i].line = lineNo;
N			if ((i + 1) > dev->maxTemp) {
N				dev->maxTemp = i + 1;
N				for (j = 0; j <= i; j++)
N					dev->tempBuffer[j].maxLine =
N					    dev->tempBuffer[j].line;
N			}
N
N			return dev->tempBuffer[i].buffer;
N		}
N	}
N
N	T(YAFFS_TRACE_BUFFERS,
N	  (TSTR("Out of temp buffers at line %d, other held by lines:"),
N	   lineNo));
X	do{ if((0x00000400) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
X	for (i = 0; i < 6; i++) {
N		T(YAFFS_TRACE_BUFFERS, (TSTR(" %d "), dev->tempBuffer[i].line));
X		do{ if((0x00000400) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N	T(YAFFS_TRACE_BUFFERS, (TSTR(" " TENDSTR)));
X	do{ if((0x00000400) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	/*
N	 * If we got here then we have to allocate an unmanaged one
N	 * This is not good.
N	 */
N
N	dev->unmanagedTempAllocations++;
N	return YMALLOC(dev->nDataBytesPerChunk);
X	return yaffs_malloc(dev->nDataBytesPerChunk);
N
N}
N
Nvoid yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer,
N				    int lineNo)
N{
N	int i;
N	
N	dev->tempInUse--;
N	 
N	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) 
X	for (i = 0; i < 6; i++) 
N	{
N		if (dev->tempBuffer[i].buffer == buffer) 
N		{
N			dev->tempBuffer[i].line = 0;
N			return;
N		}
N	}
N 
N	if (buffer) {
N		/* assume it is an unmanaged one. */
N		T(YAFFS_TRACE_BUFFERS,
N		  (TSTR("Releasing unmanaged temp buffer in line %d" TENDSTR),
N		   lineNo));
X		do{ if((0x00000400) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	  
N		YFREE(buffer);
X		free(buffer);
N		dev->unmanagedTempDeallocations++;
N	}
N
N}
N
N/*
N * Determine if we have a managed buffer.
N */
Nint yaffs_IsManagedTempBuffer(yaffs_Device * dev, const __u8 * buffer)
N{
N	int i;
N	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
X	for (i = 0; i < 6; i++) {
N		if (dev->tempBuffer[i].buffer == buffer)
N			return 1;
N
N	}
N
N    for (i = 0; i < dev->nShortOpCaches; i++) {
N        if( dev->srCache[i].data == buffer )
N            return 1;
N
N    }
N
N    if (buffer == dev->checkpointBuffer)
N      return 1;
N
N    T(YAFFS_TRACE_ALWAYS,
N	  (TSTR("yaffs: unmaged buffer detected.\n" TENDSTR)));
X    do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N    return 0;
N}
N
N
N
N/*
N * Chunk bitmap manipulations
N */
N
Nstatic Y_INLINE __u8 *yaffs_BlockBits(yaffs_Device * dev, int blk)
Xstatic __inline __u8 *yaffs_BlockBits(yaffs_Device * dev, int blk)
N{
N	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
N		T(YAFFS_TRACE_ERROR,
N		  (TSTR("**>> yaffs: BlockBits block %d is not valid" TENDSTR),
N		   blk));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	return dev->chunkBits +
N	    (dev->chunkBitmapStride * (blk - dev->internalStartBlock));
N}
N
Nstatic Y_INLINE void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)
Xstatic __inline void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)
N{
N	if(blk < dev->internalStartBlock || blk > dev->internalEndBlock ||
N	   chunk < 0 || chunk >= dev->nChunksPerBlock) {
N	   T(YAFFS_TRACE_ERROR,
N	    (TSTR("**>> yaffs: Chunk Id (%d:%d) invalid"TENDSTR),blk,chunk));
X	   do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	    YBUG();
X	    ;
N	}
N}
N
Nstatic Y_INLINE void yaffs_ClearChunkBits(yaffs_Device * dev, int blk)
Xstatic __inline void yaffs_ClearChunkBits(yaffs_Device * dev, int blk)
N{
N	__u8 *blkBits = yaffs_BlockBits(dev, blk);
N
N	memset(blkBits, 0, dev->chunkBitmapStride);
N}
N
Nstatic Y_INLINE void yaffs_ClearChunkBit(yaffs_Device * dev, int blk, int chunk)
Xstatic __inline void yaffs_ClearChunkBit(yaffs_Device * dev, int blk, int chunk)
N{
N	__u8 *blkBits = yaffs_BlockBits(dev, blk);
N
N	yaffs_VerifyChunkBitId(dev,blk,chunk);
N
N	blkBits[chunk / 8] &= ~(1 << (chunk & 7));
N}
N
Nstatic Y_INLINE void yaffs_SetChunkBit(yaffs_Device * dev, int blk, int chunk)
Xstatic __inline void yaffs_SetChunkBit(yaffs_Device * dev, int blk, int chunk)
N{
N	__u8 *blkBits = yaffs_BlockBits(dev, blk);
N	
N	yaffs_VerifyChunkBitId(dev,blk,chunk);
N
N	blkBits[chunk / 8] |= (1 << (chunk & 7));
N}
N
Nstatic Y_INLINE int yaffs_CheckChunkBit(yaffs_Device * dev, int blk, int chunk)
Xstatic __inline int yaffs_CheckChunkBit(yaffs_Device * dev, int blk, int chunk)
N{
N	__u8 *blkBits = yaffs_BlockBits(dev, blk);
N	yaffs_VerifyChunkBitId(dev,blk,chunk);
N
N	return (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
N}
N
Nstatic Y_INLINE int yaffs_StillSomeChunkBits(yaffs_Device * dev, int blk)
Xstatic __inline int yaffs_StillSomeChunkBits(yaffs_Device * dev, int blk)
N{
N	__u8 *blkBits = yaffs_BlockBits(dev, blk);
N	int i;
N	for (i = 0; i < dev->chunkBitmapStride; i++) {
N		if (*blkBits)
N			return 1;
N		blkBits++;
N	}
N	return 0;
N}
N
Nstatic int yaffs_CountChunkBits(yaffs_Device * dev, int blk)
N{
N	__u8 *blkBits = yaffs_BlockBits(dev, blk);
N	int i;
N	int n = 0;
N	for (i = 0; i < dev->chunkBitmapStride; i++) {
N		__u8 x = *blkBits;
N		while(x){
N			if(x & 1)
N				n++;
N			x >>=1;
N		}
N			
N		blkBits++;
N	}
N	return n;
N}
N
N/* 
N * Verification code
N */
N 
Nstatic int yaffs_SkipVerification(yaffs_Device *dev)
N{
N	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
X	return !(yaffs_traceMask & (0x00010000 | 0x00040000));
N}
N
Nstatic int yaffs_SkipFullVerification(yaffs_Device *dev)
N{
N	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));
X	return !(yaffs_traceMask & (0x00040000));
N}
N
Nstatic int yaffs_SkipNANDVerification(yaffs_Device *dev)
N{
N	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));
X	return !(yaffs_traceMask & (0x00020000));
N}
N
Nstatic const char * blockStateName[] = {
N"Unknown",
N"Needs scanning",
N"Scanning",
N"Empty",
N"Allocating",
N"Full",
N"Dirty",
N"Checkpoint",
N"Collecting",
N"Dead"
N};
N
Nstatic void yaffs_VerifyBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)
N{
N	int actuallyUsed;
N	int inUse;
N	
N	if(yaffs_SkipVerification(dev))
N		return;
N		
N	/* Report illegal runtime states */
N	if(bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)
X	if(bi->blockState >= (YAFFS_BLOCK_STATE_DEAD + 1))
N		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has undefined state %d"TENDSTR),n,bi->blockState));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		
N	switch(bi->blockState){
N	 case YAFFS_BLOCK_STATE_UNKNOWN:
N	 case YAFFS_BLOCK_STATE_SCANNING:
N	 case YAFFS_BLOCK_STATE_NEEDS_SCANNING:
N		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has bad run-state %s"TENDSTR),
N		n,blockStateName[bi->blockState]));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N	
N	/* Check pages in use and soft deletions are legal */
N	
N	actuallyUsed = bi->pagesInUse - bi->softDeletions;
N	
N	if(bi->pagesInUse < 0 || bi->pagesInUse > dev->nChunksPerBlock ||
N	   bi->softDeletions < 0 || bi->softDeletions > dev->nChunksPerBlock ||
N	   actuallyUsed < 0 || actuallyUsed > dev->nChunksPerBlock)
N		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has illegal values pagesInUsed %d softDeletions %d"TENDSTR),
N		n,bi->pagesInUse,bi->softDeletions));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	
N		
N	/* Check chunk bitmap legal */
N	inUse = yaffs_CountChunkBits(dev,n);
N	if(inUse != bi->pagesInUse)
N		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has inconsistent values pagesInUse %d counted chunk bits %d"TENDSTR),
N			n,bi->pagesInUse,inUse));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	
N	/* Check that the sequence number is valid.
N	 * Ten million is legal, but is very unlikely 
N	 */
N	if(dev->isYaffs2 && 
N	   (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING || bi->blockState == YAFFS_BLOCK_STATE_FULL) &&
N	   (bi->sequenceNumber < YAFFS_LOWEST_SEQUENCE_NUMBER || bi->sequenceNumber > 10000000 ))
X	   (bi->sequenceNumber < 0x00001000 || bi->sequenceNumber > 10000000 ))
N		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has suspect sequence number of %d"TENDSTR),
N		n,bi->sequenceNumber));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		
N}
N
Nstatic void yaffs_VerifyCollectedBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)
N{
N	yaffs_VerifyBlock(dev,bi,n);
N	
N	/* After collection the block should be in the erased state */
N	/* This will need to change if we do partial gc */
N	
N	if(bi->blockState != YAFFS_BLOCK_STATE_COLLECTING &&
N	   bi->blockState != YAFFS_BLOCK_STATE_EMPTY){
N		T(YAFFS_TRACE_ERROR,(TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),
N			n,bi->blockState));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N}
N
Nstatic void yaffs_VerifyBlocks(yaffs_Device *dev)
N{
N	int i;
N	int nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];
X	int nBlocksPerState[(YAFFS_BLOCK_STATE_DEAD + 1)];
N	int nIllegalBlockStates = 0;
N	
N
N	if(yaffs_SkipVerification(dev))
N		return;
N
N	memset(nBlocksPerState,0,sizeof(nBlocksPerState));
N
N		
N	for(i = dev->internalStartBlock; i <= dev->internalEndBlock; i++){
N		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);
N		yaffs_VerifyBlock(dev,bi,i);
N
N		if(bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)
X		if(bi->blockState < (YAFFS_BLOCK_STATE_DEAD + 1))
N			nBlocksPerState[bi->blockState]++;
N		else
N			nIllegalBlockStates++;
N					
N	}
N	
N	T(YAFFS_TRACE_VERIFY,(TSTR(""TENDSTR)));
X	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	T(YAFFS_TRACE_VERIFY,(TSTR("Block summary"TENDSTR)));
X	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	
N	T(YAFFS_TRACE_VERIFY,(TSTR("%d blocks have illegal states"TENDSTR),nIllegalBlockStates));
X	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	if(nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
N		T(YAFFS_TRACE_VERIFY,(TSTR("Too many allocating blocks"TENDSTR)));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	for(i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
X	for(i = 0; i < (YAFFS_BLOCK_STATE_DEAD + 1); i++)
N		T(YAFFS_TRACE_VERIFY,
N		  (TSTR("%s %d blocks"TENDSTR),
N		  blockStateName[i],nBlocksPerState[i]));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	
N	if(dev->blocksInCheckpoint != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])
N		T(YAFFS_TRACE_VERIFY,
N		 (TSTR("Checkpoint block count wrong dev %d count %d"TENDSTR),
N		 dev->blocksInCheckpoint, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		 
N	if(dev->nErasedBlocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])
N		T(YAFFS_TRACE_VERIFY,
N		 (TSTR("Erased block count wrong dev %d count %d"TENDSTR),
N		 dev->nErasedBlocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		 
N	if(nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)
N		T(YAFFS_TRACE_VERIFY,
N		 (TSTR("Too many collecting blocks %d (max is 1)"TENDSTR),
N		 nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	T(YAFFS_TRACE_VERIFY,(TSTR(""TENDSTR)));
X	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N}
N
N/*
N * Verify the object header. oh must be valid, but obj and tags may be NULL in which
N * case those tests will not be performed.
N */
Nstatic void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)
N{
N	if(obj && yaffs_SkipVerification(obj->myDev))
N		return;
N		
N	if(!(tags && obj && oh)){
N	 	T(YAFFS_TRACE_VERIFY,
N		 		(TSTR("Verifying object header tags %x obj %x oh %x"TENDSTR),
N		 		(__u32)tags,(__u32)obj,(__u32)oh));
X	 	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return;
N	}
N	
N	if(oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
N	   oh->type > YAFFS_OBJECT_TYPE_MAX)
X	   oh->type > YAFFS_OBJECT_TYPE_SPECIAL)
N	 	T(YAFFS_TRACE_VERIFY,
N		 (TSTR("Obj %d header type is illegal value 0x%x"TENDSTR),
N		 tags->objectId, oh->type));
X	 	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	if(tags->objectId != obj->objectId)
N	 	T(YAFFS_TRACE_VERIFY,
N		 (TSTR("Obj %d header mismatch objectId %d"TENDSTR),
N		 tags->objectId, obj->objectId));
X	 	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N
N	/*
N	 * Check that the object's parent ids match if parentCheck requested.
N	 * 
N	 * Tests do not apply to the root object.
N	 */
N	
N	if(parentCheck && tags->objectId > 1 && !obj->parent)
N	 	T(YAFFS_TRACE_VERIFY,
N		 (TSTR("Obj %d header mismatch parentId %d obj->parent is NULL"TENDSTR),
N	 	 tags->objectId, oh->parentObjectId));
X	 	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		
N	
N	if(parentCheck && obj->parent &&
N	   oh->parentObjectId != obj->parent->objectId && 
N	   (oh->parentObjectId != YAFFS_OBJECTID_UNLINKED ||
X	   (oh->parentObjectId != 3 ||
N	    obj->parent->objectId != YAFFS_OBJECTID_DELETED))
X	    obj->parent->objectId != 4))
N	 	T(YAFFS_TRACE_VERIFY,
N		 (TSTR("Obj %d header mismatch parentId %d parentObjectId %d"TENDSTR),
N	 	 tags->objectId, oh->parentObjectId, obj->parent->objectId));
X	 	do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		
N	
N	if(tags->objectId > 1 && oh->name[0] == 0) /* Null name */
N		T(YAFFS_TRACE_VERIFY,
N		(TSTR("Obj %d header name is NULL"TENDSTR),
N		 obj->objectId));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	if(tags->objectId > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */
N		T(YAFFS_TRACE_VERIFY,
N		(TSTR("Obj %d header name is 0xFF"TENDSTR),
N		 obj->objectId));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N}
N
N
N
Nstatic int yaffs_VerifyTnodeWorker(yaffs_Object * obj, yaffs_Tnode * tn,
N				  	__u32 level, int chunkOffset)
N{
N	int i;
N	yaffs_Device *dev = obj->myDev;
N	int ok = 1;
N
N	if (tn) {
N		if (level > 0) {
N
N			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){
X			for (i = 0; i < (16 / 2) && ok; i++){
N				if (tn->internal[i]) {
N					ok = yaffs_VerifyTnodeWorker(obj,
N							tn->internal[i],
N							level - 1,
N							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
X							(chunkOffset<<(4 - 1)) + i);
N				}
N			}
N		} else if (level == 0) {
N			yaffs_ExtendedTags tags;
N			__u32 objectId = obj->objectId;
N			
N			chunkOffset <<=  YAFFS_TNODES_LEVEL0_BITS;
X			chunkOffset <<=  4;
N			
N			for(i = 0; i < YAFFS_NTNODES_LEVEL0; i++){
X			for(i = 0; i < 16; i++){
N				__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
N				
N				if(theChunk > 0){
N					/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),tags.objectId,tags.chunkId,theChunk)); */
W "..\fs\yaffs_guts.c" 638 6 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N					yaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);
X					yaffs_ReadChunkWithTagsFromNAND(dev,theChunk,0, &tags);
N					if(tags.objectId != objectId || tags.chunkId != chunkOffset){
N						T(~0,(TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
N							objectId, chunkOffset, theChunk,
N							tags.objectId, tags.chunkId));
X						do{ if((~0) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N					}
N				}
N				chunkOffset++;
N			}
N		}
N	}
N
N	return ok;
N
N}
N
N
Nstatic void yaffs_VerifyFile(yaffs_Object *obj)
N{
N	int requiredTallness;
N	int actualTallness;
N	__u32 lastChunk;
N	__u32 x;
N	__u32 i;
N	yaffs_Device *dev;
N	yaffs_ExtendedTags tags;
N	yaffs_Tnode *tn;
N	__u32 objectId;
N	
N	if(!obj)
N		return;
N
N	if(yaffs_SkipVerification(obj->myDev))
N		return;
N	
N	dev = obj->myDev;
N	objectId = obj->objectId;
N	
N	/* Check file size is consistent with tnode depth */
N	lastChunk =  obj->variant.fileVariant.fileSize / dev->nDataBytesPerChunk + 1;
N	x = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;
X	x = lastChunk >> 4;
N	requiredTallness = 0;
N	while (x> 0) {
N		x >>= YAFFS_TNODES_INTERNAL_BITS;
X		x >>= (4 - 1);
N		requiredTallness++;
N	}
N	
N	actualTallness = obj->variant.fileVariant.topLevel;
N	
N	if(requiredTallness > actualTallness )
N		T(YAFFS_TRACE_VERIFY,
N		(TSTR("Obj %d had tnode tallness %d, needs to be %d"TENDSTR),
N		 obj->objectId,actualTallness, requiredTallness));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	
N	
N	/* Check that the chunks in the tnode tree are all correct. 
N	 * We do this by scanning through the tnode tree and
N	 * checking the tags for every chunk match.
N	 */
N
N	if(yaffs_SkipNANDVerification(dev))
N		return;
N		
N	for(i = 1; i <= lastChunk; i++){
N		tn = yaffs_FindLevel0Tnode(dev, &obj->variant.fileVariant,i);
N
N		if (tn) {
N			__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
N			if(theChunk > 0){
N				/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),objectId,i,theChunk)); */
W "..\fs\yaffs_guts.c" 708 5 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N				yaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);
X				yaffs_ReadChunkWithTagsFromNAND(dev,theChunk,0, &tags);
N				if(tags.objectId != objectId || tags.chunkId != i){
N					T(~0,(TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
N						objectId, i, theChunk,
N						tags.objectId, tags.chunkId));
X					do{ if((~0) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				}
N			}
N		}
N
N	}
N
N}
N
N
Nstatic void yaffs_VerifyHardLink(yaffs_Object *obj)
N{
N	if(obj && yaffs_SkipVerification(obj->myDev))
N		return;
N		
N	/* Verify sane equivalent object */
N}
N
Nstatic void yaffs_VerifySymlink(yaffs_Object *obj)
N{
N	if(obj && yaffs_SkipVerification(obj->myDev))
N		return;
N		
N	/* Verify symlink string */
N}
N
Nstatic void yaffs_VerifySpecial(yaffs_Object *obj)
N{
N	if(obj && yaffs_SkipVerification(obj->myDev))
N		return;
N}
N
Nstatic void yaffs_VerifyObject(yaffs_Object *obj)
N{
N	yaffs_Device *dev;
N	
N	__u32 chunkMin;
N	__u32 chunkMax;
N	
N	__u32 chunkIdOk;
N	__u32 chunkInRange;
N	__u32 chunkShouldNotBeDeleted;
N	__u32 chunkValid; 
N	
N	if(!obj)
N		return;
N		
N	if(obj->beingCreated)
N		return;
N	
N	dev = obj->myDev;
N	
N	if(yaffs_SkipVerification(dev))
N		return;
N		
N	/* Check sane object header chunk */
N
N	chunkMin = dev->internalStartBlock * dev->nChunksPerBlock;
N	chunkMax = (dev->internalEndBlock+1) * dev->nChunksPerBlock - 1;
N
N	chunkInRange = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);
N	chunkIdOk = chunkInRange || obj->hdrChunk == 0;
N	chunkValid  =  chunkInRange &&
N			yaffs_CheckChunkBit(dev,
N					    obj->hdrChunk / dev->nChunksPerBlock,
N					    obj->hdrChunk % dev->nChunksPerBlock);
N	chunkShouldNotBeDeleted = chunkInRange && !chunkValid;
N
N	if(!obj->fake &&
N	    (!chunkIdOk || chunkShouldNotBeDeleted)) {
N	   T(YAFFS_TRACE_VERIFY,
N	   (TSTR("Obj %d has chunkId %d %s %s"TENDSTR),
N	   obj->objectId,obj->hdrChunk,
N	   chunkIdOk ? "" : ",out of range",
N	   chunkShouldNotBeDeleted ? ",marked as deleted" : ""));
X	   do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N	
N	if(chunkValid &&!yaffs_SkipNANDVerification(dev)) {
N		yaffs_ExtendedTags tags;
N		yaffs_ObjectHeader *oh;
N		__u8 *buffer = yaffs_GetTempBuffer(dev,__LINE__);
X		__u8 *buffer = yaffs_GetTempBuffer(dev,792);
N		
N		oh = (yaffs_ObjectHeader *)buffer;
N
W "..\fs\yaffs_guts.c" 796 3 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N		yaffs_ReadChunkWithTagsFromNAND(dev, obj->hdrChunk,buffer, &tags);
N
N		yaffs_VerifyObjectHeader(obj,oh,&tags,1);
N		
N		yaffs_ReleaseTempBuffer(dev,buffer,__LINE__);
X		yaffs_ReleaseTempBuffer(dev,buffer,800);
N	}
N	
N	/* Verify it has a parent */
N	if(obj && !obj->fake &&
N	   (!obj->parent || obj->parent->myDev != dev)){
N	   T(YAFFS_TRACE_VERIFY,
N	   (TSTR("Obj %d has parent pointer %p which does not look like an object"TENDSTR),
N	   obj->objectId,obj->parent));	   
X	   do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);	   
N	}
N	
N	/* Verify parent is a directory */
N	if(obj->parent && obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
N	   T(YAFFS_TRACE_VERIFY,
N	   (TSTR("Obj %d's parent is not a directory (type %d)"TENDSTR),
N	   obj->objectId,obj->parent->variantType));	   
X	   do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);	   
N	}
N	
N	switch(obj->variantType){
N	case YAFFS_OBJECT_TYPE_FILE:
N		yaffs_VerifyFile(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_SYMLINK:
N		yaffs_VerifySymlink(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_DIRECTORY:
N		yaffs_VerifyDirectory(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_HARDLINK:
N		yaffs_VerifyHardLink(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_SPECIAL:
N		yaffs_VerifySpecial(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_UNKNOWN:
N	default:
N		T(YAFFS_TRACE_VERIFY,
N		(TSTR("Obj %d has illegaltype %d"TENDSTR),
N		obj->objectId,obj->variantType));	   
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);	   
N		break;
N	}
N	
N	
N}
N
Nstatic void yaffs_VerifyObjects(yaffs_Device *dev)
N{
N        yaffs_Object *obj;
N        int i;
N        struct ylist_head *lh;
N
N        if(yaffs_SkipVerification(dev))
N                return;
N	
N        /* Iterate through the objects in each hash entry */
N         
N         for(i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++){
X         for(i = 0; i <  256; i++){
N                ylist_for_each(lh, &dev->objectBucket[i].list) {
X                for (lh = (&dev->objectBucket[i]. list)->next; lh != (&dev->objectBucket[i]. list); lh = lh->next ) {
N                        if (lh) {
N                                obj = ylist_entry(lh, yaffs_Object, hashLink);
X                                obj = ((yaffs_Object *)((char *)(lh)-(unsigned long)(&((yaffs_Object *)0)->hashLink)));
N                                yaffs_VerifyObject(obj);
N                        }
N                }
N	 }
N
N}
N
N
N/*
N *  Simple hash function. Needs to have a reasonable spread
N */
N 
Nstatic Y_INLINE int yaffs_HashFunction(int n)
Xstatic __inline int yaffs_HashFunction(int n)
N{
N	n = abs(n);
N	return (n % YAFFS_NOBJECT_BUCKETS);
X	return (n % 256);
N}
N
N/*
N * Access functions to useful fake objects.
N * Note that root might have a presence in NAND if permissions are set.
N */
N 
Nyaffs_Object *yaffs_Root(yaffs_Device * dev)
N{
N	return dev->rootDir;
N}
N
Nyaffs_Object *yaffs_LostNFound(yaffs_Device * dev)
N{
N	return dev->lostNFoundDir;
N}
N
N
N/*
N *  Erased NAND checking functions
N */
N 
Nint yaffs_CheckFF(__u8 * buffer, int nBytes)
N{
N	/* Horrible, slow implementation */
N	while (nBytes--) {
N		if (*buffer != 0xFF)
N			return 0;
N		buffer++;
N	}
N	return 1;
N}
N
Nstatic int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
N				  int chunkInNAND)
N{
N
N	int retval = YAFFS_OK;
X	int retval = 1;
N	__u8 *data = yaffs_GetTempBuffer(dev, __LINE__);
X	__u8 *data = yaffs_GetTempBuffer(dev, 914);
N	yaffs_ExtendedTags tags;
N	int result;
N
W "..\fs\yaffs_guts.c" 918 11 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N	result = yaffs_ReadChunkWithTagsFromNAND(dev, chunkInNAND, data, &tags);
N	 
N	if(tags.eccResult > YAFFS_ECC_RESULT_NO_ERROR)
N		retval = YAFFS_FAIL;
X		retval = 0;
N		
N
N	if (!yaffs_CheckFF(data, dev->nDataBytesPerChunk) || tags.chunkUsed) {
N		T(YAFFS_TRACE_NANDACCESS,
N		  (TSTR("Chunk %d not erased" TENDSTR), chunkInNAND));
X		do{ if((0x00000800) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		retval = YAFFS_FAIL;
X		retval = 0;
N	}
N
N	yaffs_ReleaseTempBuffer(dev, data, __LINE__);
X	yaffs_ReleaseTempBuffer(dev, data, 930);
N
N	return retval;
N
W "..\fs\yaffs_guts.c" 916 6 variable "result" was set but never used
N}
N
Nstatic int yaffs_WriteNewChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
N					     const __u8 * data,
N					     yaffs_ExtendedTags * tags,
N					     int useReserve)
N{
N	int attempts = 0;
N	int writeOk = 0;
N	int chunk;
N
N	yaffs_InvalidateCheckpoint(dev);
N 
N	do {
N		yaffs_BlockInfo *bi = 0;
N		int erasedOk = 0;
N
N		chunk = yaffs_AllocateChunk(dev, useReserve, &bi);
N		if (chunk < 0) 
N		{
N			/* no space */
N			break;
N		}
N
N		/* First check this chunk is erased, if it needs
N		 * checking.  The checking policy (unless forced
N		 * always on) is as follows:
N		 *
N		 * Check the first page we try to write in a block.
N		 * If the check passes then we don't need to check any
N		 * more.	If the check fails, we check again...
N		 * If the block has been erased, we don't need to check.
N		 *
N		 * However, if the block has been prioritised for gc,
N		 * then we think there might be something odd about
N		 * this block and stop using it.
N		 *
N		 * Rationale: We should only ever see chunks that have
N		 * not been erased if there was a partially written
N		 * chunk due to power loss.  This checking policy should
N		 * catch that case with very few checks and thus save a
N		 * lot of checks that are most likely not needed.
N		 */
N		 
N		if (bi->gcPrioritise) {
N			yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
X			yaffs_DeleteChunk(dev, chunk, 1, 979);
N			/* try another chunk */
N			 
N			continue;
N		}
N                 
N		/* let's give it a try */
N		attempts++;
N
N#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
S		bi->skipErasedCheck = 0;
N#endif
N		if (!bi->skipErasedCheck) 
N		{
N		
N			erasedOk = yaffs_CheckChunkErased(dev, chunk);
N			if (erasedOk != YAFFS_OK) 
X			if (erasedOk != 1) 
N			{
N				T(YAFFS_TRACE_ERROR,
N				(TSTR ("**>> yaffs chunk %d was not erased"
N				TENDSTR), chunk));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N                           
N				/* try another chunk */
N				continue;
N			}
N			 
N			bi->skipErasedCheck = 1;
N		}
N 
W "..\fs\yaffs_guts.c" 1008 13 function "yaffs_WriteChunkWithTagsToNAND" declared implicitly
N		writeOk = yaffs_WriteChunkWithTagsToNAND(dev, chunk,data, tags);
N	 	
N		if (writeOk != YAFFS_OK) {
X		if (writeOk != 1) {
N			yaffs_HandleWriteChunkError(dev, chunk, erasedOk);
N			/* try another chunk */
N			continue;
N		}
N
N		/* Copy the data into the robustification buffer */
N		yaffs_HandleWriteChunkOk(dev, chunk, data, tags);
N 
N	} while (writeOk != YAFFS_OK && (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
X	} while (writeOk != 1 && (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
N	        
N 
N	if(!writeOk)
N		chunk = -1;
N
N	if (attempts > 1) 
N	{
N		T(YAFFS_TRACE_ERROR,
N			(TSTR("**>> yaffs write required %d attempts" TENDSTR),
N			attempts));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		dev->nRetriedWrites += (attempts - 1);
N	}
N
N	return chunk;
N}
N
N/*
N * Block retiring for handling a broken block.
N */
N 
Nstatic void yaffs_RetireBlock(yaffs_Device * dev, int blockInNAND)
N{
N	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
N
N	yaffs_InvalidateCheckpoint(dev);
N	
W "..\fs\yaffs_guts.c" 1047 6 function "yaffs_MarkBlockBad" declared implicitly
N	if (yaffs_MarkBlockBad(dev, blockInNAND) != YAFFS_OK) {
X	if (yaffs_MarkBlockBad(dev, blockInNAND) != 1) {
W "..\fs\yaffs_guts.c" 1048 7 function "yaffs_EraseBlockInNAND" declared implicitly
N		if (yaffs_EraseBlockInNAND(dev, blockInNAND) != YAFFS_OK) {
X		if (yaffs_EraseBlockInNAND(dev, blockInNAND) != 1) {
N			T(YAFFS_TRACE_ALWAYS, (TSTR(
N				"yaffs: Failed to mark bad and erase block %d"
N				TENDSTR), blockInNAND));
X			do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		}
N		else {
N			yaffs_ExtendedTags tags;
N			int chunkId = blockInNAND * dev->nChunksPerBlock;
N
N			__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
X			__u8 *buffer = yaffs_GetTempBuffer(dev, 1057);
N
N			memset(buffer, 0xff, dev->nDataBytesPerChunk);
N			yaffs_InitialiseTags(&tags);
N			tags.sequenceNumber = YAFFS_SEQUENCE_BAD_BLOCK;
X			tags.sequenceNumber = 0xFFFF0000;
N			if (dev->writeChunkWithTagsToNAND(dev, chunkId -
N			    dev->chunkOffset, buffer, &tags) != YAFFS_OK)
X			    dev->chunkOffset, buffer, &tags) != 1)
N				T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Failed to "
N					TCONT("write bad block marker to block %d")
N					TENDSTR), blockInNAND));
X				do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N			yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
X			yaffs_ReleaseTempBuffer(dev, buffer, 1068);
N		}
N	}
N
N	bi->blockState = YAFFS_BLOCK_STATE_DEAD;
N	bi->gcPrioritise = 0;
N	bi->needsRetiring = 0;
N
N	dev->nRetiredBlocks++;
N}
N
N/*
N * Functions for robustisizing TODO
N *
N */
N 
Nstatic void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,
N				     const __u8 * data,
N				     const yaffs_ExtendedTags * tags)
N{
N}
N
Nstatic void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,
N				    const yaffs_ExtendedTags * tags)
N{
N}
N
Nvoid yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi)
N{
N	if(!bi->gcPrioritise){
N		bi->gcPrioritise = 1;
N		dev->hasPendingPrioritisedGCs = 1;
N		bi->chunkErrorStrikes ++;
N		
N		if(bi->chunkErrorStrikes > 3){
N			bi->needsRetiring = 1; /* Too many stikes, so retire this */
N			T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Block struck out" TENDSTR)));
X			do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		}
N		
N	}
N}
N
Nstatic void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND, int erasedOk)
N{
N
N	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
N	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
N
N	yaffs_HandleChunkError(dev,bi);
N		
N	
N	if(erasedOk ) {
N		/* Was an actual write failure, so mark the block for retirement  */
N		bi->needsRetiring = 1;
N		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
N		  (TSTR("**>> Block %d needs retiring" TENDSTR), blockInNAND));
X		do{ if((0x40000000 | 0x00000010) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		
N	}
N	
N	/* Delete the chunk */
N	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
X	yaffs_DeleteChunk(dev, chunkInNAND, 1, 1130);
N}
N
N
N/*---------------- Name handling functions ------------*/ 
N
Nstatic __u16 yaffs_CalcNameSum(const YCHAR * name)
Xstatic __u16 yaffs_CalcNameSum(const char * name)
N{
N	__u16 sum = 0;
N	__u16 i = 1;
N
N	const YUCHAR *bname = (const YUCHAR *) name;
X	const unsigned char *bname = (const unsigned char *) name;
N	if (bname) {
N		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {
X		while ((*bname) && (i < (255/2))) {
N
N#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
S			sum += yaffs_toupper(*bname) * i;
N#else
N			sum += (*bname) * i;
N#endif
N			i++;
N			bname++;
N		}
N	}
N	return sum;
N}
N
Nstatic void yaffs_SetObjectName(yaffs_Object * obj, const YCHAR * name)
Xstatic void yaffs_SetObjectName(yaffs_Object * obj, const char * name)
N{
N#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
S	memset(obj->shortName,0,sizeof (YCHAR) * (YAFFS_SHORT_NAME_LENGTH+1)); 
S	if (name && yaffs_strlen(name) <= YAFFS_SHORT_NAME_LENGTH) {
S		yaffs_strcpy(obj->shortName, name);
S	} else {
S		obj->shortName[0] = _Y('\0');
S	}
N#endif
N	obj->sum = yaffs_CalcNameSum(name);
N}
N
N/*-------------------- TNODES -------------------
N
N * List of spare tnodes
N * The list is hooked together using the first pointer
N * in the tnode.
N */
N 
N/* yaffs_CreateTnodes creates a bunch more tnodes and
N * adds them to the tnode free list.
N * Don't use this function directly
N */
N
Nstatic int yaffs_CreateTnodes(yaffs_Device * dev, int nTnodes)
N{
N	int i;
N	int tnodeSize;
N	yaffs_Tnode *newTnodes;
N	__u8 *mem;
N	yaffs_Tnode *curr;
N	yaffs_Tnode *next;
N	yaffs_TnodeList *tnl;
N
N	if (nTnodes < 1)
N		return YAFFS_OK;
X		return 1;
N		
N	/* Calculate the tnode size in bytes for variable width tnode support.
N	 * Must be a multiple of 32-bits  */
N	tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
X	tnodeSize = (dev->tnodeWidth * 16)/8;
N
N	if(tnodeSize < sizeof(yaffs_Tnode))
N		tnodeSize = sizeof(yaffs_Tnode);
N		
N
N	/* make these things */
N
N	newTnodes = YMALLOC(nTnodes * tnodeSize);
X	newTnodes = yaffs_malloc(nTnodes * tnodeSize);
N	mem = (__u8 *)newTnodes;
N
N	if (!newTnodes) {
N		T(YAFFS_TRACE_ERROR,
N		  (TSTR("yaffs: Could not allocate Tnodes" TENDSTR)));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N
N	/* Hook them into the free list */
N#if 0
S	for (i = 0; i < nTnodes - 1; i++) {
S		newTnodes[i].internal[0] = &newTnodes[i + 1];
S#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
S		newTnodes[i].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
S#endif
S	}
S
S	newTnodes[nTnodes - 1].internal[0] = dev->freeTnodes;
S#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
S	newTnodes[nTnodes - 1].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
S#endif
S	dev->freeTnodes = newTnodes;
N#else
N	/* New hookup for wide tnodes */
N	for(i = 0; i < nTnodes -1; i++) {
N		curr = (yaffs_Tnode *) &mem[i * tnodeSize];
N		next = (yaffs_Tnode *) &mem[(i+1) * tnodeSize];
N		curr->internal[0] = next;
N	}
N	
N	curr = (yaffs_Tnode *) &mem[(nTnodes - 1) * tnodeSize];
N	curr->internal[0] = dev->freeTnodes;
N	dev->freeTnodes = (yaffs_Tnode *)mem;
N
N#endif
N
N
N	dev->nFreeTnodes += nTnodes;
N	dev->nTnodesCreated += nTnodes;
N
N	/* Now add this bunch of tnodes to a list for freeing up.
N	 * NB If we can't add this to the management list it isn't fatal
N	 * but it just means we can't free this bunch of tnodes later.
N	 */
N	 
N	tnl = YMALLOC(sizeof(yaffs_TnodeList));
X	tnl = yaffs_malloc(sizeof(yaffs_TnodeList));
N	if (!tnl) {
N		T(YAFFS_TRACE_ERROR,
N		  (TSTR
N		   ("yaffs: Could not add tnodes to management list" TENDSTR)));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		   return YAFFS_FAIL;
X		   return 0;
N
N	} else {
N		tnl->tnodes = newTnodes;
N		tnl->next = dev->allocatedTnodeList;
N		dev->allocatedTnodeList = tnl;
N	}
N
N	T(YAFFS_TRACE_ALLOCATE, (TSTR("yaffs: Tnodes added" TENDSTR)));
X	do{ if((0x00000004) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	return YAFFS_OK;
X	return 1;
N}
N
N/* GetTnode gets us a clean tnode. Tries to make allocate more if we run out */
N
Nstatic yaffs_Tnode *yaffs_GetTnodeRaw(yaffs_Device * dev)
N{
N	yaffs_Tnode *tn = NULL;
X	yaffs_Tnode *tn = 0;
N
N	/* If there are none left make more */
N	if (!dev->freeTnodes) {
N		yaffs_CreateTnodes(dev, YAFFS_ALLOCATION_NTNODES);
X		yaffs_CreateTnodes(dev, 100);
N	}
N
N	if (dev->freeTnodes) {
N		tn = dev->freeTnodes;
N#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
S		if (tn->internal[YAFFS_NTNODES_INTERNAL] != (void *)1) {
S			/* Hoosterman, this thing looks like it isn't in the list */
S			T(YAFFS_TRACE_ALWAYS,
S			  (TSTR("yaffs: Tnode list bug 1" TENDSTR)));
S		}
N#endif
N		dev->freeTnodes = dev->freeTnodes->internal[0];
N		dev->nFreeTnodes--;
N	}
N
N	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
N
N	return tn;
N}
N
Nstatic yaffs_Tnode *yaffs_GetTnode(yaffs_Device * dev)
N{
N	yaffs_Tnode *tn = yaffs_GetTnodeRaw(dev);
N	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
X	int tnodeSize = (dev->tnodeWidth * 16)/8;
N
N	if(tnodeSize < sizeof(yaffs_Tnode))
N		tnodeSize = sizeof(yaffs_Tnode);
N	
N	if(tn)
N		memset(tn, 0, tnodeSize);
N
N	return tn;	
N}
N
N/* FreeTnode frees up a tnode and puts it back on the free list */
Nstatic void yaffs_FreeTnode(yaffs_Device * dev, yaffs_Tnode * tn)
N{
N	if (tn) {
N#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
S		if (tn->internal[YAFFS_NTNODES_INTERNAL] != 0) {
S			/* Hoosterman, this thing looks like it is already in the list */
S			T(YAFFS_TRACE_ALWAYS,
S			  (TSTR("yaffs: Tnode list bug 2" TENDSTR)));
S		}
S		tn->internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
N#endif
N		tn->internal[0] = dev->freeTnodes;
N		dev->freeTnodes = tn;
N		dev->nFreeTnodes++;
N	}
N	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
N	
N}
N
Nstatic void yaffs_DeinitialiseTnodes(yaffs_Device * dev)
N{
N	/* Free the list of allocated tnodes */
N	yaffs_TnodeList *tmp;
N
N	while (dev->allocatedTnodeList) {
N		tmp = dev->allocatedTnodeList->next;
N
N		YFREE(dev->allocatedTnodeList->tnodes);
X		free(dev->allocatedTnodeList->tnodes);
N		YFREE(dev->allocatedTnodeList);
X		free(dev->allocatedTnodeList);
N		dev->allocatedTnodeList = tmp;
N
N	}
N
N	dev->freeTnodes = NULL;
X	dev->freeTnodes = 0;
N	dev->nFreeTnodes = 0;
N}
N
Nstatic void yaffs_InitialiseTnodes(yaffs_Device * dev)
N{
N	dev->allocatedTnodeList = NULL;
X	dev->allocatedTnodeList = 0;
N	dev->freeTnodes = NULL;
X	dev->freeTnodes = 0;
N	dev->nFreeTnodes = 0;
N	dev->nTnodesCreated = 0;
N
N}
N
N
Nvoid yaffs_PutLevel0Tnode(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos, unsigned val)
N{
N  __u32 *map = (__u32 *)tn;
N  __u32 bitInMap;
N  __u32 bitInWord;
N  __u32 wordInMap;
N  __u32 mask;
N  
N  pos &= YAFFS_TNODES_LEVEL0_MASK;
X  pos &= 0xf;
N  val >>= dev->chunkGroupBits;
N  
N  bitInMap = pos * dev->tnodeWidth;
N  wordInMap = bitInMap /32;
N  bitInWord = bitInMap & (32 -1);
N  
N  mask = dev->tnodeMask << bitInWord;
N  
N  map[wordInMap] &= ~mask;
N  map[wordInMap] |= (mask & (val << bitInWord));
N  
N  if(dev->tnodeWidth > (32-bitInWord)) {
N    bitInWord = (32 - bitInWord);
N    wordInMap++;;
N    mask = dev->tnodeMask >> (/*dev->tnodeWidth -*/ bitInWord);
N    map[wordInMap] &= ~mask;
N    map[wordInMap] |= (mask & (val >> bitInWord));
N  }
N}
N
Nstatic __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos)
N{
N  __u32 *map = (__u32 *)tn;
N  __u32 bitInMap;
N  __u32 bitInWord;
N  __u32 wordInMap;
N  __u32 val;
N  
N  pos &= YAFFS_TNODES_LEVEL0_MASK;
X  pos &= 0xf;
N  
N  bitInMap = pos * dev->tnodeWidth;
N  wordInMap = bitInMap /32;
N  bitInWord = bitInMap & (32 -1);
N  
N  val = map[wordInMap] >> bitInWord;
N  
N  if(dev->tnodeWidth > (32-bitInWord)) {
N    bitInWord = (32 - bitInWord);
N    wordInMap++;;
N    val |= (map[wordInMap] << bitInWord);
N  }
N  
N  val &= dev->tnodeMask;
N  val <<= dev->chunkGroupBits;
N  
N  return val;
N}
N
N/* ------------------- End of individual tnode manipulation -----------------*/
N
N/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
N * The look up tree is represented by the top tnode and the number of topLevel
N * in the tree. 0 means only the level 0 tnode is in the tree.
N */
N
N/* FindLevel0Tnode finds the level 0 tnode, if one exists. */
Nstatic yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device * dev,
N					  yaffs_FileStructure * fStruct,
N					  __u32 chunkId)
N{
N
N	yaffs_Tnode *tn = fStruct->top;
N	__u32 i;
N	int requiredTallness;
N	int level = fStruct->topLevel;
N
N	/* Check sane level and chunk Id */
N	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL) {
X	if (level < 0 || level > 6) {
N		return NULL;
X		return 0;
N	}
N
N	if (chunkId > YAFFS_MAX_CHUNK_ID) {
X	if (chunkId > 0x000FFFFF) {
N		return NULL;
X		return 0;
N	}
N
N	/* First check we're tall enough (ie enough topLevel) */
N
N	i = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
X	i = chunkId >> 4;
N	requiredTallness = 0;
N	while (i) {
N		i >>= YAFFS_TNODES_INTERNAL_BITS;
X		i >>= (4 - 1);
N		requiredTallness++;
N	}
N
N	if (requiredTallness > fStruct->topLevel) {
N		/* Not tall enough, so we can't find it, return NULL. */
N		return NULL;
X		return 0;
N	}
N
N	/* Traverse down to level 0 */
N	while (level > 0 && tn) {
N		tn = tn->
N		    internal[(chunkId >>
N			       ( YAFFS_TNODES_LEVEL0_BITS + 
X			       ( 4 + 
N			         (level - 1) *
N			         YAFFS_TNODES_INTERNAL_BITS)
X			         (4 - 1))
N			      ) &
N			     YAFFS_TNODES_INTERNAL_MASK];
X			     0x7];
N		level--;
N
N	}
N
N	return tn;
N}
N
N/* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.
N * This happens in two steps:
N *  1. If the tree isn't tall enough, then make it taller.
N *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
N *
N * Used when modifying the tree.
N *
N *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will
N *  be plugged into the ttree.
N */
N 
Nstatic yaffs_Tnode *yaffs_AddOrFindLevel0Tnode(yaffs_Device * dev,
N					       yaffs_FileStructure * fStruct,
N					       __u32 chunkId,
N					       yaffs_Tnode *passedTn)
N{
N
N	int requiredTallness;
N	int i;
N	int l;
N	yaffs_Tnode *tn;
N
N	__u32 x;
N
N
N	/* Check sane level and page Id */
N	if (fStruct->topLevel < 0 || fStruct->topLevel > YAFFS_TNODES_MAX_LEVEL) {
X	if (fStruct->topLevel < 0 || fStruct->topLevel > 6) {
N		return NULL;
X		return 0;
N	}
N
N	if (chunkId > YAFFS_MAX_CHUNK_ID) {
X	if (chunkId > 0x000FFFFF) {
N		return NULL;
X		return 0;
N	}
N
N	/* First check we're tall enough (ie enough topLevel) */
N
N	x = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
X	x = chunkId >> 4;
N	requiredTallness = 0;
N	while (x) {
N		x >>= YAFFS_TNODES_INTERNAL_BITS;
X		x >>= (4 - 1);
N		requiredTallness++;
N	}
N
N
N	if (requiredTallness > fStruct->topLevel) {
N		/* Not tall enough,gotta make the tree taller */
N		for (i = fStruct->topLevel; i < requiredTallness; i++) {
N		
N			tn = yaffs_GetTnode(dev);
N
N			if (tn) {
N				tn->internal[0] = fStruct->top;
N				fStruct->top = tn;
N			} else {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR("yaffs: no more tnodes" TENDSTR)));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			}
N		}
N
N		fStruct->topLevel = requiredTallness;
N	}
N
N	/* Traverse down to level 0, adding anything we need */
N
N	l = fStruct->topLevel;
N	tn = fStruct->top;
N	
N	if(l > 0) {
N		while (l > 0 && tn) {
N			x = (chunkId >>
N			     ( YAFFS_TNODES_LEVEL0_BITS +
X			     ( 4 +
N			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
X			      (l - 1) * (4 - 1))) &
N			    YAFFS_TNODES_INTERNAL_MASK;
X			    0x7;
N
N
N			if((l>1) && !tn->internal[x]){
N				/* Add missing non-level-zero tnode */
N				tn->internal[x] = yaffs_GetTnode(dev);
N
N			} else if(l == 1) {
N				/* Looking from level 1 at level 0 */
N			 	if (passedTn) {
N					/* If we already have one, then release it.*/
N					if(tn->internal[x])
N						yaffs_FreeTnode(dev,tn->internal[x]);
N					tn->internal[x] = passedTn;
N			
N				} else if(!tn->internal[x]) {
N					/* Don't have one, none passed in */
N					tn->internal[x] = yaffs_GetTnode(dev);
N				}
N			}
N		
N			tn = tn->internal[x];
N			l--;
N		}
N	} else {
N		/* top is level 0 */
N		if(passedTn) {
N			memcpy(tn,passedTn,(dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8);
X			memcpy(tn,passedTn,(dev->tnodeWidth * 16)/8);
N			yaffs_FreeTnode(dev,passedTn);
N		}
N	}
N
N	return tn;
N}
N
Nstatic int yaffs_FindChunkInGroup(yaffs_Device * dev, int theChunk,
N				  yaffs_ExtendedTags * tags, int objectId,
N				  int chunkInInode)
N{
N	int j;
N
N	for (j = 0; theChunk && j < dev->chunkGroupSize; j++) {
N		if (yaffs_CheckChunkBit
N		    (dev, theChunk / dev->nChunksPerBlock,
N		     theChunk % dev->nChunksPerBlock)) {
W "..\fs\yaffs_guts.c" 1591 4 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N			yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,
X			yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, 0,
N							tags);
N			if (yaffs_TagsMatch(tags, objectId, chunkInInode)) {
N				/* found it; */
N				return theChunk;
N
N			}
N		}
N		theChunk++;
N	}
N	return -1;
N}
N
N
N/* DeleteWorker scans backwards through the tnode tree and deletes all the
N * chunks and tnodes in the file
N * Returns 1 if the tree was deleted. 
N * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.
N */
N
Nstatic int yaffs_DeleteWorker(yaffs_Object * in, yaffs_Tnode * tn, __u32 level,
N			      int chunkOffset, int *limit)
N{
N	int i;
N	int chunkInInode;
N	int theChunk;
N	yaffs_ExtendedTags tags;
N	int foundChunk;
N	yaffs_Device *dev = in->myDev;
N
N	int allDone = 1;
N
N	if (tn) {
N		if (level > 0) {
N
N			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
X			for (i = (16 / 2) - 1; allDone && i >= 0;
N			     i--) {
N				if (tn->internal[i]) {
N					if (limit && (*limit) < 0) {
N						allDone = 0;
N					} else {
N						allDone =
N						    yaffs_DeleteWorker(in,
N								       tn->
N								       internal
N								       [i],
N								       level -
N								       1,
N								       (chunkOffset
N									<<
N									YAFFS_TNODES_INTERNAL_BITS)
X									(4 - 1))
N								       + i,
N								       limit);
N					}
N					if (allDone) {
N						yaffs_FreeTnode(dev,
N								tn->
N								internal[i]);
N						tn->internal[i] = NULL;
X						tn->internal[i] = 0;
N					}
N				}
N
N			}
N			return (allDone) ? 1 : 0;
N		} else if (level == 0) {
N			int hitLimit = 0;
N
N			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;
X			for (i = 16 - 1; i >= 0 && !hitLimit;
N			     i--) {
N			        theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
N				if (theChunk) {
N
N					chunkInInode =
N					    (chunkOffset <<
N					     YAFFS_TNODES_LEVEL0_BITS) + i;
X					     4) + i;
N
N					foundChunk =
N					    yaffs_FindChunkInGroup(dev,
N								   theChunk,
N								   &tags,
N								   in->objectId,
N								   chunkInInode);
N
N					if (foundChunk > 0) {
N						yaffs_DeleteChunk(dev,
N								  foundChunk, 1,
N								  __LINE__);
X								  1677);
N						in->nDataChunks--;
N						if (limit) {
N							*limit = *limit - 1;
N							if (*limit <= 0) {
N								hitLimit = 1;
N							}
N						}
N
N					}
N
N					yaffs_PutLevel0Tnode(dev,tn,i,0);
N				}
N
N			}
N			return (i < 0) ? 1 : 0;
N
N		}
N
N	}
N
N	return 1;
N
N}
N
Nstatic void yaffs_SoftDeleteChunk(yaffs_Device * dev, int chunk)
N{
N
N	yaffs_BlockInfo *theBlock;
N
N	T(YAFFS_TRACE_DELETION, (TSTR("soft delete chunk %d" TENDSTR), chunk));
X	do{ if((0x00000200) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	theBlock = yaffs_GetBlockInfo(dev, chunk / dev->nChunksPerBlock);
N	if (theBlock) {
N		theBlock->softDeletions++;
N		dev->nFreeChunks++;
N	}
N}
N
N/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.
N * All soft deleting does is increment the block's softdelete count and pulls the chunk out
N * of the tnode.
N * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.
N */
N 
Nstatic int yaffs_SoftDeleteWorker(yaffs_Object * in, yaffs_Tnode * tn,
N				  __u32 level, int chunkOffset)
N{
N	int i;
N	int theChunk;
N	int allDone = 1;
N	yaffs_Device *dev = in->myDev;
N
N	if (tn) {
N		if (level > 0) {
N
N			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
X			for (i = (16 / 2) - 1; allDone && i >= 0;
N			     i--) {
N				if (tn->internal[i]) {
N					allDone =
N					    yaffs_SoftDeleteWorker(in,
N								   tn->
N								   internal[i],
N								   level - 1,
N								   (chunkOffset
N								    <<
N								    YAFFS_TNODES_INTERNAL_BITS)
X								    (4 - 1))
N								   + i);
N					if (allDone) {
N						yaffs_FreeTnode(dev,
N								tn->
N								internal[i]);
N						tn->internal[i] = NULL;
X						tn->internal[i] = 0;
N					} else {
N						/* Hoosterman... how could this happen? */
N					}
N				}
N			}
N			return (allDone) ? 1 : 0;
N		} else if (level == 0) {
N
N			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
X			for (i = 16 - 1; i >= 0; i--) {
N				theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
N				if (theChunk) {
N					/* Note this does not find the real chunk, only the chunk group.
N					 * We make an assumption that a chunk group is not larger than 
N					 * a block.
N					 */
N					yaffs_SoftDeleteChunk(dev, theChunk);
N					yaffs_PutLevel0Tnode(dev,tn,i,0);
N				}
N
N			}
N			return 1;
N
N		}
N
N	}
N
N	return 1;
N
N}
N
Nstatic void yaffs_SoftDeleteFile(yaffs_Object * obj)
N{
N	if (obj->deleted &&
N	    obj->variantType == YAFFS_OBJECT_TYPE_FILE && !obj->softDeleted) {
N		if (obj->nDataChunks <= 0) {
N			/* Empty file with no duplicate object headers, just delete it immediately */
N			yaffs_FreeTnode(obj->myDev,
N					obj->variant.fileVariant.top);
N			obj->variant.fileVariant.top = NULL;
X			obj->variant.fileVariant.top = 0;
N			T(YAFFS_TRACE_TRACING,
N			  (TSTR("yaffs: Deleting empty file %d" TENDSTR),
N			   obj->objectId));
X			do{ if((0x00000100) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			yaffs_DoGenericObjectDeletion(obj);
N		} else {
N			yaffs_SoftDeleteWorker(obj,
N					       obj->variant.fileVariant.top,
N					       obj->variant.fileVariant.
N					       topLevel, 0);
N			obj->softDeleted = 1;
N		}
N	}
N}
N
N/* Pruning removes any part of the file structure tree that is beyond the
N * bounds of the file (ie that does not point to chunks).
N *
N * A file should only get pruned when its size is reduced.
N *
N * Before pruning, the chunks must be pulled from the tree and the
N * level 0 tnode entries must be zeroed out.
N * Could also use this for file deletion, but that's probably better handled
N * by a special case.
N */
N
Nstatic yaffs_Tnode *yaffs_PruneWorker(yaffs_Device * dev, yaffs_Tnode * tn,
N				      __u32 level, int del0)
N{
N	int i;
N	int hasData;
N
N	if (tn) {
N		hasData = 0;
N
N		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
X		for (i = 0; i < (16 / 2); i++) {
N			if (tn->internal[i] && level > 0) {
N				tn->internal[i] =
N				    yaffs_PruneWorker(dev, tn->internal[i],
N						      level - 1,
N						      (i == 0) ? del0 : 1);
N			}
N
N			if (tn->internal[i]) {
N				hasData++;
N			}
N		}
N
N		if (hasData == 0 && del0) {
N			/* Free and return NULL */
N
N			yaffs_FreeTnode(dev, tn);
N			tn = NULL;
X			tn = 0;
N		}
N
N	}
N
N	return tn;
N
N}
N
Nstatic int yaffs_PruneFileStructure(yaffs_Device * dev,
N				    yaffs_FileStructure * fStruct)
N{
N	int i;
N	int hasData;
N	int done = 0;
N	yaffs_Tnode *tn;
N
N	if (fStruct->topLevel > 0) {
N		fStruct->top =
N		    yaffs_PruneWorker(dev, fStruct->top, fStruct->topLevel, 0);
N
N		/* Now we have a tree with all the non-zero branches NULL but the height
N		 * is the same as it was.
N		 * Let's see if we can trim internal tnodes to shorten the tree.
N		 * We can do this if only the 0th element in the tnode is in use 
N		 * (ie all the non-zero are NULL)
N		 */
N
N		while (fStruct->topLevel && !done) {
N			tn = fStruct->top;
N
N			hasData = 0;
N			for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
X			for (i = 1; i < (16 / 2); i++) {
N				if (tn->internal[i]) {
N					hasData++;
N				}
N			}
N
N			if (!hasData) {
N				fStruct->top = tn->internal[0];
N				fStruct->topLevel--;
N				yaffs_FreeTnode(dev, tn);
N			} else {
N				done = 1;
N			}
N		}
N	}
N
N	return YAFFS_OK;
X	return 1;
N}
N
N/*-------------------- End of File Structure functions.-------------------*/
N
N/* yaffs_CreateFreeObjects creates a bunch more objects and
N * adds them to the object free list.
N */
Nstatic int yaffs_CreateFreeObjects(yaffs_Device * dev, int nObjects)
N{
N	int i;
N	yaffs_Object *newObjects;
N	yaffs_ObjectList *list;
N
N	if (nObjects < 1)
N		return YAFFS_OK;
X		return 1;
N
N	/* make these things */
N	newObjects = YMALLOC(nObjects * sizeof(yaffs_Object));
X	newObjects = yaffs_malloc(nObjects * sizeof(yaffs_Object));
N	list = YMALLOC(sizeof(yaffs_ObjectList));
X	list = yaffs_malloc(sizeof(yaffs_ObjectList));
N
N	if (!newObjects || !list) {
N		if(newObjects)
N			YFREE(newObjects);
X			free(newObjects);
N		if(list)
N			YFREE(list);
X			free(list);
N		T(YAFFS_TRACE_ALLOCATE,
N		  (TSTR("yaffs: Could not allocate more objects" TENDSTR)));
X		do{ if((0x00000004) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N	
N        /* Hook them into the free list */
N        for (i = 0; i < nObjects - 1; i++) {
N                newObjects[i].siblings.next =
N                    (struct ylist_head *)(&newObjects[i + 1]);
N        }
N
N        newObjects[nObjects - 1].siblings.next = (void *)dev->freeObjects;
N	dev->freeObjects = newObjects;
N	dev->nFreeObjects += nObjects;
N	dev->nObjectsCreated += nObjects;
N
N	/* Now add this bunch of Objects to a list for freeing up. */
N
N	list->objects = newObjects;
N	list->next = dev->allocatedObjectList;
N	dev->allocatedObjectList = list;
N
N	return YAFFS_OK;
X	return 1;
N}
N
N
N/* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */
Nstatic yaffs_Object *yaffs_AllocateEmptyObject(yaffs_Device * dev)
N{
N	yaffs_Object *tn = NULL;
X	yaffs_Object *tn = 0;
N
N#ifdef VALGRIND_TEST
S	tn = YMALLOC(sizeof(yaffs_Object));
N#else
N	/* If there are none left make more */
N	if (!dev->freeObjects) {
N		yaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);
X		yaffs_CreateFreeObjects(dev, 100);
N	}
N
N	if (dev->freeObjects) {
N		tn = dev->freeObjects;
N		dev->freeObjects =
N		    (yaffs_Object *) (dev->freeObjects->siblings.next);
N		dev->nFreeObjects--;
N	}
N#endif
N	if(tn){
N		/* Now sweeten it up... */
N
N		memset(tn, 0, sizeof(yaffs_Object));
N		tn->beingCreated = 1;
N		
N		tn->myDev = dev;
N		tn->hdrChunk = 0;
N		tn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;
N		YINIT_LIST_HEAD(&(tn->hardLinks));
X		do { (&(tn->hardLinks))->next = (&(tn->hardLinks)); (&(tn->hardLinks))->prev = (&(tn->hardLinks)); } while(0);
N		YINIT_LIST_HEAD(&(tn->hashLink));
X		do { (&(tn->hashLink))->next = (&(tn->hashLink)); (&(tn->hashLink))->prev = (&(tn->hashLink)); } while(0);
N		YINIT_LIST_HEAD(&tn->siblings);
X		do { (&tn->siblings)->next = (&tn->siblings); (&tn->siblings)->prev = (&tn->siblings); } while(0);
N		
N
N		/* Now make the directory sane */
N		if(dev->rootDir){
N			tn->parent = dev->rootDir;
N			ylist_add(&(tn->siblings),&dev->rootDir->variant.directoryVariant.children);
N		}
N
N                /* Add it to the lost and found directory.
N                 * NB Can't put root or lostNFound in lostNFound so
N		 * check if lostNFound exists first
N		 */
N		if (dev->lostNFoundDir) {
N			yaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);
N		}
N		
N		tn->beingCreated = 0;
N	}
N	
N	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
N
N	return tn;
N}
N
Nstatic yaffs_Object *yaffs_CreateFakeDirectory(yaffs_Device * dev, int number,
N					       __u32 mode)
N{
N
N	yaffs_Object *obj =
N	    yaffs_CreateNewObject(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
N	if (obj) {
N		obj->fake = 1;		/* it is fake so it might have no NAND presence... */
N		obj->renameAllowed = 0;	/* ... and we're not allowed to rename it... */
N		obj->unlinkAllowed = 0;	/* ... or unlink it */
N		obj->deleted = 0;
N		obj->unlinked = 0;
N		obj->yst_mode = mode;
N		obj->myDev = dev;
N		obj->hdrChunk = 0;	/* Not a valid chunk. */
N	}
N
N	return obj;
N
N}
N
Nstatic void yaffs_UnhashObject(yaffs_Object * tn)
N{
N	int bucket;
N        yaffs_Device *dev = tn->myDev;
N
N        /* If it is still linked into the bucket list, free from the list */
N        if (!ylist_empty(&tn->hashLink)) {
N                ylist_del_init(&tn->hashLink);
N                bucket = yaffs_HashFunction(tn->objectId);
N                dev->objectBucket[bucket].count--;
N        }
N
N}
N
N/*  FreeObject frees up a Object and puts it back on the free list */
Nstatic void yaffs_FreeObject(yaffs_Object * tn)
N{
N
N	yaffs_Device *dev = tn->myDev;
N
N	
N	if(tn->parent)
N		YBUG();
X		;
N	if(!ylist_empty(&tn->siblings))
N		YBUG();
X		;
N
N
N#ifdef  __KERNEL__
S	if (tn->myInode) {
S		/* We're still hooked up to a cached inode.
S		 * Don't delete now, but mark for later deletion
S		 */
S		tn->deferedFree = 1;
S		return;
S	}
N#endif
N
N        yaffs_UnhashObject(tn);
N
N#ifdef VALGRIND_TEST
S	YFREE(tn);
N#else
N        /* Link into the free list. */
N        tn->siblings.next = (struct ylist_head *)(dev->freeObjects);
N        dev->freeObjects = tn;
N        dev->nFreeObjects++;
N#endif
N	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
N
N}
N
N#ifdef __KERNEL__
S
Svoid yaffs_HandleDeferedFree(yaffs_Object * obj)
S{
S	if (obj->deferedFree) {
S		yaffs_FreeObject(obj);
S	}
S}
S
N#endif
N
Nstatic void yaffs_DeinitialiseObjects(yaffs_Device * dev)
N{
N	/* Free the list of allocated Objects */
N
N	yaffs_ObjectList *tmp;
N
N	while (dev->allocatedObjectList) {
N		tmp = dev->allocatedObjectList->next;
N		YFREE(dev->allocatedObjectList->objects);
X		free(dev->allocatedObjectList->objects);
N		YFREE(dev->allocatedObjectList);
X		free(dev->allocatedObjectList);
N
N		dev->allocatedObjectList = tmp;
N	}
N
N	dev->freeObjects = NULL;
X	dev->freeObjects = 0;
N	dev->nFreeObjects = 0;
N}
N
Nstatic void yaffs_InitialiseObjects(yaffs_Device * dev)
N{
N	int i;
N
N	dev->allocatedObjectList = NULL;
X	dev->allocatedObjectList = 0;
N	dev->freeObjects = NULL;
X	dev->freeObjects = 0;
N        dev->nFreeObjects = 0;
N
N        for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
X        for (i = 0; i < 256; i++) {
N                YINIT_LIST_HEAD(&dev->objectBucket[i].list);
X                do { (&dev->objectBucket[i]. list)->next = (&dev->objectBucket[i]. list); (&dev->objectBucket[i]. list)->prev = (&dev->objectBucket[i]. list); } while(0);
N                dev->objectBucket[i].count = 0;
N        }
N
N}
N
Nstatic int yaffs_FindNiceObjectBucket(yaffs_Device * dev)
N{
N	static int x = 0;
N	int i;
N	int l = 999;
N	int lowest = 999999;
N
N	/* First let's see if we can find one that's empty. */
N
N	for (i = 0; i < 10 && lowest > 0; i++) {
N		x++;
N		x %= YAFFS_NOBJECT_BUCKETS;
X		x %= 256;
N		if (dev->objectBucket[x].count < lowest) {
N			lowest = dev->objectBucket[x].count;
N			l = x;
N		}
N
N	}
N
N	/* If we didn't find an empty list, then try
N	 * looking a bit further for a short one
N	 */
N
N	for (i = 0; i < 10 && lowest > 3; i++) {
N		x++;
N		x %= YAFFS_NOBJECT_BUCKETS;
X		x %= 256;
N		if (dev->objectBucket[x].count < lowest) {
N			lowest = dev->objectBucket[x].count;
N			l = x;
N		}
N
N	}
N
N	return l;
N}
N
Nstatic int yaffs_CreateNewObjectNumber(yaffs_Device * dev)
N{
N	int bucket = yaffs_FindNiceObjectBucket(dev);
N
N	/* Now find an object value that has not already been taken
N	 * by scanning the list.
N         */
N
N        int found = 0;
N        struct ylist_head *i;
N
N        __u32 n = (__u32) bucket;
N
N	/* yaffs_CheckObjectHashSanity();  */
N
N	while (!found) {
N                found = 1;
N                n += YAFFS_NOBJECT_BUCKETS;
X                n += 256;
N                if (1 || dev->objectBucket[bucket].count > 0) {
N                        ylist_for_each(i, &dev->objectBucket[bucket].list) {
X                        for (i = (&dev->objectBucket[bucket]. list)->next; i != (&dev->objectBucket[bucket]. list); i = i->next ) {
N                                /* If there is already one in the list */
N                                if (i
N                                    && ylist_entry(i, yaffs_Object,
N                                                  hashLink)->objectId == n) {
X                                    && ((yaffs_Object *)((char *)(i)-(unsigned long)(&((yaffs_Object *)0)->hashLink)))->objectId == n) {
N                                        found = 0;
N                                }
N			}
N		}
N	}
N
N
N	return n;
N}
N
Nstatic void yaffs_HashObject(yaffs_Object * in)
N{
N        int bucket = yaffs_HashFunction(in->objectId);
N        yaffs_Device *dev = in->myDev;
N
N        ylist_add(&in->hashLink, &dev->objectBucket[bucket].list);
N        dev->objectBucket[bucket].count++;
N
N}
N
Nyaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number)
N{
N        int bucket = yaffs_HashFunction(number);
N        struct ylist_head *i;
N        yaffs_Object *in;
N
N        ylist_for_each(i, &dev->objectBucket[bucket].list) {
X        for (i = (&dev->objectBucket[bucket]. list)->next; i != (&dev->objectBucket[bucket]. list); i = i->next ) {
N                /* Look if it is in the list */
N                if (i) {
N                        in = ylist_entry(i, yaffs_Object, hashLink);
X                        in = ((yaffs_Object *)((char *)(i)-(unsigned long)(&((yaffs_Object *)0)->hashLink)));
N                        if (in->objectId == number) {
N#ifdef __KERNEL__
S                                /* Don't tell the VFS about this one if it is defered free */
S				if (in->deferedFree)
S					return NULL;
N#endif
N
N				return in;
N			}
N		}
N	}
N
N	return NULL;
X	return 0;
N}
N
Nyaffs_Object *yaffs_CreateNewObject(yaffs_Device * dev, int number,
N				    yaffs_ObjectType type)
N{
N
N	yaffs_Object *theObject;
N	yaffs_Tnode *tn = NULL;
X	yaffs_Tnode *tn = 0;
N
N	if (number < 0) {
N		number = yaffs_CreateNewObjectNumber(dev);
N	}
N
N	theObject = yaffs_AllocateEmptyObject(dev);
N	if(!theObject)
N		return NULL;
X		return 0;
N		
N	if(type == YAFFS_OBJECT_TYPE_FILE){
N		tn = yaffs_GetTnode(dev);
N		if(!tn){
N			yaffs_FreeObject(theObject);
N			return NULL;
X			return 0;
N		}
N	}
N		
N	
N
N	if (theObject) {
N		theObject->fake = 0;
N		theObject->renameAllowed = 1;
N		theObject->unlinkAllowed = 1;
N		theObject->objectId = number;
N		yaffs_HashObject(theObject);
N		theObject->variantType = type;
N#ifdef CONFIG_YAFFS_WINCE
S		yfsd_WinFileTimeNow(theObject->win_atime);
S		theObject->win_ctime[0] = theObject->win_mtime[0] =
S		    theObject->win_atime[0];
S		theObject->win_ctime[1] = theObject->win_mtime[1] =
S		    theObject->win_atime[1];
S
N#else
N
N		theObject->yst_atime = theObject->yst_mtime =
N		    theObject->yst_ctime = Y_CURRENT_TIME;
X		    theObject->yst_ctime = yaffsfs_CurrentTime();
N#endif
N		switch (type) {
N		case YAFFS_OBJECT_TYPE_FILE:
N			theObject->variant.fileVariant.fileSize = 0;
N			theObject->variant.fileVariant.scannedFileSize = 0;
N			theObject->variant.fileVariant.shrinkSize = 0xFFFFFFFF;	/* max __u32 */
N			theObject->variant.fileVariant.topLevel = 0;
N                        theObject->variant.fileVariant.top = tn;
N                        break;
N                case YAFFS_OBJECT_TYPE_DIRECTORY:
N                        YINIT_LIST_HEAD(&theObject->variant.directoryVariant.
N                                       children);
X                        do { (&theObject->variant . directoryVariant . children)->next = (&theObject->variant . directoryVariant . children); (&theObject->variant . directoryVariant . children)->prev = (&theObject->variant . directoryVariant . children); } while(0);
N                        break;
N                case YAFFS_OBJECT_TYPE_SYMLINK:
N		case YAFFS_OBJECT_TYPE_HARDLINK:
N		case YAFFS_OBJECT_TYPE_SPECIAL:
N			/* No action required */
N			break;
N		case YAFFS_OBJECT_TYPE_UNKNOWN:
N			/* todo this should not happen */
N			break;
N		}
N	}
N
N	return theObject;
N}
N
Nstatic yaffs_Object *yaffs_FindOrCreateObjectByNumber(yaffs_Device * dev,
N						      int number,
N						      yaffs_ObjectType type)
N{
N	yaffs_Object *theObject = NULL;
X	yaffs_Object *theObject = 0;
N
N	if (number > 0) {
N		theObject = yaffs_FindObjectByNumber(dev, number);
N	}
N
N	if (!theObject) {
N		theObject = yaffs_CreateNewObject(dev, number, type);
N	}
N
N	return theObject;
N
N}
N			
N
Nstatic YCHAR *yaffs_CloneString(const YCHAR * str)
Xstatic char *yaffs_CloneString(const char * str)
N{
N	YCHAR *newStr = NULL;
X	char *newStr = 0;
N
N	if (str && *str) {
N		newStr = YMALLOC((yaffs_strlen(str) + 1) * sizeof(YCHAR));
X		newStr = yaffs_malloc((strlen(str) + 1) * sizeof(char));
N		if(newStr)
N			yaffs_strcpy(newStr, str);
X			strcpy(newStr,str);
N	}
N
N	return newStr;
N
N}
N
N/*
N * Mknod (create) a new object.
N * equivalentObject only has meaning for a hard link;
N * aliasString only has meaning for a sumlink.
N * rdev only has meaning for devices (a subset of special objects)
N */
N 
Nstatic yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,
N				       yaffs_Object * parent,
N				       const YCHAR * name,
X				       const char * name,
N				       __u32 mode,
N				       __u32 uid,
N				       __u32 gid,
N				       yaffs_Object * equivalentObject,
N				       const YCHAR * aliasString, __u32 rdev)
X				       const char * aliasString, __u32 rdev)
N{
N	yaffs_Object *in;
N	YCHAR *str = NULL;
X	char *str = 0;
N
N	yaffs_Device *dev = parent->myDev;
N 
N	/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/
N	if (yaffs_FindObjectByName(parent, name)) {
N		return NULL;
X		return 0;
N	}
N
N	in = yaffs_CreateNewObject(dev, -1, type);
N
N	if(!in)
N		return YAFFS_FAIL;
X		return 0;
N	 
N	if(type == YAFFS_OBJECT_TYPE_SYMLINK)
N	{
N		str = yaffs_CloneString(aliasString);
N	 
N		if(!str)
N		{
N			yaffs_FreeObject(in);
N			return NULL;
X			return 0;
N		}
N	}
N 
N	
N
N	if (in) {
N		in->hdrChunk = 0;
N		in->valid = 1;
N		in->variantType = type;
N
N		in->yst_mode = mode;
N
N#ifdef CONFIG_YAFFS_WINCE
S		yfsd_WinFileTimeNow(in->win_atime);
S		in->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];
S		in->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];
S
N#else
N		in->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;
X		in->yst_atime = in->yst_mtime = in->yst_ctime = yaffsfs_CurrentTime();
N
N		in->yst_rdev = rdev;
N		in->yst_uid = uid;
N		in->yst_gid = gid;
N#endif
N		in->nDataChunks = 0;
N
N		yaffs_SetObjectName(in, name);
N		in->dirty = 1;
N
N		yaffs_AddObjectToDirectory(parent, in);
N
N		in->myDev = parent->myDev;
N 
N		switch (type) {
N		case YAFFS_OBJECT_TYPE_SYMLINK:
N			in->variant.symLinkVariant.alias = str;
N			break;
N		case YAFFS_OBJECT_TYPE_HARDLINK:
N			in->variant.hardLinkVariant.equivalentObject =
N                            equivalentObject;
N                        in->variant.hardLinkVariant.equivalentObjectId =
N                            equivalentObject->objectId;
N                        ylist_add(&in->hardLinks, &equivalentObject->hardLinks);
N                        break;
N                case YAFFS_OBJECT_TYPE_FILE:    
N                case YAFFS_OBJECT_TYPE_DIRECTORY:
N		case YAFFS_OBJECT_TYPE_SPECIAL:
N		case YAFFS_OBJECT_TYPE_UNKNOWN:
N			/* do nothing */
N			break;
N		}
N 
N		if (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {
N			/* Could not create the object header, fail the creation */
N 
N			yaffs_DestroyObject(in);
N			in = NULL;
X			in = 0;
N		}
N
N	}
N
N	return in;
N}
N
Nyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const char * name,
N			      __u32 mode, __u32 uid, __u32 gid)
N{
N	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
N				 uid, gid, NULL, NULL, 0);
X				 uid, gid, 0, 0, 0);
N}
N
Nyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const char * name,
N				   __u32 mode, __u32 uid, __u32 gid)
N{
N	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
N				 mode, uid, gid, NULL, NULL, 0);
X				 mode, uid, gid, 0, 0, 0);
N}
N
Nyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev)
N{
N	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
N				 uid, gid, NULL, NULL, rdev);
X				 uid, gid, 0, 0, rdev);
N}
N
Nyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid,
N				 const YCHAR * alias)
X				 const char * alias)
N{
N	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
N				 uid, gid, NULL, alias, 0);
X				 uid, gid, 0, alias, 0);
N}
N
N/* yaffs_Link returns the object id of the equivalent object.*/
Nyaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_Link(yaffs_Object * parent, const char * name,
N			 yaffs_Object * equivalentObject)
N{
N	/* Get the real object in case we were fed a hard link as an equivalent object */
N	equivalentObject = yaffs_GetEquivalentObject(equivalentObject);
N
N	if (yaffs_MknodObject
N	    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,
N	     equivalentObject, NULL, 0)) {
X	     equivalentObject, 0, 0)) {
N		return equivalentObject;
N	} else {
N		return NULL;
X		return 0;
N	}
N
N}
N
Nstatic int yaffs_ChangeObjectName(yaffs_Object * obj, yaffs_Object * newDir,
N				  const YCHAR * newName, int force, int shadows)
X				  const char * newName, int force, int shadows)
N{
N	int unlinkOp;
N	int deleteOp;
N
N	yaffs_Object *existingTarget;
N
N	if (newDir == NULL) {
X	if (newDir == 0) {
N		newDir = obj->parent;	/* use the old directory */
N	}
N
N	if (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR
N		   ("tragedy: yaffs_ChangeObjectName: newDir is not a directory"
N		    TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	
N	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
N	if (obj->myDev->isYaffs2) {
N		unlinkOp = (newDir == obj->myDev->unlinkedDir);
N	} else {
N		unlinkOp = (newDir == obj->myDev->unlinkedDir
N			    && obj->variantType == YAFFS_OBJECT_TYPE_FILE);
N	}
N
N	deleteOp = (newDir == obj->myDev->deletedDir);
N
N	existingTarget = yaffs_FindObjectByName(newDir, newName);
N
N	/* If the object is a file going into the unlinked directory, 
N	 *   then it is OK to just stuff it in since duplicate names are allowed.
N	 *   else only proceed if the new name does not exist and if we're putting 
N	 *   it into a directory.
N	 */
N	if ((unlinkOp ||
N	     deleteOp ||
N	     force ||
N	     (shadows > 0) ||
N	     !existingTarget) &&
N	    newDir->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) {
N		yaffs_SetObjectName(obj, newName);
N		obj->dirty = 1;
N
N		yaffs_AddObjectToDirectory(newDir, obj);
N
N		if (unlinkOp)
N			obj->unlinked = 1;
N
N		/* If it is a deletion then we mark it as a shrink for gc purposes. */
N		if (yaffs_UpdateObjectHeader(obj, newName, 0, deleteOp, shadows)>= 0)
N			return YAFFS_OK;
X			return 1;
N	}
N
N	return YAFFS_FAIL;
X	return 0;
N}
N
Nint yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,
Xint yaffs_RenameObject(yaffs_Object * oldDir, const char * oldName,
N		       yaffs_Object * newDir, const YCHAR * newName)
X		       yaffs_Object * newDir, const char * newName)
N{
N	yaffs_Object *obj=NULL;
X	yaffs_Object *obj=0;
N	yaffs_Object *existingTarget=NULL;
X	yaffs_Object *existingTarget=0;
N	int force = 0;
N	
N	
N	if(!oldDir || oldDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
N		YBUG();
X		;
N	if(!newDir || newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
N		YBUG();
X		;
N
N#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
S	/* Special case for case insemsitive systems (eg. WinCE).
S	 * While look-up is case insensitive, the name isn't.
S	 * Therefore we might want to change x.txt to X.txt
S	*/
S	if (oldDir == newDir && yaffs_strcmp(oldName, newName) == 0) {
S		force = 1;
S	}
N#endif
N
N	else if (yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)
X	else if (strlen(newName) > 255)
N	  /* ENAMETOOLONG */
N	  return YAFFS_FAIL;
X	  return 0;
N
N	obj = yaffs_FindObjectByName(oldDir, oldName);
N
N	if (obj && obj->renameAllowed) {
N
N		/* Now do the handling for an existing target, if there is one */
N
N                existingTarget = yaffs_FindObjectByName(newDir, newName);
N                if (existingTarget &&
N                    existingTarget->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
N                    !ylist_empty(&existingTarget->variant.directoryVariant.children)) {
N                        /* There is a target that is a non-empty directory, so we fail */
N                        return YAFFS_FAIL;      /* EEXIST or ENOTEMPTY */
X                        return 0;       
N                } else if (existingTarget && existingTarget != obj) {
N			/* Nuke the target first, using shadowing, 
N			 * but only if it isn't the same object
N			 */
N			yaffs_ChangeObjectName(obj, newDir, newName, force,
N					       existingTarget->objectId);
N			yaffs_UnlinkObject(existingTarget);
N		}
N
N		return yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);
N	}
N	return YAFFS_FAIL;
X	return 0;
N}
N
N/*------------------------- Block Management and Page Allocation ----------------*/
N
Nstatic int yaffs_InitialiseBlocks(yaffs_Device * dev)
N{
N	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
N
N    
N	dev->blockInfo = NULL;
X	dev->blockInfo = 0;
N	dev->chunkBits = NULL;
X	dev->chunkBits = 0;
N	
N	dev->allocationBlock = -1;	/* force it to get a new one */
N
N	/* If the first allocation strategy fails, thry the alternate one */
N	dev->blockInfo = YMALLOC(nBlocks * sizeof(yaffs_BlockInfo));
X	dev->blockInfo = yaffs_malloc(nBlocks * sizeof(yaffs_BlockInfo));
N    
N	if(!dev->blockInfo){
N		dev->blockInfo = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockInfo));
X		dev->blockInfo = yaffs_malloc(nBlocks * sizeof(yaffs_BlockInfo));
N		dev->blockInfoAlt = 1;
N	}
N	else
N		dev->blockInfoAlt = 0;
N    
N	if(dev->blockInfo){
N	    
N		/* Set up dynamic blockinfo stuff. */
N		dev->chunkBitmapStride = (dev->nChunksPerBlock + 7) / 8; /* round up bytes */
N		dev->chunkBits = YMALLOC(dev->chunkBitmapStride * nBlocks);
X		dev->chunkBits = yaffs_malloc(dev->chunkBitmapStride * nBlocks);
N		if(!dev->chunkBits){
N			dev->chunkBits = YMALLOC_ALT(dev->chunkBitmapStride * nBlocks);
X			dev->chunkBits = yaffs_malloc(dev->chunkBitmapStride * nBlocks);
N			dev->chunkBitsAlt = 1;
N		}
N		else
N			dev->chunkBitsAlt = 0;
N	}
N	
N	if (dev->blockInfo && dev->chunkBits) {
N		memset(dev->blockInfo, 0, nBlocks * sizeof(yaffs_BlockInfo));
N		memset(dev->chunkBits, 0, dev->chunkBitmapStride * nBlocks);
N		return YAFFS_OK;
X		return 1;
N	}
N
N    
N    
N	return YAFFS_FAIL;
X	return 0;
N
N}
N
Nstatic void yaffs_DeinitialiseBlocks(yaffs_Device * dev)
N{
N	if(dev->blockInfoAlt && dev->blockInfo)
N		YFREE_ALT(dev->blockInfo);
X		free(dev->blockInfo);
N	else if(dev->blockInfo)
N		YFREE(dev->blockInfo);
X		free(dev->blockInfo);
N
N	dev->blockInfoAlt = 0;
N
N	dev->blockInfo = NULL;
X	dev->blockInfo = 0;
N	
N	if(dev->chunkBitsAlt && dev->chunkBits)
N		YFREE_ALT(dev->chunkBits);
X		free(dev->chunkBits);
N	else if(dev->chunkBits)
N		YFREE(dev->chunkBits);
X		free(dev->chunkBits);
N	dev->chunkBitsAlt = 0;
N	dev->chunkBits = NULL;
X	dev->chunkBits = 0;
N}
N
Nstatic int yaffs_BlockNotDisqualifiedFromGC(yaffs_Device * dev,
N					    yaffs_BlockInfo * bi)
N{
N	int i;
N	__u32 seq;
N	yaffs_BlockInfo *b;
N
N	if (!dev->isYaffs2)
N		return 1;	/* disqualification only applies to yaffs2. */
N
N	if (!bi->hasShrinkHeader)
N		return 1;	/* can gc */
N
N	/* Find the oldest dirty sequence number if we don't know it and save it
N	 * so we don't have to keep recomputing it.
N	 */
N	if (!dev->oldestDirtySequence) {
N		seq = dev->sequenceNumber;
N
N		for (i = dev->internalStartBlock; i <= dev->internalEndBlock;
N		     i++) {
N			b = yaffs_GetBlockInfo(dev, i);
N			if (b->blockState == YAFFS_BLOCK_STATE_FULL &&
N			    (b->pagesInUse - b->softDeletions) <
N			    dev->nChunksPerBlock && b->sequenceNumber < seq) {
N				seq = b->sequenceNumber;
N			}
N		}
N		dev->oldestDirtySequence = seq;
N	}
N
N	/* Can't do gc of this block if there are any blocks older than this one that have
N	 * discarded pages.
N	 */
N	return (bi->sequenceNumber <= dev->oldestDirtySequence);
N
N}
N
N/* FindDiretiestBlock is used to select the dirtiest block (or close enough)
N * for garbage collection.
N */
N
Nstatic int yaffs_FindBlockForGarbageCollection(yaffs_Device * dev,
N					       int aggressive)
N{
N
N	int b = dev->currentDirtyChecker;
N
N	int i;
N	int iterations;
N	int dirtiest = -1;
N	int pagesInUse = 0;
N	int prioritised=0;
N	yaffs_BlockInfo *bi;
N	int pendingPrioritisedExist = 0;
N	
N	/* First let's see if we need to grab a prioritised block */
N	if(dev->hasPendingPrioritisedGCs){
N		for(i = dev->internalStartBlock; i < dev->internalEndBlock && !prioritised; i++){
N
N			bi = yaffs_GetBlockInfo(dev, i);
N			//yaffs_VerifyBlock(dev,bi,i);
N			
N			if(bi->gcPrioritise) {
N				pendingPrioritisedExist = 1;
N				if(bi->blockState == YAFFS_BLOCK_STATE_FULL &&
N				   yaffs_BlockNotDisqualifiedFromGC(dev, bi)){
N					pagesInUse = (bi->pagesInUse - bi->softDeletions);
N					dirtiest = i;
N					prioritised = 1;
N					aggressive = 1; /* Fool the non-aggressive skip logiv below */
N				}
N			}
N		}
N		
N		if(!pendingPrioritisedExist) /* None found, so we can clear this */
N			dev->hasPendingPrioritisedGCs = 0;
N	}
N
N	/* If we're doing aggressive GC then we are happy to take a less-dirty block, and
N	 * search harder.
N	 * else (we're doing a leasurely gc), then we only bother to do this if the
N	 * block has only a few pages in use.
N	 */
N
N	dev->nonAggressiveSkip--;
N
N	if (!aggressive && (dev->nonAggressiveSkip > 0)) {
N		return -1;
N	}
N
N	if(!prioritised)
N		pagesInUse =
N	    		(aggressive) ? dev->nChunksPerBlock : YAFFS_PASSIVE_GC_CHUNKS + 1;
X	    		(aggressive) ? dev->nChunksPerBlock : 2 + 1;
N
N	if (aggressive) {
N		iterations =
N		    dev->internalEndBlock - dev->internalStartBlock + 1;
N	} else {
N		iterations =
N		    dev->internalEndBlock - dev->internalStartBlock + 1;
N		iterations = iterations / 16;
N		if (iterations > 200) {
N			iterations = 200;
N		}
N	}
N
N	for (i = 0; i <= iterations && pagesInUse > 0 && !prioritised; i++) {
N		b++;
N		if (b < dev->internalStartBlock || b > dev->internalEndBlock) {
N			b = dev->internalStartBlock;
N		}
N
N		if (b < dev->internalStartBlock || b > dev->internalEndBlock) {
N			T(YAFFS_TRACE_ERROR,
N			  (TSTR("**>> Block %d is not valid" TENDSTR), b));
X			do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			YBUG();
X			;
N		}
N
N		bi = yaffs_GetBlockInfo(dev, b);
N
N#if 0
S		if (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT) {
S			dirtiest = b;
S			pagesInUse = 0;
S		}
S		else 
N#endif
N
N		if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
N		       (bi->pagesInUse - bi->softDeletions) < pagesInUse &&
N		        yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
N			dirtiest = b;
N			pagesInUse = (bi->pagesInUse - bi->softDeletions);
N		}
N	}
N
N	dev->currentDirtyChecker = b;
N
N	if (dirtiest > 0) {
N		T(YAFFS_TRACE_GC,
N		  (TSTR("GC Selected block %d with %d free, prioritised:%d" TENDSTR), dirtiest,
N		   dev->nChunksPerBlock - pagesInUse,prioritised));
X		do{ if((0x00000040) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N
N	dev->oldestDirtySequence = 0;
N
N	if (dirtiest > 0) {
N		dev->nonAggressiveSkip = 4;
N	}
N
N	return dirtiest;
N}
N
Nstatic void yaffs_BlockBecameDirty(yaffs_Device * dev, int blockNo)
N{
N	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockNo);
N
N	int erasedOk = 0;
N
N	/* If the block is still healthy erase it and mark as clean.
N	 * If the block has had a data failure, then retire it.
N	 */
N	 
N	T(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
N		(TSTR("yaffs_BlockBecameDirty block %d state %d %s"TENDSTR),
N		blockNo, bi->blockState, (bi->needsRetiring) ? "needs retiring" : ""));
X	do{ if((0x00000040 | 0x00000020) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		
N	bi->blockState = YAFFS_BLOCK_STATE_DIRTY;
N
N	if (!bi->needsRetiring) {
N		yaffs_InvalidateCheckpoint(dev);
W "..\fs\yaffs_guts.c" 2819 14 function "yaffs_EraseBlockInNAND" declared implicitly
N		erasedOk = yaffs_EraseBlockInNAND(dev, blockNo);
N		if (!erasedOk) {
N			dev->nErasureFailures++;
N			T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
N			  (TSTR("**>> Erasure failed %d" TENDSTR), blockNo));
X			do{ if((0x40000000 | 0x00000010) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		}
N	}
N
N	if (erasedOk && 
N	    ((yaffs_traceMask & YAFFS_TRACE_ERASE) || !yaffs_SkipVerification(dev))) {
X	    ((yaffs_traceMask & 0x00000020) || !yaffs_SkipVerification(dev))) {
N		int i;
N		for (i = 0; i < dev->nChunksPerBlock; i++) {
N			if (!yaffs_CheckChunkErased
N			    (dev, blockNo * dev->nChunksPerBlock + i)) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   (">>Block %d erasure supposedly OK, but chunk %d not erased"
N				    TENDSTR), blockNo, i));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			}
N		}
N	}
N
N	if (erasedOk) {
N		/* Clean it up... */
N		bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
N		dev->nErasedBlocks++;
N		bi->pagesInUse = 0;
N		bi->softDeletions = 0;
N		bi->hasShrinkHeader = 0;
N		bi->skipErasedCheck = 1;  /* This is clean, so no need to check */
N		bi->gcPrioritise = 0;
N		yaffs_ClearChunkBits(dev, blockNo);
N
N		T(YAFFS_TRACE_ERASE,
N		  (TSTR("Erased block %d" TENDSTR), blockNo));
X		do{ if((0x00000020) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	} else {
N		dev->nFreeChunks -= dev->nChunksPerBlock;	/* We lost a block of free space */
N
N		yaffs_RetireBlock(dev, blockNo);
N		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
N		  (TSTR("**>> Block %d retired" TENDSTR), blockNo));
X		do{ if((0x40000000 | 0x00000010) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N}
N
Nstatic int yaffs_FindBlockForAllocation(yaffs_Device * dev)
N{
N	int i;
N
N	yaffs_BlockInfo *bi;
N
N	if (dev->nErasedBlocks < 1) {
N		/* Hoosterman we've got a problem.
N		 * Can't get space to gc
N		 */
N		T(YAFFS_TRACE_ERROR,
N		  (TSTR("yaffs tragedy: no more erased blocks" TENDSTR)));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		return -1;
N	}
N	
N	/* Find an empty block. */
N
N	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
N		dev->allocationBlockFinder++;
N		if (dev->allocationBlockFinder < dev->internalStartBlock
N		    || dev->allocationBlockFinder > dev->internalEndBlock) {
N			dev->allocationBlockFinder = dev->internalStartBlock;
N		}
N
N		bi = yaffs_GetBlockInfo(dev, dev->allocationBlockFinder);
N
N		if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
N			bi->blockState = YAFFS_BLOCK_STATE_ALLOCATING;
N			dev->sequenceNumber++;
N			bi->sequenceNumber = dev->sequenceNumber;
N			dev->nErasedBlocks--;
N			T(YAFFS_TRACE_ALLOCATE,
N			  (TSTR("Allocated block %d, seq  %d, %d left" TENDSTR),
N			   dev->allocationBlockFinder, dev->sequenceNumber,
N			   dev->nErasedBlocks));
X			do{ if((0x00000004) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			return dev->allocationBlockFinder;
N		}
N	}
N
N	T(YAFFS_TRACE_ALWAYS,
N	  (TSTR
N	   ("yaffs tragedy: no more erased blocks, but there should have been %d"
N	    TENDSTR), dev->nErasedBlocks));
X	do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	return -1;
N}
N
N
N
Nstatic int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)
N{
N	if(!dev->nCheckpointBlocksRequired &&
N	   dev->isYaffs2){
N		/* Not a valid value so recalculate */
N		int nBytes = 0;
N		int nBlocks;
N		int devBlocks = (dev->endBlock - dev->startBlock + 1);
N		int tnodeSize;
N
N		tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
X		tnodeSize = (dev->tnodeWidth * 16)/8;
N
N		if(tnodeSize < sizeof(yaffs_Tnode))
N			tnodeSize = sizeof(yaffs_Tnode);
N		
N		nBytes += sizeof(yaffs_CheckpointValidity);
N		nBytes += sizeof(yaffs_CheckpointDevice);
N		nBytes += devBlocks * sizeof(yaffs_BlockInfo);
N		nBytes += devBlocks * dev->chunkBitmapStride;
N		nBytes += (sizeof(yaffs_CheckpointObject) + sizeof(__u32)) * (dev->nObjectsCreated - dev->nFreeObjects);
N		nBytes += (tnodeSize + sizeof(__u32)) * (dev->nTnodesCreated - dev->nFreeTnodes);
N		nBytes += sizeof(yaffs_CheckpointValidity);
N		nBytes += sizeof(__u32); /* checksum*/
N	
N		/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */
N	
N		nBlocks = (nBytes/(dev->nDataBytesPerChunk * dev->nChunksPerBlock)) + 3;
N	
N		dev->nCheckpointBlocksRequired = nBlocks;
N	}
N
N	return dev->nCheckpointBlocksRequired;
N}
N
N// Check if there's space to allocate...
N// Thinks.... do we need top make this ths same as yaffs_GetFreeChunks()?
Nstatic int yaffs_CheckSpaceForAllocation(yaffs_Device * dev)
N{
N	int reservedChunks;
N	int reservedBlocks = dev->nReservedBlocks;
N	int checkpointBlocks;
N	
N	if(dev->isYaffs2){
N		checkpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) - 
N				    dev->blocksInCheckpoint;
N		if(checkpointBlocks < 0)
N			checkpointBlocks = 0;
N	} else {
N		checkpointBlocks =0;
N	}
N	
N	reservedChunks = ((reservedBlocks + checkpointBlocks) * dev->nChunksPerBlock);
N	
N	return (dev->nFreeChunks > reservedChunks);
N}
N
Nstatic int yaffs_AllocateChunk(yaffs_Device * dev, int useReserve, yaffs_BlockInfo **blockUsedPtr)
N{
N	int retVal;
N	yaffs_BlockInfo *bi;
N
N	if (dev->allocationBlock < 0) {
N		/* Get next block to allocate off */
N		dev->allocationBlock = yaffs_FindBlockForAllocation(dev);
N		dev->allocationPage = 0;
N	}
N
N	if (!useReserve && !yaffs_CheckSpaceForAllocation(dev)) {
N		/* Not enough space to allocate unless we're allowed to use the reserve. */
N		return -1;
N	}
N
N	if (dev->nErasedBlocks < dev->nReservedBlocks
N	    && dev->allocationPage == 0) {
N		T(YAFFS_TRACE_ALLOCATE, (TSTR("Allocating reserve" TENDSTR)));
X		do{ if((0x00000004) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N
N	/* Next page please.... */
N	if (dev->allocationBlock >= 0) {
N		bi = yaffs_GetBlockInfo(dev, dev->allocationBlock);
N
N		retVal = (dev->allocationBlock * dev->nChunksPerBlock) +
N		    dev->allocationPage;
N		bi->pagesInUse++;
N		yaffs_SetChunkBit(dev, dev->allocationBlock,
N				  dev->allocationPage);
N
N		dev->allocationPage++;
N
N		dev->nFreeChunks--;
N
N		/* If the block is full set the state to full */
N		if (dev->allocationPage >= dev->nChunksPerBlock) {
N			bi->blockState = YAFFS_BLOCK_STATE_FULL;
N			dev->allocationBlock = -1;
N		}
N
N		if(blockUsedPtr)
N			*blockUsedPtr = bi;
N			
N		return retVal;
N	}
N	
N	T(YAFFS_TRACE_ERROR,
N	  (TSTR("!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" TENDSTR)));
X	do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	return -1;
N}
N
Nstatic int yaffs_GetErasedChunks(yaffs_Device * dev)
N{
N	int n;
N
N	n = dev->nErasedBlocks * dev->nChunksPerBlock;
N
N	if (dev->allocationBlock > 0) {
N		n += (dev->nChunksPerBlock - dev->allocationPage);
N	}
N
N	return n;
N
N}
N
Nstatic int yaffs_GarbageCollectBlock(yaffs_Device * dev, int block, int wholeBlock)
N{
N	int oldChunk;
N	int newChunk;
N	int markNAND;
N	int retVal = YAFFS_OK;
X	int retVal = 1;
N	int cleanups = 0;
N	int i;
N	int isCheckpointBlock;
N	int matchingChunk;
N	int maxCopies;
N
N	int chunksBefore = yaffs_GetErasedChunks(dev);
N	int chunksAfter;
N
N	yaffs_ExtendedTags tags;
N
N	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, block);
N
N	yaffs_Object *object;
N
N	isCheckpointBlock = (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT);
N	
N	bi->blockState = YAFFS_BLOCK_STATE_COLLECTING;
N
N	T(YAFFS_TRACE_TRACING,
N	  (TSTR("Collecting block %d, in use %d, shrink %d, wholeBlock %d" TENDSTR), 
N	  block,
N	  bi->pagesInUse,
N	  bi->hasShrinkHeader,
N	  wholeBlock));
X	do{ if((0x00000100) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	/*yaffs_VerifyFreeChunks(dev); */
N
N	bi->hasShrinkHeader = 0;	/* clear the flag so that the block can erase */
N
N	/* Take off the number of soft deleted entries because
N	 * they're going to get really deleted during GC.
N	 */
N	dev->nFreeChunks -= bi->softDeletions;
N
N	dev->isDoingGC = 1;
N
N	if (isCheckpointBlock ||
N	    !yaffs_StillSomeChunkBits(dev, block)) {
N		T(YAFFS_TRACE_TRACING,
N		  (TSTR
N		   ("Collecting block %d that has no chunks in use" TENDSTR),
N		   block));
X		do{ if((0x00000100) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		yaffs_BlockBecameDirty(dev, block);
N	} else {
N
N		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
X		__u8 *buffer = yaffs_GetTempBuffer(dev, 3088);
N		
N		yaffs_VerifyBlock(dev,bi,block);
N
N		maxCopies = (wholeBlock) ? dev->nChunksPerBlock : 10;
N		oldChunk = block * dev->nChunksPerBlock + dev->gcChunk;
N		
N		for ( /* init already done */;
N		     retVal == YAFFS_OK &&
X		     retVal == 1 &&
N		     dev->gcChunk < dev->nChunksPerBlock &&
N		     (bi->blockState == YAFFS_BLOCK_STATE_COLLECTING)&&
N		     maxCopies > 0;
N		     dev->gcChunk++, oldChunk++) {
N			if (yaffs_CheckChunkBit(dev, block, dev->gcChunk)) {
N
N				/* This page is in use and might need to be copied off */
N				
N				maxCopies--;
N
N				markNAND = 1;
N
N				yaffs_InitialiseTags(&tags);
N
W "..\fs\yaffs_guts.c" 3111 5 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N				yaffs_ReadChunkWithTagsFromNAND(dev, oldChunk,
N								buffer, &tags);
N
N				object =
N				    yaffs_FindObjectByNumber(dev,
N							     tags.objectId);
N
N				T(YAFFS_TRACE_GC_DETAIL,
N				  (TSTR
N				   ("Collecting chunk in block %d, %d %d %d " TENDSTR),
N				   dev->gcChunk, tags.objectId, tags.chunkId,
N				   tags.byteCount));
X				do{ if((0x00001000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				   
N				if(object && !yaffs_SkipVerification(dev)){
N					if(tags.chunkId == 0)
N						matchingChunk = object->hdrChunk;
N					else if(object->softDeleted)
N						matchingChunk = oldChunk; /* Defeat the test */
N					else
N						matchingChunk = yaffs_FindChunkInFile(object,tags.chunkId,NULL);
X						matchingChunk = yaffs_FindChunkInFile(object,tags.chunkId,0);
N					
N					if(oldChunk != matchingChunk)
N						T(YAFFS_TRACE_ERROR,
N						  (TSTR("gc: page in gc mismatch: %d %d %d %d"TENDSTR),
N						  oldChunk,matchingChunk,tags.objectId, tags.chunkId));
X						do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N						
N				}
N
N				if (!object) {
N					T(YAFFS_TRACE_ERROR,
N					  (TSTR
N					   ("page %d in gc has no object: %d %d %d "
N					    TENDSTR), oldChunk,
N					    tags.objectId, tags.chunkId, tags.byteCount));
X					do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				}
N
N				if (object && 
N				    object->deleted &&
N				    object->softDeleted &&
N				    tags.chunkId != 0) {
N					/* Data chunk in a soft deleted file, throw it away
N					 * It's a soft deleted data chunk,
N					 * No need to copy this, just forget about it and 
N					 * fix up the object.
N					 */
N
N					object->nDataChunks--;
N
N					if (object->nDataChunks <= 0) {
N						/* remeber to clean up the object */
N						dev->gcCleanupList[cleanups] =
N						    tags.objectId;
N						cleanups++;
N					}
N					markNAND = 0;
N				} else if (0
N					   /* Todo object && object->deleted && object->nDataChunks == 0 */
N					   ) {
N					/* Deleted object header with no data chunks.
N					 * Can be discarded and the file deleted.
N					 */
N					object->hdrChunk = 0;
N					yaffs_FreeTnode(object->myDev,
N							object->variant.
N							fileVariant.top);
N					object->variant.fileVariant.top = NULL;
X					object->variant.fileVariant.top = 0;
N					yaffs_DoGenericObjectDeletion(object);
N
N				} else if (object) {
N					/* It's either a data chunk in a live file or
N					 * an ObjectHeader, so we're interested in it.
N					 * NB Need to keep the ObjectHeaders of deleted files
N					 * until the whole file has been deleted off
N					 */
N					tags.serialNumber++;
N
N					dev->nGCCopies++;
N
N					if (tags.chunkId == 0) {
N						/* It is an object Id,
N						 * We need to nuke the shrinkheader flags first
N						 * We no longer want the shrinkHeader flag since its work is done
N						 * and if it is left in place it will mess up scanning.
N						 */
N
N						yaffs_ObjectHeader *oh;
N						oh = (yaffs_ObjectHeader *)buffer;
N						oh->isShrink = 0;
N						tags.extraIsShrinkHeader = 0;
N						
N						yaffs_VerifyObjectHeader(object,oh,&tags,1);
N					}
N
N					newChunk =
N					    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &tags, 1);
N
N					if (newChunk < 0) {
N						retVal = YAFFS_FAIL;
X						retVal = 0;
N					} else {
N
N						/* Ok, now fix up the Tnodes etc. */
N
N						if (tags.chunkId == 0) {
N							/* It's a header */
N							object->hdrChunk =  newChunk;
N							object->serial =   tags.serialNumber;
N						} else {
N							/* It's a data chunk */
N							yaffs_PutChunkIntoFile
N							    (object,
N							     tags.chunkId,
N							     newChunk, 0);
N						}
N					}
N				}
N
N				if(retVal == YAFFS_OK)
X				if(retVal == 1)
N					yaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);
X					yaffs_DeleteChunk(dev, oldChunk, markNAND, 3228);
N
N			}
N		}
N
N		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
X		yaffs_ReleaseTempBuffer(dev, buffer, 3233);
N
N
N		/* Do any required cleanups */
N		for (i = 0; i < cleanups; i++) {
N			/* Time to delete the file too */
N			object =
N			    yaffs_FindObjectByNumber(dev,
N						     dev->gcCleanupList[i]);
N			if (object) {
N				yaffs_FreeTnode(dev,
N						object->variant.fileVariant.
N						top);
N				object->variant.fileVariant.top = NULL;
X				object->variant.fileVariant.top = 0;
N				T(YAFFS_TRACE_GC,
N				  (TSTR
N				   ("yaffs: About to finally delete object %d"
N				    TENDSTR), object->objectId));
X				do{ if((0x00000040) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				yaffs_DoGenericObjectDeletion(object);
N				object->myDev->nDeletedFiles--;
N			}
N
N		}
N
N	}
N
N	yaffs_VerifyCollectedBlock(dev,bi,block);
N	  
N	if (chunksBefore >= (chunksAfter = yaffs_GetErasedChunks(dev))) {
N		T(YAFFS_TRACE_GC,
N		  (TSTR
N		   ("gc did not increase free chunks before %d after %d"
N		    TENDSTR), chunksBefore, chunksAfter));
X		do{ if((0x00000040) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N
N	/* If the gc completed then clear the current gcBlock so that we find another. */
N	if(bi->blockState != YAFFS_BLOCK_STATE_COLLECTING){
N		dev->gcBlock = -1;
N		dev->gcChunk = 0;
N	}
N	
N	dev->isDoingGC = 0;
N
N	return retVal;
W "..\fs\yaffs_guts.c" 3049 6 variable "chunksAfter" was set but never used
N}
N
N/* New garbage collector
N * If we're very low on erased blocks then we do aggressive garbage collection
N * otherwise we do "leasurely" garbage collection.
N * Aggressive gc looks further (whole array) and will accept less dirty blocks.
N * Passive gc only inspects smaller areas and will only accept more dirty blocks.
N *
N * The idea is to help clear out space in a more spread-out manner.
N * Dunno if it really does anything useful.
N */
Nstatic int yaffs_CheckGarbageCollection(yaffs_Device * dev)
N{
N	int block;
N	int aggressive;
N	int gcOk = YAFFS_OK;
X	int gcOk = 1;
N	int maxTries = 0;
N	
N	int checkpointBlockAdjust;
N
N	if (dev->isDoingGC) {
N		/* Bail out so we don't get recursive gc */
N		return YAFFS_OK;
X		return 1;
N	}
N	
N	/* This loop should pass the first time.
N	 * We'll only see looping here if the erase of the collected block fails.
N	 */
N
N	do {
N		maxTries++;
N		
N		checkpointBlockAdjust = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
N		if(checkpointBlockAdjust < 0)
N			checkpointBlockAdjust = 0;
N
N		if (dev->nErasedBlocks < (dev->nReservedBlocks + checkpointBlockAdjust + 2)) {
N			/* We need a block soon...*/
N			aggressive = 1;
N		} else {
N			/* We're in no hurry */
N			aggressive = 0;
N		}
N
N		if(dev->gcBlock <= 0){
N			dev->gcBlock = yaffs_FindBlockForGarbageCollection(dev, aggressive);
N			dev->gcChunk = 0;
N		}
N		
N		block = dev->gcBlock;
N
N		if (block > 0) {
N			dev->garbageCollections++;
N			if (!aggressive) {
N				dev->passiveGarbageCollections++;
N			}
N
N			T(YAFFS_TRACE_GC,
N			  (TSTR
N			   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),
N			   dev->nErasedBlocks, aggressive));
X			do{ if((0x00000040) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N			gcOk = yaffs_GarbageCollectBlock(dev,block,aggressive);
N		}
N
N		if (dev->nErasedBlocks < (dev->nReservedBlocks) && block > 0) {
N			T(YAFFS_TRACE_GC,
N			  (TSTR
N			   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"
N			    TENDSTR), dev->nErasedBlocks, maxTries, block));
X			do{ if((0x00000040) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		}
N	} while ((dev->nErasedBlocks < dev->nReservedBlocks) && 
N		 (block > 0) &&
N		 (maxTries < 2));
N
N	return aggressive ? gcOk : YAFFS_OK;
X	return aggressive ? gcOk : 1;
N}
N
N/*-------------------------  TAGS --------------------------------*/
N
Nstatic int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,
N			   int chunkInObject)
N{
N	return (tags->chunkId == chunkInObject &&
N		tags->objectId == objectId && !tags->chunkDeleted) ? 1 : 0;
N
N}
N
N
N/*-------------------- Data file manipulation -----------------*/
N
Nstatic int yaffs_FindChunkInFile(yaffs_Object * in, int chunkInInode,
N				 yaffs_ExtendedTags * tags)
N{
N	/*Get the Tnode, then get the level 0 offset chunk offset */
N	yaffs_Tnode *tn;
N	int theChunk = -1;
N	yaffs_ExtendedTags localTags;
N	int retVal = -1;
N
N	yaffs_Device *dev = in->myDev;
N
N	if (!tags) {
N		/* Passed a NULL, so use our own tags space */
N		tags = &localTags;
N	}
N
N	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
N
N	if (tn) {
N		theChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);
N
N		retVal =
N		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
N					   chunkInInode);
N	}
N	return retVal;
N}
N
Nstatic int yaffs_FindAndDeleteChunkInFile(yaffs_Object * in, int chunkInInode,
N					  yaffs_ExtendedTags * tags)
N{
N	/* Get the Tnode, then get the level 0 offset chunk offset */
N	yaffs_Tnode *tn;
N	int theChunk = -1;
N	yaffs_ExtendedTags localTags;
N
N	yaffs_Device *dev = in->myDev;
N	int retVal = -1;
N
N	if (!tags) {
N		/* Passed a NULL, so use our own tags space */
N		tags = &localTags;
N	}
N
N	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
N
N	if (tn) {
N
N		theChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);
N
N		retVal =
N		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
N					   chunkInInode);
N
N		/* Delete the entry in the filestructure (if found) */
N		if (retVal != -1) {
N			yaffs_PutLevel0Tnode(dev,tn,chunkInInode,0);
N		}
N	} else {
N		/*T(("No level 0 found for %d\n", chunkInInode)); */
N	}
N
N	if (retVal == -1) {
N		/* T(("Could not find %d to delete\n",chunkInInode)); */
N	}
N	return retVal;
N}
N
N#ifdef YAFFS_PARANOID
S
Sstatic int yaffs_CheckFileSanity(yaffs_Object * in)
S{
S	int chunk;
S	int nChunks;
S	int fSize;
S	int failed = 0;
S	int objId;
S	yaffs_Tnode *tn;
S	yaffs_Tags localTags;
S	yaffs_Tags *tags = &localTags;
S	int theChunk;
S	int chunkDeleted;
S
S	if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
S		/* T(("Object not a file\n")); */
S		return YAFFS_FAIL;
S	}
S
S	objId = in->objectId;
S	fSize = in->variant.fileVariant.fileSize;
S	nChunks =
S	    (fSize + in->myDev->nDataBytesPerChunk - 1) / in->myDev->nDataBytesPerChunk;
S
S	for (chunk = 1; chunk <= nChunks; chunk++) {
S		tn = yaffs_FindLevel0Tnode(in->myDev, &in->variant.fileVariant,
S					   chunk);
S
S		if (tn) {
S
S			theChunk = yaffs_GetChunkGroupBase(dev,tn,chunk);
S
S			if (yaffs_CheckChunkBits
S			    (dev, theChunk / dev->nChunksPerBlock,
S			     theChunk % dev->nChunksPerBlock)) {
S
S				yaffs_ReadChunkTagsFromNAND(in->myDev, theChunk,
S							    tags,
S							    &chunkDeleted);
S				if (yaffs_TagsMatch
S				    (tags, in->objectId, chunk, chunkDeleted)) {
S					/* found it; */
S
S				}
S			} else {
S
S				failed = 1;
S			}
S
S		} else {
S			/* T(("No level 0 found for %d\n", chunk)); */
S		}
S	}
S
S	return failed ? YAFFS_FAIL : YAFFS_OK;
S}
S
N#endif
N
Nstatic int yaffs_PutChunkIntoFile(yaffs_Object * in, int chunkInInode,
N				  int chunkInNAND, int inScan)
N{
N	/* NB inScan is zero unless scanning. 
N	 * For forward scanning, inScan is > 0; 
N	 * for backward scanning inScan is < 0
N	 */
N	 
N	yaffs_Tnode *tn;
N	yaffs_Device *dev = in->myDev;
N	int existingChunk;
N	yaffs_ExtendedTags existingTags;
N	yaffs_ExtendedTags newTags;
N	unsigned existingSerial, newSerial;
N
N	if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
N		/* Just ignore an attempt at putting a chunk into a non-file during scanning
N		 * If it is not during Scanning then something went wrong!
N		 */
N		if (!inScan) {
N			T(YAFFS_TRACE_ERROR,
N			  (TSTR
N			   ("yaffs tragedy:attempt to put data chunk into a non-file"
N			    TENDSTR)));
X			do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			YBUG();
X			;
N		}
N
N		yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
X		yaffs_DeleteChunk(dev, chunkInNAND, 1, 3523);
N		return YAFFS_OK;
X		return 1;
N	}
N
N	tn = yaffs_AddOrFindLevel0Tnode(dev, 
N					&in->variant.fileVariant,
N					chunkInInode,
N					NULL);
X					0);
N	if (!tn) {
N		return YAFFS_FAIL;
X		return 0;
N	}
N
N	existingChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);
N
N	if (inScan != 0) {
N		/* If we're scanning then we need to test for duplicates
N		 * NB This does not need to be efficient since it should only ever 
N		 * happen when the power fails during a write, then only one
N		 * chunk should ever be affected.
N		 *
N		 * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO
N		 * Update: For backward scanning we don't need to re-read tags so this is quite cheap.
N		 */
N
N		if (existingChunk > 0) {
N			/* NB Right now existing chunk will not be real chunkId if the device >= 32MB
N			 *    thus we have to do a FindChunkInFile to get the real chunk id.
N			 *
N			 * We have a duplicate now we need to decide which one to use:
N			 *
N			 * Backwards scanning YAFFS2: The old one is what we use, dump the new one.
N			 * Forward scanning YAFFS2: The new one is what we use, dump the old one.
N			 * YAFFS1: Get both sets of tags and compare serial numbers.
N			 */
N
N			if (inScan > 0) {
N				/* Only do this for forward scanning */
W "..\fs\yaffs_guts.c" 3560 5 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N				yaffs_ReadChunkWithTagsFromNAND(dev,
N								chunkInNAND,
N								NULL, &newTags);
X								0, &newTags);
N
N				/* Do a proper find */
N				existingChunk =
N				    yaffs_FindChunkInFile(in, chunkInInode,
N							  &existingTags);
N			}
N
N			if (existingChunk <= 0) {
N				/*Hoosterman - how did this happen? */
N
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("yaffs tragedy: existing chunk < 0 in scan"
N				    TENDSTR)));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N			}
N
N			/* NB The deleted flags should be false, otherwise the chunks will 
N			 * not be loaded during a scan
N			 */
N
N			if(inScan > 0) {
N				newSerial = newTags.serialNumber;
N				existingSerial = existingTags.serialNumber;
N			}
N
N			if ((inScan > 0) &&
N			    (in->myDev->isYaffs2 ||
N			     existingChunk <= 0 ||
N			     ((existingSerial + 1) & 3) == newSerial)) {
N				/* Forward scanning.                            
N				 * Use new
N				 * Delete the old one and drop through to update the tnode
N				 */
N				yaffs_DeleteChunk(dev, existingChunk, 1,
N						  __LINE__);
X						  3598);
N			} else {
N				/* Backward scanning or we want to use the existing one
N				 * Use existing.
N				 * Delete the new one and return early so that the tnode isn't changed
N				 */
N				yaffs_DeleteChunk(dev, chunkInNAND, 1,
N						  __LINE__);
X						  3605);
N				return YAFFS_OK;
X				return 1;
N			}
N		}
N
N	}
N
N	if (existingChunk == 0) {
N		in->nDataChunks++;
N	}
N
N	yaffs_PutLevel0Tnode(dev,tn,chunkInInode,chunkInNAND);
N
N	return YAFFS_OK;
X	return 1;
N}
N
Nstatic int yaffs_ReadChunkDataFromObject(yaffs_Object * in, int chunkInInode,
N					 __u8 * buffer)
N{
N	int chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, NULL);
X	int chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, 0);
N        
N	if (chunkInNAND >= 0) {
W "..\fs\yaffs_guts.c" 3627 10 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N		return yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND, buffer,NULL);
X		return yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND, buffer,0);
N						      
N	} else {
N		T(YAFFS_TRACE_NANDACCESS,
N		  (TSTR("Chunk %d not found zero instead" TENDSTR),
N		   chunkInNAND));
X		do{ if((0x00000800) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		/* get sane (zero) data if you read a hole */
N		memset(buffer, 0, in->myDev->nDataBytesPerChunk);	
N		return 0;
N	}
N
N}
N
Nvoid yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn)
N{
N	int block;
N	int page;
N	yaffs_ExtendedTags tags;
N	yaffs_BlockInfo *bi;
N
N	if (chunkId <= 0)
N		return;
N		
N
N	dev->nDeletions++;
N	block = chunkId / dev->nChunksPerBlock;
N	page = chunkId % dev->nChunksPerBlock;
N
N
N	if(!yaffs_CheckChunkBit(dev,block,page))
N		T(YAFFS_TRACE_VERIFY,
N		 	(TSTR("Deleting invalid chunk %d"TENDSTR),
N		 	 chunkId));
X		do{ if((0x00010000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	bi = yaffs_GetBlockInfo(dev, block);
N
N	T(YAFFS_TRACE_DELETION,
N	  (TSTR("line %d delete of chunk %d" TENDSTR), lyn, chunkId));
X	do{ if((0x00000200) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	if (markNAND &&
N	    bi->blockState != YAFFS_BLOCK_STATE_COLLECTING && !dev->isYaffs2) {
N
N		yaffs_InitialiseTags(&tags);
N
N		tags.chunkDeleted = 1;
N
W "..\fs\yaffs_guts.c" 3673 3 function "yaffs_WriteChunkWithTagsToNAND" declared implicitly
N		yaffs_WriteChunkWithTagsToNAND(dev, chunkId, NULL, &tags);
X		yaffs_WriteChunkWithTagsToNAND(dev, chunkId, 0, &tags);
N		yaffs_HandleUpdateChunk(dev, chunkId, &tags);
N	} else {
N		dev->nUnmarkedDeletions++;
N	}
N
N	/* Pull out of the management area.
N	 * If the whole block became dirty, this will kick off an erasure.
N	 */
N	if (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING ||
N	    bi->blockState == YAFFS_BLOCK_STATE_FULL ||
N	    bi->blockState == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
N	    bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {
N		dev->nFreeChunks++;
N
N		yaffs_ClearChunkBit(dev, block, page);
N
N		bi->pagesInUse--;
N
N		if (bi->pagesInUse == 0 &&
N		    !bi->hasShrinkHeader &&
N		    bi->blockState != YAFFS_BLOCK_STATE_ALLOCATING &&
N		    bi->blockState != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
N			yaffs_BlockBecameDirty(dev, block);
N		}
N
N	} else {
N		/* T(("Bad news deleting chunk %d\n",chunkId)); */
N	}
N
N}
N
Nstatic int yaffs_WriteChunkDataToObject(yaffs_Object * in, int chunkInInode,
N					const __u8 * buffer, int nBytes,
N					int useReserve)
N{
N	/* Find old chunk Need to do this to get serial number
N	 * Write new one and patch into tree.
N	 * Invalidate old tags.
N	 */
N
N	int prevChunkId;
N	yaffs_ExtendedTags prevTags;
N
N	int newChunkId;
N	yaffs_ExtendedTags newTags;
N
N	yaffs_Device *dev = in->myDev;
N
N	yaffs_CheckGarbageCollection(dev);
N
N	/* Get the previous chunk at this location in the file if it exists */
N	prevChunkId = yaffs_FindChunkInFile(in, chunkInInode, &prevTags);
N
N	/* Set up new tags */
N	yaffs_InitialiseTags(&newTags);
N
N	newTags.chunkId = chunkInInode;
N	newTags.objectId = in->objectId;
N	newTags.serialNumber =
N	    (prevChunkId >= 0) ? prevTags.serialNumber + 1 : 1;
N	newTags.byteCount = nBytes;
N	
N	if(nBytes < 1 || nBytes > dev->totalBytesPerChunk){
N	  T(YAFFS_TRACE_ERROR,
N	  (TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), nBytes));
X	  do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	  YBUG();
X	  ;
N     }
N	
N	
N
N	newChunkId =
N	    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
N					      useReserve);
N
N	if (newChunkId >= 0) {
N		yaffs_PutChunkIntoFile(in, chunkInInode, newChunkId, 0);
N
N		if (prevChunkId >= 0) {
N			yaffs_DeleteChunk(dev, prevChunkId, 1, __LINE__);
X			yaffs_DeleteChunk(dev, prevChunkId, 1, 3752);
N
N		}
N
N		yaffs_CheckFileSanity(in);
X		;
N	}
N	return newChunkId;
N
N}
N
N/* UpdateObjectHeader updates the header on NAND for an object.
N * If name is not NULL, then that new name is used.
N */
Nint yaffs_UpdateObjectHeader(yaffs_Object * in, const YCHAR * name, int force,
Xint yaffs_UpdateObjectHeader(yaffs_Object * in, const char * name, int force,
N			     int isShrink, int shadows)
N{
N
N	yaffs_BlockInfo *bi;
N
N	yaffs_Device *dev = in->myDev;
N
N	int prevChunkId;
N	int retVal = 0;
N	int result = 0;
N
N	int newChunkId;
N	yaffs_ExtendedTags newTags;
N	yaffs_ExtendedTags oldTags;
N
N	__u8 *buffer = NULL;
X	__u8 *buffer = 0;
N	YCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];
X	char oldName[255 + 1];
N
N        yaffs_ObjectHeader *oh = NULL;
X        yaffs_ObjectHeader *oh = 0;
N        
N        yaffs_strcpy(oldName,_Y("silly old name"));
X        strcpy(oldName,"silly old name");
N 
N
N	if (!in->fake || 
N	    in == dev->rootDir || /* The rootDir should also be saved */
N	    force) {
N
N		yaffs_CheckGarbageCollection(dev);
N		yaffs_CheckObjectDetailsLoaded(in);
N 
N		buffer = yaffs_GetTempBuffer(in->myDev, __LINE__);
X		buffer = yaffs_GetTempBuffer(in->myDev, 3796);
N		oh = (yaffs_ObjectHeader *) buffer;
N 
N		prevChunkId = in->hdrChunk;
N
N		if (prevChunkId > 0) {
W "..\fs\yaffs_guts.c" 3802 13 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N			result = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,
N							buffer, &oldTags);
N			 
N			yaffs_VerifyObjectHeader(in,oh,&oldTags,0);
N			 					
N			memcpy(oldName, oh->name, sizeof(oh->name));
N		}
N 
N		memset(buffer, 0xFF, dev->nDataBytesPerChunk);
N
N		oh->type = in->variantType;
N		oh->yst_mode = in->yst_mode;
N		oh->shadowsObject = oh->inbandShadowsObject = shadows;
N
N#ifdef CONFIG_YAFFS_WINCE
S		oh->win_atime[0] = in->win_atime[0];
S		oh->win_ctime[0] = in->win_ctime[0];
S		oh->win_mtime[0] = in->win_mtime[0];
S		oh->win_atime[1] = in->win_atime[1];
S		oh->win_ctime[1] = in->win_ctime[1];
S		oh->win_mtime[1] = in->win_mtime[1];
N#else
N		oh->yst_uid = in->yst_uid;
N		oh->yst_gid = in->yst_gid;
N		oh->yst_atime = in->yst_atime;
N		oh->yst_mtime = in->yst_mtime;
N		oh->yst_ctime = in->yst_ctime;
N		oh->yst_rdev = in->yst_rdev;
N#endif
N		if (in->parent) {
N			oh->parentObjectId = in->parent->objectId;
N		} else {
N			oh->parentObjectId = 0;
N		}
N
N		if (name && *name) {
N			memset(oh->name, 0, sizeof(oh->name));
N			yaffs_strncpy(oh->name, name, YAFFS_MAX_NAME_LENGTH);
X			strncpy(oh->name,name,255);
N		} else if (prevChunkId>=0) {
N			memcpy(oh->name, oldName, sizeof(oh->name));
N		} else {
N			memset(oh->name, 0, sizeof(oh->name));
N		}
N
N		oh->isShrink = isShrink;
N 
N		switch (in->variantType) {
N		case YAFFS_OBJECT_TYPE_UNKNOWN:
N			/* Should not happen */
N			break;
N		case YAFFS_OBJECT_TYPE_FILE:
N			oh->fileSize =
N			    (oh->parentObjectId == YAFFS_OBJECTID_DELETED
X			    (oh->parentObjectId == 4
N			     || oh->parentObjectId ==
N			     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.
X			     3) ? 0 : in->variant.
N			    fileVariant.fileSize;
N			break;
N		case YAFFS_OBJECT_TYPE_HARDLINK:
N			oh->equivalentObjectId =
N			    in->variant.hardLinkVariant.equivalentObjectId;
N			break;
N		case YAFFS_OBJECT_TYPE_SPECIAL:
N			/* Do nothing */
N			break;
N		case YAFFS_OBJECT_TYPE_DIRECTORY:
N			/* Do nothing */
N			break;
N		case YAFFS_OBJECT_TYPE_SYMLINK:
N			yaffs_strncpy(oh->alias,
N				      in->variant.symLinkVariant.alias,
N				      YAFFS_MAX_ALIAS_LENGTH);
X			strncpy(oh->alias,in->variant . symLinkVariant . alias,159);
N			oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
X			oh->alias[159] = 0;
N			break;
N		}
N 
N		/* Tags */
N		yaffs_InitialiseTags(&newTags);
N		in->serial++;
N		newTags.chunkId = 0;
N		newTags.objectId = in->objectId;
N		newTags.serialNumber = in->serial;
N
N		/* Add extra info for file header */
N
N		newTags.extraHeaderInfoAvailable = 1;
N		newTags.extraParentObjectId = oh->parentObjectId;
N		newTags.extraFileLength = oh->fileSize;
N		newTags.extraIsShrinkHeader = oh->isShrink;
N		newTags.extraEquivalentObjectId = oh->equivalentObjectId;
N		newTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;
N		newTags.extraObjectType = in->variantType;
N
N		yaffs_VerifyObjectHeader(in,oh,&newTags,1);
N 
N		/* Create new chunk in NAND */
N		newChunkId =
N		    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
N						      (prevChunkId >= 0) ? 1 : 0);
N 
N		if (newChunkId >= 0) {
N
N			in->hdrChunk = newChunkId;
N
N			if (prevChunkId >= 0) {
N				yaffs_DeleteChunk(dev, prevChunkId, 1,
N						  __LINE__);
X						  3907);
N			}
N
N			if(!yaffs_ObjectHasCachedWriteData(in))
N				in->dirty = 0;
N
N			/* If this was a shrink, then mark the block that the chunk lives on */
N			if (isShrink) {
N				bi = yaffs_GetBlockInfo(in->myDev,
N							newChunkId /in->myDev->	nChunksPerBlock);
N				bi->hasShrinkHeader = 1;
N			}
N
N		}
N
N		retVal = newChunkId;
N
N	}
N 
N	if (buffer)
N		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
X		yaffs_ReleaseTempBuffer(dev, buffer, 3927);
N 
N	return retVal;
W "..\fs\yaffs_guts.c" 3775 6 variable "result" was set but never used
N}
N
N/*------------------------ Short Operations Cache ----------------------------------------
N *   In many situations where there is no high level buffering (eg WinCE) a lot of
N *   reads might be short sequential reads, and a lot of writes may be short 
N *   sequential writes. eg. scanning/writing a jpeg file.
N *   In these cases, a short read/write cache can provide a huge perfomance benefit 
N *   with dumb-as-a-rock code.
N *   In Linux, the page cache provides read buffering aand the short op cache provides write 
N *   buffering.
N *
N *   There are a limited number (~10) of cache chunks per device so that we don't
N *   need a very intelligent search.
N */
N
Nstatic int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)
N{
N	yaffs_Device *dev = obj->myDev;
N	int i;
N	yaffs_ChunkCache *cache;
N	int nCaches = obj->myDev->nShortOpCaches;
N	
N	for(i = 0; i < nCaches; i++){
N		cache = &dev->srCache[i];
N		if (cache->object == obj &&
N		    cache->dirty)
N			return 1;
N	}
N	
N	return 0;
N}
N
N
Nstatic void yaffs_FlushFilesChunkCache(yaffs_Object * obj)
N{
N	yaffs_Device *dev = obj->myDev;
N	int lowest = -99;	/* Stop compiler whining. */
N	int i;
N	yaffs_ChunkCache *cache;
N	int chunkWritten = 0;
N	int nCaches = obj->myDev->nShortOpCaches;
N
N	if (nCaches > 0) {
N		do {
N			cache = NULL;
X			cache = 0;
N
N			/* Find the dirty cache for this object with the lowest chunk id. */
N			for (i = 0; i < nCaches; i++) {
N				if (dev->srCache[i].object == obj &&
N				    dev->srCache[i].dirty) {
N					if (!cache
N					    || dev->srCache[i].chunkId <
N					    lowest) {
N						cache = &dev->srCache[i];
N						lowest = cache->chunkId;
N					}
N				}
N			}
N
N			if (cache && !cache->locked) {
N				/* Write it out and free it up */
N
N				chunkWritten =
N				    yaffs_WriteChunkDataToObject(cache->object,
N								 cache->chunkId,
N								 cache->data,
N								 cache->nBytes,
N								 1);
N				cache->dirty = 0;
N				cache->object = NULL;
X				cache->object = 0;
N			}
N
N		} while (cache && chunkWritten > 0);
N
N		if (cache) {
N			/* Hoosterman, disk full while writing cache out. */
N			T(YAFFS_TRACE_ERROR,
N			  (TSTR("yaffs tragedy: no space during cache write" TENDSTR)));
X			do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		}
N	}
N
N}
N
N/*yaffs_FlushEntireDeviceCache(dev)
N *
N *
N */
N
Nvoid yaffs_FlushEntireDeviceCache(yaffs_Device *dev)
N{
N	yaffs_Object *obj;
N	int nCaches = dev->nShortOpCaches;
N	int i;
N	
N	/* Find a dirty object in the cache and flush it...
N	 * until there are no further dirty objects.
N	 */
N	do {
N		obj = NULL;
X		obj = 0;
N		for( i = 0; i < nCaches && !obj; i++) {
N			if (dev->srCache[i].object &&
N			    dev->srCache[i].dirty)
N				obj = dev->srCache[i].object;
N			    
N		}
N		if(obj)
N			yaffs_FlushFilesChunkCache(obj);
N			
N	} while(obj);
N	
N}
N
N
N/* Grab us a cache chunk for use.
N * First look for an empty one. 
N * Then look for the least recently used non-dirty one.
N * Then look for the least recently used dirty one...., flush and look again.
N */
Nstatic yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device * dev)
N{
N	int i;
N
N	if (dev->nShortOpCaches > 0) {
N		for (i = 0; i < dev->nShortOpCaches; i++) {
N			if (!dev->srCache[i].object) 
N				return &dev->srCache[i];
N		}
N	}
N
N	return NULL;
X	return 0;
N}
N
Nstatic yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device * dev)
N{
N	yaffs_ChunkCache *cache;
N	yaffs_Object *theObj;
N	int usage;
N	int i;
N	int pushout;
N
N	if (dev->nShortOpCaches > 0) {
N		/* Try find a non-dirty one... */
N
N		cache = yaffs_GrabChunkCacheWorker(dev);
N
N		if (!cache) {
N			/* They were all dirty, find the last recently used object and flush
N			 * its cache, then  find again.
N			 * NB what's here is not very accurate, we actually flush the object
N			 * the last recently used page.
N			 */
N
N			/* With locking we can't assume we can use entry zero */
N
N			theObj = NULL;
X			theObj = 0;
N			usage = -1;
N			cache = NULL;
X			cache = 0;
N			pushout = -1;
N
N			for (i = 0; i < dev->nShortOpCaches; i++) {
N				if (dev->srCache[i].object &&
N				    !dev->srCache[i].locked &&
N				    (dev->srCache[i].lastUse < usage || !cache))
N				{
N					usage = dev->srCache[i].lastUse;
N					theObj = dev->srCache[i].object;
N					cache = &dev->srCache[i];
N					pushout = i;
N				}
N			}
N
N			if (!cache || cache->dirty) {
N				/* Flush and try again */
N				yaffs_FlushFilesChunkCache(theObj);
N				cache = yaffs_GrabChunkCacheWorker(dev);
N			}
N
N		}
N		return cache;
N	} else
N		return NULL;
X		return 0;
N
W "..\fs\yaffs_guts.c" 4069 6 variable "pushout" was set but never used
N}
N
N/* Find a cached chunk */
Nstatic yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object * obj,
N					      int chunkId)
N{
N	yaffs_Device *dev = obj->myDev;
N	int i;
N	if (dev->nShortOpCaches > 0) {
N		for (i = 0; i < dev->nShortOpCaches; i++) {
N			if (dev->srCache[i].object == obj &&
N			    dev->srCache[i].chunkId == chunkId) {
N				dev->cacheHits++;
N
N				return &dev->srCache[i];
N			}
N		}
N	}
N	return NULL;
X	return 0;
N}
N
N/* Mark the chunk for the least recently used algorithym */
Nstatic void yaffs_UseChunkCache(yaffs_Device * dev, yaffs_ChunkCache * cache,
N				int isAWrite)
N{
N
N	if (dev->nShortOpCaches > 0) {
N		if (dev->srLastUse < 0 || dev->srLastUse > 100000000) {
N			/* Reset the cache usages */
N			int i;
N			for (i = 1; i < dev->nShortOpCaches; i++) {
N				dev->srCache[i].lastUse = 0;
N			}
N			dev->srLastUse = 0;
N		}
N
N		dev->srLastUse++;
N
N		cache->lastUse = dev->srLastUse;
N
N		if (isAWrite) {
N			cache->dirty = 1;
N		}
N	}
N}
N
N/* Invalidate a single cache page.
N * Do this when a whole page gets written,
N * ie the short cache for this page is no longer valid.
N */
Nstatic void yaffs_InvalidateChunkCache(yaffs_Object * object, int chunkId)
N{
N	if (object->myDev->nShortOpCaches > 0) {
N		yaffs_ChunkCache *cache = yaffs_FindChunkCache(object, chunkId);
N
N		if (cache) {
N			cache->object = NULL;
X			cache->object = 0;
N		}
N	}
N}
N
N/* Invalidate all the cache pages associated with this object
N * Do this whenever ther file is deleted or resized.
N */
Nstatic void yaffs_InvalidateWholeChunkCache(yaffs_Object * in)
N{
N	int i;
N	yaffs_Device *dev = in->myDev;
N
N	if (dev->nShortOpCaches > 0) {
N		/* Invalidate it. */
N		for (i = 0; i < dev->nShortOpCaches; i++) {
N			if (dev->srCache[i].object == in) {
N				dev->srCache[i].object = NULL;
X				dev->srCache[i].object = 0;
N			}
N		}
N	}
N}
N
N/*--------------------- Checkpointing --------------------*/
N
N
Nstatic int yaffs_WriteCheckpointValidityMarker(yaffs_Device *dev,int head)
N{
N	yaffs_CheckpointValidity cp;
N	
N	memset(&cp,0,sizeof(cp));
N	
N	cp.structType = sizeof(cp);
N	cp.magic = YAFFS_MAGIC;
X	cp.magic = 0x5941FF53;
N	cp.version = YAFFS_CHECKPOINT_VERSION;
X	cp.version = 3;
N	cp.head = (head) ? 1 : 0;
N	
N	return (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp))?
N		1 : 0;
N}
N
Nstatic int yaffs_ReadCheckpointValidityMarker(yaffs_Device *dev, int head)
N{
N	yaffs_CheckpointValidity cp;
N	int ok;
N
N    
N	ok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));
N    
N	if(ok)
N		ok = (cp.structType == sizeof(cp)) &&
N		     (cp.magic == YAFFS_MAGIC) &&
X		     (cp.magic == 0x5941FF53) &&
N		     (cp.version == YAFFS_CHECKPOINT_VERSION) &&
X		     (cp.version == 3) &&
N		     (cp.head == ((head) ? 1 : 0));
N	return ok ? 1 : 0;
N}
N
Nstatic void yaffs_DeviceToCheckpointDevice(yaffs_CheckpointDevice *cp, 
N					   yaffs_Device *dev)
N{
N	cp->nErasedBlocks = dev->nErasedBlocks;
N	cp->allocationBlock = dev->allocationBlock;
N	cp->allocationPage = dev->allocationPage;
N	cp->nFreeChunks = dev->nFreeChunks;
N	
N	cp->nDeletedFiles = dev->nDeletedFiles;
N	cp->nUnlinkedFiles = dev->nUnlinkedFiles;
N	cp->nBackgroundDeletions = dev->nBackgroundDeletions;
N	cp->sequenceNumber = dev->sequenceNumber;
N	cp->oldestDirtySequence = dev->oldestDirtySequence;
N	
N}
N
Nstatic void yaffs_CheckpointDeviceToDevice(yaffs_Device *dev,
N					   yaffs_CheckpointDevice *cp)
N{
N	dev->nErasedBlocks = cp->nErasedBlocks;
N	dev->allocationBlock = cp->allocationBlock;
N	dev->allocationPage = cp->allocationPage;
N	dev->nFreeChunks = cp->nFreeChunks;
N	
N	dev->nDeletedFiles = cp->nDeletedFiles;
N	dev->nUnlinkedFiles = cp->nUnlinkedFiles;
N	dev->nBackgroundDeletions = cp->nBackgroundDeletions;
N	dev->sequenceNumber = cp->sequenceNumber;
N	dev->oldestDirtySequence = cp->oldestDirtySequence;
N}
N
N
Nstatic int yaffs_WriteCheckpointDevice(yaffs_Device *dev)
N{
N	yaffs_CheckpointDevice cp;
N	__u32 nBytes;
N	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
N
N	int ok;
N		
N	/* Write device runtime values*/
N	yaffs_DeviceToCheckpointDevice(&cp,dev);
N	cp.structType = sizeof(cp);
N	
N	ok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));
N	
N	/* Write block info */
N	if(ok) {
N		nBytes = nBlocks * sizeof(yaffs_BlockInfo);
N		ok = (yaffs_CheckpointWrite(dev,dev->blockInfo,nBytes) == nBytes);
N	}
N		
N	/* Write chunk bits */		
N	if(ok) {
N		nBytes = nBlocks * dev->chunkBitmapStride;
N		ok = (yaffs_CheckpointWrite(dev,dev->chunkBits,nBytes) == nBytes);
N	}
N	return	 ok ? 1 : 0;
N
N}
N
Nstatic int yaffs_ReadCheckpointDevice(yaffs_Device *dev)
N{
N	yaffs_CheckpointDevice cp;
N	__u32 nBytes;
N	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
N
N	int ok;	
N	
N	ok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));
N	if(!ok)
N		return 0;
N		
N	if(cp.structType != sizeof(cp))
N		return 0;
N		
N	
N	yaffs_CheckpointDeviceToDevice(dev,&cp);
N	
N	nBytes = nBlocks * sizeof(yaffs_BlockInfo);
N	
N	ok = (yaffs_CheckpointRead(dev,dev->blockInfo,nBytes) == nBytes);
N	
N	if(!ok)
N		return 0;
N	nBytes = nBlocks * dev->chunkBitmapStride;
N	
N	ok = (yaffs_CheckpointRead(dev,dev->chunkBits,nBytes) == nBytes);
N	
N	return ok ? 1 : 0;
N}
N
Nstatic void yaffs_ObjectToCheckpointObject(yaffs_CheckpointObject *cp,
N					   yaffs_Object *obj)
N{
N
N	cp->objectId = obj->objectId;
N	cp->parentId = (obj->parent) ? obj->parent->objectId : 0;
N	cp->hdrChunk = obj->hdrChunk;
N	cp->variantType = obj->variantType;
N	cp->deleted = obj->deleted;
N	cp->softDeleted = obj->softDeleted;
N	cp->unlinked = obj->unlinked;
N	cp->fake = obj->fake;
N	cp->renameAllowed = obj->renameAllowed;
N	cp->unlinkAllowed = obj->unlinkAllowed;
N	cp->serial = obj->serial;
N	cp->nDataChunks = obj->nDataChunks;
N	
N	if(obj->variantType == YAFFS_OBJECT_TYPE_FILE)
N		cp->fileSizeOrEquivalentObjectId = obj->variant.fileVariant.fileSize;
N	else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
N		cp->fileSizeOrEquivalentObjectId = obj->variant.hardLinkVariant.equivalentObjectId;
N}
N
Nstatic int yaffs_CheckpointObjectToObject( yaffs_Object *obj,yaffs_CheckpointObject *cp)
N{
N
N	yaffs_Object *parent;
N
N	if (obj->variantType != cp->variantType) {
N		T(YAFFS_TRACE_ERROR,(TSTR("Checkpoint read object %d type %d "
N			TCONT("chunk %d does not match existing object type %d")
N			TENDSTR), cp->objectId, cp->variantType, cp->hdrChunk,
N			obj->variantType));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return 0;
N	}
N	
N	obj->objectId = cp->objectId;
N	
N	if(cp->parentId)
N		parent = yaffs_FindOrCreateObjectByNumber(
N					obj->myDev,
N					cp->parentId,
N					YAFFS_OBJECT_TYPE_DIRECTORY);
N	else
N		parent = NULL;
X		parent = 0;
N		
N	if(parent) {
N		if (parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
N			T(YAFFS_TRACE_ALWAYS,(TSTR("Checkpoint read object %d parent %d type %d"
N				TCONT(" chunk %d Parent type, %d, not directory")
N				TENDSTR),
N				cp->objectId,cp->parentId,cp->variantType,cp->hdrChunk,parent->variantType));
X			do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			return 0;
N		}
N		yaffs_AddObjectToDirectory(parent, obj);
N	}
N
N	obj->hdrChunk = cp->hdrChunk;
N	obj->variantType = cp->variantType;
N	obj->deleted = cp->deleted;
N	obj->softDeleted = cp->softDeleted;
N	obj->unlinked = cp->unlinked;
N	obj->fake = cp->fake;
N	obj->renameAllowed = cp->renameAllowed;
N	obj->unlinkAllowed = cp->unlinkAllowed;
N	obj->serial = cp->serial;
N	obj->nDataChunks = cp->nDataChunks;
N	
N	if(obj->variantType == YAFFS_OBJECT_TYPE_FILE)
N		obj->variant.fileVariant.fileSize = cp->fileSizeOrEquivalentObjectId;
N	else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
N		obj->variant.hardLinkVariant.equivalentObjectId = cp->fileSizeOrEquivalentObjectId;
N
N	if(obj->hdrChunk > 0)
N		obj->lazyLoaded = 1;
N	return 1;
N}
N
N
N
Nstatic int yaffs_CheckpointTnodeWorker(yaffs_Object * in, yaffs_Tnode * tn,
N				  	__u32 level, int chunkOffset)
N{
N	int i;
N	yaffs_Device *dev = in->myDev;
N	int ok = 1;
N	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
X	int tnodeSize = (dev->tnodeWidth * 16)/8;
N
N	if(tnodeSize < sizeof(yaffs_Tnode))
N		tnodeSize = sizeof(yaffs_Tnode);
N	
N
N	if (tn) {
N		if (level > 0) {
N
N			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){
X			for (i = 0; i < (16 / 2) && ok; i++){
N				if (tn->internal[i]) {
N					ok = yaffs_CheckpointTnodeWorker(in,
N							tn->internal[i],
N							level - 1,
N							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
X							(chunkOffset<<(4 - 1)) + i);
N				}
N			}
N		} else if (level == 0) {
N			__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;
X			__u32 baseOffset = chunkOffset <<  4;
N			ok = (yaffs_CheckpointWrite(dev,&baseOffset,sizeof(baseOffset)) == sizeof(baseOffset));
N			if(ok)
N				ok = (yaffs_CheckpointWrite(dev,tn,tnodeSize) == tnodeSize);
N		}
N	}
N
N	return ok;
N
N}
N
Nstatic int yaffs_WriteCheckpointTnodes(yaffs_Object *obj)
N{
N	__u32 endMarker = ~0;
N	int ok = 1;
N	
N	if(obj->variantType == YAFFS_OBJECT_TYPE_FILE){
N		ok = yaffs_CheckpointTnodeWorker(obj,
N					    obj->variant.fileVariant.top,
N					    obj->variant.fileVariant.topLevel,
N					    0);
N		if(ok)
N			ok = (yaffs_CheckpointWrite(obj->myDev,&endMarker,sizeof(endMarker)) == 
N				sizeof(endMarker));
N	}
N	
N	return ok ? 1 : 0;
N}
N
Nstatic int yaffs_ReadCheckpointTnodes(yaffs_Object *obj)
N{
N	__u32 baseChunk;
N	int ok = 1;
N	yaffs_Device *dev = obj->myDev;
N	yaffs_FileStructure *fileStructPtr = &obj->variant.fileVariant;
N	yaffs_Tnode *tn;
N	int nread = 0;
N	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
X	int tnodeSize = (dev->tnodeWidth * 16)/8;
N
N	if(tnodeSize < sizeof(yaffs_Tnode))
N		tnodeSize = sizeof(yaffs_Tnode);
N
N	ok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));
N	
N	while(ok && (~baseChunk)){
N		nread++;
N		/* Read level 0 tnode */
N		
N		
N		tn = yaffs_GetTnodeRaw(dev);
N		if(tn)
N			ok = (yaffs_CheckpointRead(dev,tn,tnodeSize) == tnodeSize);
N		else
N			ok = 0;
N			
N		if(tn && ok){
N			ok = yaffs_AddOrFindLevel0Tnode(dev,
N					       		fileStructPtr,
N					       		baseChunk,
N					       		tn) ? 1 : 0;
N					       		
N		}
N			
N		if(ok)
N			ok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));
N		
N	}
N
N	T(YAFFS_TRACE_CHECKPOINT,(
N		TSTR("Checkpoint read tnodes %d records, last %d. ok %d" TENDSTR),
N		nread,baseChunk,ok));
X	do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	return ok ? 1 : 0;	
N}
N 
N
Nstatic int yaffs_WriteCheckpointObjects(yaffs_Device *dev)
N{
N	yaffs_Object *obj;
N        yaffs_CheckpointObject cp;
N        int i;
N        int ok = 1;
N        struct ylist_head *lh;
N
N        
N        /* Iterate through the objects in each hash entry,
N	 * dumping them to the checkpointing stream.
N         */
N         
N         for(i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++){
X         for(i = 0; ok &&  i <  256; i++){
N                ylist_for_each(lh, &dev->objectBucket[i].list) {
X                for (lh = (&dev->objectBucket[i]. list)->next; lh != (&dev->objectBucket[i]. list); lh = lh->next ) {
N                        if (lh) {
N                                obj = ylist_entry(lh, yaffs_Object, hashLink);
X                                obj = ((yaffs_Object *)((char *)(lh)-(unsigned long)(&((yaffs_Object *)0)->hashLink)));
N                                if (!obj->deferedFree) {
N                                        yaffs_ObjectToCheckpointObject(&cp,obj);
N                                        cp.structType = sizeof(cp);
N
N					T(YAFFS_TRACE_CHECKPOINT,(
N						TSTR("Checkpoint write object %d parent %d type %d chunk %d obj addr %x" TENDSTR),
N						cp.objectId,cp.parentId,cp.variantType,cp.hdrChunk,(unsigned) obj));
X					do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N					ok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));
N					
N					if(ok && obj->variantType == YAFFS_OBJECT_TYPE_FILE){
N						ok = yaffs_WriteCheckpointTnodes(obj);
N					}
N				}
N			}
N		}
N	 }
N	 
N	 /* Dump end of list */
N	memset(&cp,0xFF,sizeof(yaffs_CheckpointObject));
N	cp.structType = sizeof(cp);
N	
N	if(ok)
N		ok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));
N		
N	return ok ? 1 : 0;
N}
N
Nstatic int yaffs_ReadCheckpointObjects(yaffs_Device *dev)
N{
N	yaffs_Object *obj;
N	yaffs_CheckpointObject cp;
N	int ok = 1;
N	int done = 0;
N	yaffs_Object *hardList = NULL;
X	yaffs_Object *hardList = 0;
N	
N	while(ok && !done) {
N		ok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));
N		if(cp.structType != sizeof(cp)) {
N			T(YAFFS_TRACE_CHECKPOINT,(TSTR("struct size %d instead of %d ok %d"TENDSTR),
N				cp.structType,sizeof(cp),ok));
X			do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			ok = 0;
N		}
N			
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("Checkpoint read object %d parent %d type %d chunk %d " TENDSTR),
N			cp.objectId,cp.parentId,cp.variantType,cp.hdrChunk));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		if(ok && cp.objectId == ~0)
N			done = 1;
N		else if(ok){
N			obj = yaffs_FindOrCreateObjectByNumber(dev,cp.objectId, cp.variantType);
N			if(obj) {
N				ok = yaffs_CheckpointObjectToObject(obj,&cp);
N				if (!ok)
N					break;
N				if(obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
N                                        ok = yaffs_ReadCheckpointTnodes(obj);
N                                } else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
N                                        obj->hardLinks.next =
N                                                    (struct ylist_head *)
N                                                    hardList;
N                                        hardList = obj;
N                                }
N			   
N			}
N			else
N				ok = 0;
N		}
N	}
N	
N	if(ok)
N		yaffs_HardlinkFixup(dev,hardList);
N	
N	return ok ? 1 : 0;
N}
N
Nstatic int yaffs_WriteCheckpointSum(yaffs_Device *dev)
N{
N	__u32 checkpointSum;
N	int ok;
N	
N	yaffs_GetCheckpointSum(dev,&checkpointSum);
N	
N	ok = (yaffs_CheckpointWrite(dev,&checkpointSum,sizeof(checkpointSum)) == sizeof(checkpointSum));
N	
N	if(!ok)
N		return 0;
N	
N	return 1;
N}
N
Nstatic int yaffs_ReadCheckpointSum(yaffs_Device *dev)
N{
N	__u32 checkpointSum0;
N	__u32 checkpointSum1;
N	int ok;
N	
N	yaffs_GetCheckpointSum(dev,&checkpointSum0);
N	
N	ok = (yaffs_CheckpointRead(dev,&checkpointSum1,sizeof(checkpointSum1)) == sizeof(checkpointSum1));
N	
N	if(!ok)
N		return 0;
N		
N	if(checkpointSum0 != checkpointSum1)
N		return 0;
N	
N	return 1;
N}
N
N
Nstatic int yaffs_WriteCheckpointData(yaffs_Device *dev)
N{
N
N	int ok = 1;
N	
N	if(dev->skipCheckpointWrite || !dev->isYaffs2){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("skipping checkpoint write" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = 0;
N	}
N		
N	if(ok)
N		ok = yaffs_CheckpointOpen(dev,1);
N	
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint validity" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = yaffs_WriteCheckpointValidityMarker(dev,1);
N	}
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint device" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = yaffs_WriteCheckpointDevice(dev);
N	}
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint objects" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = yaffs_WriteCheckpointObjects(dev);
N	}
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint validity" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = yaffs_WriteCheckpointValidityMarker(dev,0);
N	}
N	
N	if(ok){
N		ok = yaffs_WriteCheckpointSum(dev);
N	}
N	
N	
N	if(!yaffs_CheckpointClose(dev))
N		 ok = 0;
N		 
N	if(ok)
N	    	dev->isCheckpointed = 1;
N	 else 
N	 	dev->isCheckpointed = 0;
N
N	return dev->isCheckpointed;
N}
N
Nstatic int yaffs_ReadCheckpointData(yaffs_Device *dev)
N{
N	int ok = 1;
N
N	if(dev->skipCheckpointRead || !dev->isYaffs2){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("skipping checkpoint read" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = 0;
N	}
N    
N	if(ok)
N		ok = yaffs_CheckpointOpen(dev,0); /* open for read */
N    
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint validity" TENDSTR)));	
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);	
N		ok = yaffs_ReadCheckpointValidityMarker(dev,1);
N	}
N    
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint device" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = yaffs_ReadCheckpointDevice(dev);
N	}
N    
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint objects" TENDSTR)));	
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);	
N		ok = yaffs_ReadCheckpointObjects(dev);
N	}
N    
N	if(ok){
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint validity" TENDSTR)));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		ok = yaffs_ReadCheckpointValidityMarker(dev,0);
N	}
N 
N	if(ok){
N		ok = yaffs_ReadCheckpointSum(dev);
N		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint checksum %d" TENDSTR),ok));
X		do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	}
N 
N	if(!yaffs_CheckpointClose(dev))
N		ok = 0;
N 
N	if(ok)
N	    	dev->isCheckpointed = 1;
N	 else 
N	 	dev->isCheckpointed = 0;
N
N	return ok ? 1 : 0;
N
N}
N
Nstatic void yaffs_InvalidateCheckpoint(yaffs_Device *dev)
N{
N	if(dev->isCheckpointed || 
N	   dev->blocksInCheckpoint > 0){
N		dev->isCheckpointed = 0;
N		yaffs_CheckpointInvalidateStream(dev);
N		if(dev->superBlock && dev->markSuperBlockDirty)
N			dev->markSuperBlockDirty(dev->superBlock);
N	}
N}
N
N
Nint yaffs_CheckpointSave(yaffs_Device *dev)
N{
N
N	T(YAFFS_TRACE_CHECKPOINT,(TSTR("save entry: isCheckpointed %d"TENDSTR),dev->isCheckpointed));
X	do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	yaffs_VerifyObjects(dev);
N	yaffs_VerifyBlocks(dev);
N	yaffs_VerifyFreeChunks(dev);
N
N	if(!dev->isCheckpointed) {
N		yaffs_InvalidateCheckpoint(dev);
N		yaffs_WriteCheckpointData(dev);
N	}
N	
N	T(YAFFS_TRACE_ALWAYS,(TSTR("save exit: isCheckpointed %d"TENDSTR),dev->isCheckpointed));
X	do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	return dev->isCheckpointed;
N}
N
Nint yaffs_CheckpointRestore(yaffs_Device *dev)
N{
N	int retval;
N	T(YAFFS_TRACE_CHECKPOINT,(TSTR("restore entry: isCheckpointed %d"TENDSTR),dev->isCheckpointed));
X	do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N                
N	retval = yaffs_ReadCheckpointData(dev);
N    
N	if(dev->isCheckpointed){
N		yaffs_VerifyObjects(dev);
N		yaffs_VerifyBlocks(dev);
N		yaffs_VerifyFreeChunks(dev);
N	}
N
N	T(YAFFS_TRACE_CHECKPOINT,(TSTR("restore exit: isCheckpointed %d"TENDSTR),dev->isCheckpointed));
X	do{ if((0x00008000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	
N	return retval;
N}
N
N/*--------------------- File read/write ------------------------
N * Read and write have very similar structures.
N * In general the read/write has three parts to it
N * An incomplete chunk to start with (if the read/write is not chunk-aligned)
N * Some complete chunks
N * An incomplete chunk to end off with
N *
N * Curve-balls: the first chunk might also be the last chunk.
N */
N
Nint yaffs_ReadDataFromFile(yaffs_Object * in, __u8 * buffer, loff_t offset,
N			   int nBytes)
N{
N
N	int chunk;
N	__u32 start;
N	int nToCopy;
N	int n = nBytes;
N	int nDone = 0;
N	yaffs_ChunkCache *cache;
N
N	yaffs_Device *dev;
N
N	dev = in->myDev;
N
N	while (n > 0) {
N		//chunk = offset / dev->nDataBytesPerChunk + 1;
N		//start = offset % dev->nDataBytesPerChunk;
N		yaffs_AddrToChunk(dev,offset,&chunk,&start);
N		chunk++;
N
N		/* OK now check for the curveball where the start and end are in
N		 * the same chunk.      
N		 */
N		if ((start + n) < dev->nDataBytesPerChunk) {
N			nToCopy = n;
N		} else {
N			nToCopy = dev->nDataBytesPerChunk - start;
N		}
N
N		cache = yaffs_FindChunkCache(in, chunk);
N
N		/* If the chunk is already in the cache or it is less than a whole chunk
N		 * or we're using inband tags then use the cache (if there is caching)
N		 * else bypass the cache.
N		 */
N		if (cache || nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
N			if (dev->nShortOpCaches > 0) {
N
N				/* If we can't find the data in the cache, then load it up. */
N
N				if (!cache) {
N					cache = yaffs_GrabChunkCache(in->myDev);
N					cache->object = in;
N					cache->chunkId = chunk;
N					cache->dirty = 0;
N					cache->locked = 0;
N					yaffs_ReadChunkDataFromObject(in, chunk,
N								      cache->
N								      data);
N					cache->nBytes = 0;
N				}
N
N				yaffs_UseChunkCache(dev, cache, 0);
N
N				cache->locked = 1;
N
N
N				memcpy(buffer, &cache->data[start], nToCopy);
N
N				cache->locked = 0;
N			} else {
N				/* Read into the local buffer then copy..*/
N
N				__u8 *localBuffer =
N				    yaffs_GetTempBuffer(dev, __LINE__);
X				    yaffs_GetTempBuffer(dev, 4845);
N				yaffs_ReadChunkDataFromObject(in, chunk,
N							      localBuffer);
N
N				memcpy(buffer, &localBuffer[start], nToCopy);
N
N
N				yaffs_ReleaseTempBuffer(dev, localBuffer,
N							__LINE__);
X							4853);
N			}
N
N		} else {
N
N			/* A full chunk. Read directly into the supplied buffer. */
N			yaffs_ReadChunkDataFromObject(in, chunk, buffer);
N
N		}
N
N		n -= nToCopy;
N		offset += nToCopy;
N		buffer += nToCopy;
N		nDone += nToCopy;
N
N	}
N
N	return nDone;
N}
N
Nint yaffs_WriteDataToFile(yaffs_Object * in, const __u8 * buffer, loff_t offset,
N			  int nBytes, int writeThrough)
N{
N
N	int chunk;
N	__u32 start;
N	int nToCopy;
N        int n = nBytes;
N        int nDone = 0;
N        int nToWriteBack;
N        int startOfWrite = offset;
N        int chunkWritten = 0;
N        __u32 nBytesRead;
N        __u32 chunkStart;
N
N	yaffs_Device *dev;
N
N	dev = in->myDev;
N
N	while (n > 0 && chunkWritten >= 0) {
N		//chunk = offset / dev->nDataBytesPerChunk + 1;
N		//start = offset % dev->nDataBytesPerChunk;
N		yaffs_AddrToChunk(dev,offset,&chunk,&start);
N		
N		if(chunk * dev->nDataBytesPerChunk + start != offset ||
N		   start >= dev->nDataBytesPerChunk){
N		   T(YAFFS_TRACE_ERROR,(
N			   TSTR("AddrToChunk of offset %d gives chunk %d start %d"
N			   TENDSTR),
N		   	   (int)offset, chunk,start));
X		   do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		}
N		chunk++;
N
N		/* OK now check for the curveball where the start and end are in
N		 * the same chunk.
N		 */
N
N		if ((start + n) < dev->nDataBytesPerChunk) {
N			nToCopy = n;
N
N			/* Now folks, to calculate how many bytes to write back....
N			 * If we're overwriting and not writing to then end of file then
N			 * we need to write back as much as was there before.
N			 */
N
N			chunkStart = ((chunk - 1) * dev->nDataBytesPerChunk);
N
N			if(chunkStart > in->variant.fileVariant.fileSize)
N				nBytesRead = 0; /* Past end of file */
N			else
N				nBytesRead = in->variant.fileVariant.fileSize - chunkStart;
N
N			if (nBytesRead > dev->nDataBytesPerChunk) {
N				nBytesRead = dev->nDataBytesPerChunk;
N			}
N
N			nToWriteBack =
N			    (nBytesRead >
N			     (start + n)) ? nBytesRead : (start + n);
N			
N			if(nToWriteBack < 0 || nToWriteBack > dev->nDataBytesPerChunk)
N				YBUG();
X				;
N
N		} else {
N			nToCopy = dev->nDataBytesPerChunk - start;
N			nToWriteBack = dev->nDataBytesPerChunk;
N		}
N
N		if (nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
N			/* An incomplete start or end chunk (or maybe both start and end chunk), 
N			 * or we're using inband tags, so we want to use the cache buffers.
N			 */
N			if (dev->nShortOpCaches > 0) {
N				yaffs_ChunkCache *cache;
N				/* If we can't find the data in the cache, then load the cache */
N				cache = yaffs_FindChunkCache(in, chunk);
N				
N				if (!cache
N				    && yaffs_CheckSpaceForAllocation(in->
N								     myDev)) {
N					cache = yaffs_GrabChunkCache(in->myDev);
N					cache->object = in;
N					cache->chunkId = chunk;
N					cache->dirty = 0;
N					cache->locked = 0;
N					yaffs_ReadChunkDataFromObject(in, chunk,
N								      cache->
N								      data);
N				}
N				else if(cache && 
N				        !cache->dirty &&
N					!yaffs_CheckSpaceForAllocation(in->myDev)){
N					/* Drop the cache if it was a read cache item and
N					 * no space check has been made for it.
N					 */ 
N					 cache = NULL;
X					 cache = 0;
N				}
N
N				if (cache) {
N					yaffs_UseChunkCache(dev, cache, 1);
N					cache->locked = 1;
N
N
N					memcpy(&cache->data[start], buffer,
N					       nToCopy);
N
N
N					cache->locked = 0;
N					cache->nBytes = nToWriteBack;
N
N					if (writeThrough) {
N						chunkWritten =
N						    yaffs_WriteChunkDataToObject
N						    (cache->object,
N						     cache->chunkId,
N						     cache->data, cache->nBytes,
N						     1);
N						cache->dirty = 0;
N					}
N
N				} else {
N					chunkWritten = -1;	/* fail the write */
N				}
N			} else {
N				/* An incomplete start or end chunk (or maybe both start and end chunk)
N				 * Read into the local buffer then copy, then copy over and write back.
N				 */
N
N				__u8 *localBuffer =
N				    yaffs_GetTempBuffer(dev, __LINE__);
X				    yaffs_GetTempBuffer(dev, 5002);
N
N				yaffs_ReadChunkDataFromObject(in, chunk,
N							      localBuffer);
N
N
N
N				memcpy(&localBuffer[start], buffer, nToCopy);
N
N				chunkWritten =
N				    yaffs_WriteChunkDataToObject(in, chunk,
N								 localBuffer,
N								 nToWriteBack,
N								 0);
N
N				yaffs_ReleaseTempBuffer(dev, localBuffer,
N							__LINE__);
X							5018);
N
N			}
N
N		} else {
N			/* A full chunk. Write directly from the supplied buffer. */
N			
N
N
N			chunkWritten =
N			    yaffs_WriteChunkDataToObject(in, chunk, buffer,
N							 dev->nDataBytesPerChunk,
N							 0);
N
N			/* Since we've overwritten the cached data, we better invalidate it. */
N			yaffs_InvalidateChunkCache(in, chunk);
N		}
N
N		if (chunkWritten >= 0) {
N			n -= nToCopy;
N			offset += nToCopy;
N			buffer += nToCopy;
N			nDone += nToCopy;
N		}
N
N	}
N
N	/* Update file object */
N
N	if ((startOfWrite + nDone) > in->variant.fileVariant.fileSize) {
N		in->variant.fileVariant.fileSize = (startOfWrite + nDone);
N	}
N
N	in->dirty = 1;
N
N	return nDone;
N}
N
N
N/* ---------------------- File resizing stuff ------------------ */
N
Nstatic void yaffs_PruneResizedChunks(yaffs_Object * in, int newSize)
N{
N
N	yaffs_Device *dev = in->myDev;
N	int oldFileSize = in->variant.fileVariant.fileSize;
N
N	int lastDel = 1 + (oldFileSize - 1) / dev->nDataBytesPerChunk;
N
N	int startDel = 1 + (newSize + dev->nDataBytesPerChunk - 1) /
N	    dev->nDataBytesPerChunk;
N	int i;
N	int chunkId;
N
N	/* Delete backwards so that we don't end up with holes if
N	 * power is lost part-way through the operation.
N	 */
N	for (i = lastDel; i >= startDel; i--) {
N		/* NB this could be optimised somewhat,
N		 * eg. could retrieve the tags and write them without
N		 * using yaffs_DeleteChunk
N		 */
N
N		chunkId = yaffs_FindAndDeleteChunkInFile(in, i, NULL);
X		chunkId = yaffs_FindAndDeleteChunkInFile(in, i, 0);
N		if (chunkId > 0) {
N			if (chunkId <
N			    (dev->internalStartBlock * dev->nChunksPerBlock)
N			    || chunkId >=
N			    ((dev->internalEndBlock +
N			      1) * dev->nChunksPerBlock)) {
N				T(YAFFS_TRACE_ALWAYS,
N				  (TSTR("Found daft chunkId %d for %d" TENDSTR),
N				   chunkId, i));
X				do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			} else {
N				in->nDataChunks--;
N				yaffs_DeleteChunk(dev, chunkId, 1, __LINE__);
X				yaffs_DeleteChunk(dev, chunkId, 1, 5093);
N			}
N		}
N	}
N
N}
N
Nint yaffs_ResizeFile(yaffs_Object * in, loff_t newSize)
N{
N
N	int oldFileSize = in->variant.fileVariant.fileSize;
N	__u32 newSizeOfPartialChunk;
N	int newFullChunks;
N	
N	yaffs_Device *dev = in->myDev;
N
N	yaffs_AddrToChunk(dev, newSize, &newFullChunks, &newSizeOfPartialChunk);
N
N	yaffs_FlushFilesChunkCache(in);
N	yaffs_InvalidateWholeChunkCache(in);
N
N        yaffs_CheckGarbageCollection(dev);
N
N        if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
N                return YAFFS_FAIL;
X                return 0;
N        }
N
N        if (newSize == oldFileSize) {
N                return YAFFS_OK;
X                return 1;
N        }
N
N        if (newSize < oldFileSize) {
N
N		yaffs_PruneResizedChunks(in, newSize);
N
N		if (newSizeOfPartialChunk != 0) {
N			int lastChunk = 1 + newFullChunks;
N			
N			__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);
X			__u8 *localBuffer = yaffs_GetTempBuffer(dev, 5131);
N
N			/* Got to read and rewrite the last chunk with its new size and zero pad */
N			yaffs_ReadChunkDataFromObject(in, lastChunk,
N						      localBuffer);
N
N			memset(localBuffer + newSizeOfPartialChunk, 0,
N			       dev->nDataBytesPerChunk - newSizeOfPartialChunk);
N
N			yaffs_WriteChunkDataToObject(in, lastChunk, localBuffer,
N						     newSizeOfPartialChunk, 1);
N
N			yaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);
X			yaffs_ReleaseTempBuffer(dev, localBuffer, 5143);
N		}
N
N		in->variant.fileVariant.fileSize = newSize;
N
N		yaffs_PruneFileStructure(dev, &in->variant.fileVariant);
N	} else {
N		/* newsSize > oldFileSize */
N		in->variant.fileVariant.fileSize = newSize;
N	}
N
N		
N	
N	/* Write a new object header.
N	 * show we've shrunk the file, if need be
N	 * Do this only if the file is not in the deleted directories.
N	 */
N	if (in->parent &&
N	    in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
X	    in->parent->objectId != 3 &&
N	    in->parent->objectId != YAFFS_OBJECTID_DELETED) {
X	    in->parent->objectId != 4) {
N		yaffs_UpdateObjectHeader(in, NULL, 0,
X		yaffs_UpdateObjectHeader(in, 0, 0,
N					 (newSize < oldFileSize) ? 1 : 0, 0);
N	}
N
N	return YAFFS_OK;
X	return 1;
N}
N
Nloff_t yaffs_GetFileSize(yaffs_Object * obj)
N{
N	obj = yaffs_GetEquivalentObject(obj);
N
N	switch (obj->variantType) {
N	case YAFFS_OBJECT_TYPE_FILE:
N		return obj->variant.fileVariant.fileSize;
N	case YAFFS_OBJECT_TYPE_SYMLINK:
N		return yaffs_strlen(obj->variant.symLinkVariant.alias);
X		return strlen(obj->variant . symLinkVariant . alias);
N	default:
N		return 0;
N	}
N}
N
N
N
Nint yaffs_FlushFile(yaffs_Object * in, int updateTime)
N{
N	int retVal;
N	if (in->dirty) {
N		yaffs_FlushFilesChunkCache(in);
N		if (updateTime) {
N#ifdef CONFIG_YAFFS_WINCE
S			yfsd_WinFileTimeNow(in->win_mtime);
N#else
N
N			in->yst_mtime = Y_CURRENT_TIME;
X			in->yst_mtime = yaffsfs_CurrentTime();
N
N#endif
N		}
N
N		retVal =
N		    (yaffs_UpdateObjectHeader(in, NULL, 0, 0, 0) >=
X		    (yaffs_UpdateObjectHeader(in, 0, 0, 0, 0) >=
N		     0) ? YAFFS_OK : YAFFS_FAIL;
X		     0) ? 1 : 0;
N	} else {
N		retVal = YAFFS_OK;
X		retVal = 1;
N	}
N
N	return retVal;
N
N}
N
Nstatic int yaffs_DoGenericObjectDeletion(yaffs_Object * in)
N{
N
N	/* First off, invalidate the file's data in the cache, without flushing. */
N	yaffs_InvalidateWholeChunkCache(in);
N
N	if (in->myDev->isYaffs2 && (in->parent != in->myDev->deletedDir)) {
N		/* Move to the unlinked directory so we have a record that it was deleted. */
N		yaffs_ChangeObjectName(in, in->myDev->deletedDir,_Y("deleted"), 0, 0);
X		yaffs_ChangeObjectName(in, in->myDev->deletedDir,"deleted", 0, 0);
N
N	}
N
N	yaffs_RemoveObjectFromDirectory(in);
N	yaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, __LINE__);
X	yaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, 5225);
N	in->hdrChunk = 0;
N
N	yaffs_FreeObject(in);
N	return YAFFS_OK;
X	return 1;
N
N}
N
N/* yaffs_DeleteFile deletes the whole file data
N * and the inode associated with the file.
N * It does not delete the links associated with the file.
N */
Nstatic int yaffs_UnlinkFile(yaffs_Object * in)
N{
N
N	int retVal;
N	int immediateDeletion = 0;
N
N#ifdef __KERNEL__
S	if (!in->myInode) {
S		immediateDeletion = 1;
S	}
N#else
N	if (in->inUse <= 0) {
N		immediateDeletion = 1;
N	}
N#endif
N
N	if (immediateDeletion) {
N		retVal =
N		    yaffs_ChangeObjectName(in, in->myDev->deletedDir,
N					   _Y("deleted"), 0, 0);
X					   "deleted", 0, 0);
N		T(YAFFS_TRACE_TRACING,
N		  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
N		   in->objectId));
X		do{ if((0x00000100) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		in->deleted = 1;
N		in->myDev->nDeletedFiles++;
N		if (1 || in->myDev->isYaffs2) {
N			yaffs_ResizeFile(in, 0);
N		}
N		yaffs_SoftDeleteFile(in);
N	} else {
N		retVal =
N		    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,
N					   _Y("unlinked"), 0, 0);
X					   "unlinked", 0, 0);
N	}
N
N
N	return retVal;
N}
N
Nint yaffs_DeleteFile(yaffs_Object * in)
N{
N	int retVal = YAFFS_OK;
X	int retVal = 1;
N	int deleted = in->deleted;
N	
N	yaffs_ResizeFile(in,0);
N
N	if (in->nDataChunks > 0) {
N		/* Use soft deletion if there is data in the file.
N		 * That won't be the case if it has been resized to zero.
N		 */
N		if (!in->unlinked) {
N			retVal = yaffs_UnlinkFile(in);
N		}
N		if (retVal == YAFFS_OK && in->unlinked && !in->deleted) {
X		if (retVal == 1 && in->unlinked && !in->deleted) {
N			in->deleted = deleted = 1;
N			in->myDev->nDeletedFiles++;
N			yaffs_SoftDeleteFile(in);
N		}
N		return deleted ? YAFFS_OK : YAFFS_FAIL;
X		return deleted ? 1 : 0;
N	} else {
N		/* The file has no data chunks so we toss it immediately */
N		yaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);
N		in->variant.fileVariant.top = NULL;
X		in->variant.fileVariant.top = 0;
N		yaffs_DoGenericObjectDeletion(in);
N
N		return YAFFS_OK;
X		return 1;
N	}
N}
N
Nstatic int yaffs_DeleteDirectory(yaffs_Object * in)
N{
N        /* First check that the directory is empty. */
N        if (ylist_empty(&in->variant.directoryVariant.children)) {
N                return yaffs_DoGenericObjectDeletion(in);
N        }
N
N	return YAFFS_FAIL;
X	return 0;
N
N}
N
Nstatic int yaffs_DeleteSymLink(yaffs_Object * in)
N{
N	YFREE(in->variant.symLinkVariant.alias);
X	free(in->variant . symLinkVariant . alias);
N
N	return yaffs_DoGenericObjectDeletion(in);
N}
N
Nstatic int yaffs_DeleteHardLink(yaffs_Object * in)
N{
N        /* remove this hardlink from the list assocaited with the equivalent
N         * object
N         */
N        ylist_del_init(&in->hardLinks);
N        return yaffs_DoGenericObjectDeletion(in);
N}
N
Nstatic void yaffs_DestroyObject(yaffs_Object * obj)
N{
N	switch (obj->variantType) {
N	case YAFFS_OBJECT_TYPE_FILE:
N		yaffs_DeleteFile(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_DIRECTORY:
N		yaffs_DeleteDirectory(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_SYMLINK:
N		yaffs_DeleteSymLink(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_HARDLINK:
N		yaffs_DeleteHardLink(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_SPECIAL:
N		yaffs_DoGenericObjectDeletion(obj);
N		break;
N	case YAFFS_OBJECT_TYPE_UNKNOWN:
N		break;		/* should not happen. */
N	}
N}
N
Nstatic int yaffs_UnlinkWorker(yaffs_Object * obj)
N{
N
N        if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
N                return yaffs_DeleteHardLink(obj);
N        } else if (!ylist_empty(&obj->hardLinks)) {
N                /* Curve ball: We're unlinking an object that has a hardlink.
N                 *
N                 * This problem arises because we are not strictly following
N		 * The Linux link/inode model.
N		 *
N		 * We can't really delete the object.
N		 * Instead, we do the following:
N		 * - Select a hardlink.
N		 * - Unhook it from the hard links
N		 * - Unhook it from its parent directory (so that the rename can work)
N		 * - Rename the object to the hardlink's name.
N		 * - Delete the hardlink
N		 */
N
N		yaffs_Object *hl;
N                int retVal;
N                YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
X                char name[255 + 1];
N
N                hl = ylist_entry(obj->hardLinks.next, yaffs_Object, hardLinks);
X                hl = ((yaffs_Object *)((char *)(obj->hardLinks . next)-(unsigned long)(&((yaffs_Object *)0)->hardLinks)));
N
N                ylist_del_init(&hl->hardLinks);
N                ylist_del_init(&hl->siblings);
N
N                yaffs_GetObjectName(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
X                yaffs_GetObjectName(hl, name, 255 + 1);
N
N		retVal = yaffs_ChangeObjectName(obj, hl->parent, name, 0, 0);
N
N		if (retVal == YAFFS_OK) {
X		if (retVal == 1) {
N			retVal = yaffs_DoGenericObjectDeletion(hl);
N		}
N		return retVal;
N
N	} else {
N		switch (obj->variantType) {
N		case YAFFS_OBJECT_TYPE_FILE:
N			return yaffs_UnlinkFile(obj);
W "..\fs\yaffs_guts.c" 5398 4 statement is unreachable
N			break;
N		case YAFFS_OBJECT_TYPE_DIRECTORY:
N			return yaffs_DeleteDirectory(obj);
W "..\fs\yaffs_guts.c" 5401 4 statement is unreachable
N			break;
N		case YAFFS_OBJECT_TYPE_SYMLINK:
N			return yaffs_DeleteSymLink(obj);
W "..\fs\yaffs_guts.c" 5404 4 statement is unreachable
N			break;
N		case YAFFS_OBJECT_TYPE_SPECIAL:
N			return yaffs_DoGenericObjectDeletion(obj);
W "..\fs\yaffs_guts.c" 5407 4 statement is unreachable
N			break;
N		case YAFFS_OBJECT_TYPE_HARDLINK:
N		case YAFFS_OBJECT_TYPE_UNKNOWN:
N		default:
N			return YAFFS_FAIL;
X			return 0;
N		}
N	}
N}
N
N
Nstatic int yaffs_UnlinkObject( yaffs_Object *obj)
N{
N
N	if (obj && obj->unlinkAllowed) {
N		return yaffs_UnlinkWorker(obj);
N	}
N
N	return YAFFS_FAIL;
X	return 0;
N
N}
Nint yaffs_Unlink(yaffs_Object * dir, const YCHAR * name)
Xint yaffs_Unlink(yaffs_Object * dir, const char * name)
N{
N	yaffs_Object *obj;
N
N	obj = yaffs_FindObjectByName(dir, name);
N	return yaffs_UnlinkObject(obj);
N}
N
N/*----------------------- Initialisation Scanning ---------------------- */
N
Nstatic void yaffs_HandleShadowedObject(yaffs_Device * dev, int objId,
N				       int backwardScanning)
N{
N	yaffs_Object *obj;
N
N	if (!backwardScanning) {
N		/* Handle YAFFS1 forward scanning case
N		 * For YAFFS1 we always do the deletion
N		 */
N
N	} else {
N		/* Handle YAFFS2 case (backward scanning)
N		 * If the shadowed object exists then ignore.
N		 */
N		if (yaffs_FindObjectByNumber(dev, objId)) {
N			return;
N		}
N	}
N
N	/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.
N	 * We put it in unlinked dir to be cleaned up after the scanning
N	 */
N	obj =
N	    yaffs_FindOrCreateObjectByNumber(dev, objId,
N					     YAFFS_OBJECT_TYPE_FILE);
N	if (!obj)
N		return;
N	yaffs_AddObjectToDirectory(dev->unlinkedDir, obj);
N	obj->variant.fileVariant.shrinkSize = 0;
N	obj->valid = 1;		/* So that we don't read any other info for this file */
N
N}
N
Ntypedef struct {
N	int seq;
N	int block;
N} yaffs_BlockIndex;
N
N
Nstatic void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList)
N{
N	yaffs_Object *hl;
N	yaffs_Object *in;
N	
N	while (hardList) {
N		hl = hardList;
N		hardList = (yaffs_Object *) (hardList->hardLinks.next);
N
N		in = yaffs_FindObjectByNumber(dev,
N					      hl->variant.hardLinkVariant.
N					      equivalentObjectId);
N
N                if (in) {
N                        /* Add the hardlink pointers */
N                        hl->variant.hardLinkVariant.equivalentObject = in;
N                        ylist_add(&hl->hardLinks, &in->hardLinks);
N                } else {
N                        /* Todo Need to report/handle this better.
N                         * Got a problem... hardlink to a non-existant object
N                         */
N                        hl->variant.hardLinkVariant.equivalentObject = NULL;
X                        hl->variant.hardLinkVariant.equivalentObject = 0;
N                        YINIT_LIST_HEAD(&hl->hardLinks);
X                        do { (&hl->hardLinks)->next = (&hl->hardLinks); (&hl->hardLinks)->prev = (&hl->hardLinks); } while(0);
N
N                }
N
N	}
N
N}
N
N
N
N
N
Nstatic int ybicmp(const void *a, const void *b){
N    register int aseq = ((yaffs_BlockIndex *)a)->seq;
N    register int bseq = ((yaffs_BlockIndex *)b)->seq;
N    register int ablock = ((yaffs_BlockIndex *)a)->block;
N    register int bblock = ((yaffs_BlockIndex *)b)->block;
N    if( aseq == bseq )
N        return ablock - bblock;
N    else
N        return aseq - bseq;
N
N}
N
N
Nstruct yaffs_ShadowFixerStruct {
N	int objectId;
N	int shadowedId;
N	struct yaffs_ShadowFixerStruct *next;
N};
N
N
Nstatic void yaffs_StripDeletedObjects(yaffs_Device *dev)
N{
N	/*
N	*  Sort out state of unlinked and deleted objects after scanning.
N	*/
N	struct ylist_head *i;
N	struct ylist_head *n;
N	yaffs_Object *l;
N
N	/* Soft delete all the unlinked files */
N	ylist_for_each_safe(i, n,
N		&dev->unlinkedDir->variant.directoryVariant.children) {
X	for (i = (&dev->unlinkedDir->variant . directoryVariant . children)->next, n = (&dev->unlinkedDir->variant . directoryVariant . children)->next->next; i != (&dev->unlinkedDir->variant . directoryVariant . children); i = n, n = n->next) {
N		if (i) {
N			l = ylist_entry(i, yaffs_Object, siblings);
X			l = ((yaffs_Object *)((char *)(i)-(unsigned long)(&((yaffs_Object *)0)->siblings)));
N			yaffs_DestroyObject(l);
N		}
N	}
N	
N	ylist_for_each_safe(i, n,
N		&dev->deletedDir->variant.directoryVariant.children) {
X	for (i = (&dev->deletedDir->variant . directoryVariant . children)->next, n = (&dev->deletedDir->variant . directoryVariant . children)->next->next; i != (&dev->deletedDir->variant . directoryVariant . children); i = n, n = n->next) {
N		if (i) {
N			l = ylist_entry(i, yaffs_Object, siblings);
X			l = ((yaffs_Object *)((char *)(i)-(unsigned long)(&((yaffs_Object *)0)->siblings)));
N			yaffs_DestroyObject(l);
N		}
N	}
N
N}
N
Nstatic int yaffs_Scan(yaffs_Device * dev)
N{
N	yaffs_ExtendedTags tags;
N	int blk;
N	int blockIterator;
N	int startIterator;
N	int endIterator;
N	int result;
N
N	int chunk;
N	int c;
N	int deleted;
N	yaffs_BlockState state;
N	yaffs_Object *hardList = NULL;
X	yaffs_Object *hardList = 0;
N	yaffs_BlockInfo *bi;
N	__u32 sequenceNumber;
N	yaffs_ObjectHeader *oh;
N	yaffs_Object *in;
N	yaffs_Object *parent;
N	
N	int alloc_failed = 0;
N	
N	struct yaffs_ShadowFixerStruct *shadowFixerList = NULL;
X	struct yaffs_ShadowFixerStruct *shadowFixerList = 0;
N	
N
N	__u8 *chunkData;
N
N	
N	
N	T(YAFFS_TRACE_SCAN,
N	  (TSTR("yaffs_Scan starts  intstartblk %d intendblk %d..." TENDSTR),
N	   dev->internalStartBlock, dev->internalEndBlock));
X	do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
X	chunkData = yaffs_GetTempBuffer(dev, 5591);
N
N	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
X	dev->sequenceNumber = 0x00001000;
N
N	/* Scan all the blocks to determine their state */
N	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
N		bi = yaffs_GetBlockInfo(dev, blk);
N		yaffs_ClearChunkBits(dev, blk);
N		bi->pagesInUse = 0;
N		bi->softDeletions = 0;
N
W "..\fs\yaffs_guts.c" 5602 3 function "yaffs_QueryInitialBlockState" declared implicitly
N		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
N
N		bi->blockState = state;
N		bi->sequenceNumber = sequenceNumber;
N
N		if(bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
X		if(bi->sequenceNumber == 0xFFFF0000)
N			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
N
N		T(YAFFS_TRACE_SCAN_DEBUG,
N		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
N		   state, sequenceNumber));
X		do{ if((0x00002000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		if (state == YAFFS_BLOCK_STATE_DEAD) {
N			T(YAFFS_TRACE_BAD_BLOCKS,
N			  (TSTR("block %d is bad" TENDSTR), blk));
X			do{ if((0x00000010) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
N			T(YAFFS_TRACE_SCAN_DEBUG,
N			  (TSTR("Block empty " TENDSTR)));
X			do{ if((0x00002000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			dev->nErasedBlocks++;
N			dev->nFreeChunks += dev->nChunksPerBlock;
N		} 
N	}
N
N	startIterator = dev->internalStartBlock;
N	endIterator = dev->internalEndBlock;
N
N	/* For each block.... */
N	for (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;
N	     blockIterator++) {
N		
N		YYIELD();
X		do {} while(0);
N
N	     	YYIELD();
X	     	do {} while(0);
N	     	
N		blk = blockIterator;
N
N		bi = yaffs_GetBlockInfo(dev, blk);
W "..\fs\yaffs_guts.c" 5639 9 enumerated type mixed with another type
N		state = bi->blockState;
N
N		deleted = 0;
N
N		/* For each chunk in each block that needs scanning....*/
N		for (c = 0; !alloc_failed && c < dev->nChunksPerBlock &&
N		     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {
N			/* Read the tags and decide what to do */
N			chunk = blk * dev->nChunksPerBlock + c;
N
W "..\fs\yaffs_guts.c" 5649 13 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
X			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, 0,
N							&tags);
N
N			/* Let's have a good look at this chunk... */
N
N			if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED || tags.chunkDeleted) {
N				/* YAFFS1 only...
N				 * A deleted chunk
N				 */
N				deleted++;
N				dev->nFreeChunks++;
N				/*T((" %d %d deleted\n",blk,c)); */
N			} else if (!tags.chunkUsed) {
N				/* An unassigned chunk in the block
N				 * This means that either the block is empty or 
N				 * this is the one being allocated from
N				 */
N
N				if (c == 0) {
N					/* We're looking at the first chunk in the block so the block is unused */
N					state = YAFFS_BLOCK_STATE_EMPTY;
N					dev->nErasedBlocks++;
N				} else {
N					/* this is the block being allocated from */
N					T(YAFFS_TRACE_SCAN,
N					  (TSTR
N					   (" Allocating from %d %d" TENDSTR),
N					   blk, c));
X					do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N					state = YAFFS_BLOCK_STATE_ALLOCATING;
N					dev->allocationBlock = blk;
N					dev->allocationPage = c;
N					dev->allocationBlockFinder = blk;	
N					/* Set it to here to encourage the allocator to go forth from here. */
N					
N				}
N
N				dev->nFreeChunks += (dev->nChunksPerBlock - c);
N			} else if (tags.chunkId > 0) {
N				/* chunkId > 0 so it is a data chunk... */
N				unsigned int endpos;
N
N				yaffs_SetChunkBit(dev, blk, c);
N				bi->pagesInUse++;
N
N				in = yaffs_FindOrCreateObjectByNumber(dev,
N								      tags.
N								      objectId,
N								      YAFFS_OBJECT_TYPE_FILE);
N				/* PutChunkIntoFile checks for a clash (two data chunks with
N				 * the same chunkId).
N				 */
N				 
N				if(!in)
N					alloc_failed = 1;
N
N				if(in){
N					if(!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk,1))
N						alloc_failed = 1;
N				}
N				
N				endpos =
N				    (tags.chunkId - 1) * dev->nDataBytesPerChunk +
N				    tags.byteCount;
N				if (in && 
N				    in->variantType == YAFFS_OBJECT_TYPE_FILE
N				    && in->variant.fileVariant.scannedFileSize <
N				    endpos) {
N					in->variant.fileVariant.
N					    scannedFileSize = endpos;
N					if (!dev->useHeaderFileSize) {
N						in->variant.fileVariant.
N						    fileSize =
N						    in->variant.fileVariant.
N						    scannedFileSize;
N					}
N
N				}
N				/* T((" %d %d data %d %d\n",blk,c,tags.objectId,tags.chunkId));   */
N			} else {
N				/* chunkId == 0, so it is an ObjectHeader.
N				 * Thus, we read in the object header and make the object
N				 */
N				yaffs_SetChunkBit(dev, blk, c);
N				bi->pagesInUse++;
N
N				result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk,
N								chunkData,
N								NULL);
X								0);
N
N				oh = (yaffs_ObjectHeader *) chunkData;
N
N				in = yaffs_FindObjectByNumber(dev,
N							      tags.objectId);
N				if (in && in->variantType != oh->type) {
N					/* This should not happen, but somehow
N					 * Wev'e ended up with an objectId that has been reused but not yet 
N					 * deleted, and worse still it has changed type. Delete the old object.
N					 */
N
N					yaffs_DestroyObject(in);
N
N					in = 0;
N				}
N
N				in = yaffs_FindOrCreateObjectByNumber(dev,
N								      tags.
N								      objectId,
N								      oh->type);
N
N				if(!in)
N					alloc_failed = 1;
N					
N				if (in && oh->shadowsObject > 0) {
N				
N					struct yaffs_ShadowFixerStruct *fixer;
N					fixer = YMALLOC(sizeof(struct yaffs_ShadowFixerStruct));
X					fixer = yaffs_malloc(sizeof(struct yaffs_ShadowFixerStruct));
N					if(fixer){
N						fixer-> next = shadowFixerList;
N						shadowFixerList = fixer;
N						fixer->objectId = tags.objectId;
N						fixer->shadowedId = oh->shadowsObject;
N					}
N					
N				}
N
N				if (in && in->valid) {
N					/* We have already filled this one. We have a duplicate and need to resolve it. */
N
N					unsigned existingSerial = in->serial;
N					unsigned newSerial = tags.serialNumber;
N
N					if (((existingSerial + 1) & 3) == newSerial) {
N						/* Use new one - destroy the exisiting one */
N						yaffs_DeleteChunk(dev,
N								  in->hdrChunk,
N								  1, __LINE__);
X								  1, 5784);
N						in->valid = 0;
N					} else {
N						/* Use existing - destroy this one. */
N						yaffs_DeleteChunk(dev, chunk, 1,
N								  __LINE__);
X								  5789);
N					}
N				}
N
N				if (in && !in->valid &&
N				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
X				    (tags.objectId == 1 ||
N				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND)) {
X				     tags.objectId == 2)) {
N					/* We only load some info, don't fiddle with directory structure */
N					in->valid = 1;
N					in->variantType = oh->type;
N
N					in->yst_mode = oh->yst_mode;
N#ifdef CONFIG_YAFFS_WINCE
S					in->win_atime[0] = oh->win_atime[0];
S					in->win_ctime[0] = oh->win_ctime[0];
S					in->win_mtime[0] = oh->win_mtime[0];
S					in->win_atime[1] = oh->win_atime[1];
S					in->win_ctime[1] = oh->win_ctime[1];
S					in->win_mtime[1] = oh->win_mtime[1];
N#else
N					in->yst_uid = oh->yst_uid;
N					in->yst_gid = oh->yst_gid;
N					in->yst_atime = oh->yst_atime;
N					in->yst_mtime = oh->yst_mtime;
N					in->yst_ctime = oh->yst_ctime;
N					in->yst_rdev = oh->yst_rdev;
N#endif
N					in->hdrChunk = chunk;
N					in->serial = tags.serialNumber;
N
N				} else if (in && !in->valid) {
N					/* we need to load this info */
N
N					in->valid = 1;
N					in->variantType = oh->type;
N
N					in->yst_mode = oh->yst_mode;
N#ifdef CONFIG_YAFFS_WINCE
S					in->win_atime[0] = oh->win_atime[0];
S					in->win_ctime[0] = oh->win_ctime[0];
S					in->win_mtime[0] = oh->win_mtime[0];
S					in->win_atime[1] = oh->win_atime[1];
S					in->win_ctime[1] = oh->win_ctime[1];
S					in->win_mtime[1] = oh->win_mtime[1];
N#else
N					in->yst_uid = oh->yst_uid;
N					in->yst_gid = oh->yst_gid;
N					in->yst_atime = oh->yst_atime;
N					in->yst_mtime = oh->yst_mtime;
N					in->yst_ctime = oh->yst_ctime;
N					in->yst_rdev = oh->yst_rdev;
N#endif
N					in->hdrChunk = chunk;
N					in->serial = tags.serialNumber;
N
N					yaffs_SetObjectName(in, oh->name);
N					in->dirty = 0;
N
N					/* directory stuff...
N					 * hook up to parent
N					 */
N
N					parent =
N					    yaffs_FindOrCreateObjectByNumber
N					    (dev, oh->parentObjectId,
N					     YAFFS_OBJECT_TYPE_DIRECTORY);
N					if(!parent)
N						alloc_failed = 1;
N					if (parent && parent->variantType ==
N					    YAFFS_OBJECT_TYPE_UNKNOWN) {
N                                                /* Set up as a directory */
N                                                parent->variantType =
N                                                    YAFFS_OBJECT_TYPE_DIRECTORY;
N                                                YINIT_LIST_HEAD(&parent->variant.
N                                                               directoryVariant.
N                                                               children);
X                                                do { (&parent->variant . directoryVariant . children)->next = (&parent->variant . directoryVariant . children); (&parent->variant . directoryVariant . children)->prev = (&parent->variant . directoryVariant . children); } while(0);
N                                        } else if (!parent || parent->variantType !=
N						   YAFFS_OBJECT_TYPE_DIRECTORY)
N					{
N						/* Hoosterman, another problem....
N						 * We're trying to use a non-directory as a directory
N						 */
N
N						T(YAFFS_TRACE_ERROR,
N						  (TSTR
N						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
N						    TENDSTR)));
X						do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N						parent = dev->lostNFoundDir;
N					}
N
N					yaffs_AddObjectToDirectory(parent, in);
N
N					if (0 && (parent == dev->deletedDir ||
N						  parent == dev->unlinkedDir)) {
N						in->deleted = 1;	/* If it is unlinked at start up then it wants deleting */
N						dev->nDeletedFiles++;
N					}
N					/* Note re hardlinks.
N					 * Since we might scan a hardlink before its equivalent object is scanned
N					 * we put them all in a list.
N					 * After scanning is complete, we should have all the objects, so we run through this
N					 * list and fix up all the chains.              
N					 */
N
N					switch (in->variantType) {
N					case YAFFS_OBJECT_TYPE_UNKNOWN:	
N						/* Todo got a problem */
N						break;
N					case YAFFS_OBJECT_TYPE_FILE:
N						if (dev->useHeaderFileSize)
N
N							in->variant.fileVariant.
N							    fileSize =
N							    oh->fileSize;
N
N						break;
N					case YAFFS_OBJECT_TYPE_HARDLINK:
N						in->variant.hardLinkVariant.
N                                                    equivalentObjectId =
N                                                    oh->equivalentObjectId;
N                                                in->hardLinks.next =
N                                                    (struct ylist_head *)
N                                                    hardList;
N                                                hardList = in;
N                                                break;
N					case YAFFS_OBJECT_TYPE_DIRECTORY:
N						/* Do nothing */
N						break;
N					case YAFFS_OBJECT_TYPE_SPECIAL:
N						/* Do nothing */
N						break;
N					case YAFFS_OBJECT_TYPE_SYMLINK:	
N						in->variant.symLinkVariant.alias =
N						    yaffs_CloneString(oh->alias);
N						if(!in->variant.symLinkVariant.alias)
N							alloc_failed = 1;
N						break;
N					}
N
N/*
N 					if (parent == dev->deletedDir) {
N						yaffs_DestroyObject(in);
N						bi->hasShrinkHeader = 1;
N					}
N*/
N				}
N			}
N		}
N
N		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
N			/* If we got this far while scanning, then the block is fully allocated.*/
N			state = YAFFS_BLOCK_STATE_FULL;
N		}
N
N		bi->blockState = state;
N
N		/* Now let's see if it was dirty */
N		if (bi->pagesInUse == 0 &&
N		    !bi->hasShrinkHeader &&
N		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
N			yaffs_BlockBecameDirty(dev, blk);
N		}
N
N	}
N
N	
N	/* Ok, we've done all the scanning.
N	 * Fix up the hard link chains.
N	 * We should now have scanned all the objects, now it's time to add these 
N	 * hardlinks.
N	 */
N
N	yaffs_HardlinkFixup(dev,hardList);
N	
N	/* Fix up any shadowed objects */
N	{
N		struct yaffs_ShadowFixerStruct *fixer;
N		yaffs_Object *obj;
N		
N		while(shadowFixerList){
N			fixer = shadowFixerList;
N			shadowFixerList = fixer->next;
N			/* Complete the rename transaction by deleting the shadowed object
N			 * then setting the object header to unshadowed.
N			 */
N			obj = yaffs_FindObjectByNumber(dev,fixer->shadowedId);
N			if(obj)
N				yaffs_DestroyObject(obj);
N	
N			obj = yaffs_FindObjectByNumber(dev,fixer->objectId);
N			if(obj){
N				yaffs_UpdateObjectHeader(obj,NULL,1,0,0);
X				yaffs_UpdateObjectHeader(obj,0,1,0,0);
N			}
N			
N			YFREE(fixer);
X			free(fixer);
N		}
N	}
N
N	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
X	yaffs_ReleaseTempBuffer(dev, chunkData, 5987);
N
N	if(alloc_failed){
N		return YAFFS_FAIL;
X		return 0;
N	}
N	
N	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_Scan ends" TENDSTR)));
X	do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	
N
N	return YAFFS_OK;
X	return 1;
W "..\fs\yaffs_guts.c" 5565 6 variable "result" was set but never used
N}
N
Nstatic void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in)
N{
N	__u8 *chunkData;
N	yaffs_ObjectHeader *oh;
N	yaffs_Device *dev;
N	yaffs_ExtendedTags tags;
N	int result;
N	int alloc_failed = 0;
N
N	if(!in)
N		return;
N		
N	dev = in->myDev;
N		
N#if 0
S	T(YAFFS_TRACE_SCAN,(TSTR("details for object %d %s loaded" TENDSTR),
S		in->objectId,
S		in->lazyLoaded ? "not yet" : "already"));
N#endif
N
N	if(in->lazyLoaded && in->hdrChunk > 0){
N		in->lazyLoaded = 0;
N		chunkData = yaffs_GetTempBuffer(dev, __LINE__);
X		chunkData = yaffs_GetTempBuffer(dev, 6021);
N
W "..\fs\yaffs_guts.c" 6023 12 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N		result = yaffs_ReadChunkWithTagsFromNAND(dev,in->hdrChunk,chunkData,&tags);
N		oh = (yaffs_ObjectHeader *) chunkData;
N
N		in->yst_mode = oh->yst_mode;
N#ifdef CONFIG_YAFFS_WINCE
S		in->win_atime[0] = oh->win_atime[0];
S		in->win_ctime[0] = oh->win_ctime[0];
S		in->win_mtime[0] = oh->win_mtime[0];
S		in->win_atime[1] = oh->win_atime[1];
S		in->win_ctime[1] = oh->win_ctime[1];
S		in->win_mtime[1] = oh->win_mtime[1];
N#else
N		in->yst_uid = oh->yst_uid;
N		in->yst_gid = oh->yst_gid;
N		in->yst_atime = oh->yst_atime;
N		in->yst_mtime = oh->yst_mtime;
N		in->yst_ctime = oh->yst_ctime;
N		in->yst_rdev = oh->yst_rdev;
N		
N#endif
N		yaffs_SetObjectName(in, oh->name);
N		
N		if(in->variantType == YAFFS_OBJECT_TYPE_SYMLINK){
N			 in->variant.symLinkVariant.alias =
N						    yaffs_CloneString(oh->alias);
N			if(!in->variant.symLinkVariant.alias)
N				alloc_failed = 1; /* Not returned to caller */
N		}
N						    
N		yaffs_ReleaseTempBuffer(dev,chunkData, __LINE__);
X		yaffs_ReleaseTempBuffer(dev,chunkData, 6052);
N	}
W "..\fs\yaffs_guts.c" 6005 6 variable "result" was set but never used
W "..\fs\yaffs_guts.c" 6006 6 variable "alloc_failed" was set but never used
N}
N
Nstatic int yaffs_ScanBackwards(yaffs_Device * dev)
N{
N	yaffs_ExtendedTags tags;
N	int blk;
N	int blockIterator;
N	int startIterator;
N	int endIterator;
N	int nBlocksToScan = 0;
N
N	int chunk;
N	int result;
N	int c;
N	int deleted;
N	yaffs_BlockState state;
N	yaffs_Object *hardList = NULL;
X	yaffs_Object *hardList = 0;
N	yaffs_BlockInfo *bi;
N	__u32 sequenceNumber;
N	yaffs_ObjectHeader *oh;
N	yaffs_Object *in;
N	yaffs_Object *parent;
N	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
N	int itsUnlinked;
N	__u8 *chunkData;
N	
N	int fileSize;
N	int isShrink;
N	int foundChunksInBlock;
N	int equivalentObjectId;
N	int alloc_failed = 0;
N	
N
N	yaffs_BlockIndex *blockIndex = NULL;
X	yaffs_BlockIndex *blockIndex = 0;
N	int altBlockIndex = 0;
N
N	if (!dev->isYaffs2) {
N		T(YAFFS_TRACE_SCAN,
N		  (TSTR("yaffs_ScanBackwards is only for YAFFS2!" TENDSTR)));
X		do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N
N	T(YAFFS_TRACE_SCAN,
N	  (TSTR
N	   ("yaffs_ScanBackwards starts  intstartblk %d intendblk %d..."
N	    TENDSTR), dev->internalStartBlock, dev->internalEndBlock));
X	do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N
N	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
X	dev->sequenceNumber = 0x00001000;
N
N	blockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));
X	blockIndex = yaffs_malloc(nBlocks * sizeof(yaffs_BlockIndex));
N	
N	if(!blockIndex) {
N		blockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));
X		blockIndex = yaffs_malloc(nBlocks * sizeof(yaffs_BlockIndex));
N		altBlockIndex = 1;
N	}
N	
N	if(!blockIndex) {
N		T(YAFFS_TRACE_SCAN,
N		  (TSTR("yaffs_Scan() could not allocate block index!" TENDSTR)));
X		do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N	
N	dev->blocksInCheckpoint = 0;
N	
N	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
X	chunkData = yaffs_GetTempBuffer(dev, 6119);
N
N	/* Scan all the blocks to determine their state */
N	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
N		bi = yaffs_GetBlockInfo(dev, blk);
N		yaffs_ClearChunkBits(dev, blk);
N		bi->pagesInUse = 0;
N		bi->softDeletions = 0;
N
W "..\fs\yaffs_guts.c" 6128 3 function "yaffs_QueryInitialBlockState" declared implicitly
N		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
N
N		bi->blockState = state;
N		bi->sequenceNumber = sequenceNumber;
N
N		if(bi->sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA)
X		if(bi->sequenceNumber == 0x21)
N			bi->blockState = state = YAFFS_BLOCK_STATE_CHECKPOINT;
N		if(bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
X		if(bi->sequenceNumber == 0xFFFF0000)
N			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
N			
N		T(YAFFS_TRACE_SCAN_DEBUG,
N		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
N		   state, sequenceNumber));
X		do{ if((0x00002000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		
N		if(state == YAFFS_BLOCK_STATE_CHECKPOINT){
N			dev->blocksInCheckpoint++;
N			
N		} else if (state == YAFFS_BLOCK_STATE_DEAD) {
N			T(YAFFS_TRACE_BAD_BLOCKS,
N			  (TSTR("block %d is bad" TENDSTR), blk));
X			do{ if((0x00000010) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
N			T(YAFFS_TRACE_SCAN_DEBUG,
N			  (TSTR("Block empty " TENDSTR)));
X			do{ if((0x00002000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			dev->nErasedBlocks++;
N			dev->nFreeChunks += dev->nChunksPerBlock;
N		} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
N
N			/* Determine the highest sequence number */
N			if (sequenceNumber >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
X			if (sequenceNumber >= 0x00001000 &&
N			    sequenceNumber < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
X			    sequenceNumber < 0xEFFFFF00) {
N
N				blockIndex[nBlocksToScan].seq = sequenceNumber;
N				blockIndex[nBlocksToScan].block = blk;
N
N				nBlocksToScan++;
N
N				if (sequenceNumber >= dev->sequenceNumber) {
N					dev->sequenceNumber = sequenceNumber;
N				}
N			} else {
N				/* TODO: Nasty sequence number! */
N				T(YAFFS_TRACE_SCAN,
N				  (TSTR
N				   ("Block scanning block %d has bad sequence number %d"
N				    TENDSTR), blk, sequenceNumber));
X				do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N			}
N		}
N	}
N
N	T(YAFFS_TRACE_SCAN,
N	(TSTR("%d blocks to be sorted..." TENDSTR), nBlocksToScan));
X	do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N
N
N	YYIELD();
X	do {} while(0);
N
N	/* Sort the blocks */
N#ifndef CONFIG_YAFFS_USE_OWN_SORT
N	{
N		/* Use qsort now. */
N		yaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), ybicmp);
N	}
N#else
S	{
S	 	/* Dungy old bubble sort... */
S	 	
S		yaffs_BlockIndex temp;
S		int i;
S		int j;
S
S		for (i = 0; i < nBlocksToScan; i++)
S			for (j = i + 1; j < nBlocksToScan; j++)
S				if (blockIndex[i].seq > blockIndex[j].seq) {
S					temp = blockIndex[j];
S					blockIndex[j] = blockIndex[i];
S					blockIndex[i] = temp;
S				}
S	}
N#endif
N
N	YYIELD();
X	do {} while(0);
N
N    	T(YAFFS_TRACE_SCAN, (TSTR("...done" TENDSTR)));
X    	do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	/* Now scan the blocks looking at the data. */
N	startIterator = 0;
N	endIterator = nBlocksToScan - 1;
N	T(YAFFS_TRACE_SCAN_DEBUG,
N	  (TSTR("%d blocks to be scanned" TENDSTR), nBlocksToScan));
X	do{ if((0x00002000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	/* For each block.... backwards */
N	for (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;
N	     blockIterator--) {
N	        /* Cooperative multitasking! This loop can run for so
N		   long that watchdog timers expire. */
N	        YYIELD();
X	        do {} while(0);
N
N		/* get the block to scan in the correct order */
N		blk = blockIndex[blockIterator].block;
N
N		bi = yaffs_GetBlockInfo(dev, blk);
N		
N		
W "..\fs\yaffs_guts.c" 6233 9 enumerated type mixed with another type
N		state = bi->blockState;
N
N		deleted = 0;
N
N		/* For each chunk in each block that needs scanning.... */
N		foundChunksInBlock = 0;
N		for (c = dev->nChunksPerBlock - 1; 
N		     !alloc_failed && c >= 0 &&
N		     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
N		      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
N			/* Scan backwards... 
N			 * Read the tags and decide what to do
N			 */
N			
N			chunk = blk * dev->nChunksPerBlock + c;
N
W "..\fs\yaffs_guts.c" 6249 13 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
X			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, 0,
N							&tags);
N
N			/* Let's have a good look at this chunk... */
N
N			if (!tags.chunkUsed) {
N				/* An unassigned chunk in the block.
N				 * If there are used chunks after this one, then
N				 * it is a chunk that was skipped due to failing the erased
N				 * check. Just skip it so that it can be deleted.
N				 * But, more typically, We get here when this is an unallocated
N				 * chunk and his means that either the block is empty or 
N				 * this is the one being allocated from
N				 */
N
N				if(foundChunksInBlock)
N				{
N					/* This is a chunk that was skipped due to failing the erased check */
N					
N				} else if (c == 0) {
N					/* We're looking at the first chunk in the block so the block is unused */
N					state = YAFFS_BLOCK_STATE_EMPTY;
N					dev->nErasedBlocks++;
N				} else {
N					if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
N					    state == YAFFS_BLOCK_STATE_ALLOCATING) {
N					    	if(dev->sequenceNumber == bi->sequenceNumber) {
N							/* this is the block being allocated from */
N					    	
N							T(YAFFS_TRACE_SCAN,
N							  (TSTR
N							   (" Allocating from %d %d"
N							    TENDSTR), blk, c));
X							do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N							state = YAFFS_BLOCK_STATE_ALLOCATING;
N							dev->allocationBlock = blk;
N							dev->allocationPage = c;
N							dev->allocationBlockFinder = blk;	
N						}
N						else {
N							/* This is a partially written block that is not
N							 * the current allocation block. This block must have
N							 * had a write failure, so set up for retirement.
N							 */
N						  
N							 /* bi->needsRetiring = 1; ??? TODO */
N							 bi->gcPrioritise = 1;
N							 						 
N							 T(YAFFS_TRACE_ALWAYS,
N							 (TSTR("Partially written block %d detected" TENDSTR),
N							 blk));
X							 do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N						}
N
N					}
N					 
N				}
N
N				dev->nFreeChunks++;
N				
N			} else if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED){
N				T(YAFFS_TRACE_SCAN,
N				  (TSTR(" Unfixed ECC in chunk(%d:%d), chunk ignored"TENDSTR),
N				  blk, c));
X				do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N				  dev->nFreeChunks++;
N
N			}else if (tags.chunkId > 0) {
N				/* chunkId > 0 so it is a data chunk... */
N				unsigned int endpos;
N				__u32 chunkBase =
N				    (tags.chunkId - 1) * dev->nDataBytesPerChunk;
N								
N				foundChunksInBlock = 1;
N
N
N				yaffs_SetChunkBit(dev, blk, c);
N				bi->pagesInUse++;
N
N				in = yaffs_FindOrCreateObjectByNumber(dev,
N								      tags.
N								      objectId,
N								      YAFFS_OBJECT_TYPE_FILE);
N				if(!in){
N					/* Out of memory */
N					alloc_failed = 1;
N				}
N				
N				if (in &&
N				    in->variantType == YAFFS_OBJECT_TYPE_FILE
N				    && chunkBase <
N				    in->variant.fileVariant.shrinkSize) {
N					/* This has not been invalidated by a resize */
N					if(!yaffs_PutChunkIntoFile(in, tags.chunkId,
N							       chunk, -1)){
N						alloc_failed = 1;
N					}
N
N					/* File size is calculated by looking at the data chunks if we have not 
N					 * seen an object header yet. Stop this practice once we find an object header.
N					 */
N					endpos =
N					    (tags.chunkId -
N					     1) * dev->nDataBytesPerChunk +
N					    tags.byteCount;
N					    
N					if (!in->valid &&	/* have not got an object header yet */
N					    in->variant.fileVariant.
N					    scannedFileSize < endpos) {
N						in->variant.fileVariant.
N						    scannedFileSize = endpos;
N						in->variant.fileVariant.
N						    fileSize =
N						    in->variant.fileVariant.
N						    scannedFileSize;
N					}
N
N				} else if(in) {
N					/* This chunk has been invalidated by a resize, so delete */
N					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
X					yaffs_DeleteChunk(dev, chunk, 1, 6367);
N
N				}
N			} else {
N				/* chunkId == 0, so it is an ObjectHeader.
N				 * Thus, we read in the object header and make the object
N				 */
N				foundChunksInBlock = 1;
N
N				yaffs_SetChunkBit(dev, blk, c);
N				bi->pagesInUse++;
N
N				oh = NULL;
X				oh = 0;
N				in = NULL;
X				in = 0;
N
N				if (tags.extraHeaderInfoAvailable) {
N					in = yaffs_FindOrCreateObjectByNumber
N					    (dev, tags.objectId,
N					     tags.extraObjectType);
N					if (!in)
N						alloc_failed = 1;
N				}
N
N				if (!in ||
N#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
S				    !in->valid ||
N#endif
N				    tags.extraShadows ||
N				    (!in->valid &&
N				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
X				    (tags.objectId == 1 ||
N				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND))
X				     tags.objectId == 2))
N				    ) {
N
N					/* If we don't have  valid info then we need to read the chunk
N					 * TODO In future we can probably defer reading the chunk and 
N					 * living with invalid data until needed.
N					 */
N
N					result = yaffs_ReadChunkWithTagsFromNAND(dev,
N									chunk,
N									chunkData,
N									NULL);
X									0);
N
N					oh = (yaffs_ObjectHeader *) chunkData;
N					
N					if(dev->inbandTags){
N						/* Fix up the header if they got corrupted by inband tags */
N						oh->shadowsObject = oh->inbandShadowsObject;
N						oh->isShrink = oh->inbandIsShrink;
N					}
N
N					if (!in) {
N						in = yaffs_FindOrCreateObjectByNumber(dev, tags.objectId, oh->type);
N						if (!in)
N							alloc_failed = 1;
N					}
N
N				}
N
N				if (!in) {
N					/* TODO Hoosterman we have a problem! */
N					T(YAFFS_TRACE_ERROR,
N					  (TSTR
N					   ("yaffs tragedy: Could not make object for object  %d at chunk %d during scan"
N					    TENDSTR), tags.objectId, chunk));
X					do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N					continue;
N				}
N
N				if (in->valid) {
N					/* We have already filled this one.
N					 * We have a duplicate that will be discarded, but 
N					 * we first have to suck out resize info if it is a file.
N					 */
N
N					if ((in->variantType == YAFFS_OBJECT_TYPE_FILE) && 
N					     ((oh && 
N					       oh-> type == YAFFS_OBJECT_TYPE_FILE)||
N					      (tags.extraHeaderInfoAvailable  &&
N					       tags.extraObjectType == YAFFS_OBJECT_TYPE_FILE))
N					    ) {
N						__u32 thisSize =
N						    (oh) ? oh->fileSize : tags.
N						    extraFileLength;
N						__u32 parentObjectId =
N						    (oh) ? oh->
N						    parentObjectId : tags.
N						    extraParentObjectId;
N						
N						
N						isShrink =
N						    (oh) ? oh->isShrink : tags.
N						    extraIsShrinkHeader;
N
N						/* If it is deleted (unlinked at start also means deleted)
N						 * we treat the file size as being zeroed at this point.
N						 */
N						if (parentObjectId ==
N						    YAFFS_OBJECTID_DELETED
X						    4
N						    || parentObjectId ==
N						    YAFFS_OBJECTID_UNLINKED) {
X						    3) {
N							thisSize = 0;
N							isShrink = 1;
N						}
N
N						if (isShrink &&
N						    in->variant.fileVariant.
N						    shrinkSize > thisSize) {
N							in->variant.fileVariant.
N							    shrinkSize =
N							    thisSize;
N						}
N
N						if (isShrink) {
N							bi->hasShrinkHeader = 1;
N						}
N
N					}
N					/* Use existing - destroy this one. */
N					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
X					yaffs_DeleteChunk(dev, chunk, 1, 6485);
N
N				}
N
N				if (!in->valid && in->variantType !=
N				    (oh ? oh->type : tags.extraObjectType))
N					T(YAFFS_TRACE_ERROR, (
N						TSTR("yaffs tragedy: Bad object type, "
N					    TCONT("%d != %d, for object %d at chunk ")
N					    TCONT("%d during scan")
N						TENDSTR), oh ?
N					    oh->type : tags.extraObjectType,
N					    in->variantType, tags.objectId,
N					    chunk));
X					do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N				if (!in->valid &&
N				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
X				    (tags.objectId == 1 ||
N				     tags.objectId ==
N				     YAFFS_OBJECTID_LOSTNFOUND)) {
X				     2)) {
N					/* We only load some info, don't fiddle with directory structure */
N					in->valid = 1;
N					
N					if(oh) {
N						in->variantType = oh->type;
N
N						in->yst_mode = oh->yst_mode;
N#ifdef CONFIG_YAFFS_WINCE
S						in->win_atime[0] = oh->win_atime[0];
S						in->win_ctime[0] = oh->win_ctime[0];
S						in->win_mtime[0] = oh->win_mtime[0];
S						in->win_atime[1] = oh->win_atime[1];
S						in->win_ctime[1] = oh->win_ctime[1];
S						in->win_mtime[1] = oh->win_mtime[1];
N#else
N						in->yst_uid = oh->yst_uid;
N						in->yst_gid = oh->yst_gid;
N						in->yst_atime = oh->yst_atime;
N						in->yst_mtime = oh->yst_mtime;
N						in->yst_ctime = oh->yst_ctime;
N						in->yst_rdev = oh->yst_rdev;
N		
N#endif
N					} else {
N						in->variantType = tags.extraObjectType;
N						in->lazyLoaded = 1;
N					}
N
N					in->hdrChunk = chunk;
N
N				} else if (!in->valid) {
N					/* we need to load this info */
N
N					in->valid = 1;
N					in->hdrChunk = chunk;
N
N					if(oh) {
N						in->variantType = oh->type;
N
N						in->yst_mode = oh->yst_mode;
N#ifdef CONFIG_YAFFS_WINCE
S						in->win_atime[0] = oh->win_atime[0];
S						in->win_ctime[0] = oh->win_ctime[0];
S						in->win_mtime[0] = oh->win_mtime[0];
S						in->win_atime[1] = oh->win_atime[1];
S						in->win_ctime[1] = oh->win_ctime[1];
S						in->win_mtime[1] = oh->win_mtime[1];
N#else
N						in->yst_uid = oh->yst_uid;
N						in->yst_gid = oh->yst_gid;
N						in->yst_atime = oh->yst_atime;
N						in->yst_mtime = oh->yst_mtime;
N						in->yst_ctime = oh->yst_ctime;
N						in->yst_rdev = oh->yst_rdev;
N#endif
N
N						if (oh->shadowsObject > 0) 
N							yaffs_HandleShadowedObject(dev,
N									   oh->
N									   shadowsObject,
N									   1);
N					
N
N						yaffs_SetObjectName(in, oh->name);
N						parent =
N						    yaffs_FindOrCreateObjectByNumber
N					    		(dev, oh->parentObjectId,
N					     		 YAFFS_OBJECT_TYPE_DIRECTORY);
N
N						 fileSize = oh->fileSize;
N 						 isShrink = oh->isShrink;
N						 equivalentObjectId = oh->equivalentObjectId;
N
N					}
N					else {
N						in->variantType = tags.extraObjectType;
N						parent =
N						    yaffs_FindOrCreateObjectByNumber
N					    		(dev, tags.extraParentObjectId,
N					     		 YAFFS_OBJECT_TYPE_DIRECTORY);
N						 fileSize = tags.extraFileLength;
N						 isShrink = tags.extraIsShrinkHeader;
N						 equivalentObjectId = tags.extraEquivalentObjectId;
N						in->lazyLoaded = 1;
N
N					}
N					in->dirty = 0;
N
N					if (!parent)
N						alloc_failed = 1;
N
N					/* directory stuff...
N					 * hook up to parent
N					 */
N
N					if (parent && parent->variantType ==
N					    YAFFS_OBJECT_TYPE_UNKNOWN) {
N                                                /* Set up as a directory */
N                                                parent->variantType =
N                                                    YAFFS_OBJECT_TYPE_DIRECTORY;
N                                                YINIT_LIST_HEAD(&parent->variant.
N                                                               directoryVariant.
N                                                               children);
X                                                do { (&parent->variant . directoryVariant . children)->next = (&parent->variant . directoryVariant . children); (&parent->variant . directoryVariant . children)->prev = (&parent->variant . directoryVariant . children); } while(0);
N                                        } else if (!parent || parent->variantType !=
N						   YAFFS_OBJECT_TYPE_DIRECTORY)
N					{
N						/* Hoosterman, another problem....
N						 * We're trying to use a non-directory as a directory
N						 */
N
N						T(YAFFS_TRACE_ERROR,
N						  (TSTR
N						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
N						    TENDSTR)));
X						do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N						parent = dev->lostNFoundDir;
N					}
N
N					yaffs_AddObjectToDirectory(parent, in);
N
N					itsUnlinked = (parent == dev->deletedDir) ||
N						      (parent == dev->unlinkedDir);
N
N					if (isShrink) {
N						/* Mark the block as having a shrinkHeader */
N						bi->hasShrinkHeader = 1;
N					}
N
N					/* Note re hardlinks.
N					 * Since we might scan a hardlink before its equivalent object is scanned
N					 * we put them all in a list.
N					 * After scanning is complete, we should have all the objects, so we run
N					 * through this list and fix up all the chains.              
N					 */
N
N					switch (in->variantType) {
N					case YAFFS_OBJECT_TYPE_UNKNOWN:	
N						/* Todo got a problem */
N						break;
N					case YAFFS_OBJECT_TYPE_FILE:
N
N						if (in->variant.fileVariant.
N						    scannedFileSize < fileSize) {
N							/* This covers the case where the file size is greater
N							 * than where the data is
N							 * This will happen if the file is resized to be larger 
N							 * than its current data extents.
N							 */
N							in->variant.fileVariant.fileSize = fileSize;
N							in->variant.fileVariant.scannedFileSize =
N							    in->variant.fileVariant.fileSize;
N						}
N
N						if (isShrink &&
N						    in->variant.fileVariant.shrinkSize > fileSize) {
N							in->variant.fileVariant.shrinkSize = fileSize;
N						}
N
N						break;
N					case YAFFS_OBJECT_TYPE_HARDLINK:
N						if(!itsUnlinked) {
N                                                  in->variant.hardLinkVariant.equivalentObjectId =
N                                                    equivalentObjectId;
N                                                  in->hardLinks.next =
N                                                    (struct ylist_head *) hardList;
N                                                  hardList = in;
N                                                }
N                                                break;
N					case YAFFS_OBJECT_TYPE_DIRECTORY:
N						/* Do nothing */
N						break;
N					case YAFFS_OBJECT_TYPE_SPECIAL:
N						/* Do nothing */
N						break;
N					case YAFFS_OBJECT_TYPE_SYMLINK:
N						if(oh){
N						   in->variant.symLinkVariant.alias =
N						    yaffs_CloneString(oh->
N								      alias);
N						   if(!in->variant.symLinkVariant.alias)
N						   	alloc_failed = 1;
N						}
N						break;
N					}
N
N				}
N				
N			}
N
N		} /* End of scanning for each chunk */
N
N		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
N			/* If we got this far while scanning, then the block is fully allocated. */
N			state = YAFFS_BLOCK_STATE_FULL;
N		}
N
N		bi->blockState = state;
N
N		/* Now let's see if it was dirty */
N		if (bi->pagesInUse == 0 &&
N		    !bi->hasShrinkHeader &&
N		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
N			yaffs_BlockBecameDirty(dev, blk);
N		}
N
N	}
N
N	if (altBlockIndex) 
N		YFREE_ALT(blockIndex);
X		free(blockIndex);
N	else
N		YFREE(blockIndex);
X		free(blockIndex);
N	
N	/* Ok, we've done all the scanning.
N	 * Fix up the hard link chains.
N	 * We should now have scanned all the objects, now it's time to add these 
N	 * hardlinks.
N	 */
N	yaffs_HardlinkFixup(dev,hardList);
N	
N
N	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
X	yaffs_ReleaseTempBuffer(dev, chunkData, 6723);
N	
N	if(alloc_failed){
N		return YAFFS_FAIL;
X		return 0;
N	}
N
N	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_ScanBackwards ends" TENDSTR)));
X	do{ if((0x00000008) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	return YAFFS_OK;
X	return 1;
W "..\fs\yaffs_guts.c" 6066 6 variable "result" was set but never used
W "..\fs\yaffs_guts.c" 6068 6 variable "deleted" was set but never used
N}
N
N/*------------------------------  Directory Functions ----------------------------- */
N
Nstatic void yaffs_VerifyObjectInDirectory(yaffs_Object *obj)
N{
N        struct ylist_head *lh;
N        yaffs_Object *listObj;
N        
N        int count = 0;
N
N	if(!obj){
N		T(YAFFS_TRACE_ALWAYS, (TSTR("No object to verify" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N
N        if(yaffs_SkipVerification(obj->myDev))
N                return;
N
N	if(!obj->parent){
N		T(YAFFS_TRACE_ALWAYS, (TSTR("Object does not have parent" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N		
N	if(obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
N		T(YAFFS_TRACE_ALWAYS, (TSTR("Parent is not directory" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	
N        /* Iterate through the objects in each hash entry */
N         
N        ylist_for_each(lh, &obj->parent->variant.directoryVariant.children) {
X        for (lh = (&obj->parent->variant . directoryVariant . children)->next; lh != (&obj->parent->variant . directoryVariant . children); lh = lh->next ) {
N		if (lh) {
N                        listObj = ylist_entry(lh, yaffs_Object, siblings);
X                        listObj = ((yaffs_Object *)((char *)(lh)-(unsigned long)(&((yaffs_Object *)0)->siblings)));
N			yaffs_VerifyObject(listObj);
N			if(obj == listObj)
N				count ++;
N                }
N	 }
N	 
N	 if(count != 1){
N		T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory %d times" TENDSTR),count));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N
N}
N
Nstatic void yaffs_VerifyDirectory(yaffs_Object *directory)
N{
N
N        struct ylist_head *lh;
N        yaffs_Object *listObj;
N        
N	if(!directory)
N		YBUG();
X		;
N
N        if(yaffs_SkipFullVerification(directory->myDev))
N                return;
N
N		
N	if(directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
N		T(YAFFS_TRACE_ALWAYS, (TSTR("Directory has wrong type: %d" TENDSTR),directory->variantType));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	
N        /* Iterate through the objects in each hash entry */
N         
N        ylist_for_each(lh, &directory->variant.directoryVariant.children) {
X        for (lh = (&directory->variant . directoryVariant . children)->next; lh != (&directory->variant . directoryVariant . children); lh = lh->next ) {
N		if (lh) {
N                        listObj = ylist_entry(lh, yaffs_Object, siblings);
X                        listObj = ((yaffs_Object *)((char *)(lh)-(unsigned long)(&((yaffs_Object *)0)->siblings)));
N			if(listObj->parent != directory){
N				T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory list has wrong parent %p" TENDSTR),listObj->parent));
X				do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				YBUG();
X				;
N			}
N			yaffs_VerifyObjectInDirectory(listObj);
N                }
N	 }
N	 
N}
N
N
Nstatic void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj)
N{
N	yaffs_Device *dev = obj->myDev;
N	yaffs_Object *parent;
N	
N        yaffs_VerifyObjectInDirectory(obj);
N	parent = obj->parent;
N	
N	yaffs_VerifyDirectory(parent);
N
N        if(dev && dev->removeObjectCallback)
N                dev->removeObjectCallback(obj);
N
N           
N        ylist_del_init(&obj->siblings);
N        obj->parent = NULL;
X        obj->parent = 0;
N
N	yaffs_VerifyDirectory(parent);
N
N}
N
N
Nstatic void yaffs_AddObjectToDirectory(yaffs_Object * directory,
N				       yaffs_Object * obj)
N{
N
N	if (!directory) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR
N		   ("tragedy: Trying to add an object to a null pointer directory"
N		    TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR
N		   ("tragedy: Trying to add an object to a non-directory"
N		    TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N
N        if (obj->siblings.prev == NULL) {
X        if (obj->siblings.prev == 0) {
N                /* Not initialised */
N                YBUG();
X                ;
N
N        } else if (ylist_empty(&obj->siblings)) {
N        	YBUG();
X        	;
N        } 
N
N
N	yaffs_VerifyDirectory(directory);
N
N	yaffs_RemoveObjectFromDirectory(obj);
N        
N        
N        /* Now add it */
N        ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);
N        obj->parent = directory;
N
N        if (directory == obj->myDev->unlinkedDir
N	    || directory == obj->myDev->deletedDir) {
N		obj->unlinked = 1;
N		obj->myDev->nUnlinkedFiles++;
N		obj->renameAllowed = 0;
N	}
N
N	yaffs_VerifyDirectory(directory);
N        yaffs_VerifyObjectInDirectory(obj);
N
N
N}
N
Nyaffs_Object *yaffs_FindObjectByName(yaffs_Object * directory,
N				     const YCHAR * name)
X				     const char * name)
N{
N        int sum;
N
N        struct ylist_head *i;
N        YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
X        char buffer[255 + 1];
N
N        yaffs_Object *l;
N
N	if (!name) {
N		return NULL;
X		return 0;
N	}
N
N	if (!directory) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR
N		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
N		    TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR
N		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N
N        sum = yaffs_CalcNameSum(name);
N
N        ylist_for_each(i, &directory->variant.directoryVariant.children) {
X        for (i = (&directory->variant . directoryVariant . children)->next; i != (&directory->variant . directoryVariant . children); i = i->next ) {
N                if (i) {
N                        l = ylist_entry(i, yaffs_Object, siblings);
X                        l = ((yaffs_Object *)((char *)(i)-(unsigned long)(&((yaffs_Object *)0)->siblings)));
N                        
N                        if(l->parent != directory)
N                        	YBUG();
X                        	;
N                        
N                        yaffs_CheckObjectDetailsLoaded(l);
N
N			/* Special case for lost-n-found */
N			if (l->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
X			if (l->objectId == 2) {
N				if (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0) {
X				if (strcmp(name,"lost+found") == 0) {
N					return l;
N				}
N			} else if (yaffs_SumCompare(l->sum, sum) || l->hdrChunk <= 0){
X			} else if (((l->sum) == (sum)) || l->hdrChunk <= 0){
N				/* LostnFound chunk called Objxxx
N				 * Do a real check
N				 */
N				yaffs_GetObjectName(l, buffer,
N						    YAFFS_MAX_NAME_LENGTH);
X						    255);
N				if (yaffs_strncmp(name, buffer,YAFFS_MAX_NAME_LENGTH) == 0) {
X				if (strncmp(name,buffer,255) == 0) {
N					return l;
N				}
N
N			}
N		}
N	}
N
N	return NULL;
X	return 0;
N}
N
N
N#if 0
Sint yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,
S                                   int (*fn) (yaffs_Object *))
S{
S        struct ylist_head *i;
S        yaffs_Object *l;
S
S        if (!theDir) {
S		T(YAFFS_TRACE_ALWAYS,
S		  (TSTR
S		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
S		    TENDSTR)));
S		YBUG();
S	}
S	if (theDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
S		T(YAFFS_TRACE_ALWAYS,
S		  (TSTR
S		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
S                YBUG();
S        }
S
S        ylist_for_each(i, &theDir->variant.directoryVariant.children) {
S                if (i) {
S                        l = ylist_entry(i, yaffs_Object, siblings);
S                        if (l && !fn(l)) {
S                                return YAFFS_FAIL;
S                        }
S		}
S	}
S
S	return YAFFS_OK;
S
S}
N#endif
N
N/* GetEquivalentObject dereferences any hard links to get to the
N * actual object.
N */
N
Nyaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj)
N{
N	if (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
N		/* We want the object id of the equivalent object, not this one */
N		obj = obj->variant.hardLinkVariant.equivalentObject;
N		yaffs_CheckObjectDetailsLoaded(obj);
N	}
N	return obj;
N
N}
N
Nint yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize)
Xint yaffs_GetObjectName(yaffs_Object * obj, char * name, int buffSize)
N{
N	memset(name, 0, buffSize * sizeof(YCHAR));
X	memset(name, 0, buffSize * sizeof(char));
N	
N	yaffs_CheckObjectDetailsLoaded(obj);
N
N	if (obj->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
X	if (obj->objectId == 2) {
N		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);
X		strncpy(name,"lost+found",buffSize - 1);
N	} else if (obj->hdrChunk <= 0) {
N		YCHAR locName[20];
X		char locName[20];
N		YCHAR numString[20];
X		char numString[20];
N		YCHAR *x = &numString[19];
X		char *x = &numString[19];
N		unsigned v = obj->objectId;
N		numString[19] = 0;
N		while(v>0){
N			x--;
N			*x = '0' + (v % 10);
N			v /= 10;
N		}
N		/* make up a name */
N		yaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);
X		strcpy(locName,"obj");
N		yaffs_strcat(locName,x);
X		strcat(locName,x);
N		yaffs_strncpy(name, locName, buffSize - 1);
X		strncpy(name,locName,buffSize - 1);
N
N	}
N#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
S	else if (obj->shortName[0]) {
S		yaffs_strcpy(name, obj->shortName);
S	}
N#endif
N	else {
N		int result;
N		__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, __LINE__);
X		__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, 7029);
N
N		yaffs_ObjectHeader *oh = (yaffs_ObjectHeader *) buffer;
N
N		memset(buffer, 0, obj->myDev->nDataBytesPerChunk);
N
N		if (obj->hdrChunk > 0) {
W "..\fs\yaffs_guts.c" 7036 13 function "yaffs_ReadChunkWithTagsFromNAND" declared implicitly
N			result = yaffs_ReadChunkWithTagsFromNAND(obj->myDev,
N							obj->hdrChunk, buffer,
N							NULL);
X							0);
N		}
N		yaffs_strncpy(name, oh->name, buffSize - 1);
X		strncpy(name,oh->name,buffSize - 1);
N
N		yaffs_ReleaseTempBuffer(obj->myDev, buffer, __LINE__);
X		yaffs_ReleaseTempBuffer(obj->myDev, buffer, 7042);
W "..\fs\yaffs_guts.c" 7028 7 variable "result" was set but never used
N	}
N
N	return yaffs_strlen(name);
X	return strlen(name);
N}
N
Nint yaffs_GetObjectFileLength(yaffs_Object * obj)
N{
N
N	/* Dereference any hard linking */
N	obj = yaffs_GetEquivalentObject(obj);
N
N	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) 
N	{
N		 
N		return obj->variant.fileVariant.fileSize;
N	}
N	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {
N		return yaffs_strlen(obj->variant.symLinkVariant.alias);
X		return strlen(obj->variant . symLinkVariant . alias);
N	} else {
N		/* Only a directory should drop through to here */
N		return obj->myDev->nDataBytesPerChunk;
N	}
N}
N
Nint yaffs_GetObjectLinkCount(yaffs_Object * obj)
N{
N        int count = 0;
N        struct ylist_head *i;
N
N        if (!obj->unlinked) {
N                count++;        /* the object itself */
N        }
N        ylist_for_each(i, &obj->hardLinks) {
X        for (i = (&obj->hardLinks)->next; i != (&obj->hardLinks); i = i->next ) {
N                count++;        /* add the hard links; */
N        }
N        return count;
N
N}
N
Nint yaffs_GetObjectInode(yaffs_Object * obj)
N{
N	obj = yaffs_GetEquivalentObject(obj);
N
N	return obj->objectId;
N}
N
Nunsigned yaffs_GetObjectType(yaffs_Object * obj)
N{
N	obj = yaffs_GetEquivalentObject(obj);
N
N	switch (obj->variantType) {
N	case YAFFS_OBJECT_TYPE_FILE:
N		return DT_REG;
X		return 8;
W "..\fs\yaffs_guts.c" 7096 3 statement is unreachable
N		break;
N	case YAFFS_OBJECT_TYPE_DIRECTORY:
N		return DT_DIR;
X		return 4;
W "..\fs\yaffs_guts.c" 7099 3 statement is unreachable
N		break;
N	case YAFFS_OBJECT_TYPE_SYMLINK:
N		return DT_LNK;
X		return 10;
W "..\fs\yaffs_guts.c" 7102 3 statement is unreachable
N		break;
N	case YAFFS_OBJECT_TYPE_HARDLINK:
N		return DT_REG;
X		return 8;
W "..\fs\yaffs_guts.c" 7105 3 statement is unreachable
N		break;
N	case YAFFS_OBJECT_TYPE_SPECIAL:
N		 
N		/*
N		if (S_ISFIFO(obj->yst_mode))
N			return DT_FIFO;
N		if (S_ISCHR(obj->yst_mode))
N			return DT_CHR;
N		if (S_ISBLK(obj->yst_mode))
N			return DT_BLK;
N		if (S_ISSOCK(obj->yst_mode))
N			return DT_SOCK;
N			*/
N			
N	default:
N		return DT_REG;
X		return 8;
W "..\fs\yaffs_guts.c" 7121 3 statement is unreachable
N		break;
N	}
N}
N
NYCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj)
Xchar *yaffs_GetSymlinkAlias(yaffs_Object * obj)
N{
N	obj = yaffs_GetEquivalentObject(obj);
N	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {
N		return yaffs_CloneString(obj->variant.symLinkVariant.alias);
N	} else {
N		return yaffs_CloneString(_Y(""));
X		return yaffs_CloneString("");
N	}
N}
N
N#ifndef CONFIG_YAFFS_WINCE
N
Nint yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr)
N{
N	unsigned int valid = attr->ia_valid;
N
N	if (valid & ATTR_MODE)
X	if (valid & 1)
N		obj->yst_mode = attr->ia_mode;
N	if (valid & ATTR_UID)
X	if (valid & 2)
N		obj->yst_uid = attr->ia_uid;
N	if (valid & ATTR_GID)
X	if (valid & 4)
N		obj->yst_gid = attr->ia_gid;
N
N	if (valid & ATTR_ATIME)
X	if (valid & 16)
N		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
X		obj->yst_atime = attr->ia_atime;
N	if (valid & ATTR_CTIME)
X	if (valid & 64)
N		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
X		obj->yst_ctime = attr->ia_ctime;
N	if (valid & ATTR_MTIME)
X	if (valid & 32)
N		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
X		obj->yst_mtime = attr->ia_mtime;
N
N	if (valid & ATTR_SIZE)
X	if (valid & 8)
N		yaffs_ResizeFile(obj, attr->ia_size);
N
N	yaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);
X	yaffs_UpdateObjectHeader(obj, 0, 1, 0, 0);
N
N	return YAFFS_OK;
X	return 1;
N
N}
Nint yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr)
N{
N	unsigned int valid = 0;
N
N	attr->ia_mode = obj->yst_mode;
N	valid |= ATTR_MODE;
X	valid |= 1;
N	attr->ia_uid = obj->yst_uid;
N	valid |= ATTR_UID;
X	valid |= 2;
N	attr->ia_gid = obj->yst_gid;
N	valid |= ATTR_GID;
X	valid |= 4;
N
N	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
X	attr->ia_atime = obj->yst_atime;
N	valid |= ATTR_ATIME;
X	valid |= 16;
N	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
X	attr->ia_ctime = obj->yst_ctime;
N	valid |= ATTR_CTIME;
X	valid |= 64;
N	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
X	attr->ia_mtime = obj->yst_mtime;
N	valid |= ATTR_MTIME;
X	valid |= 32;
N
N	attr->ia_size = yaffs_GetFileSize(obj);
N	valid |= ATTR_SIZE;
X	valid |= 8;
N
N	attr->ia_valid = valid;
N
N	return YAFFS_OK;
X	return 1;
N
N}
N
N#endif
N
N#if 0
Sint yaffs_DumpObject(yaffs_Object * obj)
S{
S	YCHAR name[257];
S
S	yaffs_GetObjectName(obj, name, 256);
S
S	T(YAFFS_TRACE_ALWAYS,
S	  (TSTR
S	   ("Object %d, inode %d \"%s\"\n dirty %d valid %d serial %d sum %d"
S	    " chunk %d type %d size %d\n"
S	    TENDSTR), obj->objectId, yaffs_GetObjectInode(obj), name,
S	   obj->dirty, obj->valid, obj->serial, obj->sum, obj->hdrChunk,
S	   yaffs_GetObjectType(obj), yaffs_GetObjectFileLength(obj)));
S
S	return YAFFS_OK;
S}
N#endif
N
N/*---------------------------- Initialisation code -------------------------------------- */
N
Nstatic int yaffs_CheckDevFunctions(const yaffs_Device * dev)
N{
N
N	/* Common functions, gotta have */
N	if (!dev->eraseBlockInNAND || !dev->initialiseNAND)
N		return 0;
N
N#ifdef CONFIG_YAFFS_YAFFS2
N
N	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
N	if (dev->writeChunkWithTagsToNAND &&
N	    dev->readChunkWithTagsFromNAND &&
N	    !dev->writeChunkToNAND &&
N	    !dev->readChunkFromNAND &&
N	    dev->markNANDBlockBad && dev->queryNANDBlock)
N		return 1;
N#endif
N
N	/* Can use the "spare" style interface for yaffs1 */
N	if (!dev->isYaffs2 &&
N	    !dev->writeChunkWithTagsToNAND &&
N	    !dev->readChunkWithTagsFromNAND &&
N	    dev->writeChunkToNAND &&
N	    dev->readChunkFromNAND &&
N	    !dev->markNANDBlockBad && !dev->queryNANDBlock)
N		return 1;
N
N	return 0;		/* bad */
N}
N
N
Nstatic int yaffs_CreateInitialDirectories(yaffs_Device *dev)
N{
N	/* Initialise the unlinked, deleted, root and lost and found directories */
N	
N	dev->lostNFoundDir = dev->rootDir =  NULL;
X	dev->lostNFoundDir = dev->rootDir =  0;
N	dev->unlinkedDir = dev->deletedDir = NULL;
X	dev->unlinkedDir = dev->deletedDir = 0;
N
N	dev->unlinkedDir =
N	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
X	    yaffs_CreateFakeDirectory(dev, 3, 0040000);
N	
N	dev->deletedDir =
N	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
X	    yaffs_CreateFakeDirectory(dev, 4, 0040000);
N
N	dev->rootDir =
N	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_ROOT,
X	    yaffs_CreateFakeDirectory(dev, 1,
N				      YAFFS_ROOT_MODE | S_IFDIR);
X				      0666 | 0040000);
N	dev->lostNFoundDir =
N	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_LOSTNFOUND,
X	    yaffs_CreateFakeDirectory(dev, 2,
N				      YAFFS_LOSTNFOUND_MODE | S_IFDIR);
X				      0666 | 0040000);
N	
N	if(dev->lostNFoundDir && dev->rootDir && dev->unlinkedDir && dev->deletedDir){
N		yaffs_AddObjectToDirectory(dev->rootDir, dev->lostNFoundDir);
N		return YAFFS_OK;
X		return 1;
N	}
N	
N	return YAFFS_FAIL;
X	return 0;
N}
N
Nint yaffs_GutsInitialise(yaffs_Device * dev)
N{
N	int init_failed = 0;
N	unsigned x;
N	int bits;
N
N	T(YAFFS_TRACE_TRACING, (TSTR("yaffs: yaffs_GutsInitialise()" TENDSTR)));
X	do{ if((0x00000100) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	/* Check stuff that must be set */
N
N	if (!dev) {
N		T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Need a device" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N
N	dev->internalStartBlock = dev->startBlock;
N	dev->internalEndBlock = dev->endBlock;
N	dev->blockOffset = 0;
N	dev->chunkOffset = 0;
N	dev->nFreeChunks = 0;
N	
N	dev->gcBlock = -1;
N
N	if (dev->startBlock == 0) {
N		dev->internalStartBlock = dev->startBlock + 1;
N		dev->internalEndBlock = dev->endBlock + 1;
N		dev->blockOffset = 1;
N		dev->chunkOffset = dev->nChunksPerBlock;
N	}
N
N	/* Check geometry parameters. */
N
N	if ((!dev->inbandTags && dev->isYaffs2 && dev->totalBytesPerChunk < 1024) || 
N	    (!dev->isYaffs2 && dev->totalBytesPerChunk < 512) || 
N	    (dev->inbandTags && !dev->isYaffs2 ) ||
N	     dev->nChunksPerBlock < 2 || 
N	     dev->nReservedBlocks < 2 || 
N	     dev->internalStartBlock <= 0 || 
N	     dev->internalEndBlock <= 0 || 
N	     dev->internalEndBlock <= (dev->internalStartBlock + dev->nReservedBlocks + 2)	// otherwise it is too small
N	    ) {
N 		 
N 
N		return YAFFS_FAIL;
X		return 0;
N	}
N    
W "..\fs\yaffs_guts.c" 7318 6 function "yaffs_InitialiseNAND" declared implicitly
N	if (yaffs_InitialiseNAND(dev) != YAFFS_OK) {
X	if (yaffs_InitialiseNAND(dev) != 1) {
N		 
N		 
N		return YAFFS_FAIL;
X		return 0;
N	}
N	
N	/* Sort out space for inband tags, if required */
N	if(dev->inbandTags)
N		dev->nDataBytesPerChunk = dev->totalBytesPerChunk - sizeof(yaffs_PackedTags2TagsPart);
N	else 
N		dev->nDataBytesPerChunk = dev->totalBytesPerChunk;
N
N	/* Got the right mix of functions? */
N	if (!yaffs_CheckDevFunctions(dev)) {
N		/* Function missing */
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR
N		   ("yaffs: device function(s) missing or wrong\n" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		return YAFFS_FAIL;
X		return 0;
N	}
N    
N	/* This is really a compilation check. */
N	if (!yaffs_CheckStructures()) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR("yaffs_CheckStructures failed\n" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N    
N	if (dev->isMounted) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR("yaffs: device already mounted\n" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N    
N	/* Finished with most checks. One or two more checks happen later on too. */
N
N	dev->isMounted = 1;
N
N	/* OK now calculate a few things for the device */
N	
N	/*
N	 *  Calculate all the chunk size manipulation numbers: 	 
N	 */
N	x = dev->nDataBytesPerChunk;
N	/* We always use dev->chunkShift and dev->chunkDiv */
N	dev->chunkShift = Shifts(x);
N	x >>= dev->chunkShift;
N	dev->chunkDiv = x;
N	/* We only use chunk mask if chunkDiv is 1 */
N	dev->chunkMask = (1<<dev->chunkShift) - 1;
N	 	
N	/*
N	 * Calculate chunkGroupBits.
N	 * We need to find the next power of 2 > than internalEndBlock
N	 */
N
N	x = dev->nChunksPerBlock * (dev->internalEndBlock + 1);
N	
N	bits = ShiftsGE(x);
N	
N	/* Set up tnode width if wide tnodes are enabled. */
N	if(!dev->wideTnodesDisabled){
N		/* bits must be even so that we end up with 32-bit words */
N		if(bits & 1)
N			bits++;
N		if(bits < 16)
N			dev->tnodeWidth = 16;
N		else
N			dev->tnodeWidth = bits;
N	}
N	else
N		dev->tnodeWidth = 16;
N 
N	dev->tnodeMask = (1<<dev->tnodeWidth)-1;
N		
N	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
N	 * so if the bitwidth of the
N	 * chunk range we're using is greater than 16 we need
N	 * to figure out chunk shift and chunkGroupSize
N	 */
N		 
N	if (bits <= dev->tnodeWidth)
N		dev->chunkGroupBits = 0;
N	else
N		dev->chunkGroupBits = bits - dev->tnodeWidth;
N		
N
N	dev->chunkGroupSize = 1 << dev->chunkGroupBits;
N
N	if (dev->nChunksPerBlock < dev->chunkGroupSize) {
N		/* We have a problem because the soft delete won't work if
N		 * the chunk group size > chunks per block.
N		 * This can be remedied by using larger "virtual blocks".
N		 */
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR("yaffs: chunk group too large\n" TENDSTR)));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		return YAFFS_FAIL;
X		return 0;
N	}
N    
N	/* OK, we've finished verifying the device, lets continue with initialisation */
N
N	/* More device initialisation */
N	dev->garbageCollections = 0;
N	dev->passiveGarbageCollections = 0;
N	dev->currentDirtyChecker = 0;
N	dev->bufferedBlock = -1;
N	dev->doingBufferedBlockRewrite = 0;
N	dev->nDeletedFiles = 0;
N	dev->nBackgroundDeletions = 0;
N	dev->nUnlinkedFiles = 0;
N	dev->eccFixed = 0;
N	dev->eccUnfixed = 0;
N	dev->tagsEccFixed = 0;
N	dev->tagsEccUnfixed = 0;
N	dev->nErasureFailures = 0;
N	dev->nErasedBlocks = 0;
N	dev->isDoingGC = 0;
N	dev->hasPendingPrioritisedGCs = 1; /* Assume the worst for now, will get fixed on first GC */
N  
N	/* Initialise temporary buffers and caches. */
N	if(!yaffs_InitialiseTempBuffers(dev))
N		init_failed = 1;
N    
N	dev->srCache = NULL;
X	dev->srCache = 0;
N	dev->gcCleanupList = NULL;
X	dev->gcCleanupList = 0;
N	
N	if (!init_failed &&
N	    dev->nShortOpCaches > 0) {
N		int i;
N		void *buf;
N		int srCacheBytes = dev->nShortOpCaches * sizeof(yaffs_ChunkCache);
N
N		if (dev->nShortOpCaches > YAFFS_MAX_SHORT_OP_CACHES) {
X		if (dev->nShortOpCaches > 20) {
N			dev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;
X			dev->nShortOpCaches = 20;
N		}
N
N		dev->srCache =  YMALLOC(srCacheBytes);
X		dev->srCache =  yaffs_malloc(srCacheBytes);
N		
N		buf = (__u8 *) dev->srCache;
N		    
N		if(dev->srCache)
N			memset(dev->srCache,0,srCacheBytes);
N		   
N		for (i = 0; i < dev->nShortOpCaches && buf; i++) {
N			dev->srCache[i].object = NULL;
X			dev->srCache[i].object = 0;
N			dev->srCache[i].lastUse = 0;
N			dev->srCache[i].dirty = 0;
N			dev->srCache[i].data = buf = YMALLOC_DMA(dev->totalBytesPerChunk);
X			dev->srCache[i].data = buf = yaffs_malloc(dev->totalBytesPerChunk);
N		}
N		if(!buf)
N			init_failed = 1;
N			
N		dev->srLastUse = 0;
N	}
N
N	dev->cacheHits = 0;
N	
N	if(!init_failed){
N		dev->gcCleanupList = YMALLOC(dev->nChunksPerBlock * sizeof(__u32));
X		dev->gcCleanupList = yaffs_malloc(dev->nChunksPerBlock * sizeof(__u32));
N		if(!dev->gcCleanupList)
N			init_failed = 1;
N	}
N   
N	if (dev->isYaffs2) {
N		dev->useHeaderFileSize = 1;
N	}
N    
N    
N	if(!init_failed && !yaffs_InitialiseBlocks(dev))
N		init_failed = 1;
N	
N	yaffs_InitialiseTnodes(dev);
N	yaffs_InitialiseObjects(dev);
N    
N	if(!init_failed && !yaffs_CreateInitialDirectories(dev))
N		init_failed = 1;
N    
N	if(!init_failed){
N		/* Now scan the flash. */
N		if (dev->isYaffs2) {
N		    
N			if(yaffs_CheckpointRestore(dev)) {
N			    
N				yaffs_CheckObjectDetailsLoaded(dev->rootDir);
N				T(YAFFS_TRACE_ALWAYS,
N				  (TSTR("yaffs: restored from checkpoint" TENDSTR)));
X				do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			} else {
N                
N				/* Clean up the mess caused by an aborted checkpoint load 
N				 * and scan backwards. 
N				 */
N				yaffs_DeinitialiseBlocks(dev);
N				yaffs_DeinitialiseTnodes(dev);
N				yaffs_DeinitialiseObjects(dev);
N				
N			
N				dev->nErasedBlocks = 0;
N				dev->nFreeChunks = 0;
N				dev->allocationBlock = -1;
W "..\fs\yaffs_guts.c" 7519 27 integer conversion resulted in a change of sign
N				dev->allocationPage = -1;
N				dev->nDeletedFiles = 0;
N				dev->nUnlinkedFiles = 0;
N				dev->nBackgroundDeletions = 0;
N				dev->oldestDirtySequence = 0;
N
N				if(!init_failed && !yaffs_InitialiseBlocks(dev))
N					init_failed = 1;
N					
N				yaffs_InitialiseTnodes(dev);
N				yaffs_InitialiseObjects(dev);
N
N				if(!init_failed && !yaffs_CreateInitialDirectories(dev))
N					init_failed = 1;
N
N				if(!init_failed && !yaffs_ScanBackwards(dev))
N					init_failed = 1;
N			}
N		}else
N			if(!yaffs_Scan(dev))
N				init_failed = 1;
N
N		yaffs_StripDeletedObjects(dev);
N	}
N	
N	if(init_failed){
N        
N		/* Clean up the mess */
N		T(YAFFS_TRACE_TRACING,
N		  (TSTR("yaffs: yaffs_GutsInitialise() aborted.\n" TENDSTR)));
X		do{ if((0x00000100) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N		yaffs_Deinitialise(dev);
N        
N		return YAFFS_FAIL;
X		return 0;
N	}
N    
N	/* Zero out stats */
N	dev->nPageReads = 0;
N	dev->nPageWrites = 0;
N	dev->nBlockErasures = 0;
N	dev->nGCCopies = 0;
N	dev->nRetriedWrites = 0;
N
N	dev->nRetiredBlocks = 0;
N
N	yaffs_VerifyFreeChunks(dev);
N	yaffs_VerifyBlocks(dev);
N	
N
N	T(YAFFS_TRACE_TRACING,
N	  (TSTR("yaffs: yaffs_GutsInitialise() done.\n" TENDSTR)));
X	do{ if((0x00000100) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N	return YAFFS_OK;
X	return 1;
N
N}
N
Nvoid yaffs_Deinitialise(yaffs_Device * dev)
N{
N	if (dev->isMounted) {
N		int i;
N
N		yaffs_DeinitialiseBlocks(dev);
N		yaffs_DeinitialiseTnodes(dev);
N		yaffs_DeinitialiseObjects(dev);
N		if (dev->nShortOpCaches > 0 &&
N		    dev->srCache) {
N
N			for (i = 0; i < dev->nShortOpCaches; i++) {
N				if(dev->srCache[i].data)
N					YFREE(dev->srCache[i].data);
X					free(dev->srCache[i]. data);
N				dev->srCache[i].data = NULL;
X				dev->srCache[i].data = 0;
N			}
N
N			YFREE(dev->srCache);
X			free(dev->srCache);
N			dev->srCache = NULL;
X			dev->srCache = 0;
N		}
N
N		YFREE(dev->gcCleanupList);
X		free(dev->gcCleanupList);
N
N		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
X		for (i = 0; i < 6; i++) {
N			YFREE(dev->tempBuffer[i].buffer);
X			free(dev->tempBuffer[i]. buffer);
N		}
N
N
N		dev->isMounted = 0;
N		
N		if(dev->deinitialiseNAND)
N			dev->deinitialiseNAND(dev);
N	}
N
N}
N
Nstatic int yaffs_CountFreeChunks(yaffs_Device * dev)
N{
N	int nFree;
N	int b;
N
N	yaffs_BlockInfo *blk;
N
N	for (nFree = 0, b = dev->internalStartBlock; b <= dev->internalEndBlock;
N	     b++) {
N		blk = yaffs_GetBlockInfo(dev, b);
N
N		switch (blk->blockState) {
N		case YAFFS_BLOCK_STATE_EMPTY:
N		case YAFFS_BLOCK_STATE_ALLOCATING:
N		case YAFFS_BLOCK_STATE_COLLECTING:
N		case YAFFS_BLOCK_STATE_FULL:
N			nFree +=
N			    (dev->nChunksPerBlock - blk->pagesInUse +
N			     blk->softDeletions);
N			break;
N		default:
N			break;
N		}
N
N	}
N
N	return nFree;
N}
N
Nint yaffs_GetNumberOfFreeChunks(yaffs_Device * dev)
N{
N	/* This is what we report to the outside world */
N
N	int nFree;
N	int nDirtyCacheChunks;
N	int blocksForCheckpoint;
N
N#if 1
N	nFree = dev->nFreeChunks;
N#else
S	nFree = yaffs_CountFreeChunks(dev);
N#endif
N
N	nFree += dev->nDeletedFiles;
N	
N	/* Now count the number of dirty chunks in the cache and subtract those */
N
N	{
N		int i;
N		for (nDirtyCacheChunks = 0, i = 0; i < dev->nShortOpCaches; i++) {
N			if (dev->srCache[i].dirty)
N				nDirtyCacheChunks++;
N		}
N	}
N
N	nFree -= nDirtyCacheChunks;
N
N	nFree -= ((dev->nReservedBlocks + 1) * dev->nChunksPerBlock);
N	
N	/* Now we figure out how much to reserve for the checkpoint and report that... */
N	blocksForCheckpoint = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
N	if(blocksForCheckpoint < 0)
N		blocksForCheckpoint = 0;
N		
N	nFree -= (blocksForCheckpoint * dev->nChunksPerBlock);
N
N	if (nFree < 0)
N		nFree = 0;
N
N	return nFree;
N
N}
N
Nstatic int yaffs_freeVerificationFailures;
N
Nstatic void yaffs_VerifyFreeChunks(yaffs_Device * dev)
N{
N	int counted;
N	int difference;
N	
N	if(yaffs_SkipVerification(dev))
N		return;
N	
N	counted = yaffs_CountFreeChunks(dev);
N
N	difference = dev->nFreeChunks - counted;
N
N	if (difference) {
N		T(YAFFS_TRACE_ALWAYS,
N		  (TSTR("Freechunks verification failure %d %d %d" TENDSTR),
N		   dev->nFreeChunks, counted, difference));
X		do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		yaffs_freeVerificationFailures++;
N	}
N}
N
N/*---------------------------------------- YAFFS test code ----------------------*/
N
N#define yaffs_CheckStruct(structure,syze, name) \
N	do { \
N           if(sizeof(structure) != syze) \
N	       { \
N	         T(YAFFS_TRACE_ALWAYS,(TSTR("%s should be %d but is %d\n" TENDSTR),\
N		 name,syze,sizeof(structure))); \
N	         return YAFFS_FAIL; \
N		} \
N	} while(0)
X#define yaffs_CheckStruct(structure,syze, name) 	do {            if(sizeof(structure) != syze) 	       { 	         T(YAFFS_TRACE_ALWAYS,(TSTR("%s should be %d but is %d\n" TENDSTR),		 name,syze,sizeof(structure))); 	         return YAFFS_FAIL; 		} 	} while(0)
N
Nstatic int yaffs_CheckStructures(void)
N{
N/*      yaffs_CheckStruct(yaffs_Tags,8,"yaffs_Tags"); */
N/*      yaffs_CheckStruct(yaffs_TagsUnion,8,"yaffs_TagsUnion"); */
N/*      yaffs_CheckStruct(yaffs_Spare,16,"yaffs_Spare"); */
N#ifndef CONFIG_YAFFS_TNODE_LIST_DEBUG
N        yaffs_CheckStruct(yaffs_Tnode, 2 * YAFFS_NTNODES_LEVEL0, "yaffs_Tnode");
X        do { if(sizeof(yaffs_Tnode) != 2 * 16) { do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0); return 0; } } while(0);
N#endif
N#ifndef CONFIG_YAFFS_WINCE
N		yaffs_CheckStruct(yaffs_ObjectHeader, 512, "yaffs_ObjectHeader");
X		do { if(sizeof(yaffs_ObjectHeader) != 512) { do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0); return 0; } } while(0);
N#endif
N	    return YAFFS_OK;
X	    return 1;
N}
W "..\fs\yaffs_guts.c" 417 21 variable "blockStateName" was declared but never referenced

; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\yaffs_guts.o --asm_dir=.\ --list_dir=.\ --depend=.\flash\yaffs_guts.d --feedback=.\Flash\YL_LPC1788_Test.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\app -I..\CM3_lib -I..\Drivers -I..\Startup -I.\Easy_web -I.\Lcd_Drv -I.\IIC_Test -I.\USU_Host -I.\Nand_Test -I.\FATFS_R0.08 -I..\fs -I"D:\Program Files\mdk\ARM\RV31\INC" -I"D:\Program Files\mdk\pack\ARM\CMSIS\4.1.1\CMSIS\Include" -I"D:\Program Files\mdk\ARM\Inc\NXP\LPC177x_8x" -D__MICROLIB --omf_browse=.\flash\yaffs_guts.crf ..\fs\yaffs_guts.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ylist_add PROC
;;;65     /* Add an element to a list */
;;;66     static __inline__ void ylist_add(struct ylist_head *newEntry, 
000000  680a              LDR      r2,[r1,#0]
;;;67                                      struct ylist_head *list)
;;;68     {
;;;69             struct ylist_head *listNext = list->next;
;;;70             
;;;71             list->next = newEntry;
000002  6008              STR      r0,[r1,#0]
;;;72             newEntry->prev = list;
000004  6041              STR      r1,[r0,#4]
;;;73     	newEntry->next = listNext;
000006  6002              STR      r2,[r0,#0]
;;;74     	listNext->prev = newEntry;
000008  6050              STR      r0,[r2,#4]
;;;75     	
;;;76     }
00000a  4770              BX       lr
;;;77     
                          ENDP

                  ylist_del_init PROC
;;;102    
;;;103    static __inline__ void ylist_del_init(struct ylist_head *entry)
00000c  bf00              NOP      
00000e  6801              LDR      r1,[r0,#0]
000010  6842              LDR      r2,[r0,#4]
000012  604a              STR      r2,[r1,#4]
000014  6011              STR      r1,[r2,#0]
000016  bf00              NOP      
;;;104    {
;;;105            ylist_del(entry);
;;;106            entry->next = entry->prev = entry;
000018  6040              STR      r0,[r0,#4]
00001a  6000              STR      r0,[r0,#0]
;;;107    }
00001c  4770              BX       lr
;;;108    
                          ENDP

                  yaffs_GetBlockInfo PROC
;;;21     /* Function to manipulate block info */
;;;22     static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
00001e  4602              MOV      r2,r0
;;;23     {
;;;24     	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
000020  f8d2009c          LDR      r0,[r2,#0x9c]
000024  4288              CMP      r0,r1
000026  dc03              BGT      |L1.48|
000028  f8d200a0          LDR      r0,[r2,#0xa0]
00002c  4288              CMP      r0,r1
00002e  da01              BGE      |L1.52|
                  |L1.48|
;;;25     		T(YAFFS_TRACE_ERROR,
000030  bf00              NOP      
000032  bf00              NOP      
                  |L1.52|
;;;26     		  (TSTR
;;;27     		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
;;;28     		   blk));
;;;29     		YBUG();
;;;30     	}
;;;31     	return &dev->blockInfo[blk - dev->internalStartBlock];
000034  f8d2309c          LDR      r3,[r2,#0x9c]
000038  1acb              SUBS     r3,r1,r3
00003a  f8d200e4          LDR      r0,[r2,#0xe4]
00003e  eb0000c3          ADD      r0,r0,r3,LSL #3
;;;32     }
000042  4770              BX       lr
;;;33     
                          ENDP

                  yaffs_AddrToChunk PROC
;;;117    
;;;118    static void yaffs_AddrToChunk(yaffs_Device *dev, loff_t addr, int *chunkOut, __u32 *offsetOut)
000044  b5f0              PUSH     {r4-r7,lr}
;;;119    {
000046  4614              MOV      r4,r2
000048  461d              MOV      r5,r3
;;;120    	int chunk;
;;;121    	__u32 offset;
;;;122    	
;;;123    	chunk  = (__u32)(addr >> dev->chunkShift);
00004a  f8906080          LDRB     r6,[r0,#0x80]
00004e  fa21f206          LSR      r2,r1,r6
;;;124    		
;;;125    	if(dev->chunkDiv == 1)
000052  f8d06084          LDR      r6,[r0,#0x84]
000056  2e01              CMP      r6,#1
000058  d104              BNE      |L1.100|
;;;126    	{
;;;127    		/* easy power of 2 case */
;;;128    		offset = (__u32)(addr & dev->chunkMask);
00005a  f8d06088          LDR      r6,[r0,#0x88]
00005e  ea060301          AND      r3,r6,r1
000062  e008              B        |L1.118|
                  |L1.100|
;;;129    	}
;;;130    	else
;;;131    	{
;;;132    		/* Non power-of-2 case */
;;;133    		
;;;134    		loff_t chunkBase;
;;;135    		
;;;136    		chunk /= dev->chunkDiv;
000064  f8d07084          LDR      r7,[r0,#0x84]
000068  fbb2f2f7          UDIV     r2,r2,r7
;;;137    		
;;;138    		chunkBase = ((loff_t)chunk) * dev->nDataBytesPerChunk;
00006c  68c7              LDR      r7,[r0,#0xc]
00006e  fb07f602          MUL      r6,r7,r2
;;;139    		offset = (__u32)(addr - chunkBase);
000072  1b8b              SUBS     r3,r1,r6
;;;140    	}
000074  bf00              NOP      
                  |L1.118|
;;;141    
;;;142    	*chunkOut = chunk;
000076  6022              STR      r2,[r4,#0]
;;;143    	*offsetOut = offset;
000078  602b              STR      r3,[r5,#0]
;;;144    }
00007a  bdf0              POP      {r4-r7,pc}
;;;145    
                          ENDP

                  ShiftsGE PROC
;;;151     
;;;152    static __u32 ShiftsGE(__u32 x)
00007c  4601              MOV      r1,r0
;;;153    {
;;;154    	int extraBits;
;;;155    	int nShifts;
;;;156    	
;;;157    	nShifts = extraBits = 0;
00007e  2300              MOVS     r3,#0
000080  461a              MOV      r2,r3
000082  4618              MOV      r0,r3
;;;158    	
;;;159    	while(x>1){
000084  e005              B        |L1.146|
                  |L1.134|
;;;160    		if(x & 1) extraBits++;
000086  f0010301          AND      r3,r1,#1
00008a  b103              CBZ      r3,|L1.142|
00008c  1c52              ADDS     r2,r2,#1
                  |L1.142|
;;;161    		x>>=1;
00008e  0849              LSRS     r1,r1,#1
;;;162    		nShifts++;
000090  1c40              ADDS     r0,r0,#1
                  |L1.146|
000092  2901              CMP      r1,#1                 ;159
000094  d8f7              BHI      |L1.134|
;;;163    	}
;;;164    
;;;165    	if(extraBits) 
000096  b102              CBZ      r2,|L1.154|
;;;166    		nShifts++;
000098  1c40              ADDS     r0,r0,#1
                  |L1.154|
;;;167    		
;;;168    	return nShifts;
;;;169    }
00009a  4770              BX       lr
;;;170    
                          ENDP

                  Shifts PROC
;;;173     
;;;174    static __u32 Shifts(__u32 x)
00009c  4601              MOV      r1,r0
;;;175    {
;;;176    	int nShifts;
;;;177    	
;;;178    	nShifts =  0;
00009e  2200              MOVS     r2,#0
;;;179    	
;;;180    	if(!x) return 0;
0000a0  b909              CBNZ     r1,|L1.166|
0000a2  2000              MOVS     r0,#0
                  |L1.164|
;;;181    	
;;;182    	while( !(x&1)){
;;;183    		x>>=1;
;;;184    		nShifts++;
;;;185    	}
;;;186    		
;;;187    	return nShifts;
;;;188    }
0000a4  4770              BX       lr
                  |L1.166|
0000a6  e001              B        |L1.172|
                  |L1.168|
0000a8  0849              LSRS     r1,r1,#1              ;183
0000aa  1c52              ADDS     r2,r2,#1              ;184
                  |L1.172|
0000ac  f0010001          AND      r0,r1,#1              ;182
0000b0  2800              CMP      r0,#0                 ;182
0000b2  d0f9              BEQ      |L1.168|
0000b4  4610              MOV      r0,r2                 ;187
0000b6  e7f5              B        |L1.164|
;;;189    
                          ENDP

                  yaffs_InitialiseTempBuffers PROC
;;;195    
;;;196    static int yaffs_InitialiseTempBuffers(yaffs_Device *dev)	
0000b8  b570              PUSH     {r4-r6,lr}
;;;197    {
0000ba  4604              MOV      r4,r0
;;;198    	int i;
;;;199    	__u8 *buf = (__u8 *)1;
0000bc  2601              MOVS     r6,#1
;;;200    		
;;;201    	memset(dev->tempBuffer,0,sizeof(dev->tempBuffer));
0000be  2148              MOVS     r1,#0x48
0000c0  f60450b8          ADD      r0,r4,#0xdb8
0000c4  f7fffffe          BL       __aeabi_memclr4
;;;202    	
;;;203    	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
0000c8  2500              MOVS     r5,#0
0000ca  e013              B        |L1.244|
                  |L1.204|
;;;204    		dev->tempBuffer[i].line = 0;	/* not in use */
0000cc  2100              MOVS     r1,#0
0000ce  eb050245          ADD      r2,r5,r5,LSL #1
0000d2  f60450b8          ADD      r0,r4,#0xdb8
0000d6  eb000082          ADD      r0,r0,r2,LSL #2
0000da  6041              STR      r1,[r0,#4]
;;;205    		dev->tempBuffer[i].buffer = buf =
0000dc  f8d40090          LDR      r0,[r4,#0x90]
0000e0  f7fffffe          BL       yaffs_malloc
0000e4  4606              MOV      r6,r0
0000e6  eb050245          ADD      r2,r5,r5,LSL #1
0000ea  f60451b8          ADD      r1,r4,#0xdb8
0000ee  f8410022          STR      r0,[r1,r2,LSL #2]
0000f2  1c6d              ADDS     r5,r5,#1              ;203
                  |L1.244|
0000f4  b10e              CBZ      r6,|L1.250|
0000f6  2d06              CMP      r5,#6                 ;203
0000f8  dbe8              BLT      |L1.204|
                  |L1.250|
;;;206    		    YMALLOC_DMA(dev->totalBytesPerChunk);
;;;207    	}
;;;208        
;;;209        return buf ? YAFFS_OK : YAFFS_FAIL;
0000fa  b10e              CBZ      r6,|L1.256|
0000fc  2001              MOVS     r0,#1
                  |L1.254|
;;;210    	
;;;211    }
0000fe  bd70              POP      {r4-r6,pc}
                  |L1.256|
000100  2000              MOVS     r0,#0                 ;209
000102  e7fc              B        |L1.254|
;;;212    
                          ENDP

                  yaffs_GetTempBuffer PROC
;;;213    __u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo)
000104  e92d41f0          PUSH     {r4-r8,lr}
;;;214    {
000108  4604              MOV      r4,r0
00010a  460f              MOV      r7,r1
;;;215    	int i, j;
;;;216    
;;;217    	dev->tempInUse++;
00010c  f8d40e04          LDR      r0,[r4,#0xe04]
000110  1c40              ADDS     r0,r0,#1
000112  f8c40e04          STR      r0,[r4,#0xe04]
;;;218    	if(dev->tempInUse > dev->maxTemp)
000116  f8d41e00          LDR      r1,[r4,#0xe00]
00011a  f8d40e04          LDR      r0,[r4,#0xe04]
00011e  4288              CMP      r0,r1
000120  dd03              BLE      |L1.298|
;;;219    		dev->maxTemp = dev->tempInUse;
000122  f8d40e04          LDR      r0,[r4,#0xe04]
000126  f8c40e00          STR      r0,[r4,#0xe00]
                  |L1.298|
;;;220    
;;;221    	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
00012a  2500              MOVS     r5,#0
00012c  e031              B        |L1.402|
                  |L1.302|
;;;222    		if (dev->tempBuffer[i].line == 0) {
00012e  eb050145          ADD      r1,r5,r5,LSL #1
000132  f60450b8          ADD      r0,r4,#0xdb8
000136  eb000081          ADD      r0,r0,r1,LSL #2
00013a  6840              LDR      r0,[r0,#4]
00013c  bb40              CBNZ     r0,|L1.400|
;;;223    			dev->tempBuffer[i].line = lineNo;
00013e  eb050145          ADD      r1,r5,r5,LSL #1
000142  f60450b8          ADD      r0,r4,#0xdb8
000146  eb000081          ADD      r0,r0,r1,LSL #2
00014a  6047              STR      r7,[r0,#4]
;;;224    			if ((i + 1) > dev->maxTemp) {
00014c  1c68              ADDS     r0,r5,#1
00014e  f8d41e00          LDR      r1,[r4,#0xe00]
000152  4281              CMP      r1,r0
000154  da14              BGE      |L1.384|
;;;225    				dev->maxTemp = i + 1;
000156  f8c40e00          STR      r0,[r4,#0xe00]
;;;226    				for (j = 0; j <= i; j++)
00015a  2600              MOVS     r6,#0
00015c  e00e              B        |L1.380|
                  |L1.350|
;;;227    					dev->tempBuffer[j].maxLine =
00015e  eb060146          ADD      r1,r6,r6,LSL #1
000162  f60450b8          ADD      r0,r4,#0xdb8
000166  eb000081          ADD      r0,r0,r1,LSL #2
00016a  eb060246          ADD      r2,r6,r6,LSL #1
00016e  6841              LDR      r1,[r0,#4]
000170  f60450b8          ADD      r0,r4,#0xdb8
000174  eb000082          ADD      r0,r0,r2,LSL #2
000178  6081              STR      r1,[r0,#8]
00017a  1c76              ADDS     r6,r6,#1              ;226
                  |L1.380|
00017c  42ae              CMP      r6,r5                 ;226
00017e  ddee              BLE      |L1.350|
                  |L1.384|
;;;228    					    dev->tempBuffer[j].line;
;;;229    			}
;;;230    
;;;231    			return dev->tempBuffer[i].buffer;
000180  eb050145          ADD      r1,r5,r5,LSL #1
000184  f60450b8          ADD      r0,r4,#0xdb8
000188  f8500021          LDR      r0,[r0,r1,LSL #2]
                  |L1.396|
;;;232    		}
;;;233    	}
;;;234    
;;;235    	T(YAFFS_TRACE_BUFFERS,
;;;236    	  (TSTR("Out of temp buffers at line %d, other held by lines:"),
;;;237    	   lineNo));
;;;238    	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
;;;239    		T(YAFFS_TRACE_BUFFERS, (TSTR(" %d "), dev->tempBuffer[i].line));
;;;240    	}
;;;241    	T(YAFFS_TRACE_BUFFERS, (TSTR(" " TENDSTR)));
;;;242    
;;;243    	/*
;;;244    	 * If we got here then we have to allocate an unmanaged one
;;;245    	 * This is not good.
;;;246    	 */
;;;247    
;;;248    	dev->unmanagedTempAllocations++;
;;;249    	return YMALLOC(dev->nDataBytesPerChunk);
;;;250    
;;;251    }
00018c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.400|
000190  1c6d              ADDS     r5,r5,#1              ;221
                  |L1.402|
000192  2d06              CMP      r5,#6                 ;221
000194  dbcb              BLT      |L1.302|
000196  bf00              NOP                            ;235
000198  bf00              NOP                            ;235
00019a  2500              MOVS     r5,#0                 ;238
00019c  e002              B        |L1.420|
                  |L1.414|
00019e  bf00              NOP                            ;239
0001a0  bf00              NOP                            ;239
0001a2  1c6d              ADDS     r5,r5,#1              ;238
                  |L1.420|
0001a4  2d06              CMP      r5,#6                 ;238
0001a6  dbfa              BLT      |L1.414|
0001a8  bf00              NOP                            ;241
0001aa  bf00              NOP                            ;241
0001ac  f8d40e08          LDR      r0,[r4,#0xe08]        ;248
0001b0  1c40              ADDS     r0,r0,#1              ;248
0001b2  f8c40e08          STR      r0,[r4,#0xe08]        ;248
0001b6  68e0              LDR      r0,[r4,#0xc]          ;249
0001b8  f7fffffe          BL       yaffs_malloc
0001bc  e7e6              B        |L1.396|
;;;252    
                          ENDP

                  yaffs_ReleaseTempBuffer PROC
;;;253    void yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer,
0001be  e92d41f0          PUSH     {r4-r8,lr}
;;;254    				    int lineNo)
;;;255    {
0001c2  4604              MOV      r4,r0
0001c4  460d              MOV      r5,r1
0001c6  4617              MOV      r7,r2
;;;256    	int i;
;;;257    	
;;;258    	dev->tempInUse--;
0001c8  f8d40e04          LDR      r0,[r4,#0xe04]
0001cc  1e40              SUBS     r0,r0,#1
0001ce  f8c40e04          STR      r0,[r4,#0xe04]
;;;259    	 
;;;260    	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) 
0001d2  2600              MOVS     r6,#0
0001d4  e012              B        |L1.508|
                  |L1.470|
;;;261    	{
;;;262    		if (dev->tempBuffer[i].buffer == buffer) 
0001d6  eb060146          ADD      r1,r6,r6,LSL #1
0001da  f60450b8          ADD      r0,r4,#0xdb8
0001de  f8500021          LDR      r0,[r0,r1,LSL #2]
0001e2  42a8              CMP      r0,r5
0001e4  d109              BNE      |L1.506|
;;;263    		{
;;;264    			dev->tempBuffer[i].line = 0;
0001e6  2100              MOVS     r1,#0
0001e8  eb060246          ADD      r2,r6,r6,LSL #1
0001ec  f60450b8          ADD      r0,r4,#0xdb8
0001f0  eb000082          ADD      r0,r0,r2,LSL #2
0001f4  6041              STR      r1,[r0,#4]
                  |L1.502|
;;;265    			return;
;;;266    		}
;;;267    	}
;;;268     
;;;269    	if (buffer) {
;;;270    		/* assume it is an unmanaged one. */
;;;271    		T(YAFFS_TRACE_BUFFERS,
;;;272    		  (TSTR("Releasing unmanaged temp buffer in line %d" TENDSTR),
;;;273    		   lineNo));
;;;274    	  
;;;275    		YFREE(buffer);
;;;276    		dev->unmanagedTempDeallocations++;
;;;277    	}
;;;278    
;;;279    }
0001f6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.506|
0001fa  1c76              ADDS     r6,r6,#1              ;260
                  |L1.508|
0001fc  2e06              CMP      r6,#6                 ;260
0001fe  dbea              BLT      |L1.470|
000200  b14d              CBZ      r5,|L1.534|
000202  bf00              NOP                            ;271
000204  bf00              NOP                            ;271
000206  4628              MOV      r0,r5                 ;275
000208  f7fffffe          BL       free
00020c  f8d40e0c          LDR      r0,[r4,#0xe0c]        ;276
000210  1c40              ADDS     r0,r0,#1              ;276
000212  f8c40e0c          STR      r0,[r4,#0xe0c]        ;276
                  |L1.534|
000216  bf00              NOP      
000218  e7ed              B        |L1.502|
;;;280    
                          ENDP

                  yaffs_BlockBits PROC
;;;312    
;;;313    static Y_INLINE __u8 *yaffs_BlockBits(yaffs_Device * dev, int blk)
00021a  b510              PUSH     {r4,lr}
;;;314    {
00021c  4602              MOV      r2,r0
;;;315    	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
00021e  f8d2009c          LDR      r0,[r2,#0x9c]
000222  4288              CMP      r0,r1
000224  dc03              BGT      |L1.558|
000226  f8d200a0          LDR      r0,[r2,#0xa0]
00022a  4288              CMP      r0,r1
00022c  da01              BGE      |L1.562|
                  |L1.558|
;;;316    		T(YAFFS_TRACE_ERROR,
00022e  bf00              NOP      
000230  bf00              NOP      
                  |L1.562|
;;;317    		  (TSTR("**>> yaffs: BlockBits block %d is not valid" TENDSTR),
;;;318    		   blk));
;;;319    		YBUG();
;;;320    	}
;;;321    	return dev->chunkBits +
000232  329c              ADDS     r2,r2,#0x9c
000234  6d53              LDR      r3,[r2,#0x54]
000236  6cd0              LDR      r0,[r2,#0x4c]
000238  f852499c          LDR      r4,[r2],#-0x9c
00023c  1b0c              SUBS     r4,r1,r4
00023e  fb030004          MLA      r0,r3,r4,r0
;;;322    	    (dev->chunkBitmapStride * (blk - dev->internalStartBlock));
;;;323    }
000242  bd10              POP      {r4,pc}
;;;324    
                          ENDP

                  yaffs_VerifyChunkBitId PROC
;;;325    static Y_INLINE void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)
000244  f8d0309c          LDR      r3,[r0,#0x9c]
;;;326    {
;;;327    	if(blk < dev->internalStartBlock || blk > dev->internalEndBlock ||
000248  428b              CMP      r3,r1
00024a  dc08              BGT      |L1.606|
00024c  f8d030a0          LDR      r3,[r0,#0xa0]
000250  428b              CMP      r3,r1
000252  db04              BLT      |L1.606|
;;;328    	   chunk < 0 || chunk >= dev->nChunksPerBlock) {
000254  2a00              CMP      r2,#0
000256  db02              BLT      |L1.606|
000258  6903              LDR      r3,[r0,#0x10]
00025a  4293              CMP      r3,r2
00025c  dc01              BGT      |L1.610|
                  |L1.606|
;;;329    	   T(YAFFS_TRACE_ERROR,
00025e  bf00              NOP      
000260  bf00              NOP      
                  |L1.610|
;;;330    	    (TSTR("**>> yaffs: Chunk Id (%d:%d) invalid"TENDSTR),blk,chunk));
;;;331    	    YBUG();
;;;332    	}
;;;333    }
000262  4770              BX       lr
;;;334    
                          ENDP

                  yaffs_SetChunkBit PROC
;;;350    
;;;351    static Y_INLINE void yaffs_SetChunkBit(yaffs_Device * dev, int blk, int chunk)
000264  e92d41f0          PUSH     {r4-r8,lr}
;;;352    {
000268  4606              MOV      r6,r0
00026a  460f              MOV      r7,r1
00026c  4614              MOV      r4,r2
;;;353    	__u8 *blkBits = yaffs_BlockBits(dev, blk);
00026e  4639              MOV      r1,r7
000270  4630              MOV      r0,r6
000272  f7fffffe          BL       yaffs_BlockBits
000276  4605              MOV      r5,r0
;;;354    	
;;;355    	yaffs_VerifyChunkBitId(dev,blk,chunk);
000278  4622              MOV      r2,r4
00027a  4639              MOV      r1,r7
00027c  4630              MOV      r0,r6
00027e  f7fffffe          BL       yaffs_VerifyChunkBitId
;;;356    
;;;357    	blkBits[chunk / 8] |= (1 << (chunk & 7));
000282  17e1              ASRS     r1,r4,#31
000284  eb047151          ADD      r1,r4,r1,LSR #29
000288  10c9              ASRS     r1,r1,#3
00028a  5c69              LDRB     r1,[r5,r1]
00028c  f0040307          AND      r3,r4,#7
000290  2201              MOVS     r2,#1
000292  409a              LSLS     r2,r2,r3
000294  4311              ORRS     r1,r1,r2
000296  4620              MOV      r0,r4
000298  17e2              ASRS     r2,r4,#31
00029a  eb047252          ADD      r2,r4,r2,LSR #29
00029e  10d2              ASRS     r2,r2,#3
0002a0  54a9              STRB     r1,[r5,r2]
;;;358    }
0002a2  e8bd81f0          POP      {r4-r8,pc}
;;;359    
                          ENDP

                  yaffs_CheckChunkBit PROC
;;;360    static Y_INLINE int yaffs_CheckChunkBit(yaffs_Device * dev, int blk, int chunk)
0002a6  e92d41f0          PUSH     {r4-r8,lr}
;;;361    {
0002aa  4605              MOV      r5,r0
0002ac  460e              MOV      r6,r1
0002ae  4614              MOV      r4,r2
;;;362    	__u8 *blkBits = yaffs_BlockBits(dev, blk);
0002b0  4631              MOV      r1,r6
0002b2  4628              MOV      r0,r5
0002b4  f7fffffe          BL       yaffs_BlockBits
0002b8  4607              MOV      r7,r0
;;;363    	yaffs_VerifyChunkBitId(dev,blk,chunk);
0002ba  4622              MOV      r2,r4
0002bc  4631              MOV      r1,r6
0002be  4628              MOV      r0,r5
0002c0  f7fffffe          BL       yaffs_VerifyChunkBitId
;;;364    
;;;365    	return (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
0002c4  4621              MOV      r1,r4
0002c6  17e0              ASRS     r0,r4,#31
0002c8  eb047050          ADD      r0,r4,r0,LSR #29
0002cc  10c0              ASRS     r0,r0,#3
0002ce  5c38              LDRB     r0,[r7,r0]
0002d0  f0040307          AND      r3,r4,#7
0002d4  2201              MOVS     r2,#1
0002d6  409a              LSLS     r2,r2,r3
0002d8  4010              ANDS     r0,r0,r2
0002da  b110              CBZ      r0,|L1.738|
0002dc  2001              MOVS     r0,#1
                  |L1.734|
;;;366    }
0002de  e8bd81f0          POP      {r4-r8,pc}
                  |L1.738|
0002e2  2000              MOVS     r0,#0                 ;365
0002e4  e7fb              B        |L1.734|
;;;367    
                          ENDP

                  yaffs_CountChunkBits PROC
;;;379    
;;;380    static int yaffs_CountChunkBits(yaffs_Device * dev, int blk)
0002e6  e92d41f0          PUSH     {r4-r8,lr}
;;;381    {
0002ea  4604              MOV      r4,r0
0002ec  4688              MOV      r8,r1
;;;382    	__u8 *blkBits = yaffs_BlockBits(dev, blk);
0002ee  4641              MOV      r1,r8
0002f0  4620              MOV      r0,r4
0002f2  f7fffffe          BL       yaffs_BlockBits
0002f6  4605              MOV      r5,r0
;;;383    	int i;
;;;384    	int n = 0;
0002f8  2700              MOVS     r7,#0
;;;385    	for (i = 0; i < dev->chunkBitmapStride; i++) {
0002fa  2600              MOVS     r6,#0
0002fc  e00a              B        |L1.788|
                  |L1.766|
;;;386    		__u8 x = *blkBits;
0002fe  7828              LDRB     r0,[r5,#0]
;;;387    		while(x){
000300  e004              B        |L1.780|
                  |L1.770|
;;;388    			if(x & 1)
000302  f0000101          AND      r1,r0,#1
000306  b101              CBZ      r1,|L1.778|
;;;389    				n++;
000308  1c7f              ADDS     r7,r7,#1
                  |L1.778|
;;;390    			x >>=1;
00030a  1040              ASRS     r0,r0,#1
                  |L1.780|
00030c  2800              CMP      r0,#0                 ;387
00030e  d1f8              BNE      |L1.770|
;;;391    		}
;;;392    			
;;;393    		blkBits++;
000310  1c6d              ADDS     r5,r5,#1
000312  1c76              ADDS     r6,r6,#1              ;385
                  |L1.788|
000314  f8d400f0          LDR      r0,[r4,#0xf0]         ;385
000318  42b0              CMP      r0,r6                 ;385
00031a  dcf0              BGT      |L1.766|
;;;394    	}
;;;395    	return n;
00031c  4638              MOV      r0,r7
;;;396    }
00031e  e8bd81f0          POP      {r4-r8,pc}
;;;397    
                          ENDP

                  yaffs_SkipVerification PROC
;;;401     
;;;402    static int yaffs_SkipVerification(yaffs_Device *dev)
000322  4601              MOV      r1,r0
;;;403    {
;;;404    	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
000324  48fe              LDR      r0,|L1.1824|
000326  6800              LDR      r0,[r0,#0]  ; yaffs_traceMask
000328  f40020a0          AND      r0,r0,#0x50000
00032c  b908              CBNZ     r0,|L1.818|
00032e  2001              MOVS     r0,#1
                  |L1.816|
;;;405    }
000330  4770              BX       lr
                  |L1.818|
000332  2000              MOVS     r0,#0                 ;404
000334  e7fc              B        |L1.816|
;;;406    
                          ENDP

                  yaffs_SkipFullVerification PROC
;;;407    static int yaffs_SkipFullVerification(yaffs_Device *dev)
000336  4601              MOV      r1,r0
;;;408    {
;;;409    	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));
000338  48f9              LDR      r0,|L1.1824|
00033a  6800              LDR      r0,[r0,#0]  ; yaffs_traceMask
00033c  2201              MOVS     r2,#1
00033e  ea224090          BIC      r0,r2,r0,LSR #18
;;;410    }
000342  4770              BX       lr
;;;411    
                          ENDP

                  yaffs_SkipNANDVerification PROC
;;;412    static int yaffs_SkipNANDVerification(yaffs_Device *dev)
000344  4601              MOV      r1,r0
;;;413    {
;;;414    	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));
000346  48f6              LDR      r0,|L1.1824|
000348  6800              LDR      r0,[r0,#0]  ; yaffs_traceMask
00034a  2201              MOVS     r2,#1
00034c  ea224050          BIC      r0,r2,r0,LSR #17
;;;415    }
000350  4770              BX       lr
;;;416    
                          ENDP

                  yaffs_VerifyBlock PROC
;;;429    
;;;430    static void yaffs_VerifyBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)
000352  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
000356  4605              MOV      r5,r0
000358  460c              MOV      r4,r1
00035a  4690              MOV      r8,r2
;;;432    	int actuallyUsed;
;;;433    	int inUse;
;;;434    	
;;;435    	if(yaffs_SkipVerification(dev))
00035c  4628              MOV      r0,r5
00035e  f7fffffe          BL       yaffs_SkipVerification
000362  b108              CBZ      r0,|L1.872|
                  |L1.868|
;;;436    		return;
;;;437    		
;;;438    	/* Report illegal runtime states */
;;;439    	if(bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)
;;;440    		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has undefined state %d"TENDSTR),n,bi->blockState));
;;;441    		
;;;442    	switch(bi->blockState){
;;;443    	 case YAFFS_BLOCK_STATE_UNKNOWN:
;;;444    	 case YAFFS_BLOCK_STATE_SCANNING:
;;;445    	 case YAFFS_BLOCK_STATE_NEEDS_SCANNING:
;;;446    		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has bad run-state %s"TENDSTR),
;;;447    		n,blockStateName[bi->blockState]));
;;;448    	}
;;;449    	
;;;450    	/* Check pages in use and soft deletions are legal */
;;;451    	
;;;452    	actuallyUsed = bi->pagesInUse - bi->softDeletions;
;;;453    	
;;;454    	if(bi->pagesInUse < 0 || bi->pagesInUse > dev->nChunksPerBlock ||
;;;455    	   bi->softDeletions < 0 || bi->softDeletions > dev->nChunksPerBlock ||
;;;456    	   actuallyUsed < 0 || actuallyUsed > dev->nChunksPerBlock)
;;;457    		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has illegal values pagesInUsed %d softDeletions %d"TENDSTR),
;;;458    		n,bi->pagesInUse,bi->softDeletions));
;;;459    	
;;;460    		
;;;461    	/* Check chunk bitmap legal */
;;;462    	inUse = yaffs_CountChunkBits(dev,n);
;;;463    	if(inUse != bi->pagesInUse)
;;;464    		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has inconsistent values pagesInUse %d counted chunk bits %d"TENDSTR),
;;;465    			n,bi->pagesInUse,inUse));
;;;466    	
;;;467    	/* Check that the sequence number is valid.
;;;468    	 * Ten million is legal, but is very unlikely 
;;;469    	 */
;;;470    	if(dev->isYaffs2 && 
;;;471    	   (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING || bi->blockState == YAFFS_BLOCK_STATE_FULL) &&
;;;472    	   (bi->sequenceNumber < YAFFS_LOWEST_SEQUENCE_NUMBER || bi->sequenceNumber > 10000000 ))
;;;473    		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has suspect sequence number of %d"TENDSTR),
;;;474    		n,bi->sequenceNumber));
;;;475    		
;;;476    }
000364  e8bd81f0          POP      {r4-r8,pc}
                  |L1.872|
000368  6820              LDR      r0,[r4,#0]            ;439
00036a  f3c05003          UBFX     r0,r0,#20,#4          ;439
00036e  280a              CMP      r0,#0xa               ;439
000370  db01              BLT      |L1.886|
000372  bf00              NOP                            ;440
000374  bf00              NOP                            ;440
                  |L1.886|
000376  6820              LDR      r0,[r4,#0]            ;442
000378  f3c05003          UBFX     r0,r0,#20,#4          ;442
00037c  b120              CBZ      r0,|L1.904|
00037e  2801              CMP      r0,#1                 ;442
000380  d003              BEQ      |L1.906|
000382  2802              CMP      r0,#2                 ;442
000384  d105              BNE      |L1.914|
000386  e001              B        |L1.908|
                  |L1.904|
000388  bf00              NOP                            ;444
                  |L1.906|
00038a  bf00              NOP                            ;445
                  |L1.908|
00038c  bf00              NOP                            ;446
00038e  bf00              NOP                            ;446
000390  bf00              NOP                            ;442
                  |L1.914|
000392  bf00              NOP                            ;442
000394  6820              LDR      r0,[r4,#0]            ;452
000396  f3c02089          UBFX     r0,r0,#10,#10         ;452
00039a  8821              LDRH     r1,[r4,#0]            ;452
00039c  f3c10109          UBFX     r1,r1,#0,#10          ;452
0003a0  1a46              SUBS     r6,r0,r1              ;452
0003a2  6820              LDR      r0,[r4,#0]            ;454
0003a4  f3c02089          UBFX     r0,r0,#10,#10         ;454
0003a8  2800              CMP      r0,#0                 ;454
0003aa  db15              BLT      |L1.984|
0003ac  6820              LDR      r0,[r4,#0]            ;454
0003ae  f3c02089          UBFX     r0,r0,#10,#10         ;454
0003b2  6929              LDR      r1,[r5,#0x10]         ;454
0003b4  4288              CMP      r0,r1                 ;454
0003b6  dc0f              BGT      |L1.984|
0003b8  8820              LDRH     r0,[r4,#0]            ;455
0003ba  f3c00009          UBFX     r0,r0,#0,#10          ;455
0003be  2800              CMP      r0,#0                 ;455
0003c0  db0a              BLT      |L1.984|
0003c2  8820              LDRH     r0,[r4,#0]            ;455
0003c4  f3c00009          UBFX     r0,r0,#0,#10          ;455
0003c8  6929              LDR      r1,[r5,#0x10]         ;455
0003ca  4288              CMP      r0,r1                 ;455
0003cc  dc04              BGT      |L1.984|
0003ce  2e00              CMP      r6,#0                 ;456
0003d0  db02              BLT      |L1.984|
0003d2  6928              LDR      r0,[r5,#0x10]         ;456
0003d4  42b0              CMP      r0,r6                 ;456
0003d6  da01              BGE      |L1.988|
                  |L1.984|
0003d8  bf00              NOP                            ;457
0003da  bf00              NOP                            ;457
                  |L1.988|
0003dc  4641              MOV      r1,r8                 ;462
0003de  4628              MOV      r0,r5                 ;462
0003e0  f7fffffe          BL       yaffs_CountChunkBits
0003e4  4607              MOV      r7,r0                 ;462
0003e6  6820              LDR      r0,[r4,#0]            ;463
0003e8  f3c02089          UBFX     r0,r0,#10,#10         ;463
0003ec  42b8              CMP      r0,r7                 ;463
0003ee  d001              BEQ      |L1.1012|
0003f0  bf00              NOP                            ;464
0003f2  bf00              NOP                            ;464
                  |L1.1012|
0003f4  6de8              LDR      r0,[r5,#0x5c]         ;470
0003f6  b198              CBZ      r0,|L1.1056|
0003f8  6820              LDR      r0,[r4,#0]            ;471
0003fa  f3c05003          UBFX     r0,r0,#20,#4          ;471
0003fe  2804              CMP      r0,#4                 ;471
000400  d004              BEQ      |L1.1036|
000402  6820              LDR      r0,[r4,#0]            ;471
000404  f3c05003          UBFX     r0,r0,#20,#4          ;471
000408  2805              CMP      r0,#5                 ;471
00040a  d109              BNE      |L1.1056|
                  |L1.1036|
00040c  6860              LDR      r0,[r4,#4]            ;472
00040e  f5b05f80          CMP      r0,#0x1000            ;472
000412  d303              BCC      |L1.1052|
000414  49c3              LDR      r1,|L1.1828|
000416  6860              LDR      r0,[r4,#4]            ;472
000418  4288              CMP      r0,r1                 ;472
00041a  d901              BLS      |L1.1056|
                  |L1.1052|
00041c  bf00              NOP                            ;473
00041e  bf00              NOP                            ;473
                  |L1.1056|
000420  bf00              NOP      
000422  e79f              B        |L1.868|
;;;477    
                          ENDP

                  yaffs_VerifyCollectedBlock PROC
;;;478    static void yaffs_VerifyCollectedBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)
000424  b570              PUSH     {r4-r6,lr}
;;;479    {
000426  4605              MOV      r5,r0
000428  460c              MOV      r4,r1
00042a  4616              MOV      r6,r2
;;;480    	yaffs_VerifyBlock(dev,bi,n);
00042c  4632              MOV      r2,r6
00042e  4621              MOV      r1,r4
000430  4628              MOV      r0,r5
000432  f7fffffe          BL       yaffs_VerifyBlock
;;;481    	
;;;482    	/* After collection the block should be in the erased state */
;;;483    	/* This will need to change if we do partial gc */
;;;484    	
;;;485    	if(bi->blockState != YAFFS_BLOCK_STATE_COLLECTING &&
000436  6820              LDR      r0,[r4,#0]
000438  f3c05003          UBFX     r0,r0,#20,#4
00043c  2808              CMP      r0,#8
00043e  d006              BEQ      |L1.1102|
;;;486    	   bi->blockState != YAFFS_BLOCK_STATE_EMPTY){
000440  6820              LDR      r0,[r4,#0]
000442  f3c05003          UBFX     r0,r0,#20,#4
000446  2803              CMP      r0,#3
000448  d001              BEQ      |L1.1102|
;;;487    		T(YAFFS_TRACE_ERROR,(TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),
00044a  bf00              NOP      
00044c  bf00              NOP      
                  |L1.1102|
;;;488    			n,bi->blockState));
;;;489    	}
;;;490    }
00044e  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP

                  yaffs_VerifyBlocks PROC
;;;492    static void yaffs_VerifyBlocks(yaffs_Device *dev)
000450  b5f0              PUSH     {r4-r7,lr}
;;;493    {
000452  b08b              SUB      sp,sp,#0x2c
000454  4605              MOV      r5,r0
;;;494    	int i;
;;;495    	int nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];
;;;496    	int nIllegalBlockStates = 0;
000456  2700              MOVS     r7,#0
;;;497    	
;;;498    
;;;499    	if(yaffs_SkipVerification(dev))
000458  4628              MOV      r0,r5
00045a  f7fffffe          BL       yaffs_SkipVerification
00045e  b108              CBZ      r0,|L1.1124|
                  |L1.1120|
;;;500    		return;
;;;501    
;;;502    	memset(nBlocksPerState,0,sizeof(nBlocksPerState));
;;;503    
;;;504    		
;;;505    	for(i = dev->internalStartBlock; i <= dev->internalEndBlock; i++){
;;;506    		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);
;;;507    		yaffs_VerifyBlock(dev,bi,i);
;;;508    
;;;509    		if(bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)
;;;510    			nBlocksPerState[bi->blockState]++;
;;;511    		else
;;;512    			nIllegalBlockStates++;
;;;513    					
;;;514    	}
;;;515    	
;;;516    	T(YAFFS_TRACE_VERIFY,(TSTR(""TENDSTR)));
;;;517    	T(YAFFS_TRACE_VERIFY,(TSTR("Block summary"TENDSTR)));
;;;518    	
;;;519    	T(YAFFS_TRACE_VERIFY,(TSTR("%d blocks have illegal states"TENDSTR),nIllegalBlockStates));
;;;520    	if(nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
;;;521    		T(YAFFS_TRACE_VERIFY,(TSTR("Too many allocating blocks"TENDSTR)));
;;;522    
;;;523    	for(i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
;;;524    		T(YAFFS_TRACE_VERIFY,
;;;525    		  (TSTR("%s %d blocks"TENDSTR),
;;;526    		  blockStateName[i],nBlocksPerState[i]));
;;;527    	
;;;528    	if(dev->blocksInCheckpoint != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])
;;;529    		T(YAFFS_TRACE_VERIFY,
;;;530    		 (TSTR("Checkpoint block count wrong dev %d count %d"TENDSTR),
;;;531    		 dev->blocksInCheckpoint, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));
;;;532    		 
;;;533    	if(dev->nErasedBlocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])
;;;534    		T(YAFFS_TRACE_VERIFY,
;;;535    		 (TSTR("Erased block count wrong dev %d count %d"TENDSTR),
;;;536    		 dev->nErasedBlocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));
;;;537    		 
;;;538    	if(nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)
;;;539    		T(YAFFS_TRACE_VERIFY,
;;;540    		 (TSTR("Too many collecting blocks %d (max is 1)"TENDSTR),
;;;541    		 nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));
;;;542    
;;;543    	T(YAFFS_TRACE_VERIFY,(TSTR(""TENDSTR)));
;;;544    
;;;545    }
000460  b00b              ADD      sp,sp,#0x2c
000462  bdf0              POP      {r4-r7,pc}
                  |L1.1124|
000464  2128              MOVS     r1,#0x28              ;502
000466  a801              ADD      r0,sp,#4              ;502
000468  f7fffffe          BL       __aeabi_memclr4
00046c  f8d5409c          LDR      r4,[r5,#0x9c]         ;505
000470  e01e              B        |L1.1200|
                  |L1.1138|
000472  4621              MOV      r1,r4                 ;506
000474  4628              MOV      r0,r5                 ;506
000476  f7fffffe          BL       yaffs_GetBlockInfo
00047a  4606              MOV      r6,r0                 ;506
00047c  4622              MOV      r2,r4                 ;507
00047e  4631              MOV      r1,r6                 ;507
000480  4628              MOV      r0,r5                 ;507
000482  f7fffffe          BL       yaffs_VerifyBlock
000486  6830              LDR      r0,[r6,#0]            ;509
000488  f3c05003          UBFX     r0,r0,#20,#4          ;509
00048c  280a              CMP      r0,#0xa               ;509
00048e  da0d              BGE      |L1.1196|
000490  6830              LDR      r0,[r6,#0]            ;510
000492  f3c05003          UBFX     r0,r0,#20,#4          ;510
000496  a901              ADD      r1,sp,#4              ;510
000498  f8510020          LDR      r0,[r1,r0,LSL #2]     ;510
00049c  1c40              ADDS     r0,r0,#1              ;510
00049e  6831              LDR      r1,[r6,#0]            ;510
0004a0  f3c15103          UBFX     r1,r1,#20,#4          ;510
0004a4  aa01              ADD      r2,sp,#4              ;510
0004a6  f8420021          STR      r0,[r2,r1,LSL #2]     ;510
0004aa  e000              B        |L1.1198|
                  |L1.1196|
0004ac  1c7f              ADDS     r7,r7,#1              ;512
                  |L1.1198|
0004ae  1c64              ADDS     r4,r4,#1              ;505
                  |L1.1200|
0004b0  f8d500a0          LDR      r0,[r5,#0xa0]         ;505
0004b4  42a0              CMP      r0,r4                 ;505
0004b6  dadc              BGE      |L1.1138|
0004b8  bf00              NOP                            ;516
0004ba  bf00              NOP                            ;516
0004bc  bf00              NOP                            ;517
0004be  bf00              NOP                            ;517
0004c0  bf00              NOP                            ;519
0004c2  bf00              NOP                            ;519
0004c4  9805              LDR      r0,[sp,#0x14]         ;520
0004c6  2801              CMP      r0,#1                 ;520
0004c8  dd01              BLE      |L1.1230|
0004ca  bf00              NOP                            ;521
0004cc  bf00              NOP                            ;521
                  |L1.1230|
0004ce  2400              MOVS     r4,#0                 ;523
0004d0  e002              B        |L1.1240|
                  |L1.1234|
0004d2  bf00              NOP                            ;524
0004d4  bf00              NOP                            ;524
0004d6  1c64              ADDS     r4,r4,#1              ;523
                  |L1.1240|
0004d8  2c0a              CMP      r4,#0xa               ;523
0004da  dbfa              BLT      |L1.1234|
0004dc  f8d500c0          LDR      r0,[r5,#0xc0]         ;528
0004e0  9908              LDR      r1,[sp,#0x20]         ;528
0004e2  4288              CMP      r0,r1                 ;528
0004e4  d001              BEQ      |L1.1258|
0004e6  bf00              NOP                            ;529
0004e8  bf00              NOP                            ;529
                  |L1.1258|
0004ea  f8d500f4          LDR      r0,[r5,#0xf4]         ;533
0004ee  9904              LDR      r1,[sp,#0x10]         ;533
0004f0  4288              CMP      r0,r1                 ;533
0004f2  d001              BEQ      |L1.1272|
0004f4  bf00              NOP                            ;534
0004f6  bf00              NOP                            ;534
                  |L1.1272|
0004f8  9809              LDR      r0,[sp,#0x24]         ;538
0004fa  2801              CMP      r0,#1                 ;538
0004fc  dd01              BLE      |L1.1282|
0004fe  bf00              NOP                            ;539
000500  bf00              NOP                            ;539
                  |L1.1282|
000502  bf00              NOP                            ;543
000504  bf00              NOP                            ;543
000506  bf00              NOP      
000508  e7aa              B        |L1.1120|
;;;546    
                          ENDP

                  yaffs_VerifyObjectHeader PROC
;;;550     */
;;;551    static void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)
00050a  e92d41f0          PUSH     {r4-r8,lr}
;;;552    {
00050e  4604              MOV      r4,r0
000510  460d              MOV      r5,r1
000512  4616              MOV      r6,r2
000514  461f              MOV      r7,r3
;;;553    	if(obj && yaffs_SkipVerification(obj->myDev))
000516  b12c              CBZ      r4,|L1.1316|
000518  68a0              LDR      r0,[r4,#8]
00051a  f7fffffe          BL       yaffs_SkipVerification
00051e  b108              CBZ      r0,|L1.1316|
                  |L1.1312|
;;;554    		return;
;;;555    		
;;;556    	if(!(tags && obj && oh)){
;;;557    	 	T(YAFFS_TRACE_VERIFY,
;;;558    		 		(TSTR("Verifying object header tags %x obj %x oh %x"TENDSTR),
;;;559    		 		(__u32)tags,(__u32)obj,(__u32)oh));
;;;560    		return;
;;;561    	}
;;;562    	
;;;563    	if(oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
;;;564    	   oh->type > YAFFS_OBJECT_TYPE_MAX)
;;;565    	 	T(YAFFS_TRACE_VERIFY,
;;;566    		 (TSTR("Obj %d header type is illegal value 0x%x"TENDSTR),
;;;567    		 tags->objectId, oh->type));
;;;568    
;;;569    	if(tags->objectId != obj->objectId)
;;;570    	 	T(YAFFS_TRACE_VERIFY,
;;;571    		 (TSTR("Obj %d header mismatch objectId %d"TENDSTR),
;;;572    		 tags->objectId, obj->objectId));
;;;573    
;;;574    
;;;575    	/*
;;;576    	 * Check that the object's parent ids match if parentCheck requested.
;;;577    	 * 
;;;578    	 * Tests do not apply to the root object.
;;;579    	 */
;;;580    	
;;;581    	if(parentCheck && tags->objectId > 1 && !obj->parent)
;;;582    	 	T(YAFFS_TRACE_VERIFY,
;;;583    		 (TSTR("Obj %d header mismatch parentId %d obj->parent is NULL"TENDSTR),
;;;584    	 	 tags->objectId, oh->parentObjectId));
;;;585    		
;;;586    	
;;;587    	if(parentCheck && obj->parent &&
;;;588    	   oh->parentObjectId != obj->parent->objectId && 
;;;589    	   (oh->parentObjectId != YAFFS_OBJECTID_UNLINKED ||
;;;590    	    obj->parent->objectId != YAFFS_OBJECTID_DELETED))
;;;591    	 	T(YAFFS_TRACE_VERIFY,
;;;592    		 (TSTR("Obj %d header mismatch parentId %d parentObjectId %d"TENDSTR),
;;;593    	 	 tags->objectId, oh->parentObjectId, obj->parent->objectId));
;;;594    		
;;;595    	
;;;596    	if(tags->objectId > 1 && oh->name[0] == 0) /* Null name */
;;;597    		T(YAFFS_TRACE_VERIFY,
;;;598    		(TSTR("Obj %d header name is NULL"TENDSTR),
;;;599    		 obj->objectId));
;;;600    
;;;601    	if(tags->objectId > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */
;;;602    		T(YAFFS_TRACE_VERIFY,
;;;603    		(TSTR("Obj %d header name is 0xFF"TENDSTR),
;;;604    		 obj->objectId));
;;;605    }
000520  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1316|
000524  b10e              CBZ      r6,|L1.1322|
000526  b104              CBZ      r4,|L1.1322|
000528  b915              CBNZ     r5,|L1.1328|
                  |L1.1322|
00052a  bf00              NOP                            ;557
00052c  bf00              NOP                            ;557
00052e  e7f7              B        |L1.1312|
                  |L1.1328|
000530  7828              LDRB     r0,[r5,#0]            ;563
000532  2800              CMP      r0,#0                 ;563
000534  dd02              BLE      |L1.1340|
000536  7828              LDRB     r0,[r5,#0]            ;564
000538  2805              CMP      r0,#5                 ;564
00053a  dd01              BLE      |L1.1344|
                  |L1.1340|
00053c  bf00              NOP                            ;565
00053e  bf00              NOP                            ;565
                  |L1.1344|
000540  68b0              LDR      r0,[r6,#8]            ;569
000542  6b21              LDR      r1,[r4,#0x30]         ;569
000544  4288              CMP      r0,r1                 ;569
000546  d001              BEQ      |L1.1356|
000548  bf00              NOP                            ;570
00054a  bf00              NOP                            ;570
                  |L1.1356|
00054c  b137              CBZ      r7,|L1.1372|
00054e  68b0              LDR      r0,[r6,#8]            ;581
000550  2801              CMP      r0,#1                 ;581
000552  d903              BLS      |L1.1372|
000554  69e0              LDR      r0,[r4,#0x1c]         ;581
000556  b908              CBNZ     r0,|L1.1372|
000558  bf00              NOP                            ;582
00055a  bf00              NOP                            ;582
                  |L1.1372|
00055c  b17f              CBZ      r7,|L1.1406|
00055e  69e0              LDR      r0,[r4,#0x1c]         ;587
000560  b168              CBZ      r0,|L1.1406|
000562  6868              LDR      r0,[r5,#4]            ;588
000564  69e1              LDR      r1,[r4,#0x1c]         ;588
000566  6b09              LDR      r1,[r1,#0x30]         ;588
000568  4288              CMP      r0,r1                 ;588
00056a  d008              BEQ      |L1.1406|
00056c  6868              LDR      r0,[r5,#4]            ;589
00056e  2803              CMP      r0,#3                 ;589
000570  d103              BNE      |L1.1402|
000572  69e0              LDR      r0,[r4,#0x1c]         ;590
000574  6b00              LDR      r0,[r0,#0x30]         ;590
000576  2804              CMP      r0,#4                 ;590
000578  d001              BEQ      |L1.1406|
                  |L1.1402|
00057a  bf00              NOP                            ;591
00057c  bf00              NOP                            ;591
                  |L1.1406|
00057e  68b0              LDR      r0,[r6,#8]            ;596
000580  2801              CMP      r0,#1                 ;596
000582  d903              BLS      |L1.1420|
000584  7aa8              LDRB     r0,[r5,#0xa]          ;596
000586  b908              CBNZ     r0,|L1.1420|
000588  bf00              NOP                            ;597
00058a  bf00              NOP                            ;597
                  |L1.1420|
00058c  68b0              LDR      r0,[r6,#8]            ;601
00058e  2801              CMP      r0,#1                 ;601
000590  d904              BLS      |L1.1436|
000592  7aa8              LDRB     r0,[r5,#0xa]          ;601
000594  28ff              CMP      r0,#0xff              ;601
000596  d101              BNE      |L1.1436|
000598  bf00              NOP                            ;602
00059a  bf00              NOP                            ;602
                  |L1.1436|
00059c  bf00              NOP      
00059e  e7bf              B        |L1.1312|
;;;606    
                          ENDP

                  yaffs_GetChunkGroupBase PROC
;;;1388   
;;;1389   static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos)
0005a0  e92d41f0          PUSH     {r4-r8,lr}
;;;1390   {
0005a4  4603              MOV      r3,r0
0005a6  460c              MOV      r4,r1
;;;1391     __u32 *map = (__u32 *)tn;
0005a8  4626              MOV      r6,r4
;;;1392     __u32 bitInMap;
;;;1393     __u32 bitInWord;
;;;1394     __u32 wordInMap;
;;;1395     __u32 val;
;;;1396     
;;;1397     pos &= YAFFS_TNODES_LEVEL0_MASK;
0005aa  f002020f          AND      r2,r2,#0xf
;;;1398     
;;;1399     bitInMap = pos * dev->tnodeWidth;
0005ae  f8d3c078          LDR      r12,[r3,#0x78]
0005b2  fb0cf702          MUL      r7,r12,r2
;;;1400     wordInMap = bitInMap /32;
0005b6  097d              LSRS     r5,r7,#5
;;;1401     bitInWord = bitInMap & (32 -1);
0005b8  f007011f          AND      r1,r7,#0x1f
;;;1402     
;;;1403     val = map[wordInMap] >> bitInWord;
0005bc  f856c025          LDR      r12,[r6,r5,LSL #2]
0005c0  fa2cf001          LSR      r0,r12,r1
;;;1404     
;;;1405     if(dev->tnodeWidth > (32-bitInWord)) {
0005c4  f1c10820          RSB      r8,r1,#0x20
0005c8  f8d3c078          LDR      r12,[r3,#0x78]
0005cc  45c4              CMP      r12,r8
0005ce  d908              BLS      |L1.1506|
;;;1406       bitInWord = (32 - bitInWord);
0005d0  f1c10120          RSB      r1,r1,#0x20
;;;1407       wordInMap++;;
0005d4  1c6d              ADDS     r5,r5,#1
;;;1408       val |= (map[wordInMap] << bitInWord);
0005d6  f856c025          LDR      r12,[r6,r5,LSL #2]
0005da  fa0cfc01          LSL      r12,r12,r1
0005de  ea4c0000          ORR      r0,r12,r0
                  |L1.1506|
;;;1409     }
;;;1410     
;;;1411     val &= dev->tnodeMask;
0005e2  f8d3c07c          LDR      r12,[r3,#0x7c]
0005e6  ea0c0000          AND      r0,r12,r0
;;;1412     val <<= dev->chunkGroupBits;
0005ea  f893c072          LDRB     r12,[r3,#0x72]
0005ee  fa00f00c          LSL      r0,r0,r12
;;;1413     
;;;1414     return val;
;;;1415   }
0005f2  e8bd81f0          POP      {r4-r8,pc}
;;;1416   
                          ENDP

                  yaffs_VerifyTnodeWorker PROC
;;;608    
;;;609    static int yaffs_VerifyTnodeWorker(yaffs_Object * obj, yaffs_Tnode * tn,
0005f6  e92d4ff0          PUSH     {r4-r11,lr}
;;;610    				  	__u32 level, int chunkOffset)
;;;611    {
0005fa  b093              SUB      sp,sp,#0x4c
0005fc  4680              MOV      r8,r0
0005fe  460e              MOV      r6,r1
000600  4617              MOV      r7,r2
000602  461d              MOV      r5,r3
;;;612    	int i;
;;;613    	yaffs_Device *dev = obj->myDev;
000604  f8d80008          LDR      r0,[r8,#8]
000608  9012              STR      r0,[sp,#0x48]
;;;614    	int ok = 1;
00060a  f04f0901          MOV      r9,#1
;;;615    
;;;616    	if (tn) {
00060e  2e00              CMP      r6,#0
000610  d037              BEQ      |L1.1666|
;;;617    		if (level > 0) {
000612  b1a7              CBZ      r7,|L1.1598|
;;;618    
;;;619    			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){
000614  2400              MOVS     r4,#0
000616  e00c              B        |L1.1586|
                  |L1.1560|
;;;620    				if (tn->internal[i]) {
000618  f8560024          LDR      r0,[r6,r4,LSL #2]
00061c  b140              CBZ      r0,|L1.1584|
;;;621    					ok = yaffs_VerifyTnodeWorker(obj,
00061e  eb0403c5          ADD      r3,r4,r5,LSL #3
000622  1e7a              SUBS     r2,r7,#1
000624  f8561024          LDR      r1,[r6,r4,LSL #2]
000628  4640              MOV      r0,r8
00062a  f7fffffe          BL       yaffs_VerifyTnodeWorker
00062e  4681              MOV      r9,r0
                  |L1.1584|
000630  1c64              ADDS     r4,r4,#1              ;619
                  |L1.1586|
000632  2c08              CMP      r4,#8                 ;619
000634  da25              BGE      |L1.1666|
000636  f1b90f00          CMP      r9,#0                 ;619
00063a  d1ed              BNE      |L1.1560|
00063c  e021              B        |L1.1666|
                  |L1.1598|
;;;622    							tn->internal[i],
;;;623    							level - 1,
;;;624    							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
;;;625    				}
;;;626    			}
;;;627    		} else if (level == 0) {
00063e  bb07              CBNZ     r7,|L1.1666|
;;;628    			yaffs_ExtendedTags tags;
;;;629    			__u32 objectId = obj->objectId;
000640  f8d8b030          LDR      r11,[r8,#0x30]
;;;630    			
;;;631    			chunkOffset <<=  YAFFS_TNODES_LEVEL0_BITS;
000644  012d              LSLS     r5,r5,#4
;;;632    			
;;;633    			for(i = 0; i < YAFFS_NTNODES_LEVEL0; i++){
000646  2400              MOVS     r4,#0
000648  e018              B        |L1.1660|
                  |L1.1610|
;;;634    				__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
00064a  4622              MOV      r2,r4
00064c  4631              MOV      r1,r6
00064e  9812              LDR      r0,[sp,#0x48]
000650  f7fffffe          BL       yaffs_GetChunkGroupBase
000654  4682              MOV      r10,r0
;;;635    				
;;;636    				if(theChunk > 0){
000656  f1ba0f00          CMP      r10,#0
00065a  d00d              BEQ      |L1.1656|
;;;637    					/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),tags.objectId,tags.chunkId,theChunk)); */
;;;638    					yaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);
00065c  466b              MOV      r3,sp
00065e  2200              MOVS     r2,#0
000660  4651              MOV      r1,r10
000662  9812              LDR      r0,[sp,#0x48]
000664  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
;;;639    					if(tags.objectId != objectId || tags.chunkId != chunkOffset){
000668  9802              LDR      r0,[sp,#8]
00066a  4558              CMP      r0,r11
00066c  d102              BNE      |L1.1652|
00066e  9803              LDR      r0,[sp,#0xc]
000670  42a8              CMP      r0,r5
000672  d001              BEQ      |L1.1656|
                  |L1.1652|
;;;640    						T(~0,(TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
000674  bf00              NOP      
000676  bf00              NOP      
                  |L1.1656|
;;;641    							objectId, chunkOffset, theChunk,
;;;642    							tags.objectId, tags.chunkId));
;;;643    					}
;;;644    				}
;;;645    				chunkOffset++;
000678  1c6d              ADDS     r5,r5,#1
00067a  1c64              ADDS     r4,r4,#1              ;633
                  |L1.1660|
00067c  2c10              CMP      r4,#0x10              ;633
00067e  dbe4              BLT      |L1.1610|
;;;646    			}
;;;647    		}
000680  bf00              NOP      
                  |L1.1666|
;;;648    	}
;;;649    
;;;650    	return ok;
000682  4648              MOV      r0,r9
;;;651    
;;;652    }
000684  b013              ADD      sp,sp,#0x4c
000686  e8bd8ff0          POP      {r4-r11,pc}
;;;653    
                          ENDP

                  yaffs_FindLevel0Tnode PROC
;;;1424   /* FindLevel0Tnode finds the level 0 tnode, if one exists. */
;;;1425   static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device * dev,
00068a  b5f0              PUSH     {r4-r7,lr}
;;;1426   					  yaffs_FileStructure * fStruct,
;;;1427   					  __u32 chunkId)
;;;1428   {
00068c  4607              MOV      r7,r0
00068e  460b              MOV      r3,r1
;;;1429   
;;;1430   	yaffs_Tnode *tn = fStruct->top;
000690  691c              LDR      r4,[r3,#0x10]
;;;1431   	__u32 i;
;;;1432   	int requiredTallness;
;;;1433   	int level = fStruct->topLevel;
000692  68d9              LDR      r1,[r3,#0xc]
;;;1434   
;;;1435   	/* Check sane level and chunk Id */
;;;1436   	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL) {
000694  2900              CMP      r1,#0
000696  db01              BLT      |L1.1692|
000698  2906              CMP      r1,#6
00069a  dd01              BLE      |L1.1696|
                  |L1.1692|
;;;1437   		return NULL;
00069c  2000              MOVS     r0,#0
                  |L1.1694|
;;;1438   	}
;;;1439   
;;;1440   	if (chunkId > YAFFS_MAX_CHUNK_ID) {
;;;1441   		return NULL;
;;;1442   	}
;;;1443   
;;;1444   	/* First check we're tall enough (ie enough topLevel) */
;;;1445   
;;;1446   	i = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
;;;1447   	requiredTallness = 0;
;;;1448   	while (i) {
;;;1449   		i >>= YAFFS_TNODES_INTERNAL_BITS;
;;;1450   		requiredTallness++;
;;;1451   	}
;;;1452   
;;;1453   	if (requiredTallness > fStruct->topLevel) {
;;;1454   		/* Not tall enough, so we can't find it, return NULL. */
;;;1455   		return NULL;
;;;1456   	}
;;;1457   
;;;1458   	/* Traverse down to level 0 */
;;;1459   	while (level > 0 && tn) {
;;;1460   		tn = tn->
;;;1461   		    internal[(chunkId >>
;;;1462   			       ( YAFFS_TNODES_LEVEL0_BITS + 
;;;1463   			         (level - 1) *
;;;1464   			         YAFFS_TNODES_INTERNAL_BITS)
;;;1465   			      ) &
;;;1466   			     YAFFS_TNODES_INTERNAL_MASK];
;;;1467   		level--;
;;;1468   
;;;1469   	}
;;;1470   
;;;1471   	return tn;
;;;1472   }
00069e  bdf0              POP      {r4-r7,pc}
                  |L1.1696|
0006a0  f5b21f80          CMP      r2,#0x100000          ;1440
0006a4  d301              BCC      |L1.1706|
0006a6  2000              MOVS     r0,#0                 ;1441
0006a8  e7f9              B        |L1.1694|
                  |L1.1706|
0006aa  0915              LSRS     r5,r2,#4              ;1446
0006ac  2600              MOVS     r6,#0                 ;1447
0006ae  e001              B        |L1.1716|
                  |L1.1712|
0006b0  08ed              LSRS     r5,r5,#3              ;1449
0006b2  1c76              ADDS     r6,r6,#1              ;1450
                  |L1.1716|
0006b4  2d00              CMP      r5,#0                 ;1448
0006b6  d1fb              BNE      |L1.1712|
0006b8  68d8              LDR      r0,[r3,#0xc]          ;1453
0006ba  42b0              CMP      r0,r6                 ;1453
0006bc  da01              BGE      |L1.1730|
0006be  2000              MOVS     r0,#0                 ;1455
0006c0  e7ed              B        |L1.1694|
                  |L1.1730|
0006c2  e00a              B        |L1.1754|
                  |L1.1732|
0006c4  1e48              SUBS     r0,r1,#1              ;1460
0006c6  eb000040          ADD      r0,r0,r0,LSL #1       ;1460
0006ca  1d00              ADDS     r0,r0,#4              ;1460
0006cc  fa22f000          LSR      r0,r2,r0              ;1460
0006d0  f0000007          AND      r0,r0,#7              ;1460
0006d4  f8544020          LDR      r4,[r4,r0,LSL #2]     ;1460
0006d8  1e49              SUBS     r1,r1,#1              ;1467
                  |L1.1754|
0006da  2900              CMP      r1,#0                 ;1459
0006dc  dd01              BLE      |L1.1762|
0006de  2c00              CMP      r4,#0                 ;1459
0006e0  d1f0              BNE      |L1.1732|
                  |L1.1762|
0006e2  4620              MOV      r0,r4                 ;1471
0006e4  e7db              B        |L1.1694|
;;;1473   
                          ENDP

                  yaffs_VerifyFile PROC
;;;654    
;;;655    static void yaffs_VerifyFile(yaffs_Object *obj)
0006e6  e92d4ff0          PUSH     {r4-r11,lr}
;;;656    {
0006ea  b095              SUB      sp,sp,#0x54
0006ec  4604              MOV      r4,r0
;;;657    	int requiredTallness;
;;;658    	int actualTallness;
;;;659    	__u32 lastChunk;
;;;660    	__u32 x;
;;;661    	__u32 i;
;;;662    	yaffs_Device *dev;
;;;663    	yaffs_ExtendedTags tags;
;;;664    	yaffs_Tnode *tn;
;;;665    	__u32 objectId;
;;;666    	
;;;667    	if(!obj)
0006ee  b914              CBNZ     r4,|L1.1782|
                  |L1.1776|
;;;668    		return;
;;;669    
;;;670    	if(yaffs_SkipVerification(obj->myDev))
;;;671    		return;
;;;672    	
;;;673    	dev = obj->myDev;
;;;674    	objectId = obj->objectId;
;;;675    	
;;;676    	/* Check file size is consistent with tnode depth */
;;;677    	lastChunk =  obj->variant.fileVariant.fileSize / dev->nDataBytesPerChunk + 1;
;;;678    	x = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;
;;;679    	requiredTallness = 0;
;;;680    	while (x> 0) {
;;;681    		x >>= YAFFS_TNODES_INTERNAL_BITS;
;;;682    		requiredTallness++;
;;;683    	}
;;;684    	
;;;685    	actualTallness = obj->variant.fileVariant.topLevel;
;;;686    	
;;;687    	if(requiredTallness > actualTallness )
;;;688    		T(YAFFS_TRACE_VERIFY,
;;;689    		(TSTR("Obj %d had tnode tallness %d, needs to be %d"TENDSTR),
;;;690    		 obj->objectId,actualTallness, requiredTallness));
;;;691    	
;;;692    	
;;;693    	/* Check that the chunks in the tnode tree are all correct. 
;;;694    	 * We do this by scanning through the tnode tree and
;;;695    	 * checking the tags for every chunk match.
;;;696    	 */
;;;697    
;;;698    	if(yaffs_SkipNANDVerification(dev))
;;;699    		return;
;;;700    		
;;;701    	for(i = 1; i <= lastChunk; i++){
;;;702    		tn = yaffs_FindLevel0Tnode(dev, &obj->variant.fileVariant,i);
;;;703    
;;;704    		if (tn) {
;;;705    			__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
;;;706    			if(theChunk > 0){
;;;707    				/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),objectId,i,theChunk)); */
;;;708    				yaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);
;;;709    				if(tags.objectId != objectId || tags.chunkId != i){
;;;710    					T(~0,(TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
;;;711    						objectId, i, theChunk,
;;;712    						tags.objectId, tags.chunkId));
;;;713    				}
;;;714    			}
;;;715    		}
;;;716    
;;;717    	}
;;;718    
;;;719    }
0006f0  b015              ADD      sp,sp,#0x54
0006f2  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1782|
0006f6  68a0              LDR      r0,[r4,#8]            ;670
0006f8  f7fffffe          BL       yaffs_SkipVerification
0006fc  b100              CBZ      r0,|L1.1792|
0006fe  e7f7              B        |L1.1776|
                  |L1.1792|
000700  f8d4a008          LDR      r10,[r4,#8]           ;673
000704  6b20              LDR      r0,[r4,#0x30]         ;674
000706  9001              STR      r0,[sp,#4]            ;674
000708  6da0              LDR      r0,[r4,#0x58]         ;677
00070a  f8da100c          LDR      r1,[r10,#0xc]         ;677
00070e  fbb0f0f1          UDIV     r0,r0,r1              ;677
000712  f1000801          ADD      r8,r0,#1              ;677
000716  ea4f1918          LSR      r9,r8,#4              ;678
00071a  2700              MOVS     r7,#0                 ;679
00071c  e007              B        |L1.1838|
00071e  0000              DCW      0x0000
                  |L1.1824|
                          DCD      yaffs_traceMask
                  |L1.1828|
                          DCD      0x00989680
                  |L1.1832|
000728  ea4f09d9          LSR      r9,r9,#3              ;681
00072c  1c7f              ADDS     r7,r7,#1              ;682
                  |L1.1838|
00072e  f1b90f00          CMP      r9,#0                 ;680
000732  d1f9              BNE      |L1.1832|
000734  6e60              LDR      r0,[r4,#0x64]         ;685
000736  9014              STR      r0,[sp,#0x50]         ;685
000738  9814              LDR      r0,[sp,#0x50]         ;687
00073a  4287              CMP      r7,r0                 ;687
00073c  dd01              BLE      |L1.1858|
00073e  bf00              NOP                            ;688
000740  bf00              NOP                            ;688
                  |L1.1858|
000742  4650              MOV      r0,r10                ;698
000744  f7fffffe          BL       yaffs_SkipNANDVerification
000748  b100              CBZ      r0,|L1.1868|
00074a  e7d1              B        |L1.1776|
                  |L1.1868|
00074c  2501              MOVS     r5,#1                 ;701
00074e  e021              B        |L1.1940|
                  |L1.1872|
000750  462a              MOV      r2,r5                 ;702
000752  f1040158          ADD      r1,r4,#0x58           ;702
000756  4650              MOV      r0,r10                ;702
000758  f7fffffe          BL       yaffs_FindLevel0Tnode
00075c  4606              MOV      r6,r0                 ;702
00075e  b1c6              CBZ      r6,|L1.1938|
000760  462a              MOV      r2,r5                 ;705
000762  4631              MOV      r1,r6                 ;705
000764  4650              MOV      r0,r10                ;705
000766  f7fffffe          BL       yaffs_GetChunkGroupBase
00076a  4683              MOV      r11,r0                ;705
00076c  f1bb0f00          CMP      r11,#0                ;706
000770  d00e              BEQ      |L1.1936|
000772  ab02              ADD      r3,sp,#8              ;708
000774  2200              MOVS     r2,#0                 ;708
000776  4659              MOV      r1,r11                ;708
000778  4650              MOV      r0,r10                ;708
00077a  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
00077e  9904              LDR      r1,[sp,#0x10]         ;709
000780  9801              LDR      r0,[sp,#4]            ;709
000782  4281              CMP      r1,r0                 ;709
000784  d102              BNE      |L1.1932|
000786  9805              LDR      r0,[sp,#0x14]         ;709
000788  42a8              CMP      r0,r5                 ;709
00078a  d001              BEQ      |L1.1936|
                  |L1.1932|
00078c  bf00              NOP                            ;710
00078e  bf00              NOP                            ;710
                  |L1.1936|
000790  bf00              NOP                            ;715
                  |L1.1938|
000792  1c6d              ADDS     r5,r5,#1              ;701
                  |L1.1940|
000794  4545              CMP      r5,r8                 ;701
000796  d9db              BLS      |L1.1872|
000798  bf00              NOP      
00079a  e7a9              B        |L1.1776|
;;;720    
                          ENDP

                  yaffs_VerifyHardLink PROC
;;;721    
;;;722    static void yaffs_VerifyHardLink(yaffs_Object *obj)
00079c  b510              PUSH     {r4,lr}
;;;723    {
00079e  4604              MOV      r4,r0
;;;724    	if(obj && yaffs_SkipVerification(obj->myDev))
0007a0  b124              CBZ      r4,|L1.1964|
0007a2  68a0              LDR      r0,[r4,#8]
0007a4  f7fffffe          BL       yaffs_SkipVerification
0007a8  b100              CBZ      r0,|L1.1964|
                  |L1.1962|
;;;725    		return;
;;;726    		
;;;727    	/* Verify sane equivalent object */
;;;728    }
0007aa  bd10              POP      {r4,pc}
                  |L1.1964|
0007ac  bf00              NOP      
0007ae  e7fc              B        |L1.1962|
;;;729    
                          ENDP

                  yaffs_VerifySymlink PROC
;;;730    static void yaffs_VerifySymlink(yaffs_Object *obj)
0007b0  b510              PUSH     {r4,lr}
;;;731    {
0007b2  4604              MOV      r4,r0
;;;732    	if(obj && yaffs_SkipVerification(obj->myDev))
0007b4  b124              CBZ      r4,|L1.1984|
0007b6  68a0              LDR      r0,[r4,#8]
0007b8  f7fffffe          BL       yaffs_SkipVerification
0007bc  b100              CBZ      r0,|L1.1984|
                  |L1.1982|
;;;733    		return;
;;;734    		
;;;735    	/* Verify symlink string */
;;;736    }
0007be  bd10              POP      {r4,pc}
                  |L1.1984|
0007c0  bf00              NOP      
0007c2  e7fc              B        |L1.1982|
;;;737    
                          ENDP

                  yaffs_VerifySpecial PROC
;;;738    static void yaffs_VerifySpecial(yaffs_Object *obj)
0007c4  b510              PUSH     {r4,lr}
;;;739    {
0007c6  4604              MOV      r4,r0
;;;740    	if(obj && yaffs_SkipVerification(obj->myDev))
0007c8  b124              CBZ      r4,|L1.2004|
0007ca  68a0              LDR      r0,[r4,#8]
0007cc  f7fffffe          BL       yaffs_SkipVerification
0007d0  b100              CBZ      r0,|L1.2004|
                  |L1.2002|
;;;741    		return;
;;;742    }
0007d2  bd10              POP      {r4,pc}
                  |L1.2004|
0007d4  bf00              NOP      
0007d6  e7fc              B        |L1.2002|
;;;743    
                          ENDP

                  yaffs_VerifyObjectInDirectory PROC
;;;6735   
;;;6736   static void yaffs_VerifyObjectInDirectory(yaffs_Object *obj)
0007d8  e92d41f0          PUSH     {r4-r8,lr}
;;;6737   {
0007dc  4604              MOV      r4,r0
;;;6738           struct ylist_head *lh;
;;;6739           yaffs_Object *listObj;
;;;6740           
;;;6741           int count = 0;
0007de  2700              MOVS     r7,#0
;;;6742   
;;;6743   	if(!obj){
0007e0  b90c              CBNZ     r4,|L1.2022|
;;;6744   		T(YAFFS_TRACE_ALWAYS, (TSTR("No object to verify" TENDSTR)));
0007e2  bf00              NOP      
0007e4  bf00              NOP      
                  |L1.2022|
;;;6745   		YBUG();
;;;6746   	}
;;;6747   
;;;6748           if(yaffs_SkipVerification(obj->myDev))
0007e6  68a0              LDR      r0,[r4,#8]
0007e8  f7fffffe          BL       yaffs_SkipVerification
0007ec  b108              CBZ      r0,|L1.2034|
                  |L1.2030|
;;;6749                   return;
;;;6750   
;;;6751   	if(!obj->parent){
;;;6752   		T(YAFFS_TRACE_ALWAYS, (TSTR("Object does not have parent" TENDSTR)));
;;;6753   		YBUG();
;;;6754   	}
;;;6755   		
;;;6756   	if(obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
;;;6757   		T(YAFFS_TRACE_ALWAYS, (TSTR("Parent is not directory" TENDSTR)));
;;;6758   		YBUG();
;;;6759   	}
;;;6760   	
;;;6761           /* Iterate through the objects in each hash entry */
;;;6762            
;;;6763           ylist_for_each(lh, &obj->parent->variant.directoryVariant.children) {
;;;6764   		if (lh) {
;;;6765                           listObj = ylist_entry(lh, yaffs_Object, siblings);
;;;6766   			yaffs_VerifyObject(listObj);
;;;6767   			if(obj == listObj)
;;;6768   				count ++;
;;;6769                   }
;;;6770   	 }
;;;6771   	 
;;;6772   	 if(count != 1){
;;;6773   		T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory %d times" TENDSTR),count));
;;;6774   		YBUG();
;;;6775   	}
;;;6776   
;;;6777   }
0007ee  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2034|
0007f2  69e0              LDR      r0,[r4,#0x1c]         ;6751
0007f4  b908              CBNZ     r0,|L1.2042|
0007f6  bf00              NOP                            ;6752
0007f8  bf00              NOP                            ;6752
                  |L1.2042|
0007fa  69e0              LDR      r0,[r4,#0x1c]         ;6756
0007fc  f8900054          LDRB     r0,[r0,#0x54]         ;6756
000800  2803              CMP      r0,#3                 ;6756
000802  d001              BEQ      |L1.2056|
000804  bf00              NOP                            ;6757
000806  bf00              NOP                            ;6757
                  |L1.2056|
000808  69e0              LDR      r0,[r4,#0x1c]         ;6763
00080a  6d85              LDR      r5,[r0,#0x58]         ;6763
00080c  e009              B        |L1.2082|
                  |L1.2062|
00080e  b13d              CBZ      r5,|L1.2080|
000810  f1a50620          SUB      r6,r5,#0x20           ;6765
000814  4630              MOV      r0,r6                 ;6766
000816  f7fffffe          BL       yaffs_VerifyObject
00081a  42b4              CMP      r4,r6                 ;6767
00081c  d100              BNE      |L1.2080|
00081e  1c7f              ADDS     r7,r7,#1              ;6768
                  |L1.2080|
000820  682d              LDR      r5,[r5,#0]            ;6763
                  |L1.2082|
000822  69e0              LDR      r0,[r4,#0x1c]         ;6763
000824  3058              ADDS     r0,r0,#0x58           ;6763
000826  42a8              CMP      r0,r5                 ;6763
000828  d1f1              BNE      |L1.2062|
00082a  2f01              CMP      r7,#1                 ;6772
00082c  d001              BEQ      |L1.2098|
00082e  bf00              NOP                            ;6773
000830  bf00              NOP                            ;6773
                  |L1.2098|
000832  bf00              NOP      
000834  e7db              B        |L1.2030|
;;;6778   
                          ENDP

                  yaffs_VerifyDirectory PROC
;;;6779   static void yaffs_VerifyDirectory(yaffs_Object *directory)
000836  b570              PUSH     {r4-r6,lr}
;;;6780   {
000838  4604              MOV      r4,r0
;;;6781   
;;;6782           struct ylist_head *lh;
;;;6783           yaffs_Object *listObj;
;;;6784           
;;;6785   	if(!directory)
;;;6786   		YBUG();
;;;6787   
;;;6788           if(yaffs_SkipFullVerification(directory->myDev))
00083a  68a0              LDR      r0,[r4,#8]
00083c  f7fffffe          BL       yaffs_SkipFullVerification
000840  b100              CBZ      r0,|L1.2116|
                  |L1.2114|
;;;6789                   return;
;;;6790   
;;;6791   		
;;;6792   	if(directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
;;;6793   		T(YAFFS_TRACE_ALWAYS, (TSTR("Directory has wrong type: %d" TENDSTR),directory->variantType));
;;;6794   		YBUG();
;;;6795   	}
;;;6796   	
;;;6797           /* Iterate through the objects in each hash entry */
;;;6798            
;;;6799           ylist_for_each(lh, &directory->variant.directoryVariant.children) {
;;;6800   		if (lh) {
;;;6801                           listObj = ylist_entry(lh, yaffs_Object, siblings);
;;;6802   			if(listObj->parent != directory){
;;;6803   				T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory list has wrong parent %p" TENDSTR),listObj->parent));
;;;6804   				YBUG();
;;;6805   			}
;;;6806   			yaffs_VerifyObjectInDirectory(listObj);
;;;6807                   }
;;;6808   	 }
;;;6809   	 
;;;6810   }
000842  bd70              POP      {r4-r6,pc}
                  |L1.2116|
000844  f8940054          LDRB     r0,[r4,#0x54]         ;6792
000848  2803              CMP      r0,#3                 ;6792
00084a  d001              BEQ      |L1.2128|
00084c  bf00              NOP                            ;6793
00084e  bf00              NOP                            ;6793
                  |L1.2128|
000850  6da5              LDR      r5,[r4,#0x58]         ;6799
000852  e00b              B        |L1.2156|
                  |L1.2132|
000854  b14d              CBZ      r5,|L1.2154|
000856  f1a50620          SUB      r6,r5,#0x20           ;6801
00085a  69f0              LDR      r0,[r6,#0x1c]         ;6802
00085c  42a0              CMP      r0,r4                 ;6802
00085e  d001              BEQ      |L1.2148|
000860  bf00              NOP                            ;6803
000862  bf00              NOP                            ;6803
                  |L1.2148|
000864  4630              MOV      r0,r6                 ;6806
000866  f7fffffe          BL       yaffs_VerifyObjectInDirectory
                  |L1.2154|
00086a  682d              LDR      r5,[r5,#0]            ;6799
                  |L1.2156|
00086c  f1040058          ADD      r0,r4,#0x58           ;6799
000870  4285              CMP      r5,r0                 ;6799
000872  d1ef              BNE      |L1.2132|
000874  bf00              NOP      
000876  e7e4              B        |L1.2114|
;;;6811   
                          ENDP

                  yaffs_VerifyObject PROC
;;;743    
;;;744    static void yaffs_VerifyObject(yaffs_Object *obj)
000878  e92d4ff0          PUSH     {r4-r11,lr}
;;;745    {
00087c  b095              SUB      sp,sp,#0x54
00087e  4604              MOV      r4,r0
;;;746    	yaffs_Device *dev;
;;;747    	
;;;748    	__u32 chunkMin;
;;;749    	__u32 chunkMax;
;;;750    	
;;;751    	__u32 chunkIdOk;
;;;752    	__u32 chunkInRange;
;;;753    	__u32 chunkShouldNotBeDeleted;
;;;754    	__u32 chunkValid; 
;;;755    	
;;;756    	if(!obj)
000880  b914              CBNZ     r4,|L1.2184|
                  |L1.2178|
;;;757    		return;
;;;758    		
;;;759    	if(obj->beingCreated)
;;;760    		return;
;;;761    	
;;;762    	dev = obj->myDev;
;;;763    	
;;;764    	if(yaffs_SkipVerification(dev))
;;;765    		return;
;;;766    		
;;;767    	/* Check sane object header chunk */
;;;768    
;;;769    	chunkMin = dev->internalStartBlock * dev->nChunksPerBlock;
;;;770    	chunkMax = (dev->internalEndBlock+1) * dev->nChunksPerBlock - 1;
;;;771    
;;;772    	chunkInRange = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);
;;;773    	chunkIdOk = chunkInRange || obj->hdrChunk == 0;
;;;774    	chunkValid  =  chunkInRange &&
;;;775    			yaffs_CheckChunkBit(dev,
;;;776    					    obj->hdrChunk / dev->nChunksPerBlock,
;;;777    					    obj->hdrChunk % dev->nChunksPerBlock);
;;;778    	chunkShouldNotBeDeleted = chunkInRange && !chunkValid;
;;;779    
;;;780    	if(!obj->fake &&
;;;781    	    (!chunkIdOk || chunkShouldNotBeDeleted)) {
;;;782    	   T(YAFFS_TRACE_VERIFY,
;;;783    	   (TSTR("Obj %d has chunkId %d %s %s"TENDSTR),
;;;784    	   obj->objectId,obj->hdrChunk,
;;;785    	   chunkIdOk ? "" : ",out of range",
;;;786    	   chunkShouldNotBeDeleted ? ",marked as deleted" : ""));
;;;787    	}
;;;788    	
;;;789    	if(chunkValid &&!yaffs_SkipNANDVerification(dev)) {
;;;790    		yaffs_ExtendedTags tags;
;;;791    		yaffs_ObjectHeader *oh;
;;;792    		__u8 *buffer = yaffs_GetTempBuffer(dev,__LINE__);
;;;793    		
;;;794    		oh = (yaffs_ObjectHeader *)buffer;
;;;795    
;;;796    		yaffs_ReadChunkWithTagsFromNAND(dev, obj->hdrChunk,buffer, &tags);
;;;797    
;;;798    		yaffs_VerifyObjectHeader(obj,oh,&tags,1);
;;;799    		
;;;800    		yaffs_ReleaseTempBuffer(dev,buffer,__LINE__);
;;;801    	}
;;;802    	
;;;803    	/* Verify it has a parent */
;;;804    	if(obj && !obj->fake &&
;;;805    	   (!obj->parent || obj->parent->myDev != dev)){
;;;806    	   T(YAFFS_TRACE_VERIFY,
;;;807    	   (TSTR("Obj %d has parent pointer %p which does not look like an object"TENDSTR),
;;;808    	   obj->objectId,obj->parent));	   
;;;809    	}
;;;810    	
;;;811    	/* Verify parent is a directory */
;;;812    	if(obj->parent && obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
;;;813    	   T(YAFFS_TRACE_VERIFY,
;;;814    	   (TSTR("Obj %d's parent is not a directory (type %d)"TENDSTR),
;;;815    	   obj->objectId,obj->parent->variantType));	   
;;;816    	}
;;;817    	
;;;818    	switch(obj->variantType){
;;;819    	case YAFFS_OBJECT_TYPE_FILE:
;;;820    		yaffs_VerifyFile(obj);
;;;821    		break;
;;;822    	case YAFFS_OBJECT_TYPE_SYMLINK:
;;;823    		yaffs_VerifySymlink(obj);
;;;824    		break;
;;;825    	case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;826    		yaffs_VerifyDirectory(obj);
;;;827    		break;
;;;828    	case YAFFS_OBJECT_TYPE_HARDLINK:
;;;829    		yaffs_VerifyHardLink(obj);
;;;830    		break;
;;;831    	case YAFFS_OBJECT_TYPE_SPECIAL:
;;;832    		yaffs_VerifySpecial(obj);
;;;833    		break;
;;;834    	case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;835    	default:
;;;836    		T(YAFFS_TRACE_VERIFY,
;;;837    		(TSTR("Obj %d has illegaltype %d"TENDSTR),
;;;838    		obj->objectId,obj->variantType));	   
;;;839    		break;
;;;840    	}
;;;841    	
;;;842    	
;;;843    }
000882  b015              ADD      sp,sp,#0x54
000884  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2184|
000888  7860              LDRB     r0,[r4,#1]            ;759
00088a  f3c00080          UBFX     r0,r0,#2,#1           ;759
00088e  b100              CBZ      r0,|L1.2194|
000890  e7f7              B        |L1.2178|
                  |L1.2194|
000892  68a5              LDR      r5,[r4,#8]            ;762
000894  4628              MOV      r0,r5                 ;764
000896  f7fffffe          BL       yaffs_SkipVerification
00089a  b100              CBZ      r0,|L1.2206|
00089c  e7f1              B        |L1.2178|
                  |L1.2206|
00089e  6929              LDR      r1,[r5,#0x10]         ;769
0008a0  f8d5009c          LDR      r0,[r5,#0x9c]         ;769
0008a4  fb00f801          MUL      r8,r0,r1              ;769
0008a8  f8d500a0          LDR      r0,[r5,#0xa0]         ;770
0008ac  1c40              ADDS     r0,r0,#1              ;770
0008ae  6929              LDR      r1,[r5,#0x10]         ;770
0008b0  4348              MULS     r0,r1,r0              ;770
0008b2  f1a00901          SUB      r9,r0,#1              ;770
0008b6  6aa0              LDR      r0,[r4,#0x28]         ;772
0008b8  4540              CMP      r0,r8                 ;772
0008ba  d304              BCC      |L1.2246|
0008bc  6aa0              LDR      r0,[r4,#0x28]         ;772
0008be  4548              CMP      r0,r9                 ;772
0008c0  d801              BHI      |L1.2246|
0008c2  2001              MOVS     r0,#1                 ;772
0008c4  e000              B        |L1.2248|
                  |L1.2246|
0008c6  2000              MOVS     r0,#0                 ;772
                  |L1.2248|
0008c8  4606              MOV      r6,r0                 ;772
0008ca  b90e              CBNZ     r6,|L1.2256|
0008cc  6aa0              LDR      r0,[r4,#0x28]         ;773
0008ce  b908              CBNZ     r0,|L1.2260|
                  |L1.2256|
0008d0  2001              MOVS     r0,#1                 ;773
0008d2  e000              B        |L1.2262|
                  |L1.2260|
0008d4  2000              MOVS     r0,#0                 ;773
                  |L1.2262|
0008d6  9014              STR      r0,[sp,#0x50]         ;773
0008d8  b17e              CBZ      r6,|L1.2298|
0008da  6aa0              LDR      r0,[r4,#0x28]         ;775
0008dc  6929              LDR      r1,[r5,#0x10]         ;775
0008de  fb90f2f1          SDIV     r2,r0,r1              ;775
0008e2  fb010712          MLS      r7,r1,r2,r0           ;775
0008e6  fb90fbf1          SDIV     r11,r0,r1             ;775
0008ea  463a              MOV      r2,r7                 ;775
0008ec  4659              MOV      r1,r11                ;775
0008ee  4628              MOV      r0,r5                 ;775
0008f0  f7fffffe          BL       yaffs_CheckChunkBit
0008f4  b108              CBZ      r0,|L1.2298|
0008f6  2001              MOVS     r0,#1                 ;775
0008f8  e000              B        |L1.2300|
                  |L1.2298|
0008fa  2000              MOVS     r0,#0                 ;775
                  |L1.2300|
0008fc  4682              MOV      r10,r0                ;775
0008fe  b126              CBZ      r6,|L1.2314|
000900  f1ba0f00          CMP      r10,#0                ;778
000904  d101              BNE      |L1.2314|
000906  2001              MOVS     r0,#1                 ;778
000908  e000              B        |L1.2316|
                  |L1.2314|
00090a  2000              MOVS     r0,#0                 ;778
                  |L1.2316|
00090c  9013              STR      r0,[sp,#0x4c]         ;778
00090e  7820              LDRB     r0,[r4,#0]            ;780
000910  f3c000c0          UBFX     r0,r0,#3,#1           ;780
000914  b928              CBNZ     r0,|L1.2338|
000916  9814              LDR      r0,[sp,#0x50]         ;781
000918  b108              CBZ      r0,|L1.2334|
00091a  9813              LDR      r0,[sp,#0x4c]         ;781
00091c  b108              CBZ      r0,|L1.2338|
                  |L1.2334|
00091e  bf00              NOP                            ;782
000920  bf00              NOP                            ;782
                  |L1.2338|
000922  f1ba0f00          CMP      r10,#0                ;789
000926  d01d              BEQ      |L1.2404|
000928  4628              MOV      r0,r5                 ;789
00092a  f7fffffe          BL       yaffs_SkipNANDVerification
00092e  b9c8              CBNZ     r0,|L1.2404|
000930  f44f7146          MOV      r1,#0x318             ;792
000934  4628              MOV      r0,r5                 ;792
000936  f7fffffe          BL       yaffs_GetTempBuffer
00093a  4607              MOV      r7,r0                 ;792
00093c  46bb              MOV      r11,r7                ;794
00093e  ab01              ADD      r3,sp,#4              ;796
000940  463a              MOV      r2,r7                 ;796
000942  4628              MOV      r0,r5                 ;796
000944  6aa1              LDR      r1,[r4,#0x28]         ;796
000946  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
00094a  2301              MOVS     r3,#1                 ;798
00094c  aa01              ADD      r2,sp,#4              ;798
00094e  4659              MOV      r1,r11                ;798
000950  4620              MOV      r0,r4                 ;798
000952  f7fffffe          BL       yaffs_VerifyObjectHeader
000956  f44f7248          MOV      r2,#0x320             ;800
00095a  4639              MOV      r1,r7                 ;800
00095c  4628              MOV      r0,r5                 ;800
00095e  f7fffffe          BL       yaffs_ReleaseTempBuffer
000962  bf00              NOP                            ;801
                  |L1.2404|
000964  b15c              CBZ      r4,|L1.2430|
000966  7820              LDRB     r0,[r4,#0]            ;804
000968  f3c000c0          UBFX     r0,r0,#3,#1           ;804
00096c  b938              CBNZ     r0,|L1.2430|
00096e  69e0              LDR      r0,[r4,#0x1c]         ;805
000970  b118              CBZ      r0,|L1.2426|
000972  69e0              LDR      r0,[r4,#0x1c]         ;805
000974  6880              LDR      r0,[r0,#8]            ;805
000976  42a8              CMP      r0,r5                 ;805
000978  d001              BEQ      |L1.2430|
                  |L1.2426|
00097a  bf00              NOP                            ;806
00097c  bf00              NOP                            ;806
                  |L1.2430|
00097e  69e0              LDR      r0,[r4,#0x1c]         ;812
000980  b130              CBZ      r0,|L1.2448|
000982  69e0              LDR      r0,[r4,#0x1c]         ;812
000984  f8900054          LDRB     r0,[r0,#0x54]         ;812
000988  2803              CMP      r0,#3                 ;812
00098a  d001              BEQ      |L1.2448|
00098c  bf00              NOP                            ;813
00098e  bf00              NOP                            ;813
                  |L1.2448|
000990  f8940054          LDRB     r0,[r4,#0x54]         ;818
000994  2806              CMP      r0,#6                 ;818
000996  d218              BCS      |L1.2506|
000998  e8dff000          TBB      [pc,r0]               ;818
00099c  1803070b          DCB      0x18,0x03,0x07,0x0b
0009a0  0f13              DCB      0x0f,0x13
0009a2  4620              MOV      r0,r4                 ;820
0009a4  f7fffffe          BL       yaffs_VerifyFile
0009a8  e013              B        |L1.2514|
0009aa  4620              MOV      r0,r4                 ;823
0009ac  f7fffffe          BL       yaffs_VerifySymlink
0009b0  e00f              B        |L1.2514|
0009b2  4620              MOV      r0,r4                 ;826
0009b4  f7fffffe          BL       yaffs_VerifyDirectory
0009b8  e00b              B        |L1.2514|
0009ba  4620              MOV      r0,r4                 ;829
0009bc  f7fffffe          BL       yaffs_VerifyHardLink
0009c0  e007              B        |L1.2514|
0009c2  4620              MOV      r0,r4                 ;832
0009c4  f7fffffe          BL       yaffs_VerifySpecial
0009c8  e003              B        |L1.2514|
                  |L1.2506|
0009ca  bf00              NOP                            ;834
0009cc  bf00              NOP                            ;836
0009ce  bf00              NOP                            ;836
0009d0  bf00              NOP                            ;839
                  |L1.2514|
0009d2  bf00              NOP                            ;821
0009d4  bf00              NOP      
0009d6  e754              B        |L1.2178|
;;;844    
                          ENDP

                  yaffs_VerifyObjects PROC
;;;845    static void yaffs_VerifyObjects(yaffs_Device *dev)
0009d8  e92d41f0          PUSH     {r4-r8,lr}
;;;846    {
0009dc  4606              MOV      r6,r0
;;;847            yaffs_Object *obj;
;;;848            int i;
;;;849            struct ylist_head *lh;
;;;850    
;;;851            if(yaffs_SkipVerification(dev))
0009de  4630              MOV      r0,r6
0009e0  f7fffffe          BL       yaffs_SkipVerification
0009e4  b108              CBZ      r0,|L1.2538|
                  |L1.2534|
;;;852                    return;
;;;853    	
;;;854            /* Iterate through the objects in each hash entry */
;;;855             
;;;856             for(i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++){
;;;857                    ylist_for_each(lh, &dev->objectBucket[i].list) {
;;;858                            if (lh) {
;;;859                                    obj = ylist_entry(lh, yaffs_Object, hashLink);
;;;860                                    yaffs_VerifyObject(obj);
;;;861                            }
;;;862                    }
;;;863    	 }
;;;864    
;;;865    }
0009e6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2538|
0009ea  2400              MOVS     r4,#0                 ;856
0009ec  e016              B        |L1.2588|
                  |L1.2542|
0009ee  eb040144          ADD      r1,r4,r4,LSL #1       ;857
0009f2  f506709a          ADD      r0,r6,#0x134          ;857
0009f6  f8505021          LDR      r5,[r0,r1,LSL #2]     ;857
0009fa  e006              B        |L1.2570|
                  |L1.2556|
0009fc  b125              CBZ      r5,|L1.2568|
0009fe  f1a5070c          SUB      r7,r5,#0xc            ;859
000a02  4638              MOV      r0,r7                 ;860
000a04  f7fffffe          BL       yaffs_VerifyObject
                  |L1.2568|
000a08  682d              LDR      r5,[r5,#0]            ;857
                  |L1.2570|
000a0a  eb040144          ADD      r1,r4,r4,LSL #1       ;857
000a0e  f506709a          ADD      r0,r6,#0x134          ;857
000a12  eb000081          ADD      r0,r0,r1,LSL #2       ;857
000a16  42a8              CMP      r0,r5                 ;857
000a18  d1f0              BNE      |L1.2556|
000a1a  1c64              ADDS     r4,r4,#1              ;856
                  |L1.2588|
000a1c  2cff              CMP      r4,#0xff              ;856
000a1e  dde6              BLE      |L1.2542|
000a20  bf00              NOP      
000a22  e7e0              B        |L1.2534|
;;;866    
                          ENDP

                  yaffs_HashFunction PROC
;;;871     
;;;872    static Y_INLINE int yaffs_HashFunction(int n)
000a24  4601              MOV      r1,r0
;;;873    {
;;;874    	n = abs(n);
000a26  1e08              SUBS     r0,r1,#0
000a28  db01              BLT      |L1.2606|
000a2a  4602              MOV      r2,r0
000a2c  e000              B        |L1.2608|
                  |L1.2606|
000a2e  4242              RSBS     r2,r0,#0
                  |L1.2608|
000a30  4611              MOV      r1,r2
;;;875    	return (n % YAFFS_NOBJECT_BUCKETS);
000a32  460a              MOV      r2,r1
000a34  17c8              ASRS     r0,r1,#31
000a36  eb016010          ADD      r0,r1,r0,LSR #24
000a3a  1200              ASRS     r0,r0,#8
000a3c  eba12000          SUB      r0,r1,r0,LSL #8
;;;876    }
000a40  4770              BX       lr
;;;877    
                          ENDP

                  yaffs_CheckFF PROC
;;;897     
;;;898    int yaffs_CheckFF(__u8 * buffer, int nBytes)
000a42  4602              MOV      r2,r0
;;;899    {
;;;900    	/* Horrible, slow implementation */
;;;901    	while (nBytes--) {
000a44  e005              B        |L1.2642|
                  |L1.2630|
;;;902    		if (*buffer != 0xFF)
000a46  7810              LDRB     r0,[r2,#0]
000a48  28ff              CMP      r0,#0xff
000a4a  d001              BEQ      |L1.2640|
;;;903    			return 0;
000a4c  2000              MOVS     r0,#0
                  |L1.2638|
;;;904    		buffer++;
;;;905    	}
;;;906    	return 1;
;;;907    }
000a4e  4770              BX       lr
                  |L1.2640|
000a50  1c52              ADDS     r2,r2,#1              ;904
                  |L1.2642|
000a52  0008              MOVS     r0,r1                 ;901
000a54  f1a10101          SUB      r1,r1,#1              ;901
000a58  d1f5              BNE      |L1.2630|
000a5a  2001              MOVS     r0,#1                 ;906
000a5c  e7f7              B        |L1.2638|
;;;908    
                          ENDP

                  yaffs_CheckChunkErased PROC
;;;909    static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
000a5e  e92d41f0          PUSH     {r4-r8,lr}
;;;910    				  int chunkInNAND)
;;;911    {
000a62  b092              SUB      sp,sp,#0x48
000a64  4604              MOV      r4,r0
000a66  460d              MOV      r5,r1
;;;912    
;;;913    	int retval = YAFFS_OK;
000a68  2601              MOVS     r6,#1
;;;914    	__u8 *data = yaffs_GetTempBuffer(dev, __LINE__);
000a6a  f2403192          MOV      r1,#0x392
000a6e  4620              MOV      r0,r4
000a70  f7fffffe          BL       yaffs_GetTempBuffer
000a74  4680              MOV      r8,r0
;;;915    	yaffs_ExtendedTags tags;
;;;916    	int result;
;;;917    
;;;918    	result = yaffs_ReadChunkWithTagsFromNAND(dev, chunkInNAND, data, &tags);
000a76  466b              MOV      r3,sp
000a78  4642              MOV      r2,r8
000a7a  4629              MOV      r1,r5
000a7c  4620              MOV      r0,r4
000a7e  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
000a82  4607              MOV      r7,r0
;;;919    	 
;;;920    	if(tags.eccResult > YAFFS_ECC_RESULT_NO_ERROR)
000a84  f89d0014          LDRB     r0,[sp,#0x14]
000a88  2801              CMP      r0,#1
000a8a  dd00              BLE      |L1.2702|
;;;921    		retval = YAFFS_FAIL;
000a8c  2600              MOVS     r6,#0
                  |L1.2702|
;;;922    		
;;;923    
;;;924    	if (!yaffs_CheckFF(data, dev->nDataBytesPerChunk) || tags.chunkUsed) {
000a8e  4640              MOV      r0,r8
000a90  68e1              LDR      r1,[r4,#0xc]
000a92  f7fffffe          BL       yaffs_CheckFF
000a96  b108              CBZ      r0,|L1.2716|
000a98  9801              LDR      r0,[sp,#4]
000a9a  b110              CBZ      r0,|L1.2722|
                  |L1.2716|
;;;925    		T(YAFFS_TRACE_NANDACCESS,
000a9c  bf00              NOP      
000a9e  bf00              NOP      
;;;926    		  (TSTR("Chunk %d not erased" TENDSTR), chunkInNAND));
;;;927    		retval = YAFFS_FAIL;
000aa0  2600              MOVS     r6,#0
                  |L1.2722|
;;;928    	}
;;;929    
;;;930    	yaffs_ReleaseTempBuffer(dev, data, __LINE__);
000aa2  f24032a2          MOV      r2,#0x3a2
000aa6  4641              MOV      r1,r8
000aa8  4620              MOV      r0,r4
000aaa  f7fffffe          BL       yaffs_ReleaseTempBuffer
;;;931    
;;;932    	return retval;
000aae  4630              MOV      r0,r6
;;;933    
;;;934    }
000ab0  b012              ADD      sp,sp,#0x48
000ab2  e8bd81f0          POP      {r4-r8,pc}
;;;935    
                          ENDP

                  yaffs_HandleWriteChunkOk PROC
;;;1083    
;;;1084   static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,
000ab6  4770              BX       lr
;;;1085   				     const __u8 * data,
;;;1086   				     const yaffs_ExtendedTags * tags)
;;;1087   {
;;;1088   }
;;;1089   
                          ENDP

                  yaffs_InvalidateCheckpoint PROC
;;;4720   
;;;4721   static void yaffs_InvalidateCheckpoint(yaffs_Device *dev)
000ab8  b510              PUSH     {r4,lr}
;;;4722   {
000aba  4604              MOV      r4,r0
;;;4723   	if(dev->isCheckpointed || 
000abc  f8d40098          LDR      r0,[r4,#0x98]
000ac0  b918              CBNZ     r0,|L1.2762|
;;;4724   	   dev->blocksInCheckpoint > 0){
000ac2  f8d400c0          LDR      r0,[r4,#0xc0]
000ac6  2800              CMP      r0,#0
000ac8  dd0c              BLE      |L1.2788|
                  |L1.2762|
;;;4725   		dev->isCheckpointed = 0;
000aca  2000              MOVS     r0,#0
000acc  f8c40098          STR      r0,[r4,#0x98]
;;;4726   		yaffs_CheckpointInvalidateStream(dev);
000ad0  4620              MOV      r0,r4
000ad2  f7fffffe          BL       yaffs_CheckpointInvalidateStream
;;;4727   		if(dev->superBlock && dev->markSuperBlockDirty)
000ad6  6b60              LDR      r0,[r4,#0x34]
000ad8  b120              CBZ      r0,|L1.2788|
000ada  6e60              LDR      r0,[r4,#0x64]
000adc  b110              CBZ      r0,|L1.2788|
;;;4728   			dev->markSuperBlockDirty(dev->superBlock);
000ade  6e61              LDR      r1,[r4,#0x64]
000ae0  6b60              LDR      r0,[r4,#0x34]
000ae2  4788              BLX      r1
                  |L1.2788|
;;;4729   	}
;;;4730   }
000ae4  bd10              POP      {r4,pc}
;;;4731   
                          ENDP

                  yaffs_RetireBlock PROC
;;;1040    
;;;1041   static void yaffs_RetireBlock(yaffs_Device * dev, int blockInNAND)
000ae6  e92d41f0          PUSH     {r4-r8,lr}
;;;1042   {
000aea  b092              SUB      sp,sp,#0x48
000aec  4604              MOV      r4,r0
000aee  460e              MOV      r6,r1
;;;1043   	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
000af0  4631              MOV      r1,r6
000af2  4620              MOV      r0,r4
000af4  f7fffffe          BL       yaffs_GetBlockInfo
000af8  4605              MOV      r5,r0
;;;1044   
;;;1045   	yaffs_InvalidateCheckpoint(dev);
000afa  4620              MOV      r0,r4
000afc  f7fffffe          BL       yaffs_InvalidateCheckpoint
;;;1046   	
;;;1047   	if (yaffs_MarkBlockBad(dev, blockInNAND) != YAFFS_OK) {
000b00  4631              MOV      r1,r6
000b02  4620              MOV      r0,r4
000b04  f7fffffe          BL       yaffs_MarkBlockBad
000b08  2801              CMP      r0,#1
000b0a  d02e              BEQ      |L1.2922|
;;;1048   		if (yaffs_EraseBlockInNAND(dev, blockInNAND) != YAFFS_OK) {
000b0c  4631              MOV      r1,r6
000b0e  4620              MOV      r0,r4
000b10  f7fffffe          BL       yaffs_EraseBlockInNAND
000b14  2801              CMP      r0,#1
000b16  d001              BEQ      |L1.2844|
;;;1049   			T(YAFFS_TRACE_ALWAYS, (TSTR(
000b18  bf00              NOP      
000b1a  e026              B        |L1.2922|
                  |L1.2844|
;;;1050   				"yaffs: Failed to mark bad and erase block %d"
;;;1051   				TENDSTR), blockInNAND));
;;;1052   		}
;;;1053   		else {
;;;1054   			yaffs_ExtendedTags tags;
;;;1055   			int chunkId = blockInNAND * dev->nChunksPerBlock;
000b1c  6920              LDR      r0,[r4,#0x10]
000b1e  fb00f706          MUL      r7,r0,r6
;;;1056   
;;;1057   			__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
000b22  f2404121          MOV      r1,#0x421
000b26  4620              MOV      r0,r4
000b28  f7fffffe          BL       yaffs_GetTempBuffer
000b2c  4680              MOV      r8,r0
;;;1058   
;;;1059   			memset(buffer, 0xff, dev->nDataBytesPerChunk);
000b2e  22ff              MOVS     r2,#0xff
000b30  4640              MOV      r0,r8
000b32  68e1              LDR      r1,[r4,#0xc]
000b34  f7fffffe          BL       __aeabi_memset
;;;1060   			yaffs_InitialiseTags(&tags);
000b38  4668              MOV      r0,sp
000b3a  f7fffffe          BL       yaffs_InitialiseTags
;;;1061   			tags.sequenceNumber = YAFFS_SEQUENCE_BAD_BLOCK;
000b3e  48fe              LDR      r0,|L1.3896|
000b40  9009              STR      r0,[sp,#0x24]
;;;1062   			if (dev->writeChunkWithTagsToNAND(dev, chunkId -
000b42  f8d400a8          LDR      r0,[r4,#0xa8]
000b46  1a39              SUBS     r1,r7,r0
000b48  466b              MOV      r3,sp
000b4a  4642              MOV      r2,r8
000b4c  4620              MOV      r0,r4
000b4e  f8d4c04c          LDR      r12,[r4,#0x4c]
000b52  47e0              BLX      r12
000b54  2801              CMP      r0,#1
000b56  d001              BEQ      |L1.2908|
;;;1063   			    dev->chunkOffset, buffer, &tags) != YAFFS_OK)
;;;1064   				T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Failed to "
000b58  bf00              NOP      
000b5a  bf00              NOP      
                  |L1.2908|
;;;1065   					TCONT("write bad block marker to block %d")
;;;1066   					TENDSTR), blockInNAND));
;;;1067   
;;;1068   			yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
000b5c  f240422c          MOV      r2,#0x42c
000b60  4641              MOV      r1,r8
000b62  4620              MOV      r0,r4
000b64  f7fffffe          BL       yaffs_ReleaseTempBuffer
;;;1069   		}
000b68  bf00              NOP      
                  |L1.2922|
;;;1070   	}
;;;1071   
;;;1072   	bi->blockState = YAFFS_BLOCK_STATE_DEAD;
000b6a  6828              LDR      r0,[r5,#0]
000b6c  f4200070          BIC      r0,r0,#0xf00000
000b70  f5000010          ADD      r0,r0,#0x900000
000b74  6028              STR      r0,[r5,#0]
;;;1073   	bi->gcPrioritise = 0;
000b76  6828              LDR      r0,[r5,#0]
000b78  f0206080          BIC      r0,r0,#0x4000000
000b7c  6028              STR      r0,[r5,#0]
;;;1074   	bi->needsRetiring = 0;
000b7e  6828              LDR      r0,[r5,#0]
000b80  f0207080          BIC      r0,r0,#0x1000000
000b84  6028              STR      r0,[r5,#0]
;;;1075   
;;;1076   	dev->nRetiredBlocks++;
000b86  f8d40d64          LDR      r0,[r4,#0xd64]
000b8a  1c40              ADDS     r0,r0,#1
000b8c  f8c40d64          STR      r0,[r4,#0xd64]
;;;1077   }
000b90  b012              ADD      sp,sp,#0x48
000b92  e8bd81f0          POP      {r4-r8,pc}
;;;1078   
                          ENDP

                  yaffs_BlockBecameDirty PROC
;;;2800   
;;;2801   static void yaffs_BlockBecameDirty(yaffs_Device * dev, int blockNo)
000b96  e92d41f0          PUSH     {r4-r8,lr}
;;;2802   {
000b9a  4605              MOV      r5,r0
000b9c  4688              MOV      r8,r1
;;;2803   	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockNo);
000b9e  4641              MOV      r1,r8
000ba0  4628              MOV      r0,r5
000ba2  f7fffffe          BL       yaffs_GetBlockInfo
000ba6  4604              MOV      r4,r0
;;;2804   
;;;2805   	int erasedOk = 0;
000ba8  2600              MOVS     r6,#0
;;;2806   
;;;2807   	/* If the block is still healthy erase it and mark as clean.
;;;2808   	 * If the block has had a data failure, then retire it.
;;;2809   	 */
;;;2810   	 
;;;2811   	T(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
000baa  bf00              NOP      
000bac  bf00              NOP      
;;;2812   		(TSTR("yaffs_BlockBecameDirty block %d state %d %s"TENDSTR),
;;;2813   		blockNo, bi->blockState, (bi->needsRetiring) ? "needs retiring" : ""));
;;;2814   		
;;;2815   	bi->blockState = YAFFS_BLOCK_STATE_DIRTY;
000bae  6820              LDR      r0,[r4,#0]
000bb0  f4200070          BIC      r0,r0,#0xf00000
000bb4  f50000c0          ADD      r0,r0,#0x600000
000bb8  6020              STR      r0,[r4,#0]
;;;2816   
;;;2817   	if (!bi->needsRetiring) {
000bba  6820              LDR      r0,[r4,#0]
000bbc  f3c06000          UBFX     r0,r0,#24,#1
000bc0  b978              CBNZ     r0,|L1.3042|
;;;2818   		yaffs_InvalidateCheckpoint(dev);
000bc2  4628              MOV      r0,r5
000bc4  f7fffffe          BL       yaffs_InvalidateCheckpoint
;;;2819   		erasedOk = yaffs_EraseBlockInNAND(dev, blockNo);
000bc8  4641              MOV      r1,r8
000bca  4628              MOV      r0,r5
000bcc  f7fffffe          BL       yaffs_EraseBlockInNAND
000bd0  4606              MOV      r6,r0
;;;2820   		if (!erasedOk) {
000bd2  b936              CBNZ     r6,|L1.3042|
;;;2821   			dev->nErasureFailures++;
000bd4  f8d50d50          LDR      r0,[r5,#0xd50]
000bd8  1c40              ADDS     r0,r0,#1
000bda  f8c50d50          STR      r0,[r5,#0xd50]
;;;2822   			T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
000bde  bf00              NOP      
000be0  bf00              NOP      
                  |L1.3042|
;;;2823   			  (TSTR("**>> Erasure failed %d" TENDSTR), blockNo));
;;;2824   		}
;;;2825   	}
;;;2826   
;;;2827   	if (erasedOk && 
000be2  b1c6              CBZ      r6,|L1.3094|
;;;2828   	    ((yaffs_traceMask & YAFFS_TRACE_ERASE) || !yaffs_SkipVerification(dev))) {
000be4  48d5              LDR      r0,|L1.3900|
000be6  7800              LDRB     r0,[r0,#0]  ; yaffs_traceMask
000be8  f0000020          AND      r0,r0,#0x20
000bec  b918              CBNZ     r0,|L1.3062|
000bee  4628              MOV      r0,r5
000bf0  f7fffffe          BL       yaffs_SkipVerification
000bf4  b978              CBNZ     r0,|L1.3094|
                  |L1.3062|
;;;2829   		int i;
;;;2830   		for (i = 0; i < dev->nChunksPerBlock; i++) {
000bf6  2700              MOVS     r7,#0
000bf8  e009              B        |L1.3086|
                  |L1.3066|
;;;2831   			if (!yaffs_CheckChunkErased
000bfa  6928              LDR      r0,[r5,#0x10]
000bfc  fb087100          MLA      r1,r8,r0,r7
000c00  4628              MOV      r0,r5
000c02  f7fffffe          BL       yaffs_CheckChunkErased
000c06  b908              CBNZ     r0,|L1.3084|
;;;2832   			    (dev, blockNo * dev->nChunksPerBlock + i)) {
;;;2833   				T(YAFFS_TRACE_ERROR,
000c08  bf00              NOP      
000c0a  bf00              NOP      
                  |L1.3084|
000c0c  1c7f              ADDS     r7,r7,#1              ;2830
                  |L1.3086|
000c0e  6928              LDR      r0,[r5,#0x10]         ;2830
000c10  42b8              CMP      r0,r7                 ;2830
000c12  dcf2              BGT      |L1.3066|
;;;2834   				  (TSTR
;;;2835   				   (">>Block %d erasure supposedly OK, but chunk %d not erased"
;;;2836   				    TENDSTR), blockNo, i));
;;;2837   			}
;;;2838   		}
;;;2839   	}
000c14  bf00              NOP      
                  |L1.3094|
;;;2840   
;;;2841   	if (erasedOk) {
000c16  b33e              CBZ      r6,|L1.3176|
;;;2842   		/* Clean it up... */
;;;2843   		bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
000c18  6820              LDR      r0,[r4,#0]
000c1a  f4200070          BIC      r0,r0,#0xf00000
000c1e  f5001040          ADD      r0,r0,#0x300000
000c22  6020              STR      r0,[r4,#0]
;;;2844   		dev->nErasedBlocks++;
000c24  f8d500f4          LDR      r0,[r5,#0xf4]
000c28  1c40              ADDS     r0,r0,#1
000c2a  f8c500f4          STR      r0,[r5,#0xf4]
;;;2845   		bi->pagesInUse = 0;
000c2e  2100              MOVS     r1,#0
000c30  6820              LDR      r0,[r4,#0]
000c32  f3612093          BFI      r0,r1,#10,#10
000c36  6020              STR      r0,[r4,#0]
;;;2846   		bi->softDeletions = 0;
000c38  6820              LDR      r0,[r4,#0]
000c3a  f36f0009          BFC      r0,#0,#10
000c3e  6020              STR      r0,[r4,#0]
;;;2847   		bi->hasShrinkHeader = 0;
000c40  6820              LDR      r0,[r4,#0]
000c42  f0204080          BIC      r0,r0,#0x40000000
000c46  6020              STR      r0,[r4,#0]
;;;2848   		bi->skipErasedCheck = 1;  /* This is clean, so no need to check */
000c48  6820              LDR      r0,[r4,#0]
000c4a  f0207000          BIC      r0,r0,#0x2000000
000c4e  f1007000          ADD      r0,r0,#0x2000000
000c52  6020              STR      r0,[r4,#0]
;;;2849   		bi->gcPrioritise = 0;
000c54  6820              LDR      r0,[r4,#0]
000c56  f0206080          BIC      r0,r0,#0x4000000
000c5a  6020              STR      r0,[r4,#0]
;;;2850   		yaffs_ClearChunkBits(dev, blockNo);
000c5c  4641              MOV      r1,r8
000c5e  4628              MOV      r0,r5
000c60  f7fffffe          BL       yaffs_ClearChunkBits
;;;2851   
;;;2852   		T(YAFFS_TRACE_ERASE,
000c64  bf00              NOP      
000c66  e00b              B        |L1.3200|
                  |L1.3176|
;;;2853   		  (TSTR("Erased block %d" TENDSTR), blockNo));
;;;2854   	} else {
;;;2855   		dev->nFreeChunks -= dev->nChunksPerBlock;	/* We lost a block of free space */
000c68  6929              LDR      r1,[r5,#0x10]
000c6a  f8d50d34          LDR      r0,[r5,#0xd34]
000c6e  1a40              SUBS     r0,r0,r1
000c70  f8c50d34          STR      r0,[r5,#0xd34]
;;;2856   
;;;2857   		yaffs_RetireBlock(dev, blockNo);
000c74  4641              MOV      r1,r8
000c76  4628              MOV      r0,r5
000c78  f7fffffe          BL       yaffs_RetireBlock
;;;2858   		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
000c7c  bf00              NOP      
000c7e  bf00              NOP      
                  |L1.3200|
;;;2859   		  (TSTR("**>> Block %d retired" TENDSTR), blockNo));
;;;2860   	}
;;;2861   }
000c80  e8bd81f0          POP      {r4-r8,pc}
;;;2862   
                          ENDP

                  yaffs_HandleUpdateChunk PROC
;;;1089   
;;;1090   static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,
000c84  4770              BX       lr
;;;1091   				    const yaffs_ExtendedTags * tags)
;;;1092   {
;;;1093   }
;;;1094   
                          ENDP

                  yaffs_DeleteChunk PROC
;;;3639   
;;;3640   void yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn)
000c86  e92d4ff0          PUSH     {r4-r11,lr}
;;;3641   {
000c8a  b093              SUB      sp,sp,#0x4c
000c8c  4605              MOV      r5,r0
000c8e  460f              MOV      r7,r1
000c90  4692              MOV      r10,r2
000c92  469b              MOV      r11,r3
;;;3642   	int block;
;;;3643   	int page;
;;;3644   	yaffs_ExtendedTags tags;
;;;3645   	yaffs_BlockInfo *bi;
;;;3646   
;;;3647   	if (chunkId <= 0)
000c94  2f00              CMP      r7,#0
000c96  dc02              BGT      |L1.3230|
                  |L1.3224|
;;;3648   		return;
;;;3649   		
;;;3650   
;;;3651   	dev->nDeletions++;
;;;3652   	block = chunkId / dev->nChunksPerBlock;
;;;3653   	page = chunkId % dev->nChunksPerBlock;
;;;3654   
;;;3655   
;;;3656   	if(!yaffs_CheckChunkBit(dev,block,page))
;;;3657   		T(YAFFS_TRACE_VERIFY,
;;;3658   		 	(TSTR("Deleting invalid chunk %d"TENDSTR),
;;;3659   		 	 chunkId));
;;;3660   
;;;3661   	bi = yaffs_GetBlockInfo(dev, block);
;;;3662   
;;;3663   	T(YAFFS_TRACE_DELETION,
;;;3664   	  (TSTR("line %d delete of chunk %d" TENDSTR), lyn, chunkId));
;;;3665   
;;;3666   	if (markNAND &&
;;;3667   	    bi->blockState != YAFFS_BLOCK_STATE_COLLECTING && !dev->isYaffs2) {
;;;3668   
;;;3669   		yaffs_InitialiseTags(&tags);
;;;3670   
;;;3671   		tags.chunkDeleted = 1;
;;;3672   
;;;3673   		yaffs_WriteChunkWithTagsToNAND(dev, chunkId, NULL, &tags);
;;;3674   		yaffs_HandleUpdateChunk(dev, chunkId, &tags);
;;;3675   	} else {
;;;3676   		dev->nUnmarkedDeletions++;
;;;3677   	}
;;;3678   
;;;3679   	/* Pull out of the management area.
;;;3680   	 * If the whole block became dirty, this will kick off an erasure.
;;;3681   	 */
;;;3682   	if (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING ||
;;;3683   	    bi->blockState == YAFFS_BLOCK_STATE_FULL ||
;;;3684   	    bi->blockState == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
;;;3685   	    bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {
;;;3686   		dev->nFreeChunks++;
;;;3687   
;;;3688   		yaffs_ClearChunkBit(dev, block, page);
;;;3689   
;;;3690   		bi->pagesInUse--;
;;;3691   
;;;3692   		if (bi->pagesInUse == 0 &&
;;;3693   		    !bi->hasShrinkHeader &&
;;;3694   		    bi->blockState != YAFFS_BLOCK_STATE_ALLOCATING &&
;;;3695   		    bi->blockState != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
;;;3696   			yaffs_BlockBecameDirty(dev, block);
;;;3697   		}
;;;3698   
;;;3699   	} else {
;;;3700   		/* T(("Bad news deleting chunk %d\n",chunkId)); */
;;;3701   	}
;;;3702   
;;;3703   }
000c98  b013              ADD      sp,sp,#0x4c
000c9a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.3230|
000c9e  f8d50d78          LDR      r0,[r5,#0xd78]        ;3651
000ca2  1c40              ADDS     r0,r0,#1              ;3651
000ca4  f8c50d78          STR      r0,[r5,#0xd78]        ;3651
000ca8  6928              LDR      r0,[r5,#0x10]         ;3652
000caa  fb97f8f0          SDIV     r8,r7,r0              ;3652
000cae  6928              LDR      r0,[r5,#0x10]         ;3653
000cb0  fb97f1f0          SDIV     r1,r7,r0              ;3653
000cb4  fb007611          MLS      r6,r0,r1,r7           ;3653
000cb8  4632              MOV      r2,r6                 ;3656
000cba  4641              MOV      r1,r8                 ;3656
000cbc  4628              MOV      r0,r5                 ;3656
000cbe  f7fffffe          BL       yaffs_CheckChunkBit
000cc2  b908              CBNZ     r0,|L1.3272|
000cc4  bf00              NOP                            ;3657
000cc6  bf00              NOP                            ;3657
                  |L1.3272|
000cc8  4641              MOV      r1,r8                 ;3661
000cca  4628              MOV      r0,r5                 ;3661
000ccc  f7fffffe          BL       yaffs_GetBlockInfo
000cd0  4604              MOV      r4,r0                 ;3661
000cd2  bf00              NOP                            ;3663
000cd4  bf00              NOP                            ;3663
000cd6  f1ba0f00          CMP      r10,#0                ;3666
000cda  d017              BEQ      |L1.3340|
000cdc  6820              LDR      r0,[r4,#0]            ;3667
000cde  f3c05003          UBFX     r0,r0,#20,#4          ;3667
000ce2  2808              CMP      r0,#8                 ;3667
000ce4  d012              BEQ      |L1.3340|
000ce6  6de8              LDR      r0,[r5,#0x5c]         ;3667
000ce8  b980              CBNZ     r0,|L1.3340|
000cea  a801              ADD      r0,sp,#4              ;3669
000cec  f7fffffe          BL       yaffs_InitialiseTags
000cf0  2001              MOVS     r0,#1                 ;3671
000cf2  9008              STR      r0,[sp,#0x20]         ;3671
000cf4  ab01              ADD      r3,sp,#4              ;3673
000cf6  2200              MOVS     r2,#0                 ;3673
000cf8  4639              MOV      r1,r7                 ;3673
000cfa  4628              MOV      r0,r5                 ;3673
000cfc  f7fffffe          BL       yaffs_WriteChunkWithTagsToNAND
000d00  aa01              ADD      r2,sp,#4              ;3674
000d02  4639              MOV      r1,r7                 ;3674
000d04  4628              MOV      r0,r5                 ;3674
000d06  f7fffffe          BL       yaffs_HandleUpdateChunk
000d0a  e004              B        |L1.3350|
                  |L1.3340|
000d0c  f8d50d7c          LDR      r0,[r5,#0xd7c]        ;3676
000d10  1c40              ADDS     r0,r0,#1              ;3676
000d12  f8c50d7c          STR      r0,[r5,#0xd7c]        ;3676
                  |L1.3350|
000d16  6820              LDR      r0,[r4,#0]            ;3682
000d18  f3c05003          UBFX     r0,r0,#20,#4          ;3682
000d1c  2804              CMP      r0,#4                 ;3682
000d1e  d00e              BEQ      |L1.3390|
000d20  6820              LDR      r0,[r4,#0]            ;3683
000d22  f3c05003          UBFX     r0,r0,#20,#4          ;3683
000d26  2805              CMP      r0,#5                 ;3683
000d28  d009              BEQ      |L1.3390|
000d2a  6820              LDR      r0,[r4,#0]            ;3684
000d2c  f3c05003          UBFX     r0,r0,#20,#4          ;3684
000d30  2802              CMP      r0,#2                 ;3684
000d32  d004              BEQ      |L1.3390|
000d34  6820              LDR      r0,[r4,#0]            ;3685
000d36  f3c05003          UBFX     r0,r0,#20,#4          ;3685
000d3a  2808              CMP      r0,#8                 ;3685
000d3c  d13f              BNE      |L1.3518|
                  |L1.3390|
000d3e  f8d50d34          LDR      r0,[r5,#0xd34]        ;3686
000d42  1c40              ADDS     r0,r0,#1              ;3686
000d44  f8c50d34          STR      r0,[r5,#0xd34]        ;3686
000d48  bf00              NOP                            ;3688
000d4a  4641              MOV      r1,r8                 ;3688
000d4c  4628              MOV      r0,r5                 ;3688
000d4e  f7fffffe          BL       yaffs_BlockBits
000d52  4681              MOV      r9,r0                 ;3688
000d54  4632              MOV      r2,r6                 ;3688
000d56  4641              MOV      r1,r8                 ;3688
000d58  4628              MOV      r0,r5                 ;3688
000d5a  f7fffffe          BL       yaffs_VerifyChunkBitId
000d5e  17f1              ASRS     r1,r6,#31             ;3688
000d60  eb067151          ADD      r1,r6,r1,LSR #29      ;3688
000d64  10c9              ASRS     r1,r1,#3              ;3688
000d66  f8191001          LDRB     r1,[r9,r1]            ;3688
000d6a  f0060307          AND      r3,r6,#7              ;3688
000d6e  2201              MOVS     r2,#1                 ;3688
000d70  409a              LSLS     r2,r2,r3              ;3688
000d72  4391              BICS     r1,r1,r2              ;3688
000d74  4630              MOV      r0,r6                 ;3688
000d76  17f2              ASRS     r2,r6,#31             ;3688
000d78  eb067252          ADD      r2,r6,r2,LSR #29      ;3688
000d7c  10d2              ASRS     r2,r2,#3              ;3688
000d7e  f8091002          STRB     r1,[r9,r2]            ;3688
000d82  bf00              NOP                            ;3688
000d84  6820              LDR      r0,[r4,#0]            ;3690
000d86  0a80              LSRS     r0,r0,#10             ;3690
000d88  1e40              SUBS     r0,r0,#1              ;3690
000d8a  6821              LDR      r1,[r4,#0]            ;3690
000d8c  f3602193          BFI      r1,r0,#10,#10         ;3690
000d90  6021              STR      r1,[r4,#0]            ;3690
000d92  6820              LDR      r0,[r4,#0]            ;3692
000d94  f3c02089          UBFX     r0,r0,#10,#10         ;3692
000d98  b988              CBNZ     r0,|L1.3518|
000d9a  6820              LDR      r0,[r4,#0]            ;3693
000d9c  f3c07080          UBFX     r0,r0,#30,#1          ;3693
000da0  b968              CBNZ     r0,|L1.3518|
000da2  6820              LDR      r0,[r4,#0]            ;3694
000da4  f3c05003          UBFX     r0,r0,#20,#4          ;3694
000da8  2804              CMP      r0,#4                 ;3694
000daa  d008              BEQ      |L1.3518|
000dac  6820              LDR      r0,[r4,#0]            ;3695
000dae  f3c05003          UBFX     r0,r0,#20,#4          ;3695
000db2  2802              CMP      r0,#2                 ;3695
000db4  d003              BEQ      |L1.3518|
000db6  4641              MOV      r1,r8                 ;3696
000db8  4628              MOV      r0,r5                 ;3696
000dba  f7fffffe          BL       yaffs_BlockBecameDirty
                  |L1.3518|
000dbe  bf00              NOP      
000dc0  e76a              B        |L1.3224|
;;;3704   
                          ENDP

                  yaffs_HandleChunkError PROC
;;;1094   
;;;1095   void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi)
000dc2  680a              LDR      r2,[r1,#0]
;;;1096   {
;;;1097   	if(!bi->gcPrioritise){
000dc4  f3c26280          UBFX     r2,r2,#26,#1
000dc8  b9e2              CBNZ     r2,|L1.3588|
;;;1098   		bi->gcPrioritise = 1;
000dca  680a              LDR      r2,[r1,#0]
000dcc  f0226280          BIC      r2,r2,#0x4000000
000dd0  f1026280          ADD      r2,r2,#0x4000000
000dd4  600a              STR      r2,[r1,#0]
;;;1099   		dev->hasPendingPrioritisedGCs = 1;
000dd6  2201              MOVS     r2,#1
000dd8  f8c02d80          STR      r2,[r0,#0xd80]
;;;1100   		bi->chunkErrorStrikes ++;
000ddc  680a              LDR      r2,[r1,#0]
000dde  0ed2              LSRS     r2,r2,#27
000de0  1c52              ADDS     r2,r2,#1
000de2  680b              LDR      r3,[r1,#0]
000de4  f36263dd          BFI      r3,r2,#27,#3
000de8  600b              STR      r3,[r1,#0]
;;;1101   		
;;;1102   		if(bi->chunkErrorStrikes > 3){
000dea  680a              LDR      r2,[r1,#0]
000dec  f3c262c2          UBFX     r2,r2,#27,#3
000df0  2a03              CMP      r2,#3
000df2  dd07              BLE      |L1.3588|
;;;1103   			bi->needsRetiring = 1; /* Too many stikes, so retire this */
000df4  680a              LDR      r2,[r1,#0]
000df6  f0227280          BIC      r2,r2,#0x1000000
000dfa  f1027280          ADD      r2,r2,#0x1000000
000dfe  600a              STR      r2,[r1,#0]
;;;1104   			T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Block struck out" TENDSTR)));
000e00  bf00              NOP      
000e02  bf00              NOP      
                  |L1.3588|
;;;1105   
;;;1106   		}
;;;1107   		
;;;1108   	}
;;;1109   }
000e04  4770              BX       lr
;;;1110   
                          ENDP

                  yaffs_HandleWriteChunkError PROC
;;;1111   static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND, int erasedOk)
000e06  e92d41f0          PUSH     {r4-r8,lr}
;;;1112   {
000e0a  4605              MOV      r5,r0
000e0c  460e              MOV      r6,r1
000e0e  4617              MOV      r7,r2
;;;1113   
;;;1114   	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
000e10  6928              LDR      r0,[r5,#0x10]
000e12  fb96f8f0          SDIV     r8,r6,r0
;;;1115   	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
000e16  4641              MOV      r1,r8
000e18  4628              MOV      r0,r5
000e1a  f7fffffe          BL       yaffs_GetBlockInfo
000e1e  4604              MOV      r4,r0
;;;1116   
;;;1117   	yaffs_HandleChunkError(dev,bi);
000e20  4621              MOV      r1,r4
000e22  4628              MOV      r0,r5
000e24  f7fffffe          BL       yaffs_HandleChunkError
;;;1118   		
;;;1119   	
;;;1120   	if(erasedOk ) {
000e28  b13f              CBZ      r7,|L1.3642|
;;;1121   		/* Was an actual write failure, so mark the block for retirement  */
;;;1122   		bi->needsRetiring = 1;
000e2a  6820              LDR      r0,[r4,#0]
000e2c  f0207080          BIC      r0,r0,#0x1000000
000e30  f1007080          ADD      r0,r0,#0x1000000
000e34  6020              STR      r0,[r4,#0]
;;;1123   		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
000e36  bf00              NOP      
000e38  bf00              NOP      
                  |L1.3642|
;;;1124   		  (TSTR("**>> Block %d needs retiring" TENDSTR), blockInNAND));
;;;1125   
;;;1126   		
;;;1127   	}
;;;1128   	
;;;1129   	/* Delete the chunk */
;;;1130   	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
000e3a  f240436a          MOV      r3,#0x46a
000e3e  2201              MOVS     r2,#1
000e40  4631              MOV      r1,r6
000e42  4628              MOV      r0,r5
000e44  f7fffffe          BL       yaffs_DeleteChunk
;;;1131   }
000e48  e8bd81f0          POP      {r4-r8,pc}
;;;1132   
                          ENDP

                  yaffs_CalcCheckpointBlocksRequired PROC
;;;2912   
;;;2913   static int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)
000e4c  b570              PUSH     {r4-r6,lr}
;;;2914   {
000e4e  4601              MOV      r1,r0
;;;2915   	if(!dev->nCheckpointBlocksRequired &&
000e50  f8d100e0          LDR      r0,[r1,#0xe0]
000e54  2800              CMP      r0,#0
000e56  d12d              BNE      |L1.3764|
;;;2916   	   dev->isYaffs2){
000e58  6dc8              LDR      r0,[r1,#0x5c]
000e5a  b358              CBZ      r0,|L1.3764|
;;;2917   		/* Not a valid value so recalculate */
;;;2918   		int nBytes = 0;
000e5c  2000              MOVS     r0,#0
;;;2919   		int nBlocks;
;;;2920   		int devBlocks = (dev->endBlock - dev->startBlock + 1);
000e5e  e9d16506          LDRD     r6,r5,[r1,#0x18]
000e62  1bad              SUBS     r5,r5,r6
000e64  1c6a              ADDS     r2,r5,#1
;;;2921   		int tnodeSize;
;;;2922   
;;;2923   		tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
000e66  6f8d              LDR      r5,[r1,#0x78]
000e68  012d              LSLS     r5,r5,#4
000e6a  08eb              LSRS     r3,r5,#3
;;;2924   
;;;2925   		if(tnodeSize < sizeof(yaffs_Tnode))
000e6c  2b20              CMP      r3,#0x20
000e6e  d200              BCS      |L1.3698|
;;;2926   			tnodeSize = sizeof(yaffs_Tnode);
000e70  2320              MOVS     r3,#0x20
                  |L1.3698|
;;;2927   		
;;;2928   		nBytes += sizeof(yaffs_CheckpointValidity);
000e72  3010              ADDS     r0,r0,#0x10
;;;2929   		nBytes += sizeof(yaffs_CheckpointDevice);
000e74  3028              ADDS     r0,r0,#0x28
;;;2930   		nBytes += devBlocks * sizeof(yaffs_BlockInfo);
000e76  eb0000c2          ADD      r0,r0,r2,LSL #3
;;;2931   		nBytes += devBlocks * dev->chunkBitmapStride;
000e7a  31ac              ADDS     r1,r1,#0xac
000e7c  6c4d              LDR      r5,[r1,#0x44]
000e7e  fb020005          MLA      r0,r2,r5,r0
;;;2932   		nBytes += (sizeof(yaffs_CheckpointObject) + sizeof(__u32)) * (dev->nObjectsCreated - dev->nFreeObjects);
000e82  6fce              LDR      r6,[r1,#0x7c]
000e84  6f4d              LDR      r5,[r1,#0x74]
000e86  1bad              SUBS     r5,r5,r6
000e88  2620              MOVS     r6,#0x20
000e8a  fb060005          MLA      r0,r6,r5,r0
;;;2933   		nBytes += (tnodeSize + sizeof(__u32)) * (dev->nTnodesCreated - dev->nFreeTnodes);
000e8e  6e0e              LDR      r6,[r1,#0x60]
000e90  6d8d              LDR      r5,[r1,#0x58]
000e92  1bae              SUBS     r6,r5,r6
000e94  1d1d              ADDS     r5,r3,#4
000e96  fb050006          MLA      r0,r5,r6,r0
;;;2934   		nBytes += sizeof(yaffs_CheckpointValidity);
000e9a  3010              ADDS     r0,r0,#0x10
;;;2935   		nBytes += sizeof(__u32); /* checksum*/
000e9c  1d00              ADDS     r0,r0,#4
;;;2936   	
;;;2937   		/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */
;;;2938   	
;;;2939   		nBlocks = (nBytes/(dev->nDataBytesPerChunk * dev->nChunksPerBlock)) + 3;
000e9e  f8515ca0          LDR      r5,[r1,#-0xa0]
000ea2  f8516c9c          LDR      r6,[r1,#-0x9c]
000ea6  4375              MULS     r5,r6,r5
000ea8  fb90f5f5          SDIV     r5,r0,r5
000eac  1cec              ADDS     r4,r5,#3
;;;2940   	
;;;2941   		dev->nCheckpointBlocksRequired = nBlocks;
000eae  634c              STR      r4,[r1,#0x34]
000eb0  39ac              SUBS     r1,r1,#0xac
;;;2942   	}
000eb2  bf00              NOP      
                  |L1.3764|
;;;2943   
;;;2944   	return dev->nCheckpointBlocksRequired;
000eb4  f8d100e0          LDR      r0,[r1,#0xe0]
;;;2945   }
000eb8  bd70              POP      {r4-r6,pc}
;;;2946   
                          ENDP

                  yaffs_CheckSpaceForAllocation PROC
;;;2948   // Thinks.... do we need top make this ths same as yaffs_GetFreeChunks()?
;;;2949   static int yaffs_CheckSpaceForAllocation(yaffs_Device * dev)
000eba  e92d41f0          PUSH     {r4-r8,lr}
;;;2950   {
000ebe  4604              MOV      r4,r0
;;;2951   	int reservedChunks;
;;;2952   	int reservedBlocks = dev->nReservedBlocks;
000ec0  6a27              LDR      r7,[r4,#0x20]
;;;2953   	int checkpointBlocks;
;;;2954   	
;;;2955   	if(dev->isYaffs2){
000ec2  6de0              LDR      r0,[r4,#0x5c]
000ec4  b148              CBZ      r0,|L1.3802|
;;;2956   		checkpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) - 
000ec6  4620              MOV      r0,r4
000ec8  f7fffffe          BL       yaffs_CalcCheckpointBlocksRequired
000ecc  f8d410c0          LDR      r1,[r4,#0xc0]
000ed0  1a45              SUBS     r5,r0,r1
;;;2957   				    dev->blocksInCheckpoint;
;;;2958   		if(checkpointBlocks < 0)
000ed2  2d00              CMP      r5,#0
000ed4  da02              BGE      |L1.3804|
;;;2959   			checkpointBlocks = 0;
000ed6  2500              MOVS     r5,#0
000ed8  e000              B        |L1.3804|
                  |L1.3802|
;;;2960   	} else {
;;;2961   		checkpointBlocks =0;
000eda  2500              MOVS     r5,#0
                  |L1.3804|
;;;2962   	}
;;;2963   	
;;;2964   	reservedChunks = ((reservedBlocks + checkpointBlocks) * dev->nChunksPerBlock);
000edc  1978              ADDS     r0,r7,r5
000ede  6921              LDR      r1,[r4,#0x10]
000ee0  fb00f601          MUL      r6,r0,r1
;;;2965   	
;;;2966   	return (dev->nFreeChunks > reservedChunks);
000ee4  f8d40d34          LDR      r0,[r4,#0xd34]
000ee8  42b0              CMP      r0,r6
000eea  dd02              BLE      |L1.3826|
000eec  2001              MOVS     r0,#1
                  |L1.3822|
;;;2967   }
000eee  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3826|
000ef2  2000              MOVS     r0,#0                 ;2966
000ef4  e7fb              B        |L1.3822|
;;;2968   
                          ENDP

                  yaffs_FindBlockForAllocation PROC
;;;2862   
;;;2863   static int yaffs_FindBlockForAllocation(yaffs_Device * dev)
000ef6  b570              PUSH     {r4-r6,lr}
;;;2864   {
000ef8  4604              MOV      r4,r0
;;;2865   	int i;
;;;2866   
;;;2867   	yaffs_BlockInfo *bi;
;;;2868   
;;;2869   	if (dev->nErasedBlocks < 1) {
000efa  f8d400f4          LDR      r0,[r4,#0xf4]
000efe  2801              CMP      r0,#1
000f00  da04              BGE      |L1.3852|
;;;2870   		/* Hoosterman we've got a problem.
;;;2871   		 * Can't get space to gc
;;;2872   		 */
;;;2873   		T(YAFFS_TRACE_ERROR,
000f02  bf00              NOP      
000f04  bf00              NOP      
;;;2874   		  (TSTR("yaffs tragedy: no more erased blocks" TENDSTR)));
;;;2875   
;;;2876   		return -1;
000f06  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3850|
;;;2877   	}
;;;2878   	
;;;2879   	/* Find an empty block. */
;;;2880   
;;;2881   	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
;;;2882   		dev->allocationBlockFinder++;
;;;2883   		if (dev->allocationBlockFinder < dev->internalStartBlock
;;;2884   		    || dev->allocationBlockFinder > dev->internalEndBlock) {
;;;2885   			dev->allocationBlockFinder = dev->internalStartBlock;
;;;2886   		}
;;;2887   
;;;2888   		bi = yaffs_GetBlockInfo(dev, dev->allocationBlockFinder);
;;;2889   
;;;2890   		if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
;;;2891   			bi->blockState = YAFFS_BLOCK_STATE_ALLOCATING;
;;;2892   			dev->sequenceNumber++;
;;;2893   			bi->sequenceNumber = dev->sequenceNumber;
;;;2894   			dev->nErasedBlocks--;
;;;2895   			T(YAFFS_TRACE_ALLOCATE,
;;;2896   			  (TSTR("Allocated block %d, seq  %d, %d left" TENDSTR),
;;;2897   			   dev->allocationBlockFinder, dev->sequenceNumber,
;;;2898   			   dev->nErasedBlocks));
;;;2899   			return dev->allocationBlockFinder;
;;;2900   		}
;;;2901   	}
;;;2902   
;;;2903   	T(YAFFS_TRACE_ALWAYS,
;;;2904   	  (TSTR
;;;2905   	   ("yaffs tragedy: no more erased blocks, but there should have been %d"
;;;2906   	    TENDSTR), dev->nErasedBlocks));
;;;2907   
;;;2908   	return -1;
;;;2909   }
000f0a  bd70              POP      {r4-r6,pc}
                  |L1.3852|
000f0c  f8d4609c          LDR      r6,[r4,#0x9c]         ;2881
000f10  e03c              B        |L1.3980|
                  |L1.3858|
000f12  349c              ADDS     r4,r4,#0x9c           ;2882
000f14  6e60              LDR      r0,[r4,#0x64]         ;2882
000f16  1c40              ADDS     r0,r0,#1              ;2882
000f18  6660              STR      r0,[r4,#0x64]         ;2882
000f1a  6e60              LDR      r0,[r4,#0x64]         ;2883
000f1c  f854199c          LDR      r1,[r4],#-0x9c        ;2883
000f20  4288              CMP      r0,r1                 ;2883
000f22  db05              BLT      |L1.3888|
000f24  f8d410a0          LDR      r1,[r4,#0xa0]         ;2884
000f28  f8d40100          LDR      r0,[r4,#0x100]        ;2884
000f2c  4288              CMP      r0,r1                 ;2884
000f2e  dd09              BLE      |L1.3908|
                  |L1.3888|
000f30  f8d4009c          LDR      r0,[r4,#0x9c]         ;2885
000f34  e004              B        |L1.3904|
000f36  0000              DCW      0x0000
                  |L1.3896|
                          DCD      0xffff0000
                  |L1.3900|
                          DCD      yaffs_traceMask
                  |L1.3904|
000f40  f8c40100          STR      r0,[r4,#0x100]        ;2885
                  |L1.3908|
000f44  4620              MOV      r0,r4                 ;2888
000f46  f8d41100          LDR      r1,[r4,#0x100]        ;2888
000f4a  f7fffffe          BL       yaffs_GetBlockInfo
000f4e  4605              MOV      r5,r0                 ;2888
000f50  6828              LDR      r0,[r5,#0]            ;2890
000f52  f3c05003          UBFX     r0,r0,#20,#4          ;2890
000f56  2803              CMP      r0,#3                 ;2890
000f58  d117              BNE      |L1.3978|
000f5a  6828              LDR      r0,[r5,#0]            ;2891
000f5c  f4200070          BIC      r0,r0,#0xf00000       ;2891
000f60  f5000080          ADD      r0,r0,#0x400000       ;2891
000f64  6028              STR      r0,[r5,#0]            ;2891
000f66  f8d40e10          LDR      r0,[r4,#0xe10]        ;2892
000f6a  1c40              ADDS     r0,r0,#1              ;2892
000f6c  f8c40e10          STR      r0,[r4,#0xe10]        ;2892
000f70  f8d40e10          LDR      r0,[r4,#0xe10]        ;2893
000f74  6068              STR      r0,[r5,#4]            ;2893
000f76  f8d400f4          LDR      r0,[r4,#0xf4]         ;2894
000f7a  1e40              SUBS     r0,r0,#1              ;2894
000f7c  f8c400f4          STR      r0,[r4,#0xf4]         ;2894
000f80  bf00              NOP                            ;2895
000f82  bf00              NOP                            ;2895
000f84  f8d40100          LDR      r0,[r4,#0x100]        ;2899
000f88  e7bf              B        |L1.3850|
                  |L1.3978|
000f8a  1c76              ADDS     r6,r6,#1              ;2881
                  |L1.3980|
000f8c  f8d400a0          LDR      r0,[r4,#0xa0]         ;2881
000f90  42b0              CMP      r0,r6                 ;2881
000f92  dabe              BGE      |L1.3858|
000f94  bf00              NOP                            ;2903
000f96  bf00              NOP                            ;2903
000f98  f04f30ff          MOV      r0,#0xffffffff        ;2908
000f9c  e7b5              B        |L1.3850|
;;;2910   
                          ENDP

                  yaffs_AllocateChunk PROC
;;;2968   
;;;2969   static int yaffs_AllocateChunk(yaffs_Device * dev, int useReserve, yaffs_BlockInfo **blockUsedPtr)
000f9e  e92d41f0          PUSH     {r4-r8,lr}
;;;2970   {
000fa2  4604              MOV      r4,r0
000fa4  460f              MOV      r7,r1
000fa6  4616              MOV      r6,r2
;;;2971   	int retVal;
;;;2972   	yaffs_BlockInfo *bi;
;;;2973   
;;;2974   	if (dev->allocationBlock < 0) {
000fa8  f8d400f8          LDR      r0,[r4,#0xf8]
000fac  2800              CMP      r0,#0
000fae  da07              BGE      |L1.4032|
;;;2975   		/* Get next block to allocate off */
;;;2976   		dev->allocationBlock = yaffs_FindBlockForAllocation(dev);
000fb0  4620              MOV      r0,r4
000fb2  f7fffffe          BL       yaffs_FindBlockForAllocation
000fb6  f8c400f8          STR      r0,[r4,#0xf8]
;;;2977   		dev->allocationPage = 0;
000fba  2000              MOVS     r0,#0
000fbc  f8c400fc          STR      r0,[r4,#0xfc]
                  |L1.4032|
;;;2978   	}
;;;2979   
;;;2980   	if (!useReserve && !yaffs_CheckSpaceForAllocation(dev)) {
000fc0  b93f              CBNZ     r7,|L1.4050|
000fc2  4620              MOV      r0,r4
000fc4  f7fffffe          BL       yaffs_CheckSpaceForAllocation
000fc8  b918              CBNZ     r0,|L1.4050|
;;;2981   		/* Not enough space to allocate unless we're allowed to use the reserve. */
;;;2982   		return -1;
000fca  f04f30ff          MOV      r0,#0xffffffff
                  |L1.4046|
;;;2983   	}
;;;2984   
;;;2985   	if (dev->nErasedBlocks < dev->nReservedBlocks
;;;2986   	    && dev->allocationPage == 0) {
;;;2987   		T(YAFFS_TRACE_ALLOCATE, (TSTR("Allocating reserve" TENDSTR)));
;;;2988   	}
;;;2989   
;;;2990   	/* Next page please.... */
;;;2991   	if (dev->allocationBlock >= 0) {
;;;2992   		bi = yaffs_GetBlockInfo(dev, dev->allocationBlock);
;;;2993   
;;;2994   		retVal = (dev->allocationBlock * dev->nChunksPerBlock) +
;;;2995   		    dev->allocationPage;
;;;2996   		bi->pagesInUse++;
;;;2997   		yaffs_SetChunkBit(dev, dev->allocationBlock,
;;;2998   				  dev->allocationPage);
;;;2999   
;;;3000   		dev->allocationPage++;
;;;3001   
;;;3002   		dev->nFreeChunks--;
;;;3003   
;;;3004   		/* If the block is full set the state to full */
;;;3005   		if (dev->allocationPage >= dev->nChunksPerBlock) {
;;;3006   			bi->blockState = YAFFS_BLOCK_STATE_FULL;
;;;3007   			dev->allocationBlock = -1;
;;;3008   		}
;;;3009   
;;;3010   		if(blockUsedPtr)
;;;3011   			*blockUsedPtr = bi;
;;;3012   			
;;;3013   		return retVal;
;;;3014   	}
;;;3015   	
;;;3016   	T(YAFFS_TRACE_ERROR,
;;;3017   	  (TSTR("!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" TENDSTR)));
;;;3018   
;;;3019   	return -1;
;;;3020   }
000fce  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4050|
000fd2  6a21              LDR      r1,[r4,#0x20]         ;2985
000fd4  f8d400f4          LDR      r0,[r4,#0xf4]         ;2985
000fd8  4288              CMP      r0,r1                 ;2985
000fda  da04              BGE      |L1.4070|
000fdc  f8d400fc          LDR      r0,[r4,#0xfc]         ;2986
000fe0  b908              CBNZ     r0,|L1.4070|
000fe2  bf00              NOP                            ;2987
000fe4  bf00              NOP                            ;2987
                  |L1.4070|
000fe6  f8d400f8          LDR      r0,[r4,#0xf8]         ;2991
000fea  2800              CMP      r0,#0                 ;2991
000fec  db36              BLT      |L1.4188|
000fee  4620              MOV      r0,r4                 ;2992
000ff0  f8d410f8          LDR      r1,[r4,#0xf8]         ;2992
000ff4  f7fffffe          BL       yaffs_GetBlockInfo
000ff8  4605              MOV      r5,r0                 ;2992
000ffa  3480              ADDS     r4,r4,#0x80           ;2994
000ffc  f8542c70          LDR      r2,[r4,#-0x70]        ;2994
001000  e9d4101e          LDRD     r1,r0,[r4,#0x78]      ;2994
001004  fb010802          MLA      r8,r1,r2,r0           ;2994
001008  6828              LDR      r0,[r5,#0]            ;2996
00100a  0a80              LSRS     r0,r0,#10             ;2996
00100c  1c40              ADDS     r0,r0,#1              ;2996
00100e  6829              LDR      r1,[r5,#0]            ;2996
001010  f3602193          BFI      r1,r0,#10,#10         ;2996
001014  6029              STR      r1,[r5,#0]            ;2996
001016  e9d4121e          LDRD     r1,r2,[r4,#0x78]      ;2997
00101a  3c80              SUBS     r4,r4,#0x80           ;2997
00101c  4620              MOV      r0,r4                 ;2997
00101e  f7fffffe          BL       yaffs_SetChunkBit
001022  f8d400fc          LDR      r0,[r4,#0xfc]         ;3000
001026  1c40              ADDS     r0,r0,#1              ;3000
001028  f8c400fc          STR      r0,[r4,#0xfc]         ;3000
00102c  f8d40d34          LDR      r0,[r4,#0xd34]        ;3002
001030  1e40              SUBS     r0,r0,#1              ;3002
001032  f8c40d34          STR      r0,[r4,#0xd34]        ;3002
001036  6921              LDR      r1,[r4,#0x10]         ;3005
001038  f8d400fc          LDR      r0,[r4,#0xfc]         ;3005
00103c  4288              CMP      r0,r1                 ;3005
00103e  d309              BCC      |L1.4180|
001040  6828              LDR      r0,[r5,#0]            ;3006
001042  f4200070          BIC      r0,r0,#0xf00000       ;3006
001046  f50000a0          ADD      r0,r0,#0x500000       ;3006
00104a  6028              STR      r0,[r5,#0]            ;3006
00104c  f04f30ff          MOV      r0,#0xffffffff        ;3007
001050  f8c400f8          STR      r0,[r4,#0xf8]         ;3007
                  |L1.4180|
001054  b106              CBZ      r6,|L1.4184|
001056  6035              STR      r5,[r6,#0]            ;3011
                  |L1.4184|
001058  4640              MOV      r0,r8                 ;3013
00105a  e7b8              B        |L1.4046|
                  |L1.4188|
00105c  bf00              NOP                            ;3016
00105e  bf00              NOP                            ;3016
001060  f04f30ff          MOV      r0,#0xffffffff        ;3019
001064  e7b3              B        |L1.4046|
;;;3021   
                          ENDP

                  yaffs_WriteNewChunkWithTagsToNAND PROC
;;;935    
;;;936    static int yaffs_WriteNewChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
001066  e92d4ff8          PUSH     {r3-r11,lr}
;;;937    					     const __u8 * data,
;;;938    					     yaffs_ExtendedTags * tags,
;;;939    					     int useReserve)
;;;940    {
00106a  4606              MOV      r6,r0
00106c  4688              MOV      r8,r1
00106e  4691              MOV      r9,r2
001070  469a              MOV      r10,r3
;;;941    	int attempts = 0;
001072  2400              MOVS     r4,#0
;;;942    	int writeOk = 0;
001074  2700              MOVS     r7,#0
;;;943    	int chunk;
;;;944    
;;;945    	yaffs_InvalidateCheckpoint(dev);
001076  4630              MOV      r0,r6
001078  f7fffffe          BL       yaffs_InvalidateCheckpoint
;;;946     
;;;947    	do {
00107c  bf00              NOP      
                  |L1.4222|
;;;948    		yaffs_BlockInfo *bi = 0;
00107e  2000              MOVS     r0,#0
001080  9000              STR      r0,[sp,#0]
;;;949    		int erasedOk = 0;
001082  4683              MOV      r11,r0
;;;950    
;;;951    		chunk = yaffs_AllocateChunk(dev, useReserve, &bi);
001084  466a              MOV      r2,sp
001086  4651              MOV      r1,r10
001088  4630              MOV      r0,r6
00108a  f7fffffe          BL       yaffs_AllocateChunk
00108e  4605              MOV      r5,r0
;;;952    		if (chunk < 0) 
001090  2d00              CMP      r5,#0
001092  da00              BGE      |L1.4246|
;;;953    		{
;;;954    			/* no space */
;;;955    			break;
001094  e045              B        |L1.4386|
                  |L1.4246|
;;;956    		}
;;;957    
;;;958    		/* First check this chunk is erased, if it needs
;;;959    		 * checking.  The checking policy (unless forced
;;;960    		 * always on) is as follows:
;;;961    		 *
;;;962    		 * Check the first page we try to write in a block.
;;;963    		 * If the check passes then we don't need to check any
;;;964    		 * more.	If the check fails, we check again...
;;;965    		 * If the block has been erased, we don't need to check.
;;;966    		 *
;;;967    		 * However, if the block has been prioritised for gc,
;;;968    		 * then we think there might be something odd about
;;;969    		 * this block and stop using it.
;;;970    		 *
;;;971    		 * Rationale: We should only ever see chunks that have
;;;972    		 * not been erased if there was a partially written
;;;973    		 * chunk due to power loss.  This checking policy should
;;;974    		 * catch that case with very few checks and thus save a
;;;975    		 * lot of checks that are most likely not needed.
;;;976    		 */
;;;977    		 
;;;978    		if (bi->gcPrioritise) {
001096  9800              LDR      r0,[sp,#0]
001098  6800              LDR      r0,[r0,#0]
00109a  f3c06080          UBFX     r0,r0,#26,#1
00109e  b138              CBZ      r0,|L1.4272|
;;;979    			yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
0010a0  f24033d3          MOV      r3,#0x3d3
0010a4  2201              MOVS     r2,#1
0010a6  4629              MOV      r1,r5
0010a8  4630              MOV      r0,r6
0010aa  f7fffffe          BL       yaffs_DeleteChunk
;;;980    			/* try another chunk */
;;;981    			 
;;;982    			continue;
0010ae  e02e              B        |L1.4366|
                  |L1.4272|
;;;983    		}
;;;984                     
;;;985    		/* let's give it a try */
;;;986    		attempts++;
0010b0  1c64              ADDS     r4,r4,#1
;;;987    
;;;988    #ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
;;;989    		bi->skipErasedCheck = 0;
;;;990    #endif
;;;991    		if (!bi->skipErasedCheck) 
0010b2  9800              LDR      r0,[sp,#0]
0010b4  6800              LDR      r0,[r0,#0]
0010b6  f3c06040          UBFX     r0,r0,#25,#1
0010ba  b990              CBNZ     r0,|L1.4322|
;;;992    		{
;;;993    		
;;;994    			erasedOk = yaffs_CheckChunkErased(dev, chunk);
0010bc  4629              MOV      r1,r5
0010be  4630              MOV      r0,r6
0010c0  f7fffffe          BL       yaffs_CheckChunkErased
0010c4  4683              MOV      r11,r0
;;;995    			if (erasedOk != YAFFS_OK) 
0010c6  f1bb0f01          CMP      r11,#1
0010ca  d002              BEQ      |L1.4306|
;;;996    			{
;;;997    				T(YAFFS_TRACE_ERROR,
0010cc  bf00              NOP      
0010ce  bf00              NOP      
;;;998    				(TSTR ("**>> yaffs chunk %d was not erased"
;;;999    				TENDSTR), chunk));
;;;1000                              
;;;1001   				/* try another chunk */
;;;1002   				continue;
0010d0  e01d              B        |L1.4366|
                  |L1.4306|
;;;1003   			}
;;;1004   			 
;;;1005   			bi->skipErasedCheck = 1;
0010d2  9800              LDR      r0,[sp,#0]
0010d4  6800              LDR      r0,[r0,#0]
0010d6  f0207000          BIC      r0,r0,#0x2000000
0010da  f1007000          ADD      r0,r0,#0x2000000
0010de  9900              LDR      r1,[sp,#0]
0010e0  6008              STR      r0,[r1,#0]
                  |L1.4322|
;;;1006   		}
;;;1007    
;;;1008   		writeOk = yaffs_WriteChunkWithTagsToNAND(dev, chunk,data, tags);
0010e2  464b              MOV      r3,r9
0010e4  4642              MOV      r2,r8
0010e6  4629              MOV      r1,r5
0010e8  4630              MOV      r0,r6
0010ea  f7fffffe          BL       yaffs_WriteChunkWithTagsToNAND
0010ee  4607              MOV      r7,r0
;;;1009   	 	
;;;1010   		if (writeOk != YAFFS_OK) {
0010f0  2f01              CMP      r7,#1
0010f2  d005              BEQ      |L1.4352|
;;;1011   			yaffs_HandleWriteChunkError(dev, chunk, erasedOk);
0010f4  465a              MOV      r2,r11
0010f6  4629              MOV      r1,r5
0010f8  4630              MOV      r0,r6
0010fa  f7fffffe          BL       yaffs_HandleWriteChunkError
;;;1012   			/* try another chunk */
;;;1013   			continue;
0010fe  e006              B        |L1.4366|
                  |L1.4352|
;;;1014   		}
;;;1015   
;;;1016   		/* Copy the data into the robustification buffer */
;;;1017   		yaffs_HandleWriteChunkOk(dev, chunk, data, tags);
001100  464b              MOV      r3,r9
001102  4642              MOV      r2,r8
001104  4629              MOV      r1,r5
001106  4630              MOV      r0,r6
001108  f7fffffe          BL       yaffs_HandleWriteChunkOk
00110c  bf00              NOP                            ;982
                  |L1.4366|
;;;1018    
;;;1019   	} while (writeOk != YAFFS_OK && (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
00110e  2f01              CMP      r7,#1
001110  d007              BEQ      |L1.4386|
001112  48f8              LDR      r0,|L1.5364|
001114  6800              LDR      r0,[r0,#0]  ; yaffs_wr_attempts
001116  2800              CMP      r0,#0
001118  d0b1              BEQ      |L1.4222|
00111a  48f6              LDR      r0,|L1.5364|
00111c  6800              LDR      r0,[r0,#0]  ; yaffs_wr_attempts
00111e  4284              CMP      r4,r0
001120  d9ad              BLS      |L1.4222|
                  |L1.4386|
001122  bf00              NOP                            ;955
;;;1020   	        
;;;1021    
;;;1022   	if(!writeOk)
001124  b90f              CBNZ     r7,|L1.4394|
;;;1023   		chunk = -1;
001126  f04f35ff          MOV      r5,#0xffffffff
                  |L1.4394|
;;;1024   
;;;1025   	if (attempts > 1) 
00112a  2c01              CMP      r4,#1
00112c  dd07              BLE      |L1.4414|
;;;1026   	{
;;;1027   		T(YAFFS_TRACE_ERROR,
00112e  bf00              NOP      
001130  bf00              NOP      
;;;1028   			(TSTR("**>> yaffs write required %d attempts" TENDSTR),
;;;1029   			attempts));
;;;1030   
;;;1031   		dev->nRetriedWrites += (attempts - 1);
001132  1e60              SUBS     r0,r4,#1
001134  f8d61d60          LDR      r1,[r6,#0xd60]
001138  4408              ADD      r0,r0,r1
00113a  f8c60d60          STR      r0,[r6,#0xd60]
                  |L1.4414|
;;;1032   	}
;;;1033   
;;;1034   	return chunk;
00113e  4628              MOV      r0,r5
;;;1035   }
001140  e8bd8ff8          POP      {r3-r11,pc}
;;;1036   
                          ENDP

                  yaffs_CalcNameSum PROC
;;;1135   
;;;1136   static __u16 yaffs_CalcNameSum(const YCHAR * name)
001144  b510              PUSH     {r4,lr}
;;;1137   {
001146  4602              MOV      r2,r0
;;;1138   	__u16 sum = 0;
001148  2000              MOVS     r0,#0
;;;1139   	__u16 i = 1;
00114a  2301              MOVS     r3,#1
;;;1140   
;;;1141   	const YUCHAR *bname = (const YUCHAR *) name;
00114c  4611              MOV      r1,r2
;;;1142   	if (bname) {
00114e  b159              CBZ      r1,|L1.4456|
;;;1143   		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {
001150  e006              B        |L1.4448|
                  |L1.4434|
;;;1144   
;;;1145   #ifdef CONFIG_YAFFS_CASE_INSENSITIVE
;;;1146   			sum += yaffs_toupper(*bname) * i;
;;;1147   #else
;;;1148   			sum += (*bname) * i;
001152  780c              LDRB     r4,[r1,#0]
001154  fb040403          MLA      r4,r4,r3,r0
001158  b2a0              UXTH     r0,r4
;;;1149   #endif
;;;1150   			i++;
00115a  1c5c              ADDS     r4,r3,#1
00115c  b2a3              UXTH     r3,r4
;;;1151   			bname++;
00115e  1c49              ADDS     r1,r1,#1
                  |L1.4448|
001160  780c              LDRB     r4,[r1,#0]            ;1143
001162  b10c              CBZ      r4,|L1.4456|
001164  2b7f              CMP      r3,#0x7f              ;1143
001166  dbf4              BLT      |L1.4434|
                  |L1.4456|
;;;1152   		}
;;;1153   	}
;;;1154   	return sum;
;;;1155   }
001168  bd10              POP      {r4,pc}
;;;1156   
                          ENDP

                  yaffs_SetObjectName PROC
;;;1157   static void yaffs_SetObjectName(yaffs_Object * obj, const YCHAR * name)
00116a  b570              PUSH     {r4-r6,lr}
;;;1158   {
00116c  4604              MOV      r4,r0
00116e  460d              MOV      r5,r1
;;;1159   #ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
;;;1160   	memset(obj->shortName,0,sizeof (YCHAR) * (YAFFS_SHORT_NAME_LENGTH+1)); 
;;;1161   	if (name && yaffs_strlen(name) <= YAFFS_SHORT_NAME_LENGTH) {
;;;1162   		yaffs_strcpy(obj->shortName, name);
;;;1163   	} else {
;;;1164   		obj->shortName[0] = _Y('\0');
;;;1165   	}
;;;1166   #endif
;;;1167   	obj->sum = yaffs_CalcNameSum(name);
001170  4628              MOV      r0,r5
001172  f7fffffe          BL       yaffs_CalcNameSum
001176  80a0              STRH     r0,[r4,#4]
;;;1168   }
001178  bd70              POP      {r4-r6,pc}
;;;1169   
                          ENDP

                  yaffs_CreateTnodes PROC
;;;1181   
;;;1182   static int yaffs_CreateTnodes(yaffs_Device * dev, int nTnodes)
00117a  e92d4ff8          PUSH     {r3-r11,lr}
;;;1183   {
00117e  4604              MOV      r4,r0
001180  460e              MOV      r6,r1
;;;1184   	int i;
;;;1185   	int tnodeSize;
;;;1186   	yaffs_Tnode *newTnodes;
;;;1187   	__u8 *mem;
;;;1188   	yaffs_Tnode *curr;
;;;1189   	yaffs_Tnode *next;
;;;1190   	yaffs_TnodeList *tnl;
;;;1191   
;;;1192   	if (nTnodes < 1)
001182  2e01              CMP      r6,#1
001184  da02              BGE      |L1.4492|
;;;1193   		return YAFFS_OK;
001186  2001              MOVS     r0,#1
                  |L1.4488|
;;;1194   		
;;;1195   	/* Calculate the tnode size in bytes for variable width tnode support.
;;;1196   	 * Must be a multiple of 32-bits  */
;;;1197   	tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
;;;1198   
;;;1199   	if(tnodeSize < sizeof(yaffs_Tnode))
;;;1200   		tnodeSize = sizeof(yaffs_Tnode);
;;;1201   		
;;;1202   
;;;1203   	/* make these things */
;;;1204   
;;;1205   	newTnodes = YMALLOC(nTnodes * tnodeSize);
;;;1206   	mem = (__u8 *)newTnodes;
;;;1207   
;;;1208   	if (!newTnodes) {
;;;1209   		T(YAFFS_TRACE_ERROR,
;;;1210   		  (TSTR("yaffs: Could not allocate Tnodes" TENDSTR)));
;;;1211   		return YAFFS_FAIL;
;;;1212   	}
;;;1213   
;;;1214   	/* Hook them into the free list */
;;;1215   #if 0
;;;1216   	for (i = 0; i < nTnodes - 1; i++) {
;;;1217   		newTnodes[i].internal[0] = &newTnodes[i + 1];
;;;1218   #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
;;;1219   		newTnodes[i].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
;;;1220   #endif
;;;1221   	}
;;;1222   
;;;1223   	newTnodes[nTnodes - 1].internal[0] = dev->freeTnodes;
;;;1224   #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
;;;1225   	newTnodes[nTnodes - 1].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
;;;1226   #endif
;;;1227   	dev->freeTnodes = newTnodes;
;;;1228   #else
;;;1229   	/* New hookup for wide tnodes */
;;;1230   	for(i = 0; i < nTnodes -1; i++) {
;;;1231   		curr = (yaffs_Tnode *) &mem[i * tnodeSize];
;;;1232   		next = (yaffs_Tnode *) &mem[(i+1) * tnodeSize];
;;;1233   		curr->internal[0] = next;
;;;1234   	}
;;;1235   	
;;;1236   	curr = (yaffs_Tnode *) &mem[(nTnodes - 1) * tnodeSize];
;;;1237   	curr->internal[0] = dev->freeTnodes;
;;;1238   	dev->freeTnodes = (yaffs_Tnode *)mem;
;;;1239   
;;;1240   #endif
;;;1241   
;;;1242   
;;;1243   	dev->nFreeTnodes += nTnodes;
;;;1244   	dev->nTnodesCreated += nTnodes;
;;;1245   
;;;1246   	/* Now add this bunch of tnodes to a list for freeing up.
;;;1247   	 * NB If we can't add this to the management list it isn't fatal
;;;1248   	 * but it just means we can't free this bunch of tnodes later.
;;;1249   	 */
;;;1250   	 
;;;1251   	tnl = YMALLOC(sizeof(yaffs_TnodeList));
;;;1252   	if (!tnl) {
;;;1253   		T(YAFFS_TRACE_ERROR,
;;;1254   		  (TSTR
;;;1255   		   ("yaffs: Could not add tnodes to management list" TENDSTR)));
;;;1256   		   return YAFFS_FAIL;
;;;1257   
;;;1258   	} else {
;;;1259   		tnl->tnodes = newTnodes;
;;;1260   		tnl->next = dev->allocatedTnodeList;
;;;1261   		dev->allocatedTnodeList = tnl;
;;;1262   	}
;;;1263   
;;;1264   	T(YAFFS_TRACE_ALLOCATE, (TSTR("yaffs: Tnodes added" TENDSTR)));
;;;1265   
;;;1266   	return YAFFS_OK;
;;;1267   }
001188  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.4492|
00118c  6fa0              LDR      r0,[r4,#0x78]         ;1197
00118e  0100              LSLS     r0,r0,#4              ;1197
001190  08c7              LSRS     r7,r0,#3              ;1197
001192  2f20              CMP      r7,#0x20              ;1199
001194  d200              BCS      |L1.4504|
001196  2720              MOVS     r7,#0x20              ;1200
                  |L1.4504|
001198  fb06f007          MUL      r0,r6,r7              ;1205
00119c  f7fffffe          BL       yaffs_malloc
0011a0  4682              MOV      r10,r0                ;1205
0011a2  4655              MOV      r5,r10                ;1206
0011a4  f1ba0f00          CMP      r10,#0                ;1208
0011a8  d103              BNE      |L1.4530|
0011aa  bf00              NOP                            ;1209
0011ac  bf00              NOP                            ;1209
0011ae  2000              MOVS     r0,#0                 ;1211
0011b0  e7ea              B        |L1.4488|
                  |L1.4530|
0011b2  f04f0900          MOV      r9,#0                 ;1230
0011b6  e00b              B        |L1.4560|
                  |L1.4536|
0011b8  fb095b07          MLA      r11,r9,r7,r5          ;1231
0011bc  f1090001          ADD      r0,r9,#1              ;1232
0011c0  fb005007          MLA      r0,r0,r7,r5           ;1232
0011c4  9000              STR      r0,[sp,#0]            ;1232
0011c6  9800              LDR      r0,[sp,#0]            ;1233
0011c8  f8cb0000          STR      r0,[r11,#0]           ;1233
0011cc  f1090901          ADD      r9,r9,#1              ;1230
                  |L1.4560|
0011d0  1e70              SUBS     r0,r6,#1              ;1230
0011d2  4548              CMP      r0,r9                 ;1230
0011d4  dcf0              BGT      |L1.4536|
0011d6  fb005b07          MLA      r11,r0,r7,r5          ;1236
0011da  f5047482          ADD      r4,r4,#0x104          ;1237
0011de  6860              LDR      r0,[r4,#4]            ;1237
0011e0  f8cb0000          STR      r0,[r11,#0]           ;1237
0011e4  6065              STR      r5,[r4,#4]            ;1238
0011e6  68a0              LDR      r0,[r4,#8]            ;1243
0011e8  4430              ADD      r0,r0,r6              ;1243
0011ea  60a0              STR      r0,[r4,#8]            ;1243
0011ec  6820              LDR      r0,[r4,#0]            ;1244
0011ee  4430              ADD      r0,r0,r6              ;1244
0011f0  6020              STR      r0,[r4,#0]            ;1244
0011f2  f5a47482          SUB      r4,r4,#0x104          ;1244
0011f6  2008              MOVS     r0,#8                 ;1251
0011f8  f7fffffe          BL       yaffs_malloc
0011fc  4680              MOV      r8,r0                 ;1251
0011fe  f1b80f00          CMP      r8,#0                 ;1252
001202  d103              BNE      |L1.4620|
001204  bf00              NOP                            ;1253
001206  bf00              NOP                            ;1253
001208  2000              MOVS     r0,#0                 ;1256
00120a  e7bd              B        |L1.4488|
                  |L1.4620|
00120c  f8c8a004          STR      r10,[r8,#4]           ;1259
001210  f8d40110          LDR      r0,[r4,#0x110]        ;1260
001214  f8c80000          STR      r0,[r8,#0]            ;1260
001218  f8c48110          STR      r8,[r4,#0x110]        ;1261
00121c  bf00              NOP                            ;1264
00121e  bf00              NOP                            ;1264
001220  2001              MOVS     r0,#1                 ;1266
001222  e7b1              B        |L1.4488|
;;;1268   
                          ENDP

                  yaffs_GetTnodeRaw PROC
;;;1270   
;;;1271   static yaffs_Tnode *yaffs_GetTnodeRaw(yaffs_Device * dev)
001224  b570              PUSH     {r4-r6,lr}
;;;1272   {
001226  4604              MOV      r4,r0
;;;1273   	yaffs_Tnode *tn = NULL;
001228  2500              MOVS     r5,#0
;;;1274   
;;;1275   	/* If there are none left make more */
;;;1276   	if (!dev->freeTnodes) {
00122a  f8d40108          LDR      r0,[r4,#0x108]
00122e  b918              CBNZ     r0,|L1.4664|
;;;1277   		yaffs_CreateTnodes(dev, YAFFS_ALLOCATION_NTNODES);
001230  2164              MOVS     r1,#0x64
001232  4620              MOV      r0,r4
001234  f7fffffe          BL       yaffs_CreateTnodes
                  |L1.4664|
;;;1278   	}
;;;1279   
;;;1280   	if (dev->freeTnodes) {
001238  f8d40108          LDR      r0,[r4,#0x108]
00123c  b150              CBZ      r0,|L1.4692|
;;;1281   		tn = dev->freeTnodes;
00123e  f5047484          ADD      r4,r4,#0x108
001242  6825              LDR      r5,[r4,#0]
;;;1282   #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
;;;1283   		if (tn->internal[YAFFS_NTNODES_INTERNAL] != (void *)1) {
;;;1284   			/* Hoosterman, this thing looks like it isn't in the list */
;;;1285   			T(YAFFS_TRACE_ALWAYS,
;;;1286   			  (TSTR("yaffs: Tnode list bug 1" TENDSTR)));
;;;1287   		}
;;;1288   #endif
;;;1289   		dev->freeTnodes = dev->freeTnodes->internal[0];
001244  6820              LDR      r0,[r4,#0]
001246  6800              LDR      r0,[r0,#0]
001248  6020              STR      r0,[r4,#0]
;;;1290   		dev->nFreeTnodes--;
00124a  6860              LDR      r0,[r4,#4]
00124c  1e40              SUBS     r0,r0,#1
00124e  6060              STR      r0,[r4,#4]
001250  f5a47484          SUB      r4,r4,#0x108
                  |L1.4692|
;;;1291   	}
;;;1292   
;;;1293   	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
001254  2000              MOVS     r0,#0
001256  f8c400e0          STR      r0,[r4,#0xe0]
;;;1294   
;;;1295   	return tn;
00125a  4628              MOV      r0,r5
;;;1296   }
00125c  bd70              POP      {r4-r6,pc}
;;;1297   
                          ENDP

                  yaffs_GetTnode PROC
;;;1298   static yaffs_Tnode *yaffs_GetTnode(yaffs_Device * dev)
00125e  b570              PUSH     {r4-r6,lr}
;;;1299   {
001260  4604              MOV      r4,r0
;;;1300   	yaffs_Tnode *tn = yaffs_GetTnodeRaw(dev);
001262  4620              MOV      r0,r4
001264  f7fffffe          BL       yaffs_GetTnodeRaw
001268  4605              MOV      r5,r0
;;;1301   	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
00126a  6fa0              LDR      r0,[r4,#0x78]
00126c  0100              LSLS     r0,r0,#4
00126e  08c6              LSRS     r6,r0,#3
;;;1302   
;;;1303   	if(tnodeSize < sizeof(yaffs_Tnode))
001270  2e20              CMP      r6,#0x20
001272  d200              BCS      |L1.4726|
;;;1304   		tnodeSize = sizeof(yaffs_Tnode);
001274  2620              MOVS     r6,#0x20
                  |L1.4726|
;;;1305   	
;;;1306   	if(tn)
001276  b11d              CBZ      r5,|L1.4736|
;;;1307   		memset(tn, 0, tnodeSize);
001278  4631              MOV      r1,r6
00127a  4628              MOV      r0,r5
00127c  f7fffffe          BL       __aeabi_memclr4
                  |L1.4736|
;;;1308   
;;;1309   	return tn;	
001280  4628              MOV      r0,r5
;;;1310   }
001282  bd70              POP      {r4-r6,pc}
;;;1311   
                          ENDP

                  yaffs_FreeTnode PROC
;;;1312   /* FreeTnode frees up a tnode and puts it back on the free list */
;;;1313   static void yaffs_FreeTnode(yaffs_Device * dev, yaffs_Tnode * tn)
001284  b149              CBZ      r1,|L1.4762|
;;;1314   {
;;;1315   	if (tn) {
;;;1316   #ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
;;;1317   		if (tn->internal[YAFFS_NTNODES_INTERNAL] != 0) {
;;;1318   			/* Hoosterman, this thing looks like it is already in the list */
;;;1319   			T(YAFFS_TRACE_ALWAYS,
;;;1320   			  (TSTR("yaffs: Tnode list bug 2" TENDSTR)));
;;;1321   		}
;;;1322   		tn->internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
;;;1323   #endif
;;;1324   		tn->internal[0] = dev->freeTnodes;
001286  f8d02108          LDR      r2,[r0,#0x108]
00128a  600a              STR      r2,[r1,#0]
;;;1325   		dev->freeTnodes = tn;
00128c  f8c01108          STR      r1,[r0,#0x108]
;;;1326   		dev->nFreeTnodes++;
001290  f8d0210c          LDR      r2,[r0,#0x10c]
001294  1c52              ADDS     r2,r2,#1
001296  f8c0210c          STR      r2,[r0,#0x10c]
                  |L1.4762|
;;;1327   	}
;;;1328   	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
00129a  2200              MOVS     r2,#0
00129c  f8c020e0          STR      r2,[r0,#0xe0]
;;;1329   	
;;;1330   }
0012a0  4770              BX       lr
;;;1331   
                          ENDP

                  yaffs_DeinitialiseTnodes PROC
;;;1332   static void yaffs_DeinitialiseTnodes(yaffs_Device * dev)
0012a2  b570              PUSH     {r4-r6,lr}
;;;1333   {
0012a4  4604              MOV      r4,r0
;;;1334   	/* Free the list of allocated tnodes */
;;;1335   	yaffs_TnodeList *tmp;
;;;1336   
;;;1337   	while (dev->allocatedTnodeList) {
0012a6  e00d              B        |L1.4804|
                  |L1.4776|
;;;1338   		tmp = dev->allocatedTnodeList->next;
0012a8  f8d40110          LDR      r0,[r4,#0x110]
0012ac  6805              LDR      r5,[r0,#0]
;;;1339   
;;;1340   		YFREE(dev->allocatedTnodeList->tnodes);
0012ae  f8d41110          LDR      r1,[r4,#0x110]
0012b2  6848              LDR      r0,[r1,#4]
0012b4  f7fffffe          BL       free
;;;1341   		YFREE(dev->allocatedTnodeList);
0012b8  f8d40110          LDR      r0,[r4,#0x110]
0012bc  f7fffffe          BL       free
;;;1342   		dev->allocatedTnodeList = tmp;
0012c0  f8c45110          STR      r5,[r4,#0x110]
                  |L1.4804|
0012c4  f8d40110          LDR      r0,[r4,#0x110]        ;1337
0012c8  2800              CMP      r0,#0                 ;1337
0012ca  d1ed              BNE      |L1.4776|
;;;1343   
;;;1344   	}
;;;1345   
;;;1346   	dev->freeTnodes = NULL;
0012cc  f8c40108          STR      r0,[r4,#0x108]
;;;1347   	dev->nFreeTnodes = 0;
0012d0  f8c4010c          STR      r0,[r4,#0x10c]
;;;1348   }
0012d4  bd70              POP      {r4-r6,pc}
;;;1349   
                          ENDP

                  yaffs_InitialiseTnodes PROC
;;;1350   static void yaffs_InitialiseTnodes(yaffs_Device * dev)
0012d6  2100              MOVS     r1,#0
;;;1351   {
;;;1352   	dev->allocatedTnodeList = NULL;
0012d8  f8c01110          STR      r1,[r0,#0x110]
;;;1353   	dev->freeTnodes = NULL;
0012dc  f8c01108          STR      r1,[r0,#0x108]
;;;1354   	dev->nFreeTnodes = 0;
0012e0  f8c0110c          STR      r1,[r0,#0x10c]
;;;1355   	dev->nTnodesCreated = 0;
0012e4  f8c01104          STR      r1,[r0,#0x104]
;;;1356   
;;;1357   }
0012e8  4770              BX       lr
;;;1358   
                          ENDP

                  yaffs_PutLevel0Tnode PROC
;;;1359   
;;;1360   void yaffs_PutLevel0Tnode(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos, unsigned val)
0012ea  e92d43f0          PUSH     {r4-r9,lr}
;;;1361   {
0012ee  4604              MOV      r4,r0
0012f0  460d              MOV      r5,r1
0012f2  4617              MOV      r7,r2
;;;1362     __u32 *map = (__u32 *)tn;
0012f4  4629              MOV      r1,r5
;;;1363     __u32 bitInMap;
;;;1364     __u32 bitInWord;
;;;1365     __u32 wordInMap;
;;;1366     __u32 mask;
;;;1367     
;;;1368     pos &= YAFFS_TNODES_LEVEL0_MASK;
0012f6  f007070f          AND      r7,r7,#0xf
;;;1369     val >>= dev->chunkGroupBits;
0012fa  f8948072          LDRB     r8,[r4,#0x72]
0012fe  fa23f308          LSR      r3,r3,r8
;;;1370     
;;;1371     bitInMap = pos * dev->tnodeWidth;
001302  f8d48078          LDR      r8,[r4,#0x78]
001306  fb08fc07          MUL      r12,r8,r7
;;;1372     wordInMap = bitInMap /32;
00130a  ea4f105c          LSR      r0,r12,#5
;;;1373     bitInWord = bitInMap & (32 -1);
00130e  f00c021f          AND      r2,r12,#0x1f
;;;1374     
;;;1375     mask = dev->tnodeMask << bitInWord;
001312  f8d4807c          LDR      r8,[r4,#0x7c]
001316  fa08f602          LSL      r6,r8,r2
;;;1376     
;;;1377     map[wordInMap] &= ~mask;
00131a  f8518020          LDR      r8,[r1,r0,LSL #2]
00131e  ea280806          BIC      r8,r8,r6
001322  f8418020          STR      r8,[r1,r0,LSL #2]
;;;1378     map[wordInMap] |= (mask & (val << bitInWord));
001326  f8519020          LDR      r9,[r1,r0,LSL #2]
00132a  fa03f802          LSL      r8,r3,r2
00132e  ea080806          AND      r8,r8,r6
001332  ea490908          ORR      r9,r9,r8
001336  f8419020          STR      r9,[r1,r0,LSL #2]
;;;1379     
;;;1380     if(dev->tnodeWidth > (32-bitInWord)) {
00133a  f1c20920          RSB      r9,r2,#0x20
00133e  f8d48078          LDR      r8,[r4,#0x78]
001342  45c8              CMP      r8,r9
001344  d916              BLS      |L1.4980|
;;;1381       bitInWord = (32 - bitInWord);
001346  f1c20220          RSB      r2,r2,#0x20
;;;1382       wordInMap++;;
00134a  1c40              ADDS     r0,r0,#1
;;;1383       mask = dev->tnodeMask >> (/*dev->tnodeWidth -*/ bitInWord);
00134c  f8d4807c          LDR      r8,[r4,#0x7c]
001350  fa28f602          LSR      r6,r8,r2
;;;1384       map[wordInMap] &= ~mask;
001354  f8518020          LDR      r8,[r1,r0,LSL #2]
001358  ea280806          BIC      r8,r8,r6
00135c  f8418020          STR      r8,[r1,r0,LSL #2]
;;;1385       map[wordInMap] |= (mask & (val >> bitInWord));
001360  f8519020          LDR      r9,[r1,r0,LSL #2]
001364  fa23f802          LSR      r8,r3,r2
001368  ea080806          AND      r8,r8,r6
00136c  ea490908          ORR      r9,r9,r8
001370  f8419020          STR      r9,[r1,r0,LSL #2]
                  |L1.4980|
;;;1386     }
;;;1387   }
001374  e8bd83f0          POP      {r4-r9,pc}
;;;1388   
                          ENDP

                  yaffs_AddOrFindLevel0Tnode PROC
;;;1484    
;;;1485   static yaffs_Tnode *yaffs_AddOrFindLevel0Tnode(yaffs_Device * dev,
001378  e92d5fff          PUSH     {r0-r12,lr}
;;;1486   					       yaffs_FileStructure * fStruct,
;;;1487   					       __u32 chunkId,
;;;1488   					       yaffs_Tnode *passedTn)
;;;1489   {
00137c  460e              MOV      r6,r1
00137e  4692              MOV      r10,r2
001380  4698              MOV      r8,r3
;;;1490   
;;;1491   	int requiredTallness;
;;;1492   	int i;
;;;1493   	int l;
;;;1494   	yaffs_Tnode *tn;
;;;1495   
;;;1496   	__u32 x;
;;;1497   
;;;1498   
;;;1499   	/* Check sane level and page Id */
;;;1500   	if (fStruct->topLevel < 0 || fStruct->topLevel > YAFFS_TNODES_MAX_LEVEL) {
001382  68f0              LDR      r0,[r6,#0xc]
001384  2800              CMP      r0,#0
001386  db02              BLT      |L1.5006|
001388  68f0              LDR      r0,[r6,#0xc]
00138a  2806              CMP      r0,#6
00138c  dd03              BLE      |L1.5014|
                  |L1.5006|
;;;1501   		return NULL;
00138e  2000              MOVS     r0,#0
                  |L1.5008|
;;;1502   	}
;;;1503   
;;;1504   	if (chunkId > YAFFS_MAX_CHUNK_ID) {
;;;1505   		return NULL;
;;;1506   	}
;;;1507   
;;;1508   	/* First check we're tall enough (ie enough topLevel) */
;;;1509   
;;;1510   	x = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
;;;1511   	requiredTallness = 0;
;;;1512   	while (x) {
;;;1513   		x >>= YAFFS_TNODES_INTERNAL_BITS;
;;;1514   		requiredTallness++;
;;;1515   	}
;;;1516   
;;;1517   
;;;1518   	if (requiredTallness > fStruct->topLevel) {
;;;1519   		/* Not tall enough,gotta make the tree taller */
;;;1520   		for (i = fStruct->topLevel; i < requiredTallness; i++) {
;;;1521   		
;;;1522   			tn = yaffs_GetTnode(dev);
;;;1523   
;;;1524   			if (tn) {
;;;1525   				tn->internal[0] = fStruct->top;
;;;1526   				fStruct->top = tn;
;;;1527   			} else {
;;;1528   				T(YAFFS_TRACE_ERROR,
;;;1529   				  (TSTR("yaffs: no more tnodes" TENDSTR)));
;;;1530   			}
;;;1531   		}
;;;1532   
;;;1533   		fStruct->topLevel = requiredTallness;
;;;1534   	}
;;;1535   
;;;1536   	/* Traverse down to level 0, adding anything we need */
;;;1537   
;;;1538   	l = fStruct->topLevel;
;;;1539   	tn = fStruct->top;
;;;1540   	
;;;1541   	if(l > 0) {
;;;1542   		while (l > 0 && tn) {
;;;1543   			x = (chunkId >>
;;;1544   			     ( YAFFS_TNODES_LEVEL0_BITS +
;;;1545   			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
;;;1546   			    YAFFS_TNODES_INTERNAL_MASK;
;;;1547   
;;;1548   
;;;1549   			if((l>1) && !tn->internal[x]){
;;;1550   				/* Add missing non-level-zero tnode */
;;;1551   				tn->internal[x] = yaffs_GetTnode(dev);
;;;1552   
;;;1553   			} else if(l == 1) {
;;;1554   				/* Looking from level 1 at level 0 */
;;;1555   			 	if (passedTn) {
;;;1556   					/* If we already have one, then release it.*/
;;;1557   					if(tn->internal[x])
;;;1558   						yaffs_FreeTnode(dev,tn->internal[x]);
;;;1559   					tn->internal[x] = passedTn;
;;;1560   			
;;;1561   				} else if(!tn->internal[x]) {
;;;1562   					/* Don't have one, none passed in */
;;;1563   					tn->internal[x] = yaffs_GetTnode(dev);
;;;1564   				}
;;;1565   			}
;;;1566   		
;;;1567   			tn = tn->internal[x];
;;;1568   			l--;
;;;1569   		}
;;;1570   	} else {
;;;1571   		/* top is level 0 */
;;;1572   		if(passedTn) {
;;;1573   			memcpy(tn,passedTn,(dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8);
;;;1574   			yaffs_FreeTnode(dev,passedTn);
;;;1575   		}
;;;1576   	}
;;;1577   
;;;1578   	return tn;
;;;1579   }
001390  b004              ADD      sp,sp,#0x10
001392  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.5014|
001396  f5ba1f80          CMP      r10,#0x100000         ;1504
00139a  d301              BCC      |L1.5024|
00139c  2000              MOVS     r0,#0                 ;1505
00139e  e7f7              B        |L1.5008|
                  |L1.5024|
0013a0  ea4f151a          LSR      r5,r10,#4             ;1510
0013a4  f04f0900          MOV      r9,#0                 ;1511
0013a8  e002              B        |L1.5040|
                  |L1.5034|
0013aa  08ed              LSRS     r5,r5,#3              ;1513
0013ac  f1090901          ADD      r9,r9,#1              ;1514
                  |L1.5040|
0013b0  2d00              CMP      r5,#0                 ;1512
0013b2  d1fa              BNE      |L1.5034|
0013b4  68f0              LDR      r0,[r6,#0xc]          ;1518
0013b6  4548              CMP      r0,r9                 ;1518
0013b8  da13              BGE      |L1.5090|
0013ba  f8d6b00c          LDR      r11,[r6,#0xc]         ;1520
0013be  e00c              B        |L1.5082|
                  |L1.5056|
0013c0  9800              LDR      r0,[sp,#0]            ;1522
0013c2  f7fffffe          BL       yaffs_GetTnode
0013c6  4604              MOV      r4,r0                 ;1522
0013c8  b11c              CBZ      r4,|L1.5074|
0013ca  6930              LDR      r0,[r6,#0x10]         ;1525
0013cc  6020              STR      r0,[r4,#0]            ;1525
0013ce  6134              STR      r4,[r6,#0x10]         ;1526
0013d0  e001              B        |L1.5078|
                  |L1.5074|
0013d2  bf00              NOP                            ;1528
0013d4  bf00              NOP                            ;1528
                  |L1.5078|
0013d6  f10b0b01          ADD      r11,r11,#1            ;1520
                  |L1.5082|
0013da  45cb              CMP      r11,r9                ;1520
0013dc  dbf0              BLT      |L1.5056|
0013de  f8c6900c          STR      r9,[r6,#0xc]          ;1533
                  |L1.5090|
0013e2  68f7              LDR      r7,[r6,#0xc]          ;1538
0013e4  6934              LDR      r4,[r6,#0x10]         ;1539
0013e6  2f00              CMP      r7,#0                 ;1541
0013e8  dd33              BLE      |L1.5202|
0013ea  e02d              B        |L1.5192|
                  |L1.5100|
0013ec  1e78              SUBS     r0,r7,#1              ;1543
0013ee  eb000040          ADD      r0,r0,r0,LSL #1       ;1543
0013f2  1d00              ADDS     r0,r0,#4              ;1543
0013f4  fa2af000          LSR      r0,r10,r0             ;1543
0013f8  f0000507          AND      r5,r0,#7              ;1543
0013fc  2f01              CMP      r7,#1                 ;1549
0013fe  dd08              BLE      |L1.5138|
001400  f8540025          LDR      r0,[r4,r5,LSL #2]     ;1549
001404  b928              CBNZ     r0,|L1.5138|
001406  9800              LDR      r0,[sp,#0]            ;1551
001408  f7fffffe          BL       yaffs_GetTnode
00140c  f8440025          STR      r0,[r4,r5,LSL #2]     ;1551
001410  e017              B        |L1.5186|
                  |L1.5138|
001412  2f01              CMP      r7,#1                 ;1553
001414  d115              BNE      |L1.5186|
001416  f1b80f00          CMP      r8,#0                 ;1555
00141a  d00a              BEQ      |L1.5170|
00141c  f8540025          LDR      r0,[r4,r5,LSL #2]     ;1557
001420  b120              CBZ      r0,|L1.5164|
001422  f8541025          LDR      r1,[r4,r5,LSL #2]     ;1558
001426  9800              LDR      r0,[sp,#0]            ;1558
001428  f7fffffe          BL       yaffs_FreeTnode
                  |L1.5164|
00142c  f8448025          STR      r8,[r4,r5,LSL #2]     ;1559
001430  e007              B        |L1.5186|
                  |L1.5170|
001432  f8540025          LDR      r0,[r4,r5,LSL #2]     ;1561
001436  b920              CBNZ     r0,|L1.5186|
001438  9800              LDR      r0,[sp,#0]            ;1563
00143a  f7fffffe          BL       yaffs_GetTnode
00143e  f8440025          STR      r0,[r4,r5,LSL #2]     ;1563
                  |L1.5186|
001442  f8544025          LDR      r4,[r4,r5,LSL #2]     ;1567
001446  1e7f              SUBS     r7,r7,#1              ;1568
                  |L1.5192|
001448  2f00              CMP      r7,#0                 ;1542
00144a  dd11              BLE      |L1.5232|
00144c  2c00              CMP      r4,#0                 ;1542
00144e  d1cd              BNE      |L1.5100|
001450  e00e              B        |L1.5232|
                  |L1.5202|
001452  f1b80f00          CMP      r8,#0                 ;1572
001456  d00b              BEQ      |L1.5232|
001458  9800              LDR      r0,[sp,#0]            ;1573
00145a  6f80              LDR      r0,[r0,#0x78]         ;1573
00145c  0100              LSLS     r0,r0,#4              ;1573
00145e  08c2              LSRS     r2,r0,#3              ;1573
001460  4641              MOV      r1,r8                 ;1573
001462  4620              MOV      r0,r4                 ;1573
001464  f7fffffe          BL       __aeabi_memcpy4
001468  4641              MOV      r1,r8                 ;1574
00146a  9800              LDR      r0,[sp,#0]            ;1574
00146c  f7fffffe          BL       yaffs_FreeTnode
                  |L1.5232|
001470  4620              MOV      r0,r4                 ;1578
001472  e78d              B        |L1.5008|
;;;1580   
                          ENDP

                  yaffs_TagsMatch PROC
;;;3356   
;;;3357   static int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,
001474  4603              MOV      r3,r0
;;;3358   			   int chunkInObject)
;;;3359   {
;;;3360   	return (tags->chunkId == chunkInObject &&
001476  68d8              LDR      r0,[r3,#0xc]
001478  4290              CMP      r0,r2
00147a  d106              BNE      |L1.5258|
;;;3361   		tags->objectId == objectId && !tags->chunkDeleted) ? 1 : 0;
00147c  6898              LDR      r0,[r3,#8]
00147e  4288              CMP      r0,r1
001480  d103              BNE      |L1.5258|
001482  69d8              LDR      r0,[r3,#0x1c]
001484  b908              CBNZ     r0,|L1.5258|
001486  2001              MOVS     r0,#1
                  |L1.5256|
;;;3362   
;;;3363   }
001488  4770              BX       lr
                  |L1.5258|
00148a  2000              MOVS     r0,#0                 ;3361
00148c  e7fc              B        |L1.5256|
;;;3364   
                          ENDP

                  yaffs_FindChunkInGroup PROC
;;;1580   
;;;1581   static int yaffs_FindChunkInGroup(yaffs_Device * dev, int theChunk,
00148e  e92d5ff0          PUSH     {r4-r12,lr}
;;;1582   				  yaffs_ExtendedTags * tags, int objectId,
;;;1583   				  int chunkInInode)
;;;1584   {
001492  4605              MOV      r5,r0
001494  460c              MOV      r4,r1
001496  4616              MOV      r6,r2
001498  461f              MOV      r7,r3
00149a  f8dd9028          LDR      r9,[sp,#0x28]
;;;1585   	int j;
;;;1586   
;;;1587   	for (j = 0; theChunk && j < dev->chunkGroupSize; j++) {
00149e  f04f0800          MOV      r8,#0
0014a2  e01e              B        |L1.5346|
                  |L1.5284|
;;;1588   		if (yaffs_CheckChunkBit
0014a4  6928              LDR      r0,[r5,#0x10]
0014a6  fb94f1f0          SDIV     r1,r4,r0
0014aa  fb004a11          MLS      r10,r0,r1,r4
0014ae  fb94fbf0          SDIV     r11,r4,r0
0014b2  4652              MOV      r2,r10
0014b4  4659              MOV      r1,r11
0014b6  4628              MOV      r0,r5
0014b8  f7fffffe          BL       yaffs_CheckChunkBit
0014bc  b170              CBZ      r0,|L1.5340|
;;;1589   		    (dev, theChunk / dev->nChunksPerBlock,
;;;1590   		     theChunk % dev->nChunksPerBlock)) {
;;;1591   			yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,
0014be  4633              MOV      r3,r6
0014c0  2200              MOVS     r2,#0
0014c2  4621              MOV      r1,r4
0014c4  4628              MOV      r0,r5
0014c6  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
;;;1592   							tags);
;;;1593   			if (yaffs_TagsMatch(tags, objectId, chunkInInode)) {
0014ca  464a              MOV      r2,r9
0014cc  4639              MOV      r1,r7
0014ce  4630              MOV      r0,r6
0014d0  f7fffffe          BL       yaffs_TagsMatch
0014d4  b110              CBZ      r0,|L1.5340|
;;;1594   				/* found it; */
;;;1595   				return theChunk;
0014d6  4620              MOV      r0,r4
                  |L1.5336|
;;;1596   
;;;1597   			}
;;;1598   		}
;;;1599   		theChunk++;
;;;1600   	}
;;;1601   	return -1;
;;;1602   }
0014d8  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.5340|
0014dc  1c64              ADDS     r4,r4,#1              ;1599
0014de  f1080801          ADD      r8,r8,#1              ;1587
                  |L1.5346|
0014e2  b11c              CBZ      r4,|L1.5356|
0014e4  f8b50074          LDRH     r0,[r5,#0x74]         ;1587
0014e8  4540              CMP      r0,r8                 ;1587
0014ea  dcdb              BGT      |L1.5284|
                  |L1.5356|
0014ec  f04f30ff          MOV      r0,#0xffffffff        ;1601
0014f0  e7f2              B        |L1.5336|
0014f2  0000              DCW      0x0000
                  |L1.5364|
                          DCD      yaffs_wr_attempts
                          ENDP

                  yaffs_DeleteWorker PROC
;;;1610   
;;;1611   static int yaffs_DeleteWorker(yaffs_Object * in, yaffs_Tnode * tn, __u32 level,
0014f8  e92d4ff0          PUSH     {r4-r11,lr}
;;;1612   			      int chunkOffset, int *limit)
;;;1613   {
0014fc  b097              SUB      sp,sp,#0x5c
0014fe  4607              MOV      r7,r0
001500  460e              MOV      r6,r1
001502  4690              MOV      r8,r2
001504  469b              MOV      r11,r3
001506  9d20              LDR      r5,[sp,#0x80]
;;;1614   	int i;
;;;1615   	int chunkInInode;
;;;1616   	int theChunk;
;;;1617   	yaffs_ExtendedTags tags;
;;;1618   	int foundChunk;
;;;1619   	yaffs_Device *dev = in->myDev;
001508  68b8              LDR      r0,[r7,#8]
00150a  9003              STR      r0,[sp,#0xc]
;;;1620   
;;;1621   	int allDone = 1;
00150c  2001              MOVS     r0,#1
00150e  9002              STR      r0,[sp,#8]
;;;1622   
;;;1623   	if (tn) {
001510  2e00              CMP      r6,#0
001512  d072              BEQ      |L1.5626|
;;;1624   		if (level > 0) {
001514  f1b80f00          CMP      r8,#0
001518  d02d              BEQ      |L1.5494|
;;;1625   
;;;1626   			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
00151a  2407              MOVS     r4,#7
00151c  e01f              B        |L1.5470|
                  |L1.5406|
;;;1627   			     i--) {
;;;1628   				if (tn->internal[i]) {
00151e  f8560024          LDR      r0,[r6,r4,LSL #2]
001522  b1d8              CBZ      r0,|L1.5468|
;;;1629   					if (limit && (*limit) < 0) {
001524  b12d              CBZ      r5,|L1.5426|
001526  6828              LDR      r0,[r5,#0]
001528  2800              CMP      r0,#0
00152a  da02              BGE      |L1.5426|
;;;1630   						allDone = 0;
00152c  2000              MOVS     r0,#0
00152e  9002              STR      r0,[sp,#8]
001530  e00a              B        |L1.5448|
                  |L1.5426|
;;;1631   					} else {
;;;1632   						allDone =
001532  eb0403cb          ADD      r3,r4,r11,LSL #3
001536  f1a80201          SUB      r2,r8,#1
00153a  9500              STR      r5,[sp,#0]
00153c  f8561024          LDR      r1,[r6,r4,LSL #2]
001540  4638              MOV      r0,r7
001542  f7fffffe          BL       yaffs_DeleteWorker
001546  9002              STR      r0,[sp,#8]
                  |L1.5448|
;;;1633   						    yaffs_DeleteWorker(in,
;;;1634   								       tn->
;;;1635   								       internal
;;;1636   								       [i],
;;;1637   								       level -
;;;1638   								       1,
;;;1639   								       (chunkOffset
;;;1640   									<<
;;;1641   									YAFFS_TNODES_INTERNAL_BITS)
;;;1642   								       + i,
;;;1643   								       limit);
;;;1644   					}
;;;1645   					if (allDone) {
001548  9802              LDR      r0,[sp,#8]
00154a  b138              CBZ      r0,|L1.5468|
;;;1646   						yaffs_FreeTnode(dev,
00154c  f8561024          LDR      r1,[r6,r4,LSL #2]
001550  9803              LDR      r0,[sp,#0xc]
001552  f7fffffe          BL       yaffs_FreeTnode
;;;1647   								tn->
;;;1648   								internal[i]);
;;;1649   						tn->internal[i] = NULL;
001556  2000              MOVS     r0,#0
001558  f8460024          STR      r0,[r6,r4,LSL #2]
                  |L1.5468|
00155c  1e64              SUBS     r4,r4,#1              ;1627
                  |L1.5470|
00155e  9802              LDR      r0,[sp,#8]            ;1626
001560  b108              CBZ      r0,|L1.5478|
001562  2c00              CMP      r4,#0                 ;1626
001564  dadb              BGE      |L1.5406|
                  |L1.5478|
;;;1650   					}
;;;1651   				}
;;;1652   
;;;1653   			}
;;;1654   			return (allDone) ? 1 : 0;
001566  9802              LDR      r0,[sp,#8]
001568  b118              CBZ      r0,|L1.5490|
00156a  2001              MOVS     r0,#1
                  |L1.5484|
;;;1655   		} else if (level == 0) {
;;;1656   			int hitLimit = 0;
;;;1657   
;;;1658   			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;
;;;1659   			     i--) {
;;;1660   			        theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
;;;1661   				if (theChunk) {
;;;1662   
;;;1663   					chunkInInode =
;;;1664   					    (chunkOffset <<
;;;1665   					     YAFFS_TNODES_LEVEL0_BITS) + i;
;;;1666   
;;;1667   					foundChunk =
;;;1668   					    yaffs_FindChunkInGroup(dev,
;;;1669   								   theChunk,
;;;1670   								   &tags,
;;;1671   								   in->objectId,
;;;1672   								   chunkInInode);
;;;1673   
;;;1674   					if (foundChunk > 0) {
;;;1675   						yaffs_DeleteChunk(dev,
;;;1676   								  foundChunk, 1,
;;;1677   								  __LINE__);
;;;1678   						in->nDataChunks--;
;;;1679   						if (limit) {
;;;1680   							*limit = *limit - 1;
;;;1681   							if (*limit <= 0) {
;;;1682   								hitLimit = 1;
;;;1683   							}
;;;1684   						}
;;;1685   
;;;1686   					}
;;;1687   
;;;1688   					yaffs_PutLevel0Tnode(dev,tn,i,0);
;;;1689   				}
;;;1690   
;;;1691   			}
;;;1692   			return (i < 0) ? 1 : 0;
;;;1693   
;;;1694   		}
;;;1695   
;;;1696   	}
;;;1697   
;;;1698   	return 1;
;;;1699   
;;;1700   }
00156c  b017              ADD      sp,sp,#0x5c
00156e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.5490|
001572  2000              MOVS     r0,#0                 ;1654
001574  e7fa              B        |L1.5484|
                  |L1.5494|
001576  f1b80f00          CMP      r8,#0                 ;1655
00157a  d13d              BNE      |L1.5624|
00157c  2000              MOVS     r0,#0                 ;1656
00157e  9001              STR      r0,[sp,#4]            ;1656
001580  240f              MOVS     r4,#0xf               ;1658
001582  e031              B        |L1.5608|
                  |L1.5508|
001584  4622              MOV      r2,r4                 ;1660
001586  4631              MOV      r1,r6                 ;1660
001588  9803              LDR      r0,[sp,#0xc]          ;1660
00158a  f7fffffe          BL       yaffs_GetChunkGroupBase
00158e  4681              MOV      r9,r0                 ;1660
001590  f1b90f00          CMP      r9,#0                 ;1661
001594  d027              BEQ      |L1.5606|
001596  eb04100b          ADD      r0,r4,r11,LSL #4      ;1663
00159a  9016              STR      r0,[sp,#0x58]         ;1663
00159c  9816              LDR      r0,[sp,#0x58]         ;1667
00159e  9000              STR      r0,[sp,#0]            ;1667
0015a0  aa04              ADD      r2,sp,#0x10           ;1667
0015a2  4649              MOV      r1,r9                 ;1667
0015a4  6b3b              LDR      r3,[r7,#0x30]         ;1667
0015a6  9803              LDR      r0,[sp,#0xc]          ;1667
0015a8  f7fffffe          BL       yaffs_FindChunkInGroup
0015ac  4682              MOV      r10,r0                ;1667
0015ae  f1ba0f00          CMP      r10,#0                ;1674
0015b2  dd12              BLE      |L1.5594|
0015b4  f240638d          MOV      r3,#0x68d             ;1675
0015b8  2201              MOVS     r2,#1                 ;1675
0015ba  4651              MOV      r1,r10                ;1675
0015bc  9803              LDR      r0,[sp,#0xc]          ;1675
0015be  f7fffffe          BL       yaffs_DeleteChunk
0015c2  6af8              LDR      r0,[r7,#0x2c]         ;1678
0015c4  1e40              SUBS     r0,r0,#1              ;1678
0015c6  62f8              STR      r0,[r7,#0x2c]         ;1678
0015c8  b13d              CBZ      r5,|L1.5594|
0015ca  6828              LDR      r0,[r5,#0]            ;1680
0015cc  1e40              SUBS     r0,r0,#1              ;1680
0015ce  6028              STR      r0,[r5,#0]            ;1680
0015d0  6828              LDR      r0,[r5,#0]            ;1681
0015d2  2800              CMP      r0,#0                 ;1681
0015d4  dc01              BGT      |L1.5594|
0015d6  2001              MOVS     r0,#1                 ;1682
0015d8  9001              STR      r0,[sp,#4]            ;1682
                  |L1.5594|
0015da  2300              MOVS     r3,#0                 ;1688
0015dc  4622              MOV      r2,r4                 ;1688
0015de  4631              MOV      r1,r6                 ;1688
0015e0  9803              LDR      r0,[sp,#0xc]          ;1688
0015e2  f7fffffe          BL       yaffs_PutLevel0Tnode
                  |L1.5606|
0015e6  1e64              SUBS     r4,r4,#1              ;1659
                  |L1.5608|
0015e8  2c00              CMP      r4,#0                 ;1658
0015ea  db02              BLT      |L1.5618|
0015ec  9801              LDR      r0,[sp,#4]            ;1658
0015ee  2800              CMP      r0,#0                 ;1658
0015f0  d0c8              BEQ      |L1.5508|
                  |L1.5618|
0015f2  0fe0              LSRS     r0,r4,#31             ;1692
0015f4  e7ba              B        |L1.5484|
0015f6  e000              B        |L1.5626|
                  |L1.5624|
0015f8  bf00              NOP                            ;1694
                  |L1.5626|
0015fa  2001              MOVS     r0,#1                 ;1698
0015fc  e7b6              B        |L1.5484|
;;;1701   
                          ENDP

                  yaffs_SoftDeleteChunk PROC
;;;1702   static void yaffs_SoftDeleteChunk(yaffs_Device * dev, int chunk)
0015fe  e92d41f0          PUSH     {r4-r8,lr}
;;;1703   {
001602  4605              MOV      r5,r0
001604  460e              MOV      r6,r1
;;;1704   
;;;1705   	yaffs_BlockInfo *theBlock;
;;;1706   
;;;1707   	T(YAFFS_TRACE_DELETION, (TSTR("soft delete chunk %d" TENDSTR), chunk));
001606  bf00              NOP      
001608  bf00              NOP      
;;;1708   
;;;1709   	theBlock = yaffs_GetBlockInfo(dev, chunk / dev->nChunksPerBlock);
00160a  6928              LDR      r0,[r5,#0x10]
00160c  fb96f7f0          SDIV     r7,r6,r0
001610  4639              MOV      r1,r7
001612  4628              MOV      r0,r5
001614  f7fffffe          BL       yaffs_GetBlockInfo
001618  4604              MOV      r4,r0
;;;1710   	if (theBlock) {
00161a  b154              CBZ      r4,|L1.5682|
;;;1711   		theBlock->softDeletions++;
00161c  8820              LDRH     r0,[r4,#0]
00161e  1c40              ADDS     r0,r0,#1
001620  6821              LDR      r1,[r4,#0]
001622  f3600109          BFI      r1,r0,#0,#10
001626  6021              STR      r1,[r4,#0]
;;;1712   		dev->nFreeChunks++;
001628  f8d50d34          LDR      r0,[r5,#0xd34]
00162c  1c40              ADDS     r0,r0,#1
00162e  f8c50d34          STR      r0,[r5,#0xd34]
                  |L1.5682|
;;;1713   	}
;;;1714   }
001632  e8bd81f0          POP      {r4-r8,pc}
;;;1715   
                          ENDP

                  yaffs_SoftDeleteWorker PROC
;;;1721    
;;;1722   static int yaffs_SoftDeleteWorker(yaffs_Object * in, yaffs_Tnode * tn,
001636  e92d5ff0          PUSH     {r4-r12,lr}
;;;1723   				  __u32 level, int chunkOffset)
;;;1724   {
00163a  4681              MOV      r9,r0
00163c  460d              MOV      r5,r1
00163e  4616              MOV      r6,r2
001640  469a              MOV      r10,r3
;;;1725   	int i;
;;;1726   	int theChunk;
;;;1727   	int allDone = 1;
001642  f04f0801          MOV      r8,#1
;;;1728   	yaffs_Device *dev = in->myDev;
001646  f8d9b008          LDR      r11,[r9,#8]
;;;1729   
;;;1730   	if (tn) {
00164a  2d00              CMP      r5,#0
00164c  d040              BEQ      |L1.5840|
;;;1731   		if (level > 0) {
00164e  b336              CBZ      r6,|L1.5790|
;;;1732   
;;;1733   			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
001650  2407              MOVS     r4,#7
001652  e017              B        |L1.5764|
                  |L1.5716|
;;;1734   			     i--) {
;;;1735   				if (tn->internal[i]) {
001654  f8550024          LDR      r0,[r5,r4,LSL #2]
001658  b198              CBZ      r0,|L1.5762|
;;;1736   					allDone =
00165a  eb0403ca          ADD      r3,r4,r10,LSL #3
00165e  1e72              SUBS     r2,r6,#1
001660  f8551024          LDR      r1,[r5,r4,LSL #2]
001664  4648              MOV      r0,r9
001666  f7fffffe          BL       yaffs_SoftDeleteWorker
00166a  4680              MOV      r8,r0
;;;1737   					    yaffs_SoftDeleteWorker(in,
;;;1738   								   tn->
;;;1739   								   internal[i],
;;;1740   								   level - 1,
;;;1741   								   (chunkOffset
;;;1742   								    <<
;;;1743   								    YAFFS_TNODES_INTERNAL_BITS)
;;;1744   								   + i);
;;;1745   					if (allDone) {
00166c  f1b80f00          CMP      r8,#0
001670  d007              BEQ      |L1.5762|
;;;1746   						yaffs_FreeTnode(dev,
001672  f8551024          LDR      r1,[r5,r4,LSL #2]
001676  4658              MOV      r0,r11
001678  f7fffffe          BL       yaffs_FreeTnode
;;;1747   								tn->
;;;1748   								internal[i]);
;;;1749   						tn->internal[i] = NULL;
00167c  2000              MOVS     r0,#0
00167e  f8450024          STR      r0,[r5,r4,LSL #2]
                  |L1.5762|
001682  1e64              SUBS     r4,r4,#1              ;1734
                  |L1.5764|
001684  f1b80f00          CMP      r8,#0                 ;1733
001688  d001              BEQ      |L1.5774|
00168a  2c00              CMP      r4,#0                 ;1733
00168c  dae2              BGE      |L1.5716|
                  |L1.5774|
;;;1750   					} else {
;;;1751   						/* Hoosterman... how could this happen? */
;;;1752   					}
;;;1753   				}
;;;1754   			}
;;;1755   			return (allDone) ? 1 : 0;
00168e  f1b80f00          CMP      r8,#0
001692  d002              BEQ      |L1.5786|
001694  2001              MOVS     r0,#1
                  |L1.5782|
;;;1756   		} else if (level == 0) {
;;;1757   
;;;1758   			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
;;;1759   				theChunk = yaffs_GetChunkGroupBase(dev,tn,i);
;;;1760   				if (theChunk) {
;;;1761   					/* Note this does not find the real chunk, only the chunk group.
;;;1762   					 * We make an assumption that a chunk group is not larger than 
;;;1763   					 * a block.
;;;1764   					 */
;;;1765   					yaffs_SoftDeleteChunk(dev, theChunk);
;;;1766   					yaffs_PutLevel0Tnode(dev,tn,i,0);
;;;1767   				}
;;;1768   
;;;1769   			}
;;;1770   			return 1;
;;;1771   
;;;1772   		}
;;;1773   
;;;1774   	}
;;;1775   
;;;1776   	return 1;
;;;1777   
;;;1778   }
001696  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.5786|
00169a  2000              MOVS     r0,#0                 ;1755
00169c  e7fb              B        |L1.5782|
                  |L1.5790|
00169e  b9be              CBNZ     r6,|L1.5840|
0016a0  240f              MOVS     r4,#0xf               ;1758
0016a2  e011              B        |L1.5832|
                  |L1.5796|
0016a4  4622              MOV      r2,r4                 ;1759
0016a6  4629              MOV      r1,r5                 ;1759
0016a8  4658              MOV      r0,r11                ;1759
0016aa  f7fffffe          BL       yaffs_GetChunkGroupBase
0016ae  4607              MOV      r7,r0                 ;1759
0016b0  b14f              CBZ      r7,|L1.5830|
0016b2  4639              MOV      r1,r7                 ;1765
0016b4  4658              MOV      r0,r11                ;1765
0016b6  f7fffffe          BL       yaffs_SoftDeleteChunk
0016ba  2300              MOVS     r3,#0                 ;1766
0016bc  4622              MOV      r2,r4                 ;1766
0016be  4629              MOV      r1,r5                 ;1766
0016c0  4658              MOV      r0,r11                ;1766
0016c2  f7fffffe          BL       yaffs_PutLevel0Tnode
                  |L1.5830|
0016c6  1e64              SUBS     r4,r4,#1              ;1758
                  |L1.5832|
0016c8  2c00              CMP      r4,#0                 ;1758
0016ca  daeb              BGE      |L1.5796|
0016cc  2001              MOVS     r0,#1                 ;1770
0016ce  e7e2              B        |L1.5782|
                  |L1.5840|
0016d0  2001              MOVS     r0,#1                 ;1776
0016d2  e7e0              B        |L1.5782|
;;;1779   
                          ENDP

                  yaffs_UnhashObject PROC
;;;2016   
;;;2017   static void yaffs_UnhashObject(yaffs_Object * tn)
0016d4  b570              PUSH     {r4-r6,lr}
;;;2018   {
0016d6  4604              MOV      r4,r0
;;;2019   	int bucket;
;;;2020           yaffs_Device *dev = tn->myDev;
0016d8  68a6              LDR      r6,[r4,#8]
;;;2021   
;;;2022           /* If it is still linked into the bucket list, free from the list */
;;;2023           if (!ylist_empty(&tn->hashLink)) {
0016da  f104000c          ADD      r0,r4,#0xc
0016de  f7fffffe          BL       ylist_empty
0016e2  b9b0              CBNZ     r0,|L1.5906|
;;;2024                   ylist_del_init(&tn->hashLink);
0016e4  f104000c          ADD      r0,r4,#0xc
0016e8  f7fffffe          BL       ylist_del_init
;;;2025                   bucket = yaffs_HashFunction(tn->objectId);
0016ec  6b20              LDR      r0,[r4,#0x30]
0016ee  f7fffffe          BL       yaffs_HashFunction
0016f2  4605              MOV      r5,r0
;;;2026                   dev->objectBucket[bucket].count--;
0016f4  eb050145          ADD      r1,r5,r5,LSL #1
0016f8  f506709a          ADD      r0,r6,#0x134
0016fc  eb000081          ADD      r0,r0,r1,LSL #2
001700  6880              LDR      r0,[r0,#8]
001702  1e40              SUBS     r0,r0,#1
001704  eb050245          ADD      r2,r5,r5,LSL #1
001708  f506719a          ADD      r1,r6,#0x134
00170c  eb010182          ADD      r1,r1,r2,LSL #2
001710  6088              STR      r0,[r1,#8]
                  |L1.5906|
;;;2027           }
;;;2028   
;;;2029   }
001712  bd70              POP      {r4-r6,pc}
;;;2030   
                          ENDP

                  yaffs_FreeObject PROC
;;;2031   /*  FreeObject frees up a Object and puts it back on the free list */
;;;2032   static void yaffs_FreeObject(yaffs_Object * tn)
001714  b570              PUSH     {r4-r6,lr}
;;;2033   {
001716  4605              MOV      r5,r0
;;;2034   
;;;2035   	yaffs_Device *dev = tn->myDev;
001718  68ac              LDR      r4,[r5,#8]
;;;2036   
;;;2037   	
;;;2038   	if(tn->parent)
;;;2039   		YBUG();
;;;2040   	if(!ylist_empty(&tn->siblings))
00171a  f1050020          ADD      r0,r5,#0x20
00171e  f7fffffe          BL       ylist_empty
;;;2041   		YBUG();
;;;2042   
;;;2043   
;;;2044   #ifdef  __KERNEL__
;;;2045   	if (tn->myInode) {
;;;2046   		/* We're still hooked up to a cached inode.
;;;2047   		 * Don't delete now, but mark for later deletion
;;;2048   		 */
;;;2049   		tn->deferedFree = 1;
;;;2050   		return;
;;;2051   	}
;;;2052   #endif
;;;2053   
;;;2054           yaffs_UnhashObject(tn);
001722  4628              MOV      r0,r5
001724  f7fffffe          BL       yaffs_UnhashObject
;;;2055   
;;;2056   #ifdef VALGRIND_TEST
;;;2057   	YFREE(tn);
;;;2058   #else
;;;2059           /* Link into the free list. */
;;;2060           tn->siblings.next = (struct ylist_head *)(dev->freeObjects);
001728  34e0              ADDS     r4,r4,#0xe0
00172a  6c60              LDR      r0,[r4,#0x44]
00172c  6228              STR      r0,[r5,#0x20]
;;;2061           dev->freeObjects = tn;
00172e  6465              STR      r5,[r4,#0x44]
;;;2062           dev->nFreeObjects++;
001730  6ca0              LDR      r0,[r4,#0x48]
001732  1c40              ADDS     r0,r0,#1
001734  64a0              STR      r0,[r4,#0x48]
;;;2063   #endif
;;;2064   	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
001736  2000              MOVS     r0,#0
001738  f84409e0          STR      r0,[r4],#-0xe0
;;;2065   
;;;2066   }
00173c  bd70              POP      {r4-r6,pc}
;;;2067   
                          ENDP

                  yaffs_RemoveObjectFromDirectory PROC
;;;6812   
;;;6813   static void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj)
00173e  b570              PUSH     {r4-r6,lr}
;;;6814   {
001740  4604              MOV      r4,r0
;;;6815   	yaffs_Device *dev = obj->myDev;
001742  68a5              LDR      r5,[r4,#8]
;;;6816   	yaffs_Object *parent;
;;;6817   	
;;;6818           yaffs_VerifyObjectInDirectory(obj);
001744  4620              MOV      r0,r4
001746  f7fffffe          BL       yaffs_VerifyObjectInDirectory
;;;6819   	parent = obj->parent;
00174a  69e6              LDR      r6,[r4,#0x1c]
;;;6820   	
;;;6821   	yaffs_VerifyDirectory(parent);
00174c  4630              MOV      r0,r6
00174e  f7fffffe          BL       yaffs_VerifyDirectory
;;;6822   
;;;6823           if(dev && dev->removeObjectCallback)
001752  b125              CBZ      r5,|L1.5982|
001754  6e28              LDR      r0,[r5,#0x60]
001756  b110              CBZ      r0,|L1.5982|
;;;6824                   dev->removeObjectCallback(obj);
001758  4620              MOV      r0,r4
00175a  6e29              LDR      r1,[r5,#0x60]
00175c  4788              BLX      r1
                  |L1.5982|
;;;6825   
;;;6826              
;;;6827           ylist_del_init(&obj->siblings);
00175e  f1040020          ADD      r0,r4,#0x20
001762  f7fffffe          BL       ylist_del_init
;;;6828           obj->parent = NULL;
001766  2000              MOVS     r0,#0
001768  61e0              STR      r0,[r4,#0x1c]
;;;6829   
;;;6830   	yaffs_VerifyDirectory(parent);
00176a  4630              MOV      r0,r6
00176c  f7fffffe          BL       yaffs_VerifyDirectory
;;;6831   
;;;6832   }
001770  bd70              POP      {r4-r6,pc}
;;;6833   
                          ENDP

                  yaffs_ObjectHasCachedWriteData PROC
;;;3944   
;;;3945   static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)
001772  b570              PUSH     {r4-r6,lr}
;;;3946   {
001774  4601              MOV      r1,r0
;;;3947   	yaffs_Device *dev = obj->myDev;
001776  688c              LDR      r4,[r1,#8]
;;;3948   	int i;
;;;3949   	yaffs_ChunkCache *cache;
;;;3950   	int nCaches = obj->myDev->nShortOpCaches;
001778  6888              LDR      r0,[r1,#8]
00177a  6a45              LDR      r5,[r0,#0x24]
;;;3951   	
;;;3952   	for(i = 0; i < nCaches; i++){
00177c  2200              MOVS     r2,#0
00177e  e00d              B        |L1.6044|
                  |L1.6016|
;;;3953   		cache = &dev->srCache[i];
001780  ebc206c2          RSB      r6,r2,r2,LSL #3
001784  f8d40d94          LDR      r0,[r4,#0xd94]
001788  eb000386          ADD      r3,r0,r6,LSL #2
;;;3954   		if (cache->object == obj &&
00178c  6818              LDR      r0,[r3,#0]
00178e  4288              CMP      r0,r1
001790  d103              BNE      |L1.6042|
;;;3955   		    cache->dirty)
001792  68d8              LDR      r0,[r3,#0xc]
001794  b108              CBZ      r0,|L1.6042|
;;;3956   			return 1;
001796  2001              MOVS     r0,#1
                  |L1.6040|
;;;3957   	}
;;;3958   	
;;;3959   	return 0;
;;;3960   }
001798  bd70              POP      {r4-r6,pc}
                  |L1.6042|
00179a  1c52              ADDS     r2,r2,#1              ;3952
                  |L1.6044|
00179c  42aa              CMP      r2,r5                 ;3952
00179e  dbef              BLT      |L1.6016|
0017a0  2000              MOVS     r0,#0                 ;3959
0017a2  e7f9              B        |L1.6040|
;;;3961   
                          ENDP

                  yaffs_CloneString PROC
;;;2305   
;;;2306   static YCHAR *yaffs_CloneString(const YCHAR * str)
0017a4  b570              PUSH     {r4-r6,lr}
;;;2307   {
0017a6  4604              MOV      r4,r0
;;;2308   	YCHAR *newStr = NULL;
0017a8  2500              MOVS     r5,#0
;;;2309   
;;;2310   	if (str && *str) {
0017aa  b174              CBZ      r4,|L1.6090|
0017ac  7820              LDRB     r0,[r4,#0]
0017ae  b160              CBZ      r0,|L1.6090|
;;;2311   		newStr = YMALLOC((yaffs_strlen(str) + 1) * sizeof(YCHAR));
0017b0  4620              MOV      r0,r4
0017b2  f7fffffe          BL       strlen
0017b6  1c46              ADDS     r6,r0,#1
0017b8  4630              MOV      r0,r6
0017ba  f7fffffe          BL       yaffs_malloc
0017be  4605              MOV      r5,r0
;;;2312   		if(newStr)
0017c0  b11d              CBZ      r5,|L1.6090|
;;;2313   			yaffs_strcpy(newStr, str);
0017c2  4621              MOV      r1,r4
0017c4  4628              MOV      r0,r5
0017c6  f7fffffe          BL       strcpy
                  |L1.6090|
;;;2314   	}
;;;2315   
;;;2316   	return newStr;
0017ca  4628              MOV      r0,r5
;;;2317   
;;;2318   }
0017cc  bd70              POP      {r4-r6,pc}
;;;2319   
                          ENDP

                  yaffs_CheckObjectDetailsLoaded PROC
;;;5998   
;;;5999   static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in)
0017ce  e92d43f0          PUSH     {r4-r9,lr}
;;;6000   {
0017d2  b093              SUB      sp,sp,#0x4c
0017d4  4604              MOV      r4,r0
;;;6001   	__u8 *chunkData;
;;;6002   	yaffs_ObjectHeader *oh;
;;;6003   	yaffs_Device *dev;
;;;6004   	yaffs_ExtendedTags tags;
;;;6005   	int result;
;;;6006   	int alloc_failed = 0;
0017d6  f04f0800          MOV      r8,#0
;;;6007   
;;;6008   	if(!in)
0017da  b914              CBNZ     r4,|L1.6114|
                  |L1.6108|
;;;6009   		return;
;;;6010   		
;;;6011   	dev = in->myDev;
;;;6012   		
;;;6013   #if 0
;;;6014   	T(YAFFS_TRACE_SCAN,(TSTR("details for object %d %s loaded" TENDSTR),
;;;6015   		in->objectId,
;;;6016   		in->lazyLoaded ? "not yet" : "already"));
;;;6017   #endif
;;;6018   
;;;6019   	if(in->lazyLoaded && in->hdrChunk > 0){
;;;6020   		in->lazyLoaded = 0;
;;;6021   		chunkData = yaffs_GetTempBuffer(dev, __LINE__);
;;;6022   
;;;6023   		result = yaffs_ReadChunkWithTagsFromNAND(dev,in->hdrChunk,chunkData,&tags);
;;;6024   		oh = (yaffs_ObjectHeader *) chunkData;
;;;6025   
;;;6026   		in->yst_mode = oh->yst_mode;
;;;6027   #ifdef CONFIG_YAFFS_WINCE
;;;6028   		in->win_atime[0] = oh->win_atime[0];
;;;6029   		in->win_ctime[0] = oh->win_ctime[0];
;;;6030   		in->win_mtime[0] = oh->win_mtime[0];
;;;6031   		in->win_atime[1] = oh->win_atime[1];
;;;6032   		in->win_ctime[1] = oh->win_ctime[1];
;;;6033   		in->win_mtime[1] = oh->win_mtime[1];
;;;6034   #else
;;;6035   		in->yst_uid = oh->yst_uid;
;;;6036   		in->yst_gid = oh->yst_gid;
;;;6037   		in->yst_atime = oh->yst_atime;
;;;6038   		in->yst_mtime = oh->yst_mtime;
;;;6039   		in->yst_ctime = oh->yst_ctime;
;;;6040   		in->yst_rdev = oh->yst_rdev;
;;;6041   		
;;;6042   #endif
;;;6043   		yaffs_SetObjectName(in, oh->name);
;;;6044   		
;;;6045   		if(in->variantType == YAFFS_OBJECT_TYPE_SYMLINK){
;;;6046   			 in->variant.symLinkVariant.alias =
;;;6047   						    yaffs_CloneString(oh->alias);
;;;6048   			if(!in->variant.symLinkVariant.alias)
;;;6049   				alloc_failed = 1; /* Not returned to caller */
;;;6050   		}
;;;6051   						    
;;;6052   		yaffs_ReleaseTempBuffer(dev,chunkData, __LINE__);
;;;6053   	}
;;;6054   }
0017dc  b013              ADD      sp,sp,#0x4c
0017de  e8bd83f0          POP      {r4-r9,pc}
                  |L1.6114|
0017e2  68a7              LDR      r7,[r4,#8]            ;6011
0017e4  7860              LDRB     r0,[r4,#1]            ;6019
0017e6  f0000001          AND      r0,r0,#1              ;6019
0017ea  2800              CMP      r0,#0                 ;6019
0017ec  d03f              BEQ      |L1.6254|
0017ee  6aa0              LDR      r0,[r4,#0x28]         ;6019
0017f0  2800              CMP      r0,#0                 ;6019
0017f2  dd3c              BLE      |L1.6254|
0017f4  7860              LDRB     r0,[r4,#1]            ;6020
0017f6  f0200001          BIC      r0,r0,#1              ;6020
0017fa  7060              STRB     r0,[r4,#1]            ;6020
0017fc  f2417185          MOV      r1,#0x1785            ;6021
001800  4638              MOV      r0,r7                 ;6021
001802  f7fffffe          BL       yaffs_GetTempBuffer
001806  4605              MOV      r5,r0                 ;6021
001808  ab01              ADD      r3,sp,#4              ;6023
00180a  462a              MOV      r2,r5                 ;6023
00180c  4638              MOV      r0,r7                 ;6023
00180e  6aa1              LDR      r1,[r4,#0x28]         ;6023
001810  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
001814  4681              MOV      r9,r0                 ;6023
001816  462e              MOV      r6,r5                 ;6024
001818  f5067686          ADD      r6,r6,#0x10c          ;6026
00181c  6830              LDR      r0,[r6,#0]            ;6026
00181e  6360              STR      r0,[r4,#0x34]         ;6026
001820  6870              LDR      r0,[r6,#4]            ;6035
001822  63e0              STR      r0,[r4,#0x3c]         ;6035
001824  68b0              LDR      r0,[r6,#8]            ;6036
001826  6420              STR      r0,[r4,#0x40]         ;6036
001828  68f0              LDR      r0,[r6,#0xc]          ;6037
00182a  6460              STR      r0,[r4,#0x44]         ;6037
00182c  6930              LDR      r0,[r6,#0x10]         ;6038
00182e  64a0              STR      r0,[r4,#0x48]         ;6038
001830  6970              LDR      r0,[r6,#0x14]         ;6039
001832  64e0              STR      r0,[r4,#0x4c]         ;6039
001834  f8d600c0          LDR      r0,[r6,#0xc0]         ;6040
001838  f5a67686          SUB      r6,r6,#0x10c          ;6040
00183c  6520              STR      r0,[r4,#0x50]         ;6040
00183e  f106010a          ADD      r1,r6,#0xa            ;6043
001842  4620              MOV      r0,r4                 ;6043
001844  f7fffffe          BL       yaffs_SetObjectName
001848  f8940054          LDRB     r0,[r4,#0x54]         ;6045
00184c  2802              CMP      r0,#2                 ;6045
00184e  d108              BNE      |L1.6242|
001850  f5067096          ADD      r0,r6,#0x12c          ;6046
001854  f7fffffe          BL       yaffs_CloneString
001858  65a0              STR      r0,[r4,#0x58]         ;6046
00185a  6da0              LDR      r0,[r4,#0x58]         ;6048
00185c  b908              CBNZ     r0,|L1.6242|
00185e  f04f0801          MOV      r8,#1                 ;6049
                  |L1.6242|
001862  f24172a4          MOV      r2,#0x17a4            ;6052
001866  4629              MOV      r1,r5                 ;6052
001868  4638              MOV      r0,r7                 ;6052
00186a  f7fffffe          BL       yaffs_ReleaseTempBuffer
                  |L1.6254|
00186e  bf00              NOP      
001870  e7b4              B        |L1.6108|
;;;6055   
                          ENDP

                  yaffs_GetErasedChunks PROC
;;;3021   
;;;3022   static int yaffs_GetErasedChunks(yaffs_Device * dev)
001872  4601              MOV      r1,r0
;;;3023   {
;;;3024   	int n;
;;;3025   
;;;3026   	n = dev->nErasedBlocks * dev->nChunksPerBlock;
001874  690b              LDR      r3,[r1,#0x10]
001876  f8d120f4          LDR      r2,[r1,#0xf4]
00187a  fb02f003          MUL      r0,r2,r3
;;;3027   
;;;3028   	if (dev->allocationBlock > 0) {
00187e  f8d120f8          LDR      r2,[r1,#0xf8]
001882  2a00              CMP      r2,#0
001884  dd04              BLE      |L1.6288|
;;;3029   		n += (dev->nChunksPerBlock - dev->allocationPage);
001886  f8d130fc          LDR      r3,[r1,#0xfc]
00188a  690a              LDR      r2,[r1,#0x10]
00188c  1ad2              SUBS     r2,r2,r3
00188e  4410              ADD      r0,r0,r2
                  |L1.6288|
;;;3030   	}
;;;3031   
;;;3032   	return n;
;;;3033   
;;;3034   }
001890  4770              BX       lr
;;;3035   
                          ENDP

                  yaffs_FindObjectByNumber PROC
;;;2191   
;;;2192   yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number)
001892  e92d41f0          PUSH     {r4-r8,lr}
;;;2193   {
001896  4605              MOV      r5,r0
001898  460e              MOV      r6,r1
;;;2194           int bucket = yaffs_HashFunction(number);
00189a  4630              MOV      r0,r6
00189c  f7fffffe          BL       yaffs_HashFunction
0018a0  4680              MOV      r8,r0
;;;2195           struct ylist_head *i;
;;;2196           yaffs_Object *in;
;;;2197   
;;;2198           ylist_for_each(i, &dev->objectBucket[bucket].list) {
0018a2  eb080148          ADD      r1,r8,r8,LSL #1
0018a6  f505709a          ADD      r0,r5,#0x134
0018aa  f8504021          LDR      r4,[r0,r1,LSL #2]
0018ae  e009              B        |L1.6340|
                  |L1.6320|
;;;2199                   /* Look if it is in the list */
;;;2200                   if (i) {
0018b0  b13c              CBZ      r4,|L1.6338|
;;;2201                           in = ylist_entry(i, yaffs_Object, hashLink);
0018b2  f1a4070c          SUB      r7,r4,#0xc
;;;2202                           if (in->objectId == number) {
0018b6  6b38              LDR      r0,[r7,#0x30]
0018b8  42b0              CMP      r0,r6
0018ba  d102              BNE      |L1.6338|
;;;2203   #ifdef __KERNEL__
;;;2204                                   /* Don't tell the VFS about this one if it is defered free */
;;;2205   				if (in->deferedFree)
;;;2206   					return NULL;
;;;2207   #endif
;;;2208   
;;;2209   				return in;
0018bc  4638              MOV      r0,r7
                  |L1.6334|
;;;2210   			}
;;;2211   		}
;;;2212   	}
;;;2213   
;;;2214   	return NULL;
;;;2215   }
0018be  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6338|
0018c2  6824              LDR      r4,[r4,#0]            ;2198
                  |L1.6340|
0018c4  eb080148          ADD      r1,r8,r8,LSL #1       ;2198
0018c8  f505709a          ADD      r0,r5,#0x134          ;2198
0018cc  eb000081          ADD      r0,r0,r1,LSL #2       ;2198
0018d0  42a0              CMP      r0,r4                 ;2198
0018d2  d1ed              BNE      |L1.6320|
0018d4  2000              MOVS     r0,#0                 ;2214
0018d6  e7f2              B        |L1.6334|
;;;2216   
                          ENDP

                  yaffs_FindChunkInFile PROC
;;;3367   
;;;3368   static int yaffs_FindChunkInFile(yaffs_Object * in, int chunkInInode,
0018d8  e92d47f0          PUSH     {r4-r10,lr}
;;;3369   				 yaffs_ExtendedTags * tags)
;;;3370   {
0018dc  b094              SUB      sp,sp,#0x50
0018de  4604              MOV      r4,r0
0018e0  460e              MOV      r6,r1
0018e2  4617              MOV      r7,r2
;;;3371   	/*Get the Tnode, then get the level 0 offset chunk offset */
;;;3372   	yaffs_Tnode *tn;
;;;3373   	int theChunk = -1;
0018e4  f04f38ff          MOV      r8,#0xffffffff
;;;3374   	yaffs_ExtendedTags localTags;
;;;3375   	int retVal = -1;
0018e8  46c1              MOV      r9,r8
;;;3376   
;;;3377   	yaffs_Device *dev = in->myDev;
0018ea  f8d4a008          LDR      r10,[r4,#8]
;;;3378   
;;;3379   	if (!tags) {
0018ee  b907              CBNZ     r7,|L1.6386|
;;;3380   		/* Passed a NULL, so use our own tags space */
;;;3381   		tags = &localTags;
0018f0  af02              ADD      r7,sp,#8
                  |L1.6386|
;;;3382   	}
;;;3383   
;;;3384   	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
0018f2  4632              MOV      r2,r6
0018f4  f1040158          ADD      r1,r4,#0x58
0018f8  4650              MOV      r0,r10
0018fa  f7fffffe          BL       yaffs_FindLevel0Tnode
0018fe  4605              MOV      r5,r0
;;;3385   
;;;3386   	if (tn) {
001900  b16d              CBZ      r5,|L1.6430|
;;;3387   		theChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);
001902  4632              MOV      r2,r6
001904  4629              MOV      r1,r5
001906  4650              MOV      r0,r10
001908  f7fffffe          BL       yaffs_GetChunkGroupBase
00190c  4680              MOV      r8,r0
;;;3388   
;;;3389   		retVal =
00190e  9600              STR      r6,[sp,#0]
001910  463a              MOV      r2,r7
001912  4641              MOV      r1,r8
001914  4650              MOV      r0,r10
001916  6b23              LDR      r3,[r4,#0x30]
001918  f7fffffe          BL       yaffs_FindChunkInGroup
00191c  4681              MOV      r9,r0
                  |L1.6430|
;;;3390   		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
;;;3391   					   chunkInInode);
;;;3392   	}
;;;3393   	return retVal;
00191e  4648              MOV      r0,r9
;;;3394   }
001920  b014              ADD      sp,sp,#0x50
001922  e8bd87f0          POP      {r4-r10,pc}
;;;3395   
                          ENDP

                  yaffs_PutChunkIntoFile PROC
;;;3495   
;;;3496   static int yaffs_PutChunkIntoFile(yaffs_Object * in, int chunkInInode,
001926  e92d4ff0          PUSH     {r4-r11,lr}
;;;3497   				  int chunkInNAND, int inScan)
;;;3498   {
00192a  b0a5              SUB      sp,sp,#0x94
00192c  4604              MOV      r4,r0
00192e  4689              MOV      r9,r1
001930  4690              MOV      r8,r2
001932  461e              MOV      r6,r3
;;;3499   	/* NB inScan is zero unless scanning. 
;;;3500   	 * For forward scanning, inScan is > 0; 
;;;3501   	 * for backward scanning inScan is < 0
;;;3502   	 */
;;;3503   	 
;;;3504   	yaffs_Tnode *tn;
;;;3505   	yaffs_Device *dev = in->myDev;
001934  68a0              LDR      r0,[r4,#8]
001936  9024              STR      r0,[sp,#0x90]
;;;3506   	int existingChunk;
;;;3507   	yaffs_ExtendedTags existingTags;
;;;3508   	yaffs_ExtendedTags newTags;
;;;3509   	unsigned existingSerial, newSerial;
;;;3510   
;;;3511   	if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
001938  f8940054          LDRB     r0,[r4,#0x54]
00193c  2801              CMP      r0,#1
00193e  d00d              BEQ      |L1.6492|
;;;3512   		/* Just ignore an attempt at putting a chunk into a non-file during scanning
;;;3513   		 * If it is not during Scanning then something went wrong!
;;;3514   		 */
;;;3515   		if (!inScan) {
001940  b90e              CBNZ     r6,|L1.6470|
;;;3516   			T(YAFFS_TRACE_ERROR,
001942  bf00              NOP      
001944  bf00              NOP      
                  |L1.6470|
;;;3517   			  (TSTR
;;;3518   			   ("yaffs tragedy:attempt to put data chunk into a non-file"
;;;3519   			    TENDSTR)));
;;;3520   			YBUG();
;;;3521   		}
;;;3522   
;;;3523   		yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
001946  f64053c3          MOV      r3,#0xdc3
00194a  2201              MOVS     r2,#1
00194c  4641              MOV      r1,r8
00194e  9824              LDR      r0,[sp,#0x90]
001950  f7fffffe          BL       yaffs_DeleteChunk
;;;3524   		return YAFFS_OK;
001954  2001              MOVS     r0,#1
                  |L1.6486|
;;;3525   	}
;;;3526   
;;;3527   	tn = yaffs_AddOrFindLevel0Tnode(dev, 
;;;3528   					&in->variant.fileVariant,
;;;3529   					chunkInInode,
;;;3530   					NULL);
;;;3531   	if (!tn) {
;;;3532   		return YAFFS_FAIL;
;;;3533   	}
;;;3534   
;;;3535   	existingChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);
;;;3536   
;;;3537   	if (inScan != 0) {
;;;3538   		/* If we're scanning then we need to test for duplicates
;;;3539   		 * NB This does not need to be efficient since it should only ever 
;;;3540   		 * happen when the power fails during a write, then only one
;;;3541   		 * chunk should ever be affected.
;;;3542   		 *
;;;3543   		 * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO
;;;3544   		 * Update: For backward scanning we don't need to re-read tags so this is quite cheap.
;;;3545   		 */
;;;3546   
;;;3547   		if (existingChunk > 0) {
;;;3548   			/* NB Right now existing chunk will not be real chunkId if the device >= 32MB
;;;3549   			 *    thus we have to do a FindChunkInFile to get the real chunk id.
;;;3550   			 *
;;;3551   			 * We have a duplicate now we need to decide which one to use:
;;;3552   			 *
;;;3553   			 * Backwards scanning YAFFS2: The old one is what we use, dump the new one.
;;;3554   			 * Forward scanning YAFFS2: The new one is what we use, dump the old one.
;;;3555   			 * YAFFS1: Get both sets of tags and compare serial numbers.
;;;3556   			 */
;;;3557   
;;;3558   			if (inScan > 0) {
;;;3559   				/* Only do this for forward scanning */
;;;3560   				yaffs_ReadChunkWithTagsFromNAND(dev,
;;;3561   								chunkInNAND,
;;;3562   								NULL, &newTags);
;;;3563   
;;;3564   				/* Do a proper find */
;;;3565   				existingChunk =
;;;3566   				    yaffs_FindChunkInFile(in, chunkInInode,
;;;3567   							  &existingTags);
;;;3568   			}
;;;3569   
;;;3570   			if (existingChunk <= 0) {
;;;3571   				/*Hoosterman - how did this happen? */
;;;3572   
;;;3573   				T(YAFFS_TRACE_ERROR,
;;;3574   				  (TSTR
;;;3575   				   ("yaffs tragedy: existing chunk < 0 in scan"
;;;3576   				    TENDSTR)));
;;;3577   
;;;3578   			}
;;;3579   
;;;3580   			/* NB The deleted flags should be false, otherwise the chunks will 
;;;3581   			 * not be loaded during a scan
;;;3582   			 */
;;;3583   
;;;3584   			if(inScan > 0) {
;;;3585   				newSerial = newTags.serialNumber;
;;;3586   				existingSerial = existingTags.serialNumber;
;;;3587   			}
;;;3588   
;;;3589   			if ((inScan > 0) &&
;;;3590   			    (in->myDev->isYaffs2 ||
;;;3591   			     existingChunk <= 0 ||
;;;3592   			     ((existingSerial + 1) & 3) == newSerial)) {
;;;3593   				/* Forward scanning.                            
;;;3594   				 * Use new
;;;3595   				 * Delete the old one and drop through to update the tnode
;;;3596   				 */
;;;3597   				yaffs_DeleteChunk(dev, existingChunk, 1,
;;;3598   						  __LINE__);
;;;3599   			} else {
;;;3600   				/* Backward scanning or we want to use the existing one
;;;3601   				 * Use existing.
;;;3602   				 * Delete the new one and return early so that the tnode isn't changed
;;;3603   				 */
;;;3604   				yaffs_DeleteChunk(dev, chunkInNAND, 1,
;;;3605   						  __LINE__);
;;;3606   				return YAFFS_OK;
;;;3607   			}
;;;3608   		}
;;;3609   
;;;3610   	}
;;;3611   
;;;3612   	if (existingChunk == 0) {
;;;3613   		in->nDataChunks++;
;;;3614   	}
;;;3615   
;;;3616   	yaffs_PutLevel0Tnode(dev,tn,chunkInInode,chunkInNAND);
;;;3617   
;;;3618   	return YAFFS_OK;
;;;3619   }
001956  b025              ADD      sp,sp,#0x94
001958  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.6492|
00195c  2300              MOVS     r3,#0                 ;3527
00195e  464a              MOV      r2,r9                 ;3527
001960  f1040158          ADD      r1,r4,#0x58           ;3527
001964  9824              LDR      r0,[sp,#0x90]         ;3527
001966  f7fffffe          BL       yaffs_AddOrFindLevel0Tnode
00196a  4607              MOV      r7,r0                 ;3527
00196c  b90f              CBNZ     r7,|L1.6514|
00196e  2000              MOVS     r0,#0                 ;3532
001970  e7f1              B        |L1.6486|
                  |L1.6514|
001972  464a              MOV      r2,r9                 ;3535
001974  4639              MOV      r1,r7                 ;3535
001976  9824              LDR      r0,[sp,#0x90]         ;3535
001978  f7fffffe          BL       yaffs_GetChunkGroupBase
00197c  4605              MOV      r5,r0                 ;3535
00197e  b36e              CBZ      r6,|L1.6620|
001980  2d00              CMP      r5,#0                 ;3547
001982  dd35              BLE      |L1.6640|
001984  2e00              CMP      r6,#0                 ;3558
001986  dd0b              BLE      |L1.6560|
001988  466b              MOV      r3,sp                 ;3560
00198a  2200              MOVS     r2,#0                 ;3560
00198c  4641              MOV      r1,r8                 ;3560
00198e  9824              LDR      r0,[sp,#0x90]         ;3560
001990  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
001994  aa12              ADD      r2,sp,#0x48           ;3565
001996  4649              MOV      r1,r9                 ;3565
001998  4620              MOV      r0,r4                 ;3565
00199a  f7fffffe          BL       yaffs_FindChunkInFile
00199e  4605              MOV      r5,r0                 ;3565
                  |L1.6560|
0019a0  2d00              CMP      r5,#0                 ;3570
0019a2  dc01              BGT      |L1.6568|
0019a4  bf00              NOP                            ;3573
0019a6  bf00              NOP                            ;3573
                  |L1.6568|
0019a8  2e00              CMP      r6,#0                 ;3584
0019aa  dd03              BLE      |L1.6580|
0019ac  f8ddb020          LDR      r11,[sp,#0x20]        ;3585
0019b0  f8dda068          LDR      r10,[sp,#0x68]        ;3586
                  |L1.6580|
0019b4  2e00              CMP      r6,#0                 ;3589
0019b6  dd12              BLE      |L1.6622|
0019b8  68a0              LDR      r0,[r4,#8]            ;3590
0019ba  6dc0              LDR      r0,[r0,#0x5c]         ;3590
0019bc  b938              CBNZ     r0,|L1.6606|
0019be  2d00              CMP      r5,#0                 ;3591
0019c0  dd05              BLE      |L1.6606|
0019c2  f10a0001          ADD      r0,r10,#1             ;3592
0019c6  f0000003          AND      r0,r0,#3              ;3592
0019ca  4558              CMP      r0,r11                ;3592
0019cc  d107              BNE      |L1.6622|
                  |L1.6606|
0019ce  f640630e          MOV      r3,#0xe0e             ;3597
0019d2  2201              MOVS     r2,#1                 ;3597
0019d4  4629              MOV      r1,r5                 ;3597
0019d6  9824              LDR      r0,[sp,#0x90]         ;3597
0019d8  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.6620|
0019dc  e008              B        |L1.6640|
                  |L1.6622|
0019de  f6406315          MOV      r3,#0xe15             ;3604
0019e2  2201              MOVS     r2,#1                 ;3604
0019e4  4641              MOV      r1,r8                 ;3604
0019e6  9824              LDR      r0,[sp,#0x90]         ;3604
0019e8  f7fffffe          BL       yaffs_DeleteChunk
0019ec  2001              MOVS     r0,#1                 ;3606
0019ee  e7b2              B        |L1.6486|
                  |L1.6640|
0019f0  b915              CBNZ     r5,|L1.6648|
0019f2  6ae0              LDR      r0,[r4,#0x2c]         ;3613
0019f4  1c40              ADDS     r0,r0,#1              ;3613
0019f6  62e0              STR      r0,[r4,#0x2c]         ;3613
                  |L1.6648|
0019f8  4643              MOV      r3,r8                 ;3616
0019fa  464a              MOV      r2,r9                 ;3616
0019fc  4639              MOV      r1,r7                 ;3616
0019fe  9824              LDR      r0,[sp,#0x90]         ;3616
001a00  f7fffffe          BL       yaffs_PutLevel0Tnode
001a04  2001              MOVS     r0,#1                 ;3618
001a06  e7a6              B        |L1.6486|
;;;3620   
                          ENDP

                  yaffs_GarbageCollectBlock PROC
;;;3035   
;;;3036   static int yaffs_GarbageCollectBlock(yaffs_Device * dev, int block, int wholeBlock)
001a08  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3037   {
001a0c  b09e              SUB      sp,sp,#0x78
001a0e  4604              MOV      r4,r0
001a10  4689              MOV      r9,r1
;;;3038   	int oldChunk;
;;;3039   	int newChunk;
;;;3040   	int markNAND;
;;;3041   	int retVal = YAFFS_OK;
001a12  2001              MOVS     r0,#1
001a14  901c              STR      r0,[sp,#0x70]
;;;3042   	int cleanups = 0;
001a16  2000              MOVS     r0,#0
001a18  901b              STR      r0,[sp,#0x6c]
;;;3043   	int i;
;;;3044   	int isCheckpointBlock;
;;;3045   	int matchingChunk;
;;;3046   	int maxCopies;
;;;3047   
;;;3048   	int chunksBefore = yaffs_GetErasedChunks(dev);
001a1a  4620              MOV      r0,r4
001a1c  f7fffffe          BL       yaffs_GetErasedChunks
001a20  9017              STR      r0,[sp,#0x5c]
;;;3049   	int chunksAfter;
;;;3050   
;;;3051   	yaffs_ExtendedTags tags;
;;;3052   
;;;3053   	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, block);
001a22  4649              MOV      r1,r9
001a24  4620              MOV      r0,r4
001a26  f7fffffe          BL       yaffs_GetBlockInfo
001a2a  4606              MOV      r6,r0
;;;3054   
;;;3055   	yaffs_Object *object;
;;;3056   
;;;3057   	isCheckpointBlock = (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT);
001a2c  6830              LDR      r0,[r6,#0]
001a2e  f3c05003          UBFX     r0,r0,#20,#4
001a32  2807              CMP      r0,#7
001a34  d101              BNE      |L1.6714|
001a36  2001              MOVS     r0,#1
001a38  e000              B        |L1.6716|
                  |L1.6714|
001a3a  2000              MOVS     r0,#0
                  |L1.6716|
001a3c  901a              STR      r0,[sp,#0x68]
;;;3058   	
;;;3059   	bi->blockState = YAFFS_BLOCK_STATE_COLLECTING;
001a3e  6830              LDR      r0,[r6,#0]
001a40  f4200070          BIC      r0,r0,#0xf00000
001a44  f5000000          ADD      r0,r0,#0x800000
001a48  6030              STR      r0,[r6,#0]
;;;3060   
;;;3061   	T(YAFFS_TRACE_TRACING,
001a4a  bf00              NOP      
001a4c  bf00              NOP      
;;;3062   	  (TSTR("Collecting block %d, in use %d, shrink %d, wholeBlock %d" TENDSTR), 
;;;3063   	  block,
;;;3064   	  bi->pagesInUse,
;;;3065   	  bi->hasShrinkHeader,
;;;3066   	  wholeBlock));
;;;3067   
;;;3068   	/*yaffs_VerifyFreeChunks(dev); */
;;;3069   
;;;3070   	bi->hasShrinkHeader = 0;	/* clear the flag so that the block can erase */
001a4e  6830              LDR      r0,[r6,#0]
001a50  f0204080          BIC      r0,r0,#0x40000000
001a54  6030              STR      r0,[r6,#0]
;;;3071   
;;;3072   	/* Take off the number of soft deleted entries because
;;;3073   	 * they're going to get really deleted during GC.
;;;3074   	 */
;;;3075   	dev->nFreeChunks -= bi->softDeletions;
001a56  8831              LDRH     r1,[r6,#0]
001a58  f3c10109          UBFX     r1,r1,#0,#10
001a5c  f8d40d34          LDR      r0,[r4,#0xd34]
001a60  1a40              SUBS     r0,r0,r1
001a62  f8c40d34          STR      r0,[r4,#0xd34]
;;;3076   
;;;3077   	dev->isDoingGC = 1;
001a66  2001              MOVS     r0,#1
001a68  f8c40114          STR      r0,[r4,#0x114]
;;;3078   
;;;3079   	if (isCheckpointBlock ||
001a6c  981a              LDR      r0,[sp,#0x68]
001a6e  b9e0              CBNZ     r0,|L1.6826|
;;;3080   	    !yaffs_StillSomeChunkBits(dev, block)) {
001a70  46a3              MOV      r11,r4
001a72  f8cd900c          STR      r9,[sp,#0xc]
001a76  4658              MOV      r0,r11
001a78  9903              LDR      r1,[sp,#0xc]
001a7a  f7fffffe          BL       yaffs_BlockBits
001a7e  9002              STR      r0,[sp,#8]
001a80  2000              MOVS     r0,#0
001a82  9001              STR      r0,[sp,#4]
001a84  e00a              B        |L1.6812|
                  |L1.6790|
001a86  9802              LDR      r0,[sp,#8]
001a88  7800              LDRB     r0,[r0,#0]
001a8a  b108              CBZ      r0,|L1.6800|
001a8c  2001              MOVS     r0,#1
001a8e  e00b              B        |L1.6824|
                  |L1.6800|
001a90  9802              LDR      r0,[sp,#8]
001a92  1c40              ADDS     r0,r0,#1
001a94  9002              STR      r0,[sp,#8]
001a96  9801              LDR      r0,[sp,#4]
001a98  1c40              ADDS     r0,r0,#1
001a9a  9001              STR      r0,[sp,#4]
                  |L1.6812|
001a9c  f8db10f0          LDR      r1,[r11,#0xf0]
001aa0  9801              LDR      r0,[sp,#4]
001aa2  4281              CMP      r1,r0
001aa4  dcef              BGT      |L1.6790|
001aa6  2000              MOVS     r0,#0
                  |L1.6824|
001aa8  b930              CBNZ     r0,|L1.6840|
                  |L1.6826|
;;;3081   		T(YAFFS_TRACE_TRACING,
001aaa  bf00              NOP      
001aac  bf00              NOP      
;;;3082   		  (TSTR
;;;3083   		   ("Collecting block %d that has no chunks in use" TENDSTR),
;;;3084   		   block));
;;;3085   		yaffs_BlockBecameDirty(dev, block);
001aae  4649              MOV      r1,r9
001ab0  4620              MOV      r0,r4
001ab2  f7fffffe          BL       yaffs_BlockBecameDirty
001ab6  e0ee              B        |L1.7318|
                  |L1.6840|
;;;3086   	} else {
;;;3087   
;;;3088   		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
001ab8  f44f6141          MOV      r1,#0xc10
001abc  4620              MOV      r0,r4
001abe  f7fffffe          BL       yaffs_GetTempBuffer
001ac2  4683              MOV      r11,r0
;;;3089   		
;;;3090   		yaffs_VerifyBlock(dev,bi,block);
001ac4  464a              MOV      r2,r9
001ac6  4631              MOV      r1,r6
001ac8  4620              MOV      r0,r4
001aca  f7fffffe          BL       yaffs_VerifyBlock
;;;3091   
;;;3092   		maxCopies = (wholeBlock) ? dev->nChunksPerBlock : 10;
001ace  9820              LDR      r0,[sp,#0x80]
001ad0  b108              CBZ      r0,|L1.6870|
001ad2  6920              LDR      r0,[r4,#0x10]
001ad4  e000              B        |L1.6872|
                  |L1.6870|
001ad6  200a              MOVS     r0,#0xa
                  |L1.6872|
001ad8  9018              STR      r0,[sp,#0x60]
;;;3093   		oldChunk = block * dev->nChunksPerBlock + dev->gcChunk;
001ada  6921              LDR      r1,[r4,#0x10]
001adc  f8d4011c          LDR      r0,[r4,#0x11c]
001ae0  fb090701          MLA      r7,r9,r1,r0
;;;3094   		
;;;3095   		for ( /* init already done */;
001ae4  e09c              B        |L1.7200|
                  |L1.6886|
;;;3096   		     retVal == YAFFS_OK &&
;;;3097   		     dev->gcChunk < dev->nChunksPerBlock &&
;;;3098   		     (bi->blockState == YAFFS_BLOCK_STATE_COLLECTING)&&
;;;3099   		     maxCopies > 0;
;;;3100   		     dev->gcChunk++, oldChunk++) {
;;;3101   			if (yaffs_CheckChunkBit(dev, block, dev->gcChunk)) {
001ae6  4649              MOV      r1,r9
001ae8  4620              MOV      r0,r4
001aea  f8d4211c          LDR      r2,[r4,#0x11c]
001aee  f7fffffe          BL       yaffs_CheckChunkBit
001af2  2800              CMP      r0,#0
001af4  d076              BEQ      |L1.7140|
;;;3102   
;;;3103   				/* This page is in use and might need to be copied off */
;;;3104   				
;;;3105   				maxCopies--;
001af6  9818              LDR      r0,[sp,#0x60]
001af8  1e40              SUBS     r0,r0,#1
001afa  9018              STR      r0,[sp,#0x60]
;;;3106   
;;;3107   				markNAND = 1;
001afc  2001              MOVS     r0,#1
001afe  901d              STR      r0,[sp,#0x74]
;;;3108   
;;;3109   				yaffs_InitialiseTags(&tags);
001b00  a804              ADD      r0,sp,#0x10
001b02  f7fffffe          BL       yaffs_InitialiseTags
;;;3110   
;;;3111   				yaffs_ReadChunkWithTagsFromNAND(dev, oldChunk,
001b06  ab04              ADD      r3,sp,#0x10
001b08  465a              MOV      r2,r11
001b0a  4639              MOV      r1,r7
001b0c  4620              MOV      r0,r4
001b0e  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
;;;3112   								buffer, &tags);
;;;3113   
;;;3114   				object =
001b12  4620              MOV      r0,r4
001b14  9906              LDR      r1,[sp,#0x18]
001b16  f7fffffe          BL       yaffs_FindObjectByNumber
001b1a  4605              MOV      r5,r0
;;;3115   				    yaffs_FindObjectByNumber(dev,
;;;3116   							     tags.objectId);
;;;3117   
;;;3118   				T(YAFFS_TRACE_GC_DETAIL,
001b1c  bf00              NOP      
001b1e  bf00              NOP      
;;;3119   				  (TSTR
;;;3120   				   ("Collecting chunk in block %d, %d %d %d " TENDSTR),
;;;3121   				   dev->gcChunk, tags.objectId, tags.chunkId,
;;;3122   				   tags.byteCount));
;;;3123   				   
;;;3124   				if(object && !yaffs_SkipVerification(dev)){
001b20  b1cd              CBZ      r5,|L1.6998|
001b22  4620              MOV      r0,r4
001b24  f7fffffe          BL       yaffs_SkipVerification
001b28  b9a8              CBNZ     r0,|L1.6998|
;;;3125   					if(tags.chunkId == 0)
001b2a  9807              LDR      r0,[sp,#0x1c]
001b2c  b910              CBNZ     r0,|L1.6964|
;;;3126   						matchingChunk = object->hdrChunk;
001b2e  6aa8              LDR      r0,[r5,#0x28]
001b30  9019              STR      r0,[sp,#0x64]
001b32  e00b              B        |L1.6988|
                  |L1.6964|
;;;3127   					else if(object->softDeleted)
001b34  7828              LDRB     r0,[r5,#0]
001b36  f3c00040          UBFX     r0,r0,#1,#1
001b3a  b108              CBZ      r0,|L1.6976|
;;;3128   						matchingChunk = oldChunk; /* Defeat the test */
001b3c  9719              STR      r7,[sp,#0x64]
001b3e  e005              B        |L1.6988|
                  |L1.6976|
;;;3129   					else
;;;3130   						matchingChunk = yaffs_FindChunkInFile(object,tags.chunkId,NULL);
001b40  2200              MOVS     r2,#0
001b42  4628              MOV      r0,r5
001b44  9907              LDR      r1,[sp,#0x1c]
001b46  f7fffffe          BL       yaffs_FindChunkInFile
001b4a  9019              STR      r0,[sp,#0x64]
                  |L1.6988|
;;;3131   					
;;;3132   					if(oldChunk != matchingChunk)
001b4c  9819              LDR      r0,[sp,#0x64]
001b4e  4287              CMP      r7,r0
001b50  d001              BEQ      |L1.6998|
;;;3133   						T(YAFFS_TRACE_ERROR,
001b52  bf00              NOP      
001b54  bf00              NOP      
                  |L1.6998|
;;;3134   						  (TSTR("gc: page in gc mismatch: %d %d %d %d"TENDSTR),
;;;3135   						  oldChunk,matchingChunk,tags.objectId, tags.chunkId));
;;;3136   						
;;;3137   				}
;;;3138   
;;;3139   				if (!object) {
001b56  b90d              CBNZ     r5,|L1.7004|
;;;3140   					T(YAFFS_TRACE_ERROR,
001b58  bf00              NOP      
001b5a  bf00              NOP      
                  |L1.7004|
;;;3141   					  (TSTR
;;;3142   					   ("page %d in gc has no object: %d %d %d "
;;;3143   					    TENDSTR), oldChunk,
;;;3144   					    tags.objectId, tags.chunkId, tags.byteCount));
;;;3145   				}
;;;3146   
;;;3147   				if (object && 
001b5c  b1dd              CBZ      r5,|L1.7062|
;;;3148   				    object->deleted &&
001b5e  7828              LDRB     r0,[r5,#0]
001b60  f0000001          AND      r0,r0,#1
001b64  b1b8              CBZ      r0,|L1.7062|
;;;3149   				    object->softDeleted &&
001b66  7828              LDRB     r0,[r5,#0]
001b68  f3c00040          UBFX     r0,r0,#1,#1
001b6c  b198              CBZ      r0,|L1.7062|
;;;3150   				    tags.chunkId != 0) {
001b6e  9807              LDR      r0,[sp,#0x1c]
001b70  b188              CBZ      r0,|L1.7062|
;;;3151   					/* Data chunk in a soft deleted file, throw it away
;;;3152   					 * It's a soft deleted data chunk,
;;;3153   					 * No need to copy this, just forget about it and 
;;;3154   					 * fix up the object.
;;;3155   					 */
;;;3156   
;;;3157   					object->nDataChunks--;
001b72  6ae8              LDR      r0,[r5,#0x2c]
001b74  1e40              SUBS     r0,r0,#1
001b76  62e8              STR      r0,[r5,#0x2c]
;;;3158   
;;;3159   					if (object->nDataChunks <= 0) {
001b78  6ae8              LDR      r0,[r5,#0x2c]
001b7a  2800              CMP      r0,#0
001b7c  dc08              BGT      |L1.7056|
;;;3160   						/* remeber to clean up the object */
;;;3161   						dev->gcCleanupList[cleanups] =
001b7e  9906              LDR      r1,[sp,#0x18]
001b80  f8d42d3c          LDR      r2,[r4,#0xd3c]
001b84  981b              LDR      r0,[sp,#0x6c]
001b86  f8421020          STR      r1,[r2,r0,LSL #2]
;;;3162   						    tags.objectId;
;;;3163   						cleanups++;
001b8a  981b              LDR      r0,[sp,#0x6c]
001b8c  1c40              ADDS     r0,r0,#1
001b8e  901b              STR      r0,[sp,#0x6c]
                  |L1.7056|
;;;3164   					}
;;;3165   					markNAND = 0;
001b90  2000              MOVS     r0,#0
001b92  901d              STR      r0,[sp,#0x74]
001b94  e034              B        |L1.7168|
                  |L1.7062|
;;;3166   				} else if (0
;;;3167   					   /* Todo object && object->deleted && object->nDataChunks == 0 */
;;;3168   					   ) {
;;;3169   					/* Deleted object header with no data chunks.
;;;3170   					 * Can be discarded and the file deleted.
;;;3171   					 */
;;;3172   					object->hdrChunk = 0;
;;;3173   					yaffs_FreeTnode(object->myDev,
;;;3174   							object->variant.
;;;3175   							fileVariant.top);
;;;3176   					object->variant.fileVariant.top = NULL;
;;;3177   					yaffs_DoGenericObjectDeletion(object);
;;;3178   
;;;3179   				} else if (object) {
001b96  b325              CBZ      r5,|L1.7138|
;;;3180   					/* It's either a data chunk in a live file or
;;;3181   					 * an ObjectHeader, so we're interested in it.
;;;3182   					 * NB Need to keep the ObjectHeaders of deleted files
;;;3183   					 * until the whole file has been deleted off
;;;3184   					 */
;;;3185   					tags.serialNumber++;
001b98  980c              LDR      r0,[sp,#0x30]
001b9a  1c40              ADDS     r0,r0,#1
001b9c  900c              STR      r0,[sp,#0x30]
;;;3186   
;;;3187   					dev->nGCCopies++;
001b9e  f8d40d54          LDR      r0,[r4,#0xd54]
001ba2  1c40              ADDS     r0,r0,#1
001ba4  f8c40d54          STR      r0,[r4,#0xd54]
;;;3188   
;;;3189   					if (tags.chunkId == 0) {
001ba8  9807              LDR      r0,[sp,#0x1c]
001baa  b970              CBNZ     r0,|L1.7114|
;;;3190   						/* It is an object Id,
;;;3191   						 * We need to nuke the shrinkheader flags first
;;;3192   						 * We no longer want the shrinkHeader flag since its work is done
;;;3193   						 * and if it is left in place it will mess up scanning.
;;;3194   						 */
;;;3195   
;;;3196   						yaffs_ObjectHeader *oh;
;;;3197   						oh = (yaffs_ObjectHeader *)buffer;
001bac  f8cdb00c          STR      r11,[sp,#0xc]
;;;3198   						oh->isShrink = 0;
001bb0  2000              MOVS     r0,#0
001bb2  f8ddb00c          LDR      r11,[sp,#0xc]
001bb6  f8cb01fc          STR      r0,[r11,#0x1fc]
;;;3199   						tags.extraIsShrinkHeader = 0;
001bba  9010              STR      r0,[sp,#0x40]
;;;3200   						
;;;3201   						yaffs_VerifyObjectHeader(object,oh,&tags,1);
001bbc  2301              MOVS     r3,#1
001bbe  aa04              ADD      r2,sp,#0x10
001bc0  4628              MOV      r0,r5
001bc2  9903              LDR      r1,[sp,#0xc]
001bc4  f7fffffe          BL       yaffs_VerifyObjectHeader
;;;3202   					}
001bc8  bf00              NOP      
                  |L1.7114|
;;;3203   
;;;3204   					newChunk =
001bca  2301              MOVS     r3,#1
001bcc  aa04              ADD      r2,sp,#0x10
001bce  4659              MOV      r1,r11
001bd0  4620              MOV      r0,r4
001bd2  f7fffffe          BL       yaffs_WriteNewChunkWithTagsToNAND
001bd6  4680              MOV      r8,r0
;;;3205   					    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &tags, 1);
;;;3206   
;;;3207   					if (newChunk < 0) {
001bd8  f1b80f00          CMP      r8,#0
001bdc  da03              BGE      |L1.7142|
;;;3208   						retVal = YAFFS_FAIL;
001bde  2000              MOVS     r0,#0
001be0  901c              STR      r0,[sp,#0x70]
                  |L1.7138|
001be2  e00d              B        |L1.7168|
                  |L1.7140|
001be4  e016              B        |L1.7188|
                  |L1.7142|
;;;3209   					} else {
;;;3210   
;;;3211   						/* Ok, now fix up the Tnodes etc. */
;;;3212   
;;;3213   						if (tags.chunkId == 0) {
001be6  9807              LDR      r0,[sp,#0x1c]
001be8  b920              CBNZ     r0,|L1.7156|
;;;3214   							/* It's a header */
;;;3215   							object->hdrChunk =  newChunk;
001bea  f8c58028          STR      r8,[r5,#0x28]
;;;3216   							object->serial =   tags.serialNumber;
001bee  980c              LDR      r0,[sp,#0x30]
001bf0  70a8              STRB     r0,[r5,#2]
001bf2  e005              B        |L1.7168|
                  |L1.7156|
;;;3217   						} else {
;;;3218   							/* It's a data chunk */
;;;3219   							yaffs_PutChunkIntoFile
001bf4  2300              MOVS     r3,#0
001bf6  4642              MOV      r2,r8
001bf8  4628              MOV      r0,r5
001bfa  9907              LDR      r1,[sp,#0x1c]
001bfc  f7fffffe          BL       yaffs_PutChunkIntoFile
                  |L1.7168|
;;;3220   							    (object,
;;;3221   							     tags.chunkId,
;;;3222   							     newChunk, 0);
;;;3223   						}
;;;3224   					}
;;;3225   				}
;;;3226   
;;;3227   				if(retVal == YAFFS_OK)
001c00  981c              LDR      r0,[sp,#0x70]
001c02  2801              CMP      r0,#1
001c04  d106              BNE      |L1.7188|
;;;3228   					yaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);
001c06  f640439c          MOV      r3,#0xc9c
001c0a  4639              MOV      r1,r7
001c0c  4620              MOV      r0,r4
001c0e  9a1d              LDR      r2,[sp,#0x74]
001c10  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.7188|
001c14  f8d4011c          LDR      r0,[r4,#0x11c]        ;3100
001c18  1c40              ADDS     r0,r0,#1              ;3100
001c1a  f8c4011c          STR      r0,[r4,#0x11c]        ;3100
001c1e  1c7f              ADDS     r7,r7,#1              ;3100
                  |L1.7200|
001c20  981c              LDR      r0,[sp,#0x70]         ;3096
001c22  2801              CMP      r0,#1                 ;3096
001c24  d10d              BNE      |L1.7234|
001c26  6921              LDR      r1,[r4,#0x10]         ;3097
001c28  f8d4011c          LDR      r0,[r4,#0x11c]        ;3097
001c2c  4288              CMP      r0,r1                 ;3097
001c2e  da08              BGE      |L1.7234|
001c30  6830              LDR      r0,[r6,#0]            ;3098
001c32  f3c05003          UBFX     r0,r0,#20,#4          ;3098
001c36  2808              CMP      r0,#8                 ;3098
001c38  d103              BNE      |L1.7234|
001c3a  9818              LDR      r0,[sp,#0x60]         ;3099
001c3c  2800              CMP      r0,#0                 ;3099
001c3e  f73faf52          BGT      |L1.6886|
                  |L1.7234|
;;;3229   
;;;3230   			}
;;;3231   		}
;;;3232   
;;;3233   		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
001c42  f64042a1          MOV      r2,#0xca1
001c46  4659              MOV      r1,r11
001c48  4620              MOV      r0,r4
001c4a  f7fffffe          BL       yaffs_ReleaseTempBuffer
;;;3234   
;;;3235   
;;;3236   		/* Do any required cleanups */
;;;3237   		for (i = 0; i < cleanups; i++) {
001c4e  f04f0a00          MOV      r10,#0
001c52  e01c              B        |L1.7310|
                  |L1.7252|
;;;3238   			/* Time to delete the file too */
;;;3239   			object =
001c54  f8d40d3c          LDR      r0,[r4,#0xd3c]
001c58  f850102a          LDR      r1,[r0,r10,LSL #2]
001c5c  4620              MOV      r0,r4
001c5e  f7fffffe          BL       yaffs_FindObjectByNumber
001c62  4605              MOV      r5,r0
;;;3240   			    yaffs_FindObjectByNumber(dev,
;;;3241   						     dev->gcCleanupList[i]);
;;;3242   			if (object) {
001c64  b18d              CBZ      r5,|L1.7306|
;;;3243   				yaffs_FreeTnode(dev,
001c66  4620              MOV      r0,r4
001c68  6ea9              LDR      r1,[r5,#0x68]
001c6a  f7fffffe          BL       yaffs_FreeTnode
;;;3244   						object->variant.fileVariant.
;;;3245   						top);
;;;3246   				object->variant.fileVariant.top = NULL;
001c6e  2100              MOVS     r1,#0
001c70  66a9              STR      r1,[r5,#0x68]
;;;3247   				T(YAFFS_TRACE_GC,
001c72  bf00              NOP      
001c74  bf00              NOP      
;;;3248   				  (TSTR
;;;3249   				   ("yaffs: About to finally delete object %d"
;;;3250   				    TENDSTR), object->objectId));
;;;3251   				yaffs_DoGenericObjectDeletion(object);
001c76  4628              MOV      r0,r5
001c78  f7fffffe          BL       yaffs_DoGenericObjectDeletion
;;;3252   				object->myDev->nDeletedFiles--;
001c7c  68a8              LDR      r0,[r5,#8]
001c7e  f8d00dac          LDR      r0,[r0,#0xdac]
001c82  1e40              SUBS     r0,r0,#1
001c84  68a9              LDR      r1,[r5,#8]
001c86  f8c10dac          STR      r0,[r1,#0xdac]
                  |L1.7306|
001c8a  f10a0a01          ADD      r10,r10,#1            ;3237
                  |L1.7310|
001c8e  981b              LDR      r0,[sp,#0x6c]         ;3237
001c90  4582              CMP      r10,r0                ;3237
001c92  dbdf              BLT      |L1.7252|
;;;3253   			}
;;;3254   
;;;3255   		}
;;;3256   
;;;3257   	}
001c94  bf00              NOP      
                  |L1.7318|
;;;3258   
;;;3259   	yaffs_VerifyCollectedBlock(dev,bi,block);
001c96  464a              MOV      r2,r9
001c98  4631              MOV      r1,r6
001c9a  4620              MOV      r0,r4
001c9c  f7fffffe          BL       yaffs_VerifyCollectedBlock
;;;3260   	  
;;;3261   	if (chunksBefore >= (chunksAfter = yaffs_GetErasedChunks(dev))) {
001ca0  4620              MOV      r0,r4
001ca2  f7fffffe          BL       yaffs_GetErasedChunks
001ca6  9016              STR      r0,[sp,#0x58]
001ca8  9917              LDR      r1,[sp,#0x5c]
001caa  4288              CMP      r0,r1
001cac  dc01              BGT      |L1.7346|
;;;3262   		T(YAFFS_TRACE_GC,
001cae  bf00              NOP      
001cb0  bf00              NOP      
                  |L1.7346|
;;;3263   		  (TSTR
;;;3264   		   ("gc did not increase free chunks before %d after %d"
;;;3265   		    TENDSTR), chunksBefore, chunksAfter));
;;;3266   	}
;;;3267   
;;;3268   	/* If the gc completed then clear the current gcBlock so that we find another. */
;;;3269   	if(bi->blockState != YAFFS_BLOCK_STATE_COLLECTING){
001cb2  6830              LDR      r0,[r6,#0]
001cb4  f3c05003          UBFX     r0,r0,#20,#4
001cb8  2808              CMP      r0,#8
001cba  d006              BEQ      |L1.7370|
;;;3270   		dev->gcBlock = -1;
001cbc  f04f30ff          MOV      r0,#0xffffffff
001cc0  f8c40118          STR      r0,[r4,#0x118]
;;;3271   		dev->gcChunk = 0;
001cc4  2000              MOVS     r0,#0
001cc6  f8c4011c          STR      r0,[r4,#0x11c]
                  |L1.7370|
;;;3272   	}
;;;3273   	
;;;3274   	dev->isDoingGC = 0;
001cca  2000              MOVS     r0,#0
001ccc  f8c40114          STR      r0,[r4,#0x114]
;;;3275   
;;;3276   	return retVal;
001cd0  981c              LDR      r0,[sp,#0x70]
;;;3277   }
001cd2  b021              ADD      sp,sp,#0x84
001cd4  e8bd8ff0          POP      {r4-r11,pc}
;;;3278   
                          ENDP

                  yaffs_BlockNotDisqualifiedFromGC PROC
;;;2646   
;;;2647   static int yaffs_BlockNotDisqualifiedFromGC(yaffs_Device * dev,
001cd8  e92d41f0          PUSH     {r4-r8,lr}
;;;2648   					    yaffs_BlockInfo * bi)
;;;2649   {
001cdc  4604              MOV      r4,r0
001cde  460f              MOV      r7,r1
;;;2650   	int i;
;;;2651   	__u32 seq;
;;;2652   	yaffs_BlockInfo *b;
;;;2653   
;;;2654   	if (!dev->isYaffs2)
001ce0  6de0              LDR      r0,[r4,#0x5c]
001ce2  b910              CBNZ     r0,|L1.7402|
;;;2655   		return 1;	/* disqualification only applies to yaffs2. */
001ce4  2001              MOVS     r0,#1
                  |L1.7398|
;;;2656   
;;;2657   	if (!bi->hasShrinkHeader)
;;;2658   		return 1;	/* can gc */
;;;2659   
;;;2660   	/* Find the oldest dirty sequence number if we don't know it and save it
;;;2661   	 * so we don't have to keep recomputing it.
;;;2662   	 */
;;;2663   	if (!dev->oldestDirtySequence) {
;;;2664   		seq = dev->sequenceNumber;
;;;2665   
;;;2666   		for (i = dev->internalStartBlock; i <= dev->internalEndBlock;
;;;2667   		     i++) {
;;;2668   			b = yaffs_GetBlockInfo(dev, i);
;;;2669   			if (b->blockState == YAFFS_BLOCK_STATE_FULL &&
;;;2670   			    (b->pagesInUse - b->softDeletions) <
;;;2671   			    dev->nChunksPerBlock && b->sequenceNumber < seq) {
;;;2672   				seq = b->sequenceNumber;
;;;2673   			}
;;;2674   		}
;;;2675   		dev->oldestDirtySequence = seq;
;;;2676   	}
;;;2677   
;;;2678   	/* Can't do gc of this block if there are any blocks older than this one that have
;;;2679   	 * discarded pages.
;;;2680   	 */
;;;2681   	return (bi->sequenceNumber <= dev->oldestDirtySequence);
;;;2682   
;;;2683   }
001ce6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7402|
001cea  6838              LDR      r0,[r7,#0]            ;2657
001cec  f3c07080          UBFX     r0,r0,#30,#1          ;2657
001cf0  b908              CBNZ     r0,|L1.7414|
001cf2  2001              MOVS     r0,#1                 ;2658
001cf4  e7f7              B        |L1.7398|
                  |L1.7414|
001cf6  f8d40e14          LDR      r0,[r4,#0xe14]        ;2663
001cfa  bb20              CBNZ     r0,|L1.7494|
001cfc  f8d48e10          LDR      r8,[r4,#0xe10]        ;2664
001d00  f8d4609c          LDR      r6,[r4,#0x9c]         ;2666
001d04  e019              B        |L1.7482|
                  |L1.7430|
001d06  4631              MOV      r1,r6                 ;2668
001d08  4620              MOV      r0,r4                 ;2668
001d0a  f7fffffe          BL       yaffs_GetBlockInfo
001d0e  4605              MOV      r5,r0                 ;2668
001d10  6828              LDR      r0,[r5,#0]            ;2669
001d12  f3c05003          UBFX     r0,r0,#20,#4          ;2669
001d16  2805              CMP      r0,#5                 ;2669
001d18  d10e              BNE      |L1.7480|
001d1a  6828              LDR      r0,[r5,#0]            ;2670
001d1c  f3c02089          UBFX     r0,r0,#10,#10         ;2670
001d20  8829              LDRH     r1,[r5,#0]            ;2670
001d22  f3c10109          UBFX     r1,r1,#0,#10          ;2670
001d26  1a40              SUBS     r0,r0,r1              ;2670
001d28  6921              LDR      r1,[r4,#0x10]         ;2670
001d2a  4288              CMP      r0,r1                 ;2670
001d2c  da04              BGE      |L1.7480|
001d2e  6868              LDR      r0,[r5,#4]            ;2671
001d30  4540              CMP      r0,r8                 ;2671
001d32  d201              BCS      |L1.7480|
001d34  f8d58004          LDR      r8,[r5,#4]            ;2672
                  |L1.7480|
001d38  1c76              ADDS     r6,r6,#1              ;2667
                  |L1.7482|
001d3a  f8d400a0          LDR      r0,[r4,#0xa0]         ;2666
001d3e  42b0              CMP      r0,r6                 ;2666
001d40  dae1              BGE      |L1.7430|
001d42  f8c48e14          STR      r8,[r4,#0xe14]        ;2675
                  |L1.7494|
001d46  6878              LDR      r0,[r7,#4]            ;2681
001d48  f8d41e14          LDR      r1,[r4,#0xe14]        ;2681
001d4c  4288              CMP      r0,r1                 ;2681
001d4e  d801              BHI      |L1.7508|
001d50  2001              MOVS     r0,#1                 ;2681
001d52  e7c8              B        |L1.7398|
                  |L1.7508|
001d54  2000              MOVS     r0,#0                 ;2681
001d56  e7c6              B        |L1.7398|
;;;2684   
                          ENDP

                  yaffs_FindBlockForGarbageCollection PROC
;;;2688   
;;;2689   static int yaffs_FindBlockForGarbageCollection(yaffs_Device * dev,
001d58  e92d5ffc          PUSH     {r2-r12,lr}
;;;2690   					       int aggressive)
;;;2691   {
001d5c  4604              MOV      r4,r0
001d5e  4689              MOV      r9,r1
;;;2692   
;;;2693   	int b = dev->currentDirtyChecker;
001d60  f8d46d38          LDR      r6,[r4,#0xd38]
;;;2694   
;;;2695   	int i;
;;;2696   	int iterations;
;;;2697   	int dirtiest = -1;
001d64  f04f3aff          MOV      r10,#0xffffffff
;;;2698   	int pagesInUse = 0;
001d68  2000              MOVS     r0,#0
001d6a  9001              STR      r0,[sp,#4]
;;;2699   	int prioritised=0;
001d6c  4683              MOV      r11,r0
;;;2700   	yaffs_BlockInfo *bi;
;;;2701   	int pendingPrioritisedExist = 0;
001d6e  9000              STR      r0,[sp,#0]
;;;2702   	
;;;2703   	/* First let's see if we need to grab a prioritised block */
;;;2704   	if(dev->hasPendingPrioritisedGCs){
001d70  f8d40d80          LDR      r0,[r4,#0xd80]
001d74  b380              CBZ      r0,|L1.7640|
;;;2705   		for(i = dev->internalStartBlock; i < dev->internalEndBlock && !prioritised; i++){
001d76  f8d4709c          LDR      r7,[r4,#0x9c]
001d7a  e021              B        |L1.7616|
                  |L1.7548|
;;;2706   
;;;2707   			bi = yaffs_GetBlockInfo(dev, i);
001d7c  4639              MOV      r1,r7
001d7e  4620              MOV      r0,r4
001d80  f7fffffe          BL       yaffs_GetBlockInfo
001d84  4605              MOV      r5,r0
;;;2708   			//yaffs_VerifyBlock(dev,bi,i);
;;;2709   			
;;;2710   			if(bi->gcPrioritise) {
001d86  6828              LDR      r0,[r5,#0]
001d88  f3c06080          UBFX     r0,r0,#26,#1
001d8c  b1b8              CBZ      r0,|L1.7614|
;;;2711   				pendingPrioritisedExist = 1;
001d8e  2001              MOVS     r0,#1
001d90  9000              STR      r0,[sp,#0]
;;;2712   				if(bi->blockState == YAFFS_BLOCK_STATE_FULL &&
001d92  6828              LDR      r0,[r5,#0]
001d94  f3c05003          UBFX     r0,r0,#20,#4
001d98  2805              CMP      r0,#5
001d9a  d110              BNE      |L1.7614|
;;;2713   				   yaffs_BlockNotDisqualifiedFromGC(dev, bi)){
001d9c  4629              MOV      r1,r5
001d9e  4620              MOV      r0,r4
001da0  f7fffffe          BL       yaffs_BlockNotDisqualifiedFromGC
001da4  b158              CBZ      r0,|L1.7614|
;;;2714   					pagesInUse = (bi->pagesInUse - bi->softDeletions);
001da6  6828              LDR      r0,[r5,#0]
001da8  f3c02089          UBFX     r0,r0,#10,#10
001dac  8829              LDRH     r1,[r5,#0]
001dae  f3c10109          UBFX     r1,r1,#0,#10
001db2  1a40              SUBS     r0,r0,r1
001db4  9001              STR      r0,[sp,#4]
;;;2715   					dirtiest = i;
001db6  46ba              MOV      r10,r7
;;;2716   					prioritised = 1;
001db8  f04f0b01          MOV      r11,#1
;;;2717   					aggressive = 1; /* Fool the non-aggressive skip logiv below */
001dbc  46d9              MOV      r9,r11
                  |L1.7614|
001dbe  1c7f              ADDS     r7,r7,#1              ;2705
                  |L1.7616|
001dc0  f8d400a0          LDR      r0,[r4,#0xa0]         ;2705
001dc4  42b8              CMP      r0,r7                 ;2705
001dc6  dd02              BLE      |L1.7630|
001dc8  f1bb0f00          CMP      r11,#0                ;2705
001dcc  d0d6              BEQ      |L1.7548|
                  |L1.7630|
;;;2718   				}
;;;2719   			}
;;;2720   		}
;;;2721   		
;;;2722   		if(!pendingPrioritisedExist) /* None found, so we can clear this */
001dce  9800              LDR      r0,[sp,#0]
001dd0  b910              CBNZ     r0,|L1.7640|
;;;2723   			dev->hasPendingPrioritisedGCs = 0;
001dd2  2000              MOVS     r0,#0
001dd4  f8c40d80          STR      r0,[r4,#0xd80]
                  |L1.7640|
;;;2724   	}
;;;2725   
;;;2726   	/* If we're doing aggressive GC then we are happy to take a less-dirty block, and
;;;2727   	 * search harder.
;;;2728   	 * else (we're doing a leasurely gc), then we only bother to do this if the
;;;2729   	 * block has only a few pages in use.
;;;2730   	 */
;;;2731   
;;;2732   	dev->nonAggressiveSkip--;
001dd8  f8d40d40          LDR      r0,[r4,#0xd40]
001ddc  1e40              SUBS     r0,r0,#1
001dde  f8c40d40          STR      r0,[r4,#0xd40]
;;;2733   
;;;2734   	if (!aggressive && (dev->nonAggressiveSkip > 0)) {
001de2  f1b90f00          CMP      r9,#0
001de6  d107              BNE      |L1.7672|
001de8  f8d40d40          LDR      r0,[r4,#0xd40]
001dec  2800              CMP      r0,#0
001dee  dd03              BLE      |L1.7672|
;;;2735   		return -1;
001df0  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7668|
;;;2736   	}
;;;2737   
;;;2738   	if(!prioritised)
;;;2739   		pagesInUse =
;;;2740   	    		(aggressive) ? dev->nChunksPerBlock : YAFFS_PASSIVE_GC_CHUNKS + 1;
;;;2741   
;;;2742   	if (aggressive) {
;;;2743   		iterations =
;;;2744   		    dev->internalEndBlock - dev->internalStartBlock + 1;
;;;2745   	} else {
;;;2746   		iterations =
;;;2747   		    dev->internalEndBlock - dev->internalStartBlock + 1;
;;;2748   		iterations = iterations / 16;
;;;2749   		if (iterations > 200) {
;;;2750   			iterations = 200;
;;;2751   		}
;;;2752   	}
;;;2753   
;;;2754   	for (i = 0; i <= iterations && pagesInUse > 0 && !prioritised; i++) {
;;;2755   		b++;
;;;2756   		if (b < dev->internalStartBlock || b > dev->internalEndBlock) {
;;;2757   			b = dev->internalStartBlock;
;;;2758   		}
;;;2759   
;;;2760   		if (b < dev->internalStartBlock || b > dev->internalEndBlock) {
;;;2761   			T(YAFFS_TRACE_ERROR,
;;;2762   			  (TSTR("**>> Block %d is not valid" TENDSTR), b));
;;;2763   			YBUG();
;;;2764   		}
;;;2765   
;;;2766   		bi = yaffs_GetBlockInfo(dev, b);
;;;2767   
;;;2768   #if 0
;;;2769   		if (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT) {
;;;2770   			dirtiest = b;
;;;2771   			pagesInUse = 0;
;;;2772   		}
;;;2773   		else 
;;;2774   #endif
;;;2775   
;;;2776   		if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
;;;2777   		       (bi->pagesInUse - bi->softDeletions) < pagesInUse &&
;;;2778   		        yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
;;;2779   			dirtiest = b;
;;;2780   			pagesInUse = (bi->pagesInUse - bi->softDeletions);
;;;2781   		}
;;;2782   	}
;;;2783   
;;;2784   	dev->currentDirtyChecker = b;
;;;2785   
;;;2786   	if (dirtiest > 0) {
;;;2787   		T(YAFFS_TRACE_GC,
;;;2788   		  (TSTR("GC Selected block %d with %d free, prioritised:%d" TENDSTR), dirtiest,
;;;2789   		   dev->nChunksPerBlock - pagesInUse,prioritised));
;;;2790   	}
;;;2791   
;;;2792   	dev->oldestDirtySequence = 0;
;;;2793   
;;;2794   	if (dirtiest > 0) {
;;;2795   		dev->nonAggressiveSkip = 4;
;;;2796   	}
;;;2797   
;;;2798   	return dirtiest;
;;;2799   }
001df4  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.7672|
001df8  f1bb0f00          CMP      r11,#0                ;2738
001dfc  d106              BNE      |L1.7692|
001dfe  f1b90f00          CMP      r9,#0                 ;2739
001e02  d001              BEQ      |L1.7688|
001e04  6920              LDR      r0,[r4,#0x10]         ;2740
001e06  e000              B        |L1.7690|
                  |L1.7688|
001e08  2003              MOVS     r0,#3                 ;2740
                  |L1.7690|
001e0a  9001              STR      r0,[sp,#4]            ;2740
                  |L1.7692|
001e0c  f1b90f00          CMP      r9,#0                 ;2742
001e10  d005              BEQ      |L1.7710|
001e12  e9d41027          LDRD     r1,r0,[r4,#0x9c]      ;2743
001e16  1a40              SUBS     r0,r0,r1              ;2743
001e18  f1000801          ADD      r8,r0,#1              ;2743
001e1c  e010              B        |L1.7744|
                  |L1.7710|
001e1e  e9d41027          LDRD     r1,r0,[r4,#0x9c]      ;2746
001e22  1a40              SUBS     r0,r0,r1              ;2746
001e24  f1000801          ADD      r8,r0,#1              ;2746
001e28  4640              MOV      r0,r8                 ;2748
001e2a  ea4f71e8          ASR      r1,r8,#31             ;2748
001e2e  eb087111          ADD      r1,r8,r1,LSR #28      ;2748
001e32  ea4f1821          ASR      r8,r1,#4              ;2748
001e36  f1b80fc8          CMP      r8,#0xc8              ;2749
001e3a  dd01              BLE      |L1.7744|
001e3c  f04f08c8          MOV      r8,#0xc8              ;2750
                  |L1.7744|
001e40  2700              MOVS     r7,#0                 ;2754
001e42  e037              B        |L1.7860|
                  |L1.7748|
001e44  1c76              ADDS     r6,r6,#1              ;2755
001e46  f8d4009c          LDR      r0,[r4,#0x9c]         ;2756
001e4a  42b0              CMP      r0,r6                 ;2756
001e4c  dc03              BGT      |L1.7766|
001e4e  f8d400a0          LDR      r0,[r4,#0xa0]         ;2756
001e52  42b0              CMP      r0,r6                 ;2756
001e54  da01              BGE      |L1.7770|
                  |L1.7766|
001e56  f8d4609c          LDR      r6,[r4,#0x9c]         ;2757
                  |L1.7770|
001e5a  f8d4009c          LDR      r0,[r4,#0x9c]         ;2760
001e5e  42b0              CMP      r0,r6                 ;2760
001e60  dc03              BGT      |L1.7786|
001e62  f8d400a0          LDR      r0,[r4,#0xa0]         ;2760
001e66  42b0              CMP      r0,r6                 ;2760
001e68  da01              BGE      |L1.7790|
                  |L1.7786|
001e6a  bf00              NOP                            ;2761
001e6c  bf00              NOP                            ;2761
                  |L1.7790|
001e6e  4631              MOV      r1,r6                 ;2766
001e70  4620              MOV      r0,r4                 ;2766
001e72  f7fffffe          BL       yaffs_GetBlockInfo
001e76  4605              MOV      r5,r0                 ;2766
001e78  6828              LDR      r0,[r5,#0]            ;2776
001e7a  f3c05003          UBFX     r0,r0,#20,#4          ;2776
001e7e  2805              CMP      r0,#5                 ;2776
001e80  d117              BNE      |L1.7858|
001e82  6828              LDR      r0,[r5,#0]            ;2777
001e84  f3c02089          UBFX     r0,r0,#10,#10         ;2777
001e88  8829              LDRH     r1,[r5,#0]            ;2777
001e8a  f3c10109          UBFX     r1,r1,#0,#10          ;2777
001e8e  1a41              SUBS     r1,r0,r1              ;2777
001e90  9801              LDR      r0,[sp,#4]            ;2777
001e92  4281              CMP      r1,r0                 ;2777
001e94  da0d              BGE      |L1.7858|
001e96  4629              MOV      r1,r5                 ;2778
001e98  4620              MOV      r0,r4                 ;2778
001e9a  f7fffffe          BL       yaffs_BlockNotDisqualifiedFromGC
001e9e  b140              CBZ      r0,|L1.7858|
001ea0  46b2              MOV      r10,r6                ;2779
001ea2  6828              LDR      r0,[r5,#0]            ;2780
001ea4  f3c02089          UBFX     r0,r0,#10,#10         ;2780
001ea8  8829              LDRH     r1,[r5,#0]            ;2780
001eaa  f3c10109          UBFX     r1,r1,#0,#10          ;2780
001eae  1a40              SUBS     r0,r0,r1              ;2780
001eb0  9001              STR      r0,[sp,#4]            ;2780
                  |L1.7858|
001eb2  1c7f              ADDS     r7,r7,#1              ;2754
                  |L1.7860|
001eb4  4547              CMP      r7,r8                 ;2754
001eb6  dc05              BGT      |L1.7876|
001eb8  9801              LDR      r0,[sp,#4]            ;2754
001eba  2800              CMP      r0,#0                 ;2754
001ebc  dd02              BLE      |L1.7876|
001ebe  f1bb0f00          CMP      r11,#0                ;2754
001ec2  d0bf              BEQ      |L1.7748|
                  |L1.7876|
001ec4  f8c46d38          STR      r6,[r4,#0xd38]        ;2784
001ec8  f1ba0f00          CMP      r10,#0                ;2786
001ecc  dd01              BLE      |L1.7890|
001ece  bf00              NOP                            ;2787
001ed0  bf00              NOP                            ;2787
                  |L1.7890|
001ed2  2000              MOVS     r0,#0                 ;2792
001ed4  f8c40e14          STR      r0,[r4,#0xe14]        ;2792
001ed8  f1ba0f00          CMP      r10,#0                ;2794
001edc  dd02              BLE      |L1.7908|
001ede  2004              MOVS     r0,#4                 ;2795
001ee0  f8c40d40          STR      r0,[r4,#0xd40]        ;2795
                  |L1.7908|
001ee4  4650              MOV      r0,r10                ;2798
001ee6  e785              B        |L1.7668|
;;;2800   
                          ENDP

                  yaffs_CheckGarbageCollection PROC
;;;3287    */
;;;3288   static int yaffs_CheckGarbageCollection(yaffs_Device * dev)
001ee8  e92d47f0          PUSH     {r4-r10,lr}
;;;3289   {
001eec  4604              MOV      r4,r0
;;;3290   	int block;
;;;3291   	int aggressive;
;;;3292   	int gcOk = YAFFS_OK;
001eee  f04f0901          MOV      r9,#1
;;;3293   	int maxTries = 0;
001ef2  f04f0800          MOV      r8,#0
;;;3294   	
;;;3295   	int checkpointBlockAdjust;
;;;3296   
;;;3297   	if (dev->isDoingGC) {
001ef6  f8d40114          LDR      r0,[r4,#0x114]
001efa  b110              CBZ      r0,|L1.7938|
;;;3298   		/* Bail out so we don't get recursive gc */
;;;3299   		return YAFFS_OK;
001efc  2001              MOVS     r0,#1
                  |L1.7934|
;;;3300   	}
;;;3301   	
;;;3302   	/* This loop should pass the first time.
;;;3303   	 * We'll only see looping here if the erase of the collected block fails.
;;;3304   	 */
;;;3305   
;;;3306   	do {
;;;3307   		maxTries++;
;;;3308   		
;;;3309   		checkpointBlockAdjust = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
;;;3310   		if(checkpointBlockAdjust < 0)
;;;3311   			checkpointBlockAdjust = 0;
;;;3312   
;;;3313   		if (dev->nErasedBlocks < (dev->nReservedBlocks + checkpointBlockAdjust + 2)) {
;;;3314   			/* We need a block soon...*/
;;;3315   			aggressive = 1;
;;;3316   		} else {
;;;3317   			/* We're in no hurry */
;;;3318   			aggressive = 0;
;;;3319   		}
;;;3320   
;;;3321   		if(dev->gcBlock <= 0){
;;;3322   			dev->gcBlock = yaffs_FindBlockForGarbageCollection(dev, aggressive);
;;;3323   			dev->gcChunk = 0;
;;;3324   		}
;;;3325   		
;;;3326   		block = dev->gcBlock;
;;;3327   
;;;3328   		if (block > 0) {
;;;3329   			dev->garbageCollections++;
;;;3330   			if (!aggressive) {
;;;3331   				dev->passiveGarbageCollections++;
;;;3332   			}
;;;3333   
;;;3334   			T(YAFFS_TRACE_GC,
;;;3335   			  (TSTR
;;;3336   			   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),
;;;3337   			   dev->nErasedBlocks, aggressive));
;;;3338   
;;;3339   			gcOk = yaffs_GarbageCollectBlock(dev,block,aggressive);
;;;3340   		}
;;;3341   
;;;3342   		if (dev->nErasedBlocks < (dev->nReservedBlocks) && block > 0) {
;;;3343   			T(YAFFS_TRACE_GC,
;;;3344   			  (TSTR
;;;3345   			   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"
;;;3346   			    TENDSTR), dev->nErasedBlocks, maxTries, block));
;;;3347   		}
;;;3348   	} while ((dev->nErasedBlocks < dev->nReservedBlocks) && 
;;;3349   		 (block > 0) &&
;;;3350   		 (maxTries < 2));
;;;3351   
;;;3352   	return aggressive ? gcOk : YAFFS_OK;
;;;3353   }
001efe  e8bd87f0          POP      {r4-r10,pc}
                  |L1.7938|
001f02  bf00              NOP                            ;3306
                  |L1.7940|
001f04  f1080801          ADD      r8,r8,#1              ;3307
001f08  4620              MOV      r0,r4                 ;3309
001f0a  f7fffffe          BL       yaffs_CalcCheckpointBlocksRequired
001f0e  f8d410c0          LDR      r1,[r4,#0xc0]         ;3309
001f12  1a47              SUBS     r7,r0,r1              ;3309
001f14  2f00              CMP      r7,#0                 ;3310
001f16  da00              BGE      |L1.7962|
001f18  2700              MOVS     r7,#0                 ;3311
                  |L1.7962|
001f1a  6a20              LDR      r0,[r4,#0x20]         ;3313
001f1c  4438              ADD      r0,r0,r7              ;3313
001f1e  1c80              ADDS     r0,r0,#2              ;3313
001f20  f8d410f4          LDR      r1,[r4,#0xf4]         ;3313
001f24  4281              CMP      r1,r0                 ;3313
001f26  da01              BGE      |L1.7980|
001f28  2601              MOVS     r6,#1                 ;3315
001f2a  e000              B        |L1.7982|
                  |L1.7980|
001f2c  2600              MOVS     r6,#0                 ;3318
                  |L1.7982|
001f2e  f8d40118          LDR      r0,[r4,#0x118]        ;3321
001f32  2800              CMP      r0,#0                 ;3321
001f34  dc08              BGT      |L1.8008|
001f36  4631              MOV      r1,r6                 ;3322
001f38  4620              MOV      r0,r4                 ;3322
001f3a  f7fffffe          BL       yaffs_FindBlockForGarbageCollection
001f3e  f8c40118          STR      r0,[r4,#0x118]        ;3322
001f42  2000              MOVS     r0,#0                 ;3323
001f44  f8c4011c          STR      r0,[r4,#0x11c]        ;3323
                  |L1.8008|
001f48  f8d45118          LDR      r5,[r4,#0x118]        ;3326
001f4c  2d00              CMP      r5,#0                 ;3328
001f4e  dd12              BLE      |L1.8054|
001f50  f8d40d58          LDR      r0,[r4,#0xd58]        ;3329
001f54  1c40              ADDS     r0,r0,#1              ;3329
001f56  f8c40d58          STR      r0,[r4,#0xd58]        ;3329
001f5a  b926              CBNZ     r6,|L1.8038|
001f5c  f8d40d5c          LDR      r0,[r4,#0xd5c]        ;3331
001f60  1c40              ADDS     r0,r0,#1              ;3331
001f62  f8c40d5c          STR      r0,[r4,#0xd5c]        ;3331
                  |L1.8038|
001f66  bf00              NOP                            ;3334
001f68  bf00              NOP                            ;3334
001f6a  4632              MOV      r2,r6                 ;3339
001f6c  4629              MOV      r1,r5                 ;3339
001f6e  4620              MOV      r0,r4                 ;3339
001f70  f7fffffe          BL       yaffs_GarbageCollectBlock
001f74  4681              MOV      r9,r0                 ;3339
                  |L1.8054|
001f76  6a21              LDR      r1,[r4,#0x20]         ;3342
001f78  f8d400f4          LDR      r0,[r4,#0xf4]         ;3342
001f7c  4288              CMP      r0,r1                 ;3342
001f7e  da03              BGE      |L1.8072|
001f80  2d00              CMP      r5,#0                 ;3342
001f82  dd01              BLE      |L1.8072|
001f84  bf00              NOP                            ;3343
001f86  bf00              NOP                            ;3343
                  |L1.8072|
001f88  6a21              LDR      r1,[r4,#0x20]         ;3348
001f8a  f8d400f4          LDR      r0,[r4,#0xf4]         ;3348
001f8e  4288              CMP      r0,r1                 ;3348
001f90  da04              BGE      |L1.8092|
001f92  2d00              CMP      r5,#0                 ;3349
001f94  dd02              BLE      |L1.8092|
001f96  f1b80f02          CMP      r8,#2                 ;3350
001f9a  dbb3              BLT      |L1.7940|
                  |L1.8092|
001f9c  b10e              CBZ      r6,|L1.8098|
001f9e  4648              MOV      r0,r9                 ;3352
001fa0  e7ad              B        |L1.7934|
                  |L1.8098|
001fa2  2001              MOVS     r0,#1                 ;3352
001fa4  e7ab              B        |L1.7934|
;;;3354   
                          ENDP

                  yaffs_UpdateObjectHeader PROC
;;;3764    */
;;;3765   int yaffs_UpdateObjectHeader(yaffs_Object * in, const YCHAR * name, int force,
001fa6  e92d4fff          PUSH     {r0-r11,lr}
;;;3766   			     int isShrink, int shadows)
;;;3767   {
001faa  b0e9              SUB      sp,sp,#0x1a4
001fac  4604              MOV      r4,r0
001fae  468a              MOV      r10,r1
001fb0  469b              MOV      r11,r3
;;;3768   
;;;3769   	yaffs_BlockInfo *bi;
;;;3770   
;;;3771   	yaffs_Device *dev = in->myDev;
001fb2  68a0              LDR      r0,[r4,#8]
001fb4  9068              STR      r0,[sp,#0x1a0]
;;;3772   
;;;3773   	int prevChunkId;
;;;3774   	int retVal = 0;
001fb6  2000              MOVS     r0,#0
001fb8  9067              STR      r0,[sp,#0x19c]
;;;3775   	int result = 0;
001fba  9066              STR      r0,[sp,#0x198]
;;;3776   
;;;3777   	int newChunkId;
;;;3778   	yaffs_ExtendedTags newTags;
;;;3779   	yaffs_ExtendedTags oldTags;
;;;3780   
;;;3781   	__u8 *buffer = NULL;
001fbc  4680              MOV      r8,r0
;;;3782   	YCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];
;;;3783   
;;;3784           yaffs_ObjectHeader *oh = NULL;
001fbe  2500              MOVS     r5,#0
;;;3785           
;;;3786           yaffs_strcpy(oldName,_Y("silly old name"));
001fc0  a1fa              ADR      r1,|L1.9132|
001fc2  a802              ADD      r0,sp,#8
001fc4  f7fffffe          BL       strcpy
;;;3787    
;;;3788   
;;;3789   	if (!in->fake || 
001fc8  7820              LDRB     r0,[r4,#0]
001fca  f3c000c0          UBFX     r0,r0,#3,#1
001fce  b138              CBZ      r0,|L1.8160|
;;;3790   	    in == dev->rootDir || /* The rootDir should also be saved */
001fd0  9868              LDR      r0,[sp,#0x1a0]
001fd2  f8d00d84          LDR      r0,[r0,#0xd84]
001fd6  42a0              CMP      r0,r4
001fd8  d002              BEQ      |L1.8160|
;;;3791   	    force) {
001fda  986b              LDR      r0,[sp,#0x1ac]
001fdc  2800              CMP      r0,#0
001fde  d075              BEQ      |L1.8396|
                  |L1.8160|
;;;3792   
;;;3793   		yaffs_CheckGarbageCollection(dev);
001fe0  9868              LDR      r0,[sp,#0x1a0]
001fe2  f7fffffe          BL       yaffs_CheckGarbageCollection
;;;3794   		yaffs_CheckObjectDetailsLoaded(in);
001fe6  4620              MOV      r0,r4
001fe8  f7fffffe          BL       yaffs_CheckObjectDetailsLoaded
;;;3795    
;;;3796   		buffer = yaffs_GetTempBuffer(in->myDev, __LINE__);
001fec  f64061d4          MOV      r1,#0xed4
001ff0  68a0              LDR      r0,[r4,#8]
001ff2  f7fffffe          BL       yaffs_GetTempBuffer
001ff6  4680              MOV      r8,r0
;;;3797   		oh = (yaffs_ObjectHeader *) buffer;
001ff8  4645              MOV      r5,r8
;;;3798    
;;;3799   		prevChunkId = in->hdrChunk;
001ffa  6aa6              LDR      r6,[r4,#0x28]
;;;3800   
;;;3801   		if (prevChunkId > 0) {
001ffc  2e00              CMP      r6,#0
001ffe  dd13              BLE      |L1.8232|
;;;3802   			result = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,
002000  ab42              ADD      r3,sp,#0x108
002002  4642              MOV      r2,r8
002004  4631              MOV      r1,r6
002006  9868              LDR      r0,[sp,#0x1a0]
002008  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
00200c  9066              STR      r0,[sp,#0x198]
;;;3803   							buffer, &oldTags);
;;;3804   			 
;;;3805   			yaffs_VerifyObjectHeader(in,oh,&oldTags,0);
00200e  2300              MOVS     r3,#0
002010  aa42              ADD      r2,sp,#0x108
002012  4629              MOV      r1,r5
002014  4620              MOV      r0,r4
002016  f7fffffe          BL       yaffs_VerifyObjectHeader
;;;3806   			 					
;;;3807   			memcpy(oldName, oh->name, sizeof(oh->name));
00201a  f44f7280          MOV      r2,#0x100
00201e  f105010a          ADD      r1,r5,#0xa
002022  a802              ADD      r0,sp,#8
002024  f7fffffe          BL       __aeabi_memcpy
                  |L1.8232|
;;;3808   		}
;;;3809    
;;;3810   		memset(buffer, 0xFF, dev->nDataBytesPerChunk);
002028  9868              LDR      r0,[sp,#0x1a0]
00202a  22ff              MOVS     r2,#0xff
00202c  68c1              LDR      r1,[r0,#0xc]
00202e  4640              MOV      r0,r8
002030  f7fffffe          BL       __aeabi_memset
;;;3811   
;;;3812   		oh->type = in->variantType;
002034  f8940054          LDRB     r0,[r4,#0x54]
002038  35a4              ADDS     r5,r5,#0xa4
00203a  f8050ca4          STRB     r0,[r5,#-0xa4]
;;;3813   		oh->yst_mode = in->yst_mode;
00203e  6b60              LDR      r0,[r4,#0x34]
002040  66a8              STR      r0,[r5,#0x68]
;;;3814   		oh->shadowsObject = oh->inbandShadowsObject = shadows;
002042  9876              LDR      r0,[sp,#0x1d8]
002044  f8c50144          STR      r0,[r5,#0x144]
002048  f8c50154          STR      r0,[r5,#0x154]
;;;3815   
;;;3816   #ifdef CONFIG_YAFFS_WINCE
;;;3817   		oh->win_atime[0] = in->win_atime[0];
;;;3818   		oh->win_ctime[0] = in->win_ctime[0];
;;;3819   		oh->win_mtime[0] = in->win_mtime[0];
;;;3820   		oh->win_atime[1] = in->win_atime[1];
;;;3821   		oh->win_ctime[1] = in->win_ctime[1];
;;;3822   		oh->win_mtime[1] = in->win_mtime[1];
;;;3823   #else
;;;3824   		oh->yst_uid = in->yst_uid;
00204c  6be0              LDR      r0,[r4,#0x3c]
00204e  66e8              STR      r0,[r5,#0x6c]
;;;3825   		oh->yst_gid = in->yst_gid;
002050  6c20              LDR      r0,[r4,#0x40]
002052  6728              STR      r0,[r5,#0x70]
;;;3826   		oh->yst_atime = in->yst_atime;
002054  6c60              LDR      r0,[r4,#0x44]
002056  6768              STR      r0,[r5,#0x74]
;;;3827   		oh->yst_mtime = in->yst_mtime;
002058  6ca0              LDR      r0,[r4,#0x48]
00205a  67a8              STR      r0,[r5,#0x78]
;;;3828   		oh->yst_ctime = in->yst_ctime;
00205c  6ce0              LDR      r0,[r4,#0x4c]
00205e  67e8              STR      r0,[r5,#0x7c]
;;;3829   		oh->yst_rdev = in->yst_rdev;
002060  6d20              LDR      r0,[r4,#0x50]
002062  f8c50128          STR      r0,[r5,#0x128]
002066  3da4              SUBS     r5,r5,#0xa4
;;;3830   #endif
;;;3831   		if (in->parent) {
002068  69e0              LDR      r0,[r4,#0x1c]
00206a  b118              CBZ      r0,|L1.8308|
;;;3832   			oh->parentObjectId = in->parent->objectId;
00206c  69e0              LDR      r0,[r4,#0x1c]
00206e  6b00              LDR      r0,[r0,#0x30]
002070  6068              STR      r0,[r5,#4]
002072  e001              B        |L1.8312|
                  |L1.8308|
;;;3833   		} else {
;;;3834   			oh->parentObjectId = 0;
002074  2000              MOVS     r0,#0
002076  6068              STR      r0,[r5,#4]
                  |L1.8312|
;;;3835   		}
;;;3836   
;;;3837   		if (name && *name) {
002078  f1ba0f00          CMP      r10,#0
00207c  d00f              BEQ      |L1.8350|
00207e  f89a0000          LDRB     r0,[r10,#0]
002082  b160              CBZ      r0,|L1.8350|
;;;3838   			memset(oh->name, 0, sizeof(oh->name));
002084  f44f7180          MOV      r1,#0x100
002088  f105000a          ADD      r0,r5,#0xa
00208c  f7fffffe          BL       __aeabi_memclr
;;;3839   			yaffs_strncpy(oh->name, name, YAFFS_MAX_NAME_LENGTH);
002090  22ff              MOVS     r2,#0xff
002092  4651              MOV      r1,r10
002094  f105000a          ADD      r0,r5,#0xa
002098  f7fffffe          BL       strncpy
00209c  e00f              B        |L1.8382|
                  |L1.8350|
;;;3840   		} else if (prevChunkId>=0) {
00209e  2e00              CMP      r6,#0
0020a0  db07              BLT      |L1.8370|
;;;3841   			memcpy(oh->name, oldName, sizeof(oh->name));
0020a2  f44f7280          MOV      r2,#0x100
0020a6  a902              ADD      r1,sp,#8
0020a8  f105000a          ADD      r0,r5,#0xa
0020ac  f7fffffe          BL       __aeabi_memcpy
0020b0  e005              B        |L1.8382|
                  |L1.8370|
;;;3842   		} else {
;;;3843   			memset(oh->name, 0, sizeof(oh->name));
0020b2  f44f7180          MOV      r1,#0x100
0020b6  f105000a          ADD      r0,r5,#0xa
0020ba  f7fffffe          BL       __aeabi_memclr
                  |L1.8382|
;;;3844   		}
;;;3845   
;;;3846   		oh->isShrink = isShrink;
0020be  f8c5b1fc          STR      r11,[r5,#0x1fc]
;;;3847    
;;;3848   		switch (in->variantType) {
0020c2  f8940054          LDRB     r0,[r4,#0x54]
0020c6  2806              CMP      r0,#6
0020c8  d223              BCS      |L1.8466|
0020ca  e000              B        |L1.8398|
                  |L1.8396|
0020cc  e080              B        |L1.8656|
                  |L1.8398|
0020ce  e8dff000          TBB      [pc,r0]
0020d2  0304              DCB      0x03,0x04
0020d4  16151014          DCB      0x16,0x15,0x10,0x14
;;;3849   		case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;3850   			/* Should not happen */
;;;3851   			break;
0020d8  e01b              B        |L1.8466|
;;;3852   		case YAFFS_OBJECT_TYPE_FILE:
;;;3853   			oh->fileSize =
0020da  6868              LDR      r0,[r5,#4]
0020dc  2804              CMP      r0,#4
0020de  d002              BEQ      |L1.8422|
;;;3854   			    (oh->parentObjectId == YAFFS_OBJECTID_DELETED
;;;3855   			     || oh->parentObjectId ==
0020e0  6868              LDR      r0,[r5,#4]
0020e2  2803              CMP      r0,#3
0020e4  d101              BNE      |L1.8426|
                  |L1.8422|
;;;3856   			     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.
0020e6  2000              MOVS     r0,#0
0020e8  e000              B        |L1.8428|
                  |L1.8426|
0020ea  6da0              LDR      r0,[r4,#0x58]
                  |L1.8428|
0020ec  f8c50124          STR      r0,[r5,#0x124]
;;;3857   			    fileVariant.fileSize;
;;;3858   			break;
0020f0  e00f              B        |L1.8466|
;;;3859   		case YAFFS_OBJECT_TYPE_HARDLINK:
;;;3860   			oh->equivalentObjectId =
0020f2  6de0              LDR      r0,[r4,#0x5c]
0020f4  f8c50128          STR      r0,[r5,#0x128]
;;;3861   			    in->variant.hardLinkVariant.equivalentObjectId;
;;;3862   			break;
0020f8  e00b              B        |L1.8466|
;;;3863   		case YAFFS_OBJECT_TYPE_SPECIAL:
;;;3864   			/* Do nothing */
;;;3865   			break;
0020fa  e00a              B        |L1.8466|
;;;3866   		case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;3867   			/* Do nothing */
;;;3868   			break;
0020fc  e009              B        |L1.8466|
;;;3869   		case YAFFS_OBJECT_TYPE_SYMLINK:
;;;3870   			yaffs_strncpy(oh->alias,
0020fe  229f              MOVS     r2,#0x9f
002100  f5057096          ADD      r0,r5,#0x12c
002104  6da1              LDR      r1,[r4,#0x58]
002106  f7fffffe          BL       strncpy
;;;3871   				      in->variant.symLinkVariant.alias,
;;;3872   				      YAFFS_MAX_ALIAS_LENGTH);
;;;3873   			oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
00210a  2100              MOVS     r1,#0
00210c  f88511cb          STRB     r1,[r5,#0x1cb]
;;;3874   			break;
002110  bf00              NOP      
                  |L1.8466|
002112  bf00              NOP                            ;3851
;;;3875   		}
;;;3876    
;;;3877   		/* Tags */
;;;3878   		yaffs_InitialiseTags(&newTags);
002114  a854              ADD      r0,sp,#0x150
002116  f7fffffe          BL       yaffs_InitialiseTags
;;;3879   		in->serial++;
00211a  78a0              LDRB     r0,[r4,#2]
00211c  1c40              ADDS     r0,r0,#1
00211e  70a0              STRB     r0,[r4,#2]
;;;3880   		newTags.chunkId = 0;
002120  2000              MOVS     r0,#0
002122  9057              STR      r0,[sp,#0x15c]
;;;3881   		newTags.objectId = in->objectId;
002124  6b20              LDR      r0,[r4,#0x30]
002126  9056              STR      r0,[sp,#0x158]
;;;3882   		newTags.serialNumber = in->serial;
002128  78a0              LDRB     r0,[r4,#2]
00212a  905c              STR      r0,[sp,#0x170]
;;;3883   
;;;3884   		/* Add extra info for file header */
;;;3885   
;;;3886   		newTags.extraHeaderInfoAvailable = 1;
00212c  2001              MOVS     r0,#1
00212e  905e              STR      r0,[sp,#0x178]
;;;3887   		newTags.extraParentObjectId = oh->parentObjectId;
002130  6868              LDR      r0,[r5,#4]
002132  905f              STR      r0,[sp,#0x17c]
;;;3888   		newTags.extraFileLength = oh->fileSize;
002134  f8d50124          LDR      r0,[r5,#0x124]
002138  9063              STR      r0,[sp,#0x18c]
;;;3889   		newTags.extraIsShrinkHeader = oh->isShrink;
00213a  f8d501fc          LDR      r0,[r5,#0x1fc]
00213e  9060              STR      r0,[sp,#0x180]
;;;3890   		newTags.extraEquivalentObjectId = oh->equivalentObjectId;
002140  f8d50128          LDR      r0,[r5,#0x128]
002144  9064              STR      r0,[sp,#0x190]
;;;3891   		newTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;
002146  f8d501f8          LDR      r0,[r5,#0x1f8]
00214a  2800              CMP      r0,#0
00214c  dd01              BLE      |L1.8530|
00214e  2001              MOVS     r0,#1
002150  e000              B        |L1.8532|
                  |L1.8530|
002152  2000              MOVS     r0,#0
                  |L1.8532|
002154  9061              STR      r0,[sp,#0x184]
;;;3892   		newTags.extraObjectType = in->variantType;
002156  f8940054          LDRB     r0,[r4,#0x54]
00215a  f88d0188          STRB     r0,[sp,#0x188]
;;;3893   
;;;3894   		yaffs_VerifyObjectHeader(in,oh,&newTags,1);
00215e  2301              MOVS     r3,#1
002160  aa54              ADD      r2,sp,#0x150
002162  4629              MOV      r1,r5
002164  4620              MOV      r0,r4
002166  f7fffffe          BL       yaffs_VerifyObjectHeader
;;;3895    
;;;3896   		/* Create new chunk in NAND */
;;;3897   		newChunkId =
00216a  2001              MOVS     r0,#1
00216c  eb0073e6          ADD      r3,r0,r6,ASR #31
002170  aa54              ADD      r2,sp,#0x150
002172  4641              MOV      r1,r8
002174  9868              LDR      r0,[sp,#0x1a0]
002176  f7fffffe          BL       yaffs_WriteNewChunkWithTagsToNAND
00217a  4607              MOV      r7,r0
;;;3898   		    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
;;;3899   						      (prevChunkId >= 0) ? 1 : 0);
;;;3900    
;;;3901   		if (newChunkId >= 0) {
00217c  2f00              CMP      r7,#0
00217e  db26              BLT      |L1.8654|
;;;3902   
;;;3903   			in->hdrChunk = newChunkId;
002180  62a7              STR      r7,[r4,#0x28]
;;;3904   
;;;3905   			if (prevChunkId >= 0) {
002182  2e00              CMP      r6,#0
002184  db06              BLT      |L1.8596|
;;;3906   				yaffs_DeleteChunk(dev, prevChunkId, 1,
002186  f6407343          MOV      r3,#0xf43
00218a  2201              MOVS     r2,#1
00218c  4631              MOV      r1,r6
00218e  9868              LDR      r0,[sp,#0x1a0]
002190  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.8596|
;;;3907   						  __LINE__);
;;;3908   			}
;;;3909   
;;;3910   			if(!yaffs_ObjectHasCachedWriteData(in))
002194  4620              MOV      r0,r4
002196  f7fffffe          BL       yaffs_ObjectHasCachedWriteData
00219a  b918              CBNZ     r0,|L1.8612|
;;;3911   				in->dirty = 0;
00219c  7820              LDRB     r0,[r4,#0]
00219e  f0200040          BIC      r0,r0,#0x40
0021a2  7020              STRB     r0,[r4,#0]
                  |L1.8612|
;;;3912   
;;;3913   			/* If this was a shrink, then mark the block that the chunk lives on */
;;;3914   			if (isShrink) {
0021a4  f1bb0f00          CMP      r11,#0
0021a8  d011              BEQ      |L1.8654|
;;;3915   				bi = yaffs_GetBlockInfo(in->myDev,
0021aa  68a0              LDR      r0,[r4,#8]
0021ac  6900              LDR      r0,[r0,#0x10]
0021ae  fb97f0f0          SDIV     r0,r7,r0
0021b2  9001              STR      r0,[sp,#4]
0021b4  68a0              LDR      r0,[r4,#8]
0021b6  9901              LDR      r1,[sp,#4]
0021b8  f7fffffe          BL       yaffs_GetBlockInfo
0021bc  4681              MOV      r9,r0
;;;3916   							newChunkId /in->myDev->	nChunksPerBlock);
;;;3917   				bi->hasShrinkHeader = 1;
0021be  f8d90000          LDR      r0,[r9,#0]
0021c2  f0204180          BIC      r1,r0,#0x40000000
0021c6  f1014180          ADD      r1,r1,#0x40000000
0021ca  f8c91000          STR      r1,[r9,#0]
                  |L1.8654|
;;;3918   			}
;;;3919   
;;;3920   		}
;;;3921   
;;;3922   		retVal = newChunkId;
0021ce  9767              STR      r7,[sp,#0x19c]
                  |L1.8656|
;;;3923   
;;;3924   	}
;;;3925    
;;;3926   	if (buffer)
0021d0  f1b80f00          CMP      r8,#0
0021d4  d005              BEQ      |L1.8674|
;;;3927   		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
0021d6  f6407257          MOV      r2,#0xf57
0021da  4641              MOV      r1,r8
0021dc  9868              LDR      r0,[sp,#0x1a0]
0021de  f7fffffe          BL       yaffs_ReleaseTempBuffer
                  |L1.8674|
;;;3928    
;;;3929   	return retVal;
0021e2  9867              LDR      r0,[sp,#0x19c]
;;;3930   }
0021e4  b06d              ADD      sp,sp,#0x1b4
0021e6  e8bd8ff0          POP      {r4-r11,pc}
;;;3931   
                          ENDP

                  yaffs_AddObjectToDirectory PROC
;;;6834   
;;;6835   static void yaffs_AddObjectToDirectory(yaffs_Object * directory,
0021ea  b570              PUSH     {r4-r6,lr}
;;;6836   				       yaffs_Object * obj)
;;;6837   {
0021ec  4605              MOV      r5,r0
0021ee  460c              MOV      r4,r1
;;;6838   
;;;6839   	if (!directory) {
0021f0  b90d              CBNZ     r5,|L1.8694|
;;;6840   		T(YAFFS_TRACE_ALWAYS,
0021f2  bf00              NOP      
0021f4  bf00              NOP      
                  |L1.8694|
;;;6841   		  (TSTR
;;;6842   		   ("tragedy: Trying to add an object to a null pointer directory"
;;;6843   		    TENDSTR)));
;;;6844   		YBUG();
;;;6845   	}
;;;6846   	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
0021f6  f8950054          LDRB     r0,[r5,#0x54]
0021fa  2803              CMP      r0,#3
0021fc  d001              BEQ      |L1.8706|
;;;6847   		T(YAFFS_TRACE_ALWAYS,
0021fe  bf00              NOP      
002200  bf00              NOP      
                  |L1.8706|
;;;6848   		  (TSTR
;;;6849   		   ("tragedy: Trying to add an object to a non-directory"
;;;6850   		    TENDSTR)));
;;;6851   		YBUG();
;;;6852   	}
;;;6853   
;;;6854           if (obj->siblings.prev == NULL) {
002202  6a60              LDR      r0,[r4,#0x24]
002204  b118              CBZ      r0,|L1.8718|
;;;6855                   /* Not initialised */
;;;6856                   YBUG();
;;;6857   
;;;6858           } else if (ylist_empty(&obj->siblings)) {
002206  f1040020          ADD      r0,r4,#0x20
00220a  f7fffffe          BL       ylist_empty
                  |L1.8718|
;;;6859           	YBUG();
;;;6860           } 
;;;6861   
;;;6862   
;;;6863   	yaffs_VerifyDirectory(directory);
00220e  4628              MOV      r0,r5
002210  f7fffffe          BL       yaffs_VerifyDirectory
;;;6864   
;;;6865   	yaffs_RemoveObjectFromDirectory(obj);
002214  4620              MOV      r0,r4
002216  f7fffffe          BL       yaffs_RemoveObjectFromDirectory
;;;6866           
;;;6867           
;;;6868           /* Now add it */
;;;6869           ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);
00221a  f1050158          ADD      r1,r5,#0x58
00221e  f1040020          ADD      r0,r4,#0x20
002222  f7fffffe          BL       ylist_add
;;;6870           obj->parent = directory;
002226  61e5              STR      r5,[r4,#0x1c]
;;;6871   
;;;6872           if (directory == obj->myDev->unlinkedDir
002228  68a0              LDR      r0,[r4,#8]
00222a  f8d00da0          LDR      r0,[r0,#0xda0]
00222e  42a8              CMP      r0,r5
002230  d004              BEQ      |L1.8764|
;;;6873   	    || directory == obj->myDev->deletedDir) {
002232  68a0              LDR      r0,[r4,#8]
002234  f8d00da4          LDR      r0,[r0,#0xda4]
002238  42a8              CMP      r0,r5
00223a  d10f              BNE      |L1.8796|
                  |L1.8764|
;;;6874   		obj->unlinked = 1;
00223c  7820              LDRB     r0,[r4,#0]
00223e  f0200004          BIC      r0,r0,#4
002242  1d00              ADDS     r0,r0,#4
002244  7020              STRB     r0,[r4,#0]
;;;6875   		obj->myDev->nUnlinkedFiles++;
002246  68a0              LDR      r0,[r4,#8]
002248  f8d00db0          LDR      r0,[r0,#0xdb0]
00224c  1c40              ADDS     r0,r0,#1
00224e  68a1              LDR      r1,[r4,#8]
002250  f8c10db0          STR      r0,[r1,#0xdb0]
;;;6876   		obj->renameAllowed = 0;
002254  7820              LDRB     r0,[r4,#0]
002256  f0200010          BIC      r0,r0,#0x10
00225a  7020              STRB     r0,[r4,#0]
                  |L1.8796|
;;;6877   	}
;;;6878   
;;;6879   	yaffs_VerifyDirectory(directory);
00225c  4628              MOV      r0,r5
00225e  f7fffffe          BL       yaffs_VerifyDirectory
;;;6880           yaffs_VerifyObjectInDirectory(obj);
002262  4620              MOV      r0,r4
002264  f7fffffe          BL       yaffs_VerifyObjectInDirectory
;;;6881   
;;;6882   
;;;6883   }
002268  bd70              POP      {r4-r6,pc}
;;;6884   
                          ENDP

                  yaffs_GetObjectName PROC
;;;6996   
;;;6997   int yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize)
00226a  e92d43f0          PUSH     {r4-r9,lr}
;;;6998   {
00226e  b08b              SUB      sp,sp,#0x2c
002270  4604              MOV      r4,r0
002272  4688              MOV      r8,r1
002274  4615              MOV      r5,r2
;;;6999   	memset(name, 0, buffSize * sizeof(YCHAR));
002276  4629              MOV      r1,r5
002278  4640              MOV      r0,r8
00227a  f7fffffe          BL       __aeabi_memclr
;;;7000   	
;;;7001   	yaffs_CheckObjectDetailsLoaded(obj);
00227e  4620              MOV      r0,r4
002280  f7fffffe          BL       yaffs_CheckObjectDetailsLoaded
;;;7002   
;;;7003   	if (obj->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
002284  6b20              LDR      r0,[r4,#0x30]
002286  2802              CMP      r0,#2
002288  d105              BNE      |L1.8854|
;;;7004   		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);
00228a  1e6a              SUBS     r2,r5,#1
00228c  a14b              ADR      r1,|L1.9148|
00228e  4640              MOV      r0,r8
002290  f7fffffe          BL       strncpy
002294  e047              B        |L1.8998|
                  |L1.8854|
;;;7005   	} else if (obj->hdrChunk <= 0) {
002296  6aa0              LDR      r0,[r4,#0x28]
002298  2800              CMP      r0,#0
00229a  dc21              BGT      |L1.8928|
;;;7006   		YCHAR locName[20];
;;;7007   		YCHAR numString[20];
;;;7008   		YCHAR *x = &numString[19];
00229c  f10d0617          ADD      r6,sp,#0x17
;;;7009   		unsigned v = obj->objectId;
0022a0  6b27              LDR      r7,[r4,#0x30]
;;;7010   		numString[19] = 0;
0022a2  2000              MOVS     r0,#0
0022a4  f88d0017          STRB     r0,[sp,#0x17]
;;;7011   		while(v>0){
0022a8  e00a              B        |L1.8896|
                  |L1.8874|
;;;7012   			x--;
0022aa  1e76              SUBS     r6,r6,#1
;;;7013   			*x = '0' + (v % 10);
0022ac  200a              MOVS     r0,#0xa
0022ae  fbb7f1f0          UDIV     r1,r7,r0
0022b2  fb007011          MLS      r0,r0,r1,r7
0022b6  3030              ADDS     r0,r0,#0x30
0022b8  7030              STRB     r0,[r6,#0]
;;;7014   			v /= 10;
0022ba  200a              MOVS     r0,#0xa
0022bc  fbb7f7f0          UDIV     r7,r7,r0
                  |L1.8896|
0022c0  2f00              CMP      r7,#0                 ;7011
0022c2  d1f2              BNE      |L1.8874|
;;;7015   		}
;;;7016   		/* make up a name */
;;;7017   		yaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);
0022c4  a140              ADR      r1,|L1.9160|
0022c6  a806              ADD      r0,sp,#0x18
0022c8  f7fffffe          BL       strcpy
;;;7018   		yaffs_strcat(locName,x);
0022cc  4631              MOV      r1,r6
0022ce  a806              ADD      r0,sp,#0x18
0022d0  f7fffffe          BL       strcat
;;;7019   		yaffs_strncpy(name, locName, buffSize - 1);
0022d4  1e6a              SUBS     r2,r5,#1
0022d6  a906              ADD      r1,sp,#0x18
0022d8  4640              MOV      r0,r8
0022da  f7fffffe          BL       strncpy
;;;7020   
;;;7021   	}
0022de  e022              B        |L1.8998|
                  |L1.8928|
;;;7022   #ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
;;;7023   	else if (obj->shortName[0]) {
;;;7024   		yaffs_strcpy(name, obj->shortName);
;;;7025   	}
;;;7026   #endif
;;;7027   	else {
;;;7028   		int result;
;;;7029   		__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, __LINE__);
0022e0  f6413175          MOV      r1,#0x1b75
0022e4  68a0              LDR      r0,[r4,#8]
0022e6  f7fffffe          BL       yaffs_GetTempBuffer
0022ea  4606              MOV      r6,r0
;;;7030   
;;;7031   		yaffs_ObjectHeader *oh = (yaffs_ObjectHeader *) buffer;
0022ec  4637              MOV      r7,r6
;;;7032   
;;;7033   		memset(buffer, 0, obj->myDev->nDataBytesPerChunk);
0022ee  68a0              LDR      r0,[r4,#8]
0022f0  68c1              LDR      r1,[r0,#0xc]
0022f2  4630              MOV      r0,r6
0022f4  f7fffffe          BL       __aeabi_memclr
;;;7034   
;;;7035   		if (obj->hdrChunk > 0) {
0022f8  6aa0              LDR      r0,[r4,#0x28]
0022fa  2800              CMP      r0,#0
0022fc  dd06              BLE      |L1.8972|
;;;7036   			result = yaffs_ReadChunkWithTagsFromNAND(obj->myDev,
0022fe  2300              MOVS     r3,#0
002300  4632              MOV      r2,r6
002302  6aa1              LDR      r1,[r4,#0x28]
002304  68a0              LDR      r0,[r4,#8]
002306  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
00230a  4681              MOV      r9,r0
                  |L1.8972|
;;;7037   							obj->hdrChunk, buffer,
;;;7038   							NULL);
;;;7039   		}
;;;7040   		yaffs_strncpy(name, oh->name, buffSize - 1);
00230c  1e6a              SUBS     r2,r5,#1
00230e  f107010a          ADD      r1,r7,#0xa
002312  4640              MOV      r0,r8
002314  f7fffffe          BL       strncpy
;;;7041   
;;;7042   		yaffs_ReleaseTempBuffer(obj->myDev, buffer, __LINE__);
002318  f6413282          MOV      r2,#0x1b82
00231c  4631              MOV      r1,r6
00231e  68a0              LDR      r0,[r4,#8]
002320  f7fffffe          BL       yaffs_ReleaseTempBuffer
;;;7043   	}
002324  bf00              NOP      
                  |L1.8998|
;;;7044   
;;;7045   	return yaffs_strlen(name);
002326  4640              MOV      r0,r8
002328  f7fffffe          BL       strlen
;;;7046   }
00232c  b00b              ADD      sp,sp,#0x2c
00232e  e8bd83f0          POP      {r4-r9,pc}
;;;7047   
                          ENDP

                  yaffs_FindObjectByName PROC
;;;6884   
;;;6885   yaffs_Object *yaffs_FindObjectByName(yaffs_Object * directory,
002332  e92d41f0          PUSH     {r4-r8,lr}
;;;6886   				     const YCHAR * name)
;;;6887   {
002336  b0c0              SUB      sp,sp,#0x100
002338  4604              MOV      r4,r0
00233a  460f              MOV      r7,r1
;;;6888           int sum;
;;;6889   
;;;6890           struct ylist_head *i;
;;;6891           YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
;;;6892   
;;;6893           yaffs_Object *l;
;;;6894   
;;;6895   	if (!name) {
00233c  b91f              CBNZ     r7,|L1.9030|
;;;6896   		return NULL;
00233e  2000              MOVS     r0,#0
                  |L1.9024|
;;;6897   	}
;;;6898   
;;;6899   	if (!directory) {
;;;6900   		T(YAFFS_TRACE_ALWAYS,
;;;6901   		  (TSTR
;;;6902   		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
;;;6903   		    TENDSTR)));
;;;6904   		YBUG();
;;;6905   	}
;;;6906   	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
;;;6907   		T(YAFFS_TRACE_ALWAYS,
;;;6908   		  (TSTR
;;;6909   		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
;;;6910   		YBUG();
;;;6911   	}
;;;6912   
;;;6913           sum = yaffs_CalcNameSum(name);
;;;6914   
;;;6915           ylist_for_each(i, &directory->variant.directoryVariant.children) {
;;;6916                   if (i) {
;;;6917                           l = ylist_entry(i, yaffs_Object, siblings);
;;;6918                           
;;;6919                           if(l->parent != directory)
;;;6920                           	YBUG();
;;;6921                           
;;;6922                           yaffs_CheckObjectDetailsLoaded(l);
;;;6923   
;;;6924   			/* Special case for lost-n-found */
;;;6925   			if (l->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
;;;6926   				if (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0) {
;;;6927   					return l;
;;;6928   				}
;;;6929   			} else if (yaffs_SumCompare(l->sum, sum) || l->hdrChunk <= 0){
;;;6930   				/* LostnFound chunk called Objxxx
;;;6931   				 * Do a real check
;;;6932   				 */
;;;6933   				yaffs_GetObjectName(l, buffer,
;;;6934   						    YAFFS_MAX_NAME_LENGTH);
;;;6935   				if (yaffs_strncmp(name, buffer,YAFFS_MAX_NAME_LENGTH) == 0) {
;;;6936   					return l;
;;;6937   				}
;;;6938   
;;;6939   			}
;;;6940   		}
;;;6941   	}
;;;6942   
;;;6943   	return NULL;
;;;6944   }
002340  b040              ADD      sp,sp,#0x100
002342  e8bd81f0          POP      {r4-r8,pc}
                  |L1.9030|
002346  b90c              CBNZ     r4,|L1.9036|
002348  bf00              NOP                            ;6900
00234a  bf00              NOP                            ;6900
                  |L1.9036|
00234c  f8940054          LDRB     r0,[r4,#0x54]         ;6906
002350  2803              CMP      r0,#3                 ;6906
002352  d001              BEQ      |L1.9048|
002354  bf00              NOP                            ;6907
002356  bf00              NOP                            ;6907
                  |L1.9048|
002358  4638              MOV      r0,r7                 ;6913
00235a  f7fffffe          BL       yaffs_CalcNameSum
00235e  4680              MOV      r8,r0                 ;6913
002360  6da5              LDR      r5,[r4,#0x58]         ;6915
002362  e034              B        |L1.9166|
                  |L1.9060|
002364  b30d              CBZ      r5,|L1.9130|
002366  f1a50620          SUB      r6,r5,#0x20           ;6917
00236a  4630              MOV      r0,r6                 ;6922
00236c  f7fffffe          BL       yaffs_CheckObjectDetailsLoaded
002370  6b30              LDR      r0,[r6,#0x30]         ;6925
002372  2802              CMP      r0,#2                 ;6925
002374  d106              BNE      |L1.9092|
002376  a111              ADR      r1,|L1.9148|
002378  4638              MOV      r0,r7                 ;6926
00237a  f7fffffe          BL       strcmp
00237e  b9a0              CBNZ     r0,|L1.9130|
002380  4630              MOV      r0,r6                 ;6927
002382  e7dd              B        |L1.9024|
                  |L1.9092|
002384  88b0              LDRH     r0,[r6,#4]            ;6929
002386  4540              CMP      r0,r8                 ;6929
002388  d002              BEQ      |L1.9104|
00238a  6ab0              LDR      r0,[r6,#0x28]         ;6929
00238c  2800              CMP      r0,#0                 ;6929
00238e  dc1d              BGT      |L1.9164|
                  |L1.9104|
002390  22ff              MOVS     r2,#0xff              ;6933
002392  4669              MOV      r1,sp                 ;6933
002394  4630              MOV      r0,r6                 ;6933
002396  f7fffffe          BL       yaffs_GetObjectName
00239a  22ff              MOVS     r2,#0xff              ;6935
00239c  4669              MOV      r1,sp                 ;6935
00239e  4638              MOV      r0,r7                 ;6935
0023a0  f7fffffe          BL       strncmp
0023a4  b908              CBNZ     r0,|L1.9130|
0023a6  4630              MOV      r0,r6                 ;6936
0023a8  e7ca              B        |L1.9024|
                  |L1.9130|
0023aa  e00f              B        |L1.9164|
                  |L1.9132|
0023ac  73696c6c          DCB      "silly old name",0
0023b0  79206f6c
0023b4  64206e61
0023b8  6d6500  
0023bb  00                DCB      0
                  |L1.9148|
0023bc  6c6f7374          DCB      "lost+found",0
0023c0  2b666f75
0023c4  6e6400  
0023c7  00                DCB      0
                  |L1.9160|
0023c8  6f626a00          DCB      "obj",0
                  |L1.9164|
0023cc  682d              LDR      r5,[r5,#0]            ;6915
                  |L1.9166|
0023ce  f1040058          ADD      r0,r4,#0x58           ;6915
0023d2  4285              CMP      r5,r0                 ;6915
0023d4  d1c6              BNE      |L1.9060|
0023d6  2000              MOVS     r0,#0                 ;6943
0023d8  e7b2              B        |L1.9024|
;;;6945   
                          ENDP

                  yaffs_ChangeObjectName PROC
;;;2468   
;;;2469   static int yaffs_ChangeObjectName(yaffs_Object * obj, yaffs_Object * newDir,
0023da  e92d4ff8          PUSH     {r3-r11,lr}
;;;2470   				  const YCHAR * newName, int force, int shadows)
;;;2471   {
0023de  4604              MOV      r4,r0
0023e0  460d              MOV      r5,r1
0023e2  4617              MOV      r7,r2
0023e4  4698              MOV      r8,r3
0023e6  f8dd9028          LDR      r9,[sp,#0x28]
;;;2472   	int unlinkOp;
;;;2473   	int deleteOp;
;;;2474   
;;;2475   	yaffs_Object *existingTarget;
;;;2476   
;;;2477   	if (newDir == NULL) {
0023ea  b905              CBNZ     r5,|L1.9198|
;;;2478   		newDir = obj->parent;	/* use the old directory */
0023ec  69e5              LDR      r5,[r4,#0x1c]
                  |L1.9198|
;;;2479   	}
;;;2480   
;;;2481   	if (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
0023ee  f8950054          LDRB     r0,[r5,#0x54]
0023f2  2803              CMP      r0,#3
0023f4  d001              BEQ      |L1.9210|
;;;2482   		T(YAFFS_TRACE_ALWAYS,
0023f6  bf00              NOP      
0023f8  bf00              NOP      
                  |L1.9210|
;;;2483   		  (TSTR
;;;2484   		   ("tragedy: yaffs_ChangeObjectName: newDir is not a directory"
;;;2485   		    TENDSTR)));
;;;2486   		YBUG();
;;;2487   	}
;;;2488   	
;;;2489   	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
;;;2490   	if (obj->myDev->isYaffs2) {
0023fa  68a0              LDR      r0,[r4,#8]
0023fc  6dc0              LDR      r0,[r0,#0x5c]
0023fe  b148              CBZ      r0,|L1.9236|
;;;2491   		unlinkOp = (newDir == obj->myDev->unlinkedDir);
002400  68a0              LDR      r0,[r4,#8]
002402  f8d00da0          LDR      r0,[r0,#0xda0]
002406  42a8              CMP      r0,r5
002408  d101              BNE      |L1.9230|
00240a  2001              MOVS     r0,#1
00240c  e000              B        |L1.9232|
                  |L1.9230|
00240e  2000              MOVS     r0,#0
                  |L1.9232|
002410  4682              MOV      r10,r0
002412  e00b              B        |L1.9260|
                  |L1.9236|
;;;2492   	} else {
;;;2493   		unlinkOp = (newDir == obj->myDev->unlinkedDir
002414  68a0              LDR      r0,[r4,#8]
002416  f8d00da0          LDR      r0,[r0,#0xda0]
00241a  42a8              CMP      r0,r5
00241c  d104              BNE      |L1.9256|
;;;2494   			    && obj->variantType == YAFFS_OBJECT_TYPE_FILE);
00241e  f8940054          LDRB     r0,[r4,#0x54]
002422  2801              CMP      r0,#1
002424  d100              BNE      |L1.9256|
002426  e000              B        |L1.9258|
                  |L1.9256|
002428  2000              MOVS     r0,#0
                  |L1.9258|
00242a  4682              MOV      r10,r0
                  |L1.9260|
;;;2495   	}
;;;2496   
;;;2497   	deleteOp = (newDir == obj->myDev->deletedDir);
00242c  68a0              LDR      r0,[r4,#8]
00242e  f8d00da4          LDR      r0,[r0,#0xda4]
002432  42a8              CMP      r0,r5
002434  d101              BNE      |L1.9274|
002436  2001              MOVS     r0,#1
002438  e000              B        |L1.9276|
                  |L1.9274|
00243a  2000              MOVS     r0,#0
                  |L1.9276|
00243c  4683              MOV      r11,r0
;;;2498   
;;;2499   	existingTarget = yaffs_FindObjectByName(newDir, newName);
00243e  4639              MOV      r1,r7
002440  4628              MOV      r0,r5
002442  f7fffffe          BL       yaffs_FindObjectByName
002446  4606              MOV      r6,r0
;;;2500   
;;;2501   	/* If the object is a file going into the unlinked directory, 
;;;2502   	 *   then it is OK to just stuff it in since duplicate names are allowed.
;;;2503   	 *   else only proceed if the new name does not exist and if we're putting 
;;;2504   	 *   it into a directory.
;;;2505   	 */
;;;2506   	if ((unlinkOp ||
002448  f1ba0f00          CMP      r10,#0
00244c  d109              BNE      |L1.9314|
;;;2507   	     deleteOp ||
00244e  f1bb0f00          CMP      r11,#0
002452  d106              BNE      |L1.9314|
;;;2508   	     force ||
002454  f1b80f00          CMP      r8,#0
002458  d103              BNE      |L1.9314|
;;;2509   	     (shadows > 0) ||
00245a  f1b90f00          CMP      r9,#0
00245e  dc00              BGT      |L1.9314|
;;;2510   	     !existingTarget) &&
002460  bb2e              CBNZ     r6,|L1.9390|
                  |L1.9314|
;;;2511   	    newDir->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) {
002462  f8950054          LDRB     r0,[r5,#0x54]
002466  2803              CMP      r0,#3
002468  d121              BNE      |L1.9390|
;;;2512   		yaffs_SetObjectName(obj, newName);
00246a  4639              MOV      r1,r7
00246c  4620              MOV      r0,r4
00246e  f7fffffe          BL       yaffs_SetObjectName
;;;2513   		obj->dirty = 1;
002472  7820              LDRB     r0,[r4,#0]
002474  f0200040          BIC      r0,r0,#0x40
002478  3040              ADDS     r0,r0,#0x40
00247a  7020              STRB     r0,[r4,#0]
;;;2514   
;;;2515   		yaffs_AddObjectToDirectory(newDir, obj);
00247c  4621              MOV      r1,r4
00247e  4628              MOV      r0,r5
002480  f7fffffe          BL       yaffs_AddObjectToDirectory
;;;2516   
;;;2517   		if (unlinkOp)
002484  f1ba0f00          CMP      r10,#0
002488  d004              BEQ      |L1.9364|
;;;2518   			obj->unlinked = 1;
00248a  7820              LDRB     r0,[r4,#0]
00248c  f0200004          BIC      r0,r0,#4
002490  1d00              ADDS     r0,r0,#4
002492  7020              STRB     r0,[r4,#0]
                  |L1.9364|
;;;2519   
;;;2520   		/* If it is a deletion then we mark it as a shrink for gc purposes. */
;;;2521   		if (yaffs_UpdateObjectHeader(obj, newName, 0, deleteOp, shadows)>= 0)
002494  465b              MOV      r3,r11
002496  2200              MOVS     r2,#0
002498  4639              MOV      r1,r7
00249a  4620              MOV      r0,r4
00249c  f8cd9000          STR      r9,[sp,#0]
0024a0  f7fffffe          BL       yaffs_UpdateObjectHeader
0024a4  2800              CMP      r0,#0
0024a6  db02              BLT      |L1.9390|
;;;2522   			return YAFFS_OK;
0024a8  2001              MOVS     r0,#1
                  |L1.9386|
;;;2523   	}
;;;2524   
;;;2525   	return YAFFS_FAIL;
;;;2526   }
0024aa  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.9390|
0024ae  2000              MOVS     r0,#0                 ;2525
0024b0  e7fb              B        |L1.9386|
;;;2527   
                          ENDP

                  yaffs_InvalidateWholeChunkCache PROC
;;;4176    */
;;;4177   static void yaffs_InvalidateWholeChunkCache(yaffs_Object * in)
0024b2  b530              PUSH     {r4,r5,lr}
;;;4178   {
0024b4  4602              MOV      r2,r0
;;;4179   	int i;
;;;4180   	yaffs_Device *dev = in->myDev;
0024b6  6891              LDR      r1,[r2,#8]
;;;4181   
;;;4182   	if (dev->nShortOpCaches > 0) {
0024b8  6a4b              LDR      r3,[r1,#0x24]
0024ba  2b00              CMP      r3,#0
0024bc  dd14              BLE      |L1.9448|
;;;4183   		/* Invalidate it. */
;;;4184   		for (i = 0; i < dev->nShortOpCaches; i++) {
0024be  2000              MOVS     r0,#0
0024c0  e00f              B        |L1.9442|
                  |L1.9410|
;;;4185   			if (dev->srCache[i].object == in) {
0024c2  ebc004c0          RSB      r4,r0,r0,LSL #3
0024c6  f8d13d94          LDR      r3,[r1,#0xd94]
0024ca  f8533024          LDR      r3,[r3,r4,LSL #2]
0024ce  4293              CMP      r3,r2
0024d0  d106              BNE      |L1.9440|
;;;4186   				dev->srCache[i].object = NULL;
0024d2  2300              MOVS     r3,#0
0024d4  ebc005c0          RSB      r5,r0,r0,LSL #3
0024d8  f8d14d94          LDR      r4,[r1,#0xd94]
0024dc  f8443025          STR      r3,[r4,r5,LSL #2]
                  |L1.9440|
0024e0  1c40              ADDS     r0,r0,#1              ;4184
                  |L1.9442|
0024e2  6a4b              LDR      r3,[r1,#0x24]         ;4184
0024e4  4283              CMP      r3,r0                 ;4184
0024e6  dcec              BGT      |L1.9410|
                  |L1.9448|
;;;4187   			}
;;;4188   		}
;;;4189   	}
;;;4190   }
0024e8  bd30              POP      {r4,r5,pc}
;;;4191   
                          ENDP

                  yaffs_DoGenericObjectDeletion PROC
;;;5211   
;;;5212   static int yaffs_DoGenericObjectDeletion(yaffs_Object * in)
0024ea  b538              PUSH     {r3-r5,lr}
;;;5213   {
0024ec  4604              MOV      r4,r0
;;;5214   
;;;5215   	/* First off, invalidate the file's data in the cache, without flushing. */
;;;5216   	yaffs_InvalidateWholeChunkCache(in);
0024ee  4620              MOV      r0,r4
0024f0  f7fffffe          BL       yaffs_InvalidateWholeChunkCache
;;;5217   
;;;5218   	if (in->myDev->isYaffs2 && (in->parent != in->myDev->deletedDir)) {
0024f4  68a0              LDR      r0,[r4,#8]
0024f6  6dc0              LDR      r0,[r0,#0x5c]
0024f8  b178              CBZ      r0,|L1.9498|
0024fa  68a1              LDR      r1,[r4,#8]
0024fc  69e0              LDR      r0,[r4,#0x1c]
0024fe  f8d11da4          LDR      r1,[r1,#0xda4]
002502  4288              CMP      r0,r1
002504  d009              BEQ      |L1.9498|
;;;5219   		/* Move to the unlinked directory so we have a record that it was deleted. */
;;;5220   		yaffs_ChangeObjectName(in, in->myDev->deletedDir,_Y("deleted"), 0, 0);
002506  2000              MOVS     r0,#0
002508  9000              STR      r0,[sp,#0]
00250a  68a0              LDR      r0,[r4,#8]
00250c  2300              MOVS     r3,#0
00250e  a2f8              ADR      r2,|L1.10480|
002510  f8d01da4          LDR      r1,[r0,#0xda4]
002514  4620              MOV      r0,r4
002516  f7fffffe          BL       yaffs_ChangeObjectName
                  |L1.9498|
;;;5221   
;;;5222   	}
;;;5223   
;;;5224   	yaffs_RemoveObjectFromDirectory(in);
00251a  4620              MOV      r0,r4
00251c  f7fffffe          BL       yaffs_RemoveObjectFromDirectory
;;;5225   	yaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, __LINE__);
002520  f2414369          MOV      r3,#0x1469
002524  2201              MOVS     r2,#1
002526  6aa1              LDR      r1,[r4,#0x28]
002528  68a0              LDR      r0,[r4,#8]
00252a  f7fffffe          BL       yaffs_DeleteChunk
;;;5226   	in->hdrChunk = 0;
00252e  2000              MOVS     r0,#0
002530  62a0              STR      r0,[r4,#0x28]
;;;5227   
;;;5228   	yaffs_FreeObject(in);
002532  4620              MOV      r0,r4
002534  f7fffffe          BL       yaffs_FreeObject
;;;5229   	return YAFFS_OK;
002538  2001              MOVS     r0,#1
;;;5230   
;;;5231   }
00253a  bd38              POP      {r3-r5,pc}
;;;5232   
                          ENDP

                  yaffs_SoftDeleteFile PROC
;;;1779   
;;;1780   static void yaffs_SoftDeleteFile(yaffs_Object * obj)
00253c  b510              PUSH     {r4,lr}
;;;1781   {
00253e  4604              MOV      r4,r0
;;;1782   	if (obj->deleted &&
002540  7820              LDRB     r0,[r4,#0]
002542  f0000001          AND      r0,r0,#1
002546  b308              CBZ      r0,|L1.9612|
;;;1783   	    obj->variantType == YAFFS_OBJECT_TYPE_FILE && !obj->softDeleted) {
002548  f8940054          LDRB     r0,[r4,#0x54]
00254c  2801              CMP      r0,#1
00254e  d11d              BNE      |L1.9612|
002550  7820              LDRB     r0,[r4,#0]
002552  f3c00040          UBFX     r0,r0,#1,#1
002556  b9c8              CBNZ     r0,|L1.9612|
;;;1784   		if (obj->nDataChunks <= 0) {
002558  6ae0              LDR      r0,[r4,#0x2c]
00255a  2800              CMP      r0,#0
00255c  dc0b              BGT      |L1.9590|
;;;1785   			/* Empty file with no duplicate object headers, just delete it immediately */
;;;1786   			yaffs_FreeTnode(obj->myDev,
00255e  6ea1              LDR      r1,[r4,#0x68]
002560  68a0              LDR      r0,[r4,#8]
002562  f7fffffe          BL       yaffs_FreeTnode
;;;1787   					obj->variant.fileVariant.top);
;;;1788   			obj->variant.fileVariant.top = NULL;
002566  2100              MOVS     r1,#0
002568  66a1              STR      r1,[r4,#0x68]
;;;1789   			T(YAFFS_TRACE_TRACING,
00256a  bf00              NOP      
00256c  bf00              NOP      
;;;1790   			  (TSTR("yaffs: Deleting empty file %d" TENDSTR),
;;;1791   			   obj->objectId));
;;;1792   			yaffs_DoGenericObjectDeletion(obj);
00256e  4620              MOV      r0,r4
002570  f7fffffe          BL       yaffs_DoGenericObjectDeletion
002574  e00a              B        |L1.9612|
                  |L1.9590|
;;;1793   		} else {
;;;1794   			yaffs_SoftDeleteWorker(obj,
002576  2300              MOVS     r3,#0
002578  4620              MOV      r0,r4
00257a  e9d42119          LDRD     r2,r1,[r4,#0x64]
00257e  f7fffffe          BL       yaffs_SoftDeleteWorker
;;;1795   					       obj->variant.fileVariant.top,
;;;1796   					       obj->variant.fileVariant.
;;;1797   					       topLevel, 0);
;;;1798   			obj->softDeleted = 1;
002582  7820              LDRB     r0,[r4,#0]
002584  f0200002          BIC      r0,r0,#2
002588  1c80              ADDS     r0,r0,#2
00258a  7020              STRB     r0,[r4,#0]
                  |L1.9612|
;;;1799   		}
;;;1800   	}
;;;1801   }
00258c  bd10              POP      {r4,pc}
;;;1802   
                          ENDP

                  yaffs_PruneWorker PROC
;;;1813   
;;;1814   static yaffs_Tnode *yaffs_PruneWorker(yaffs_Device * dev, yaffs_Tnode * tn,
00258e  e92d47f0          PUSH     {r4-r10,lr}
;;;1815   				      __u32 level, int del0)
;;;1816   {
002592  4681              MOV      r9,r0
002594  460d              MOV      r5,r1
002596  4616              MOV      r6,r2
002598  4698              MOV      r8,r3
;;;1817   	int i;
;;;1818   	int hasData;
;;;1819   
;;;1820   	if (tn) {
00259a  b31d              CBZ      r5,|L1.9700|
;;;1821   		hasData = 0;
00259c  2700              MOVS     r7,#0
;;;1822   
;;;1823   		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
00259e  2400              MOVS     r4,#0
0025a0  e015              B        |L1.9678|
                  |L1.9634|
;;;1824   			if (tn->internal[i] && level > 0) {
0025a2  f8550024          LDR      r0,[r5,r4,LSL #2]
0025a6  b168              CBZ      r0,|L1.9668|
0025a8  b166              CBZ      r6,|L1.9668|
;;;1825   				tn->internal[i] =
0025aa  b90c              CBNZ     r4,|L1.9648|
;;;1826   				    yaffs_PruneWorker(dev, tn->internal[i],
;;;1827   						      level - 1,
;;;1828   						      (i == 0) ? del0 : 1);
0025ac  4640              MOV      r0,r8
0025ae  e000              B        |L1.9650|
                  |L1.9648|
0025b0  2001              MOVS     r0,#1
                  |L1.9650|
0025b2  4603              MOV      r3,r0
0025b4  1e72              SUBS     r2,r6,#1
0025b6  f8551024          LDR      r1,[r5,r4,LSL #2]
0025ba  4648              MOV      r0,r9
0025bc  f7fffffe          BL       yaffs_PruneWorker
0025c0  f8450024          STR      r0,[r5,r4,LSL #2]
                  |L1.9668|
;;;1829   			}
;;;1830   
;;;1831   			if (tn->internal[i]) {
0025c4  f8550024          LDR      r0,[r5,r4,LSL #2]
0025c8  b100              CBZ      r0,|L1.9676|
;;;1832   				hasData++;
0025ca  1c7f              ADDS     r7,r7,#1
                  |L1.9676|
0025cc  1c64              ADDS     r4,r4,#1              ;1823
                  |L1.9678|
0025ce  2c08              CMP      r4,#8                 ;1823
0025d0  dbe7              BLT      |L1.9634|
;;;1833   			}
;;;1834   		}
;;;1835   
;;;1836   		if (hasData == 0 && del0) {
0025d2  b93f              CBNZ     r7,|L1.9700|
0025d4  f1b80f00          CMP      r8,#0
0025d8  d004              BEQ      |L1.9700|
;;;1837   			/* Free and return NULL */
;;;1838   
;;;1839   			yaffs_FreeTnode(dev, tn);
0025da  4629              MOV      r1,r5
0025dc  4648              MOV      r0,r9
0025de  f7fffffe          BL       yaffs_FreeTnode
;;;1840   			tn = NULL;
0025e2  2500              MOVS     r5,#0
                  |L1.9700|
;;;1841   		}
;;;1842   
;;;1843   	}
;;;1844   
;;;1845   	return tn;
0025e4  4628              MOV      r0,r5
;;;1846   
;;;1847   }
0025e6  e8bd87f0          POP      {r4-r10,pc}
;;;1848   
                          ENDP

                  yaffs_PruneFileStructure PROC
;;;1849   static int yaffs_PruneFileStructure(yaffs_Device * dev,
0025ea  e92d47f0          PUSH     {r4-r10,lr}
;;;1850   				    yaffs_FileStructure * fStruct)
;;;1851   {
0025ee  4680              MOV      r8,r0
0025f0  460c              MOV      r4,r1
;;;1852   	int i;
;;;1853   	int hasData;
;;;1854   	int done = 0;
0025f2  f04f0900          MOV      r9,#0
;;;1855   	yaffs_Tnode *tn;
;;;1856   
;;;1857   	if (fStruct->topLevel > 0) {
0025f6  68e0              LDR      r0,[r4,#0xc]
0025f8  2800              CMP      r0,#0
0025fa  dd24              BLE      |L1.9798|
;;;1858   		fStruct->top =
0025fc  2300              MOVS     r3,#0
0025fe  4640              MOV      r0,r8
002600  e9d42103          LDRD     r2,r1,[r4,#0xc]
002604  f7fffffe          BL       yaffs_PruneWorker
002608  6120              STR      r0,[r4,#0x10]
;;;1859   		    yaffs_PruneWorker(dev, fStruct->top, fStruct->topLevel, 0);
;;;1860   
;;;1861   		/* Now we have a tree with all the non-zero branches NULL but the height
;;;1862   		 * is the same as it was.
;;;1863   		 * Let's see if we can trim internal tnodes to shorten the tree.
;;;1864   		 * We can do this if only the 0th element in the tnode is in use 
;;;1865   		 * (ie all the non-zero are NULL)
;;;1866   		 */
;;;1867   
;;;1868   		while (fStruct->topLevel && !done) {
00260a  e017              B        |L1.9788|
                  |L1.9740|
;;;1869   			tn = fStruct->top;
00260c  6925              LDR      r5,[r4,#0x10]
;;;1870   
;;;1871   			hasData = 0;
00260e  2700              MOVS     r7,#0
;;;1872   			for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
002610  2601              MOVS     r6,#1
002612  e004              B        |L1.9758|
                  |L1.9748|
;;;1873   				if (tn->internal[i]) {
002614  f8550026          LDR      r0,[r5,r6,LSL #2]
002618  b100              CBZ      r0,|L1.9756|
;;;1874   					hasData++;
00261a  1c7f              ADDS     r7,r7,#1
                  |L1.9756|
00261c  1c76              ADDS     r6,r6,#1              ;1872
                  |L1.9758|
00261e  2e08              CMP      r6,#8                 ;1872
002620  dbf8              BLT      |L1.9748|
;;;1875   				}
;;;1876   			}
;;;1877   
;;;1878   			if (!hasData) {
002622  b94f              CBNZ     r7,|L1.9784|
;;;1879   				fStruct->top = tn->internal[0];
002624  6828              LDR      r0,[r5,#0]
002626  6120              STR      r0,[r4,#0x10]
;;;1880   				fStruct->topLevel--;
002628  68e0              LDR      r0,[r4,#0xc]
00262a  1e40              SUBS     r0,r0,#1
00262c  60e0              STR      r0,[r4,#0xc]
;;;1881   				yaffs_FreeTnode(dev, tn);
00262e  4629              MOV      r1,r5
002630  4640              MOV      r0,r8
002632  f7fffffe          BL       yaffs_FreeTnode
002636  e001              B        |L1.9788|
                  |L1.9784|
;;;1882   			} else {
;;;1883   				done = 1;
002638  f04f0901          MOV      r9,#1
                  |L1.9788|
00263c  68e0              LDR      r0,[r4,#0xc]          ;1868
00263e  b110              CBZ      r0,|L1.9798|
002640  f1b90f00          CMP      r9,#0                 ;1868
002644  d0e2              BEQ      |L1.9740|
                  |L1.9798|
;;;1884   			}
;;;1885   		}
;;;1886   	}
;;;1887   
;;;1888   	return YAFFS_OK;
002646  2001              MOVS     r0,#1
;;;1889   }
002648  e8bd87f0          POP      {r4-r10,pc}
;;;1890   
                          ENDP

                  yaffs_CreateFreeObjects PROC
;;;1895    */
;;;1896   static int yaffs_CreateFreeObjects(yaffs_Device * dev, int nObjects)
00264c  e92d41f0          PUSH     {r4-r8,lr}
;;;1897   {
002650  4604              MOV      r4,r0
002652  460e              MOV      r6,r1
;;;1898   	int i;
;;;1899   	yaffs_Object *newObjects;
;;;1900   	yaffs_ObjectList *list;
;;;1901   
;;;1902   	if (nObjects < 1)
002654  2e01              CMP      r6,#1
002656  da02              BGE      |L1.9822|
;;;1903   		return YAFFS_OK;
002658  2001              MOVS     r0,#1
                  |L1.9818|
;;;1904   
;;;1905   	/* make these things */
;;;1906   	newObjects = YMALLOC(nObjects * sizeof(yaffs_Object));
;;;1907   	list = YMALLOC(sizeof(yaffs_ObjectList));
;;;1908   
;;;1909   	if (!newObjects || !list) {
;;;1910   		if(newObjects)
;;;1911   			YFREE(newObjects);
;;;1912   		if(list)
;;;1913   			YFREE(list);
;;;1914   		T(YAFFS_TRACE_ALLOCATE,
;;;1915   		  (TSTR("yaffs: Could not allocate more objects" TENDSTR)));
;;;1916   		return YAFFS_FAIL;
;;;1917   	}
;;;1918   	
;;;1919           /* Hook them into the free list */
;;;1920           for (i = 0; i < nObjects - 1; i++) {
;;;1921                   newObjects[i].siblings.next =
;;;1922                       (struct ylist_head *)(&newObjects[i + 1]);
;;;1923           }
;;;1924   
;;;1925           newObjects[nObjects - 1].siblings.next = (void *)dev->freeObjects;
;;;1926   	dev->freeObjects = newObjects;
;;;1927   	dev->nFreeObjects += nObjects;
;;;1928   	dev->nObjectsCreated += nObjects;
;;;1929   
;;;1930   	/* Now add this bunch of Objects to a list for freeing up. */
;;;1931   
;;;1932   	list->objects = newObjects;
;;;1933   	list->next = dev->allocatedObjectList;
;;;1934   	dev->allocatedObjectList = list;
;;;1935   
;;;1936   	return YAFFS_OK;
;;;1937   }
00265a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.9822|
00265e  216c              MOVS     r1,#0x6c              ;1906
002660  fb06f001          MUL      r0,r6,r1              ;1906
002664  f7fffffe          BL       yaffs_malloc
002668  4605              MOV      r5,r0                 ;1906
00266a  2008              MOVS     r0,#8                 ;1907
00266c  f7fffffe          BL       yaffs_malloc
002670  4607              MOV      r7,r0                 ;1907
002672  b105              CBZ      r5,|L1.9846|
002674  b95f              CBNZ     r7,|L1.9870|
                  |L1.9846|
002676  b115              CBZ      r5,|L1.9854|
002678  4628              MOV      r0,r5                 ;1911
00267a  f7fffffe          BL       free
                  |L1.9854|
00267e  b117              CBZ      r7,|L1.9862|
002680  4638              MOV      r0,r7                 ;1913
002682  f7fffffe          BL       free
                  |L1.9862|
002686  bf00              NOP                            ;1914
002688  bf00              NOP                            ;1914
00268a  2000              MOVS     r0,#0                 ;1916
00268c  e7e5              B        |L1.9818|
                  |L1.9870|
00268e  f04f0800          MOV      r8,#0                 ;1920
002692  e010              B        |L1.9910|
                  |L1.9876|
002694  f1080001          ADD      r0,r8,#1              ;1921
002698  eb0000c0          ADD      r0,r0,r0,LSL #3       ;1921
00269c  eb000040          ADD      r0,r0,r0,LSL #1       ;1921
0026a0  eb050080          ADD      r0,r5,r0,LSL #2       ;1921
0026a4  eb0801c8          ADD      r1,r8,r8,LSL #3       ;1921
0026a8  eb010141          ADD      r1,r1,r1,LSL #1       ;1921
0026ac  eb050181          ADD      r1,r5,r1,LSL #2       ;1921
0026b0  6208              STR      r0,[r1,#0x20]         ;1921
0026b2  f1080801          ADD      r8,r8,#1              ;1920
                  |L1.9910|
0026b6  1e70              SUBS     r0,r6,#1              ;1920
0026b8  4540              CMP      r0,r8                 ;1920
0026ba  dceb              BGT      |L1.9876|
0026bc  f5047490          ADD      r4,r4,#0x120          ;1925
0026c0  eb0000c0          ADD      r0,r0,r0,LSL #3       ;1925
0026c4  eb000040          ADD      r0,r0,r0,LSL #1       ;1925
0026c8  eb050080          ADD      r0,r5,r0,LSL #2       ;1925
0026cc  6861              LDR      r1,[r4,#4]            ;1925
0026ce  6201              STR      r1,[r0,#0x20]         ;1925
0026d0  6065              STR      r5,[r4,#4]            ;1926
0026d2  68a0              LDR      r0,[r4,#8]            ;1927
0026d4  4430              ADD      r0,r0,r6              ;1927
0026d6  60a0              STR      r0,[r4,#8]            ;1927
0026d8  6820              LDR      r0,[r4,#0]            ;1928
0026da  4430              ADD      r0,r0,r6              ;1928
0026dc  6020              STR      r0,[r4,#0]            ;1928
0026de  603d              STR      r5,[r7,#0]            ;1932
0026e0  6920              LDR      r0,[r4,#0x10]         ;1933
0026e2  6078              STR      r0,[r7,#4]            ;1933
0026e4  6127              STR      r7,[r4,#0x10]         ;1934
0026e6  f5a47490          SUB      r4,r4,#0x120          ;1934
0026ea  2001              MOVS     r0,#1                 ;1936
0026ec  e7b5              B        |L1.9818|
;;;1938   
                          ENDP

                  yaffs_AllocateEmptyObject PROC
;;;1940   /* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */
;;;1941   static yaffs_Object *yaffs_AllocateEmptyObject(yaffs_Device * dev)
0026ee  b570              PUSH     {r4-r6,lr}
;;;1942   {
0026f0  4605              MOV      r5,r0
;;;1943   	yaffs_Object *tn = NULL;
0026f2  2400              MOVS     r4,#0
;;;1944   
;;;1945   #ifdef VALGRIND_TEST
;;;1946   	tn = YMALLOC(sizeof(yaffs_Object));
;;;1947   #else
;;;1948   	/* If there are none left make more */
;;;1949   	if (!dev->freeObjects) {
0026f4  f8d50124          LDR      r0,[r5,#0x124]
0026f8  b918              CBNZ     r0,|L1.9986|
;;;1950   		yaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);
0026fa  2164              MOVS     r1,#0x64
0026fc  4628              MOV      r0,r5
0026fe  f7fffffe          BL       yaffs_CreateFreeObjects
                  |L1.9986|
;;;1951   	}
;;;1952   
;;;1953   	if (dev->freeObjects) {
002702  f8d50124          LDR      r0,[r5,#0x124]
002706  b150              CBZ      r0,|L1.10014|
;;;1954   		tn = dev->freeObjects;
002708  f5057592          ADD      r5,r5,#0x124
00270c  682c              LDR      r4,[r5,#0]
;;;1955   		dev->freeObjects =
00270e  6828              LDR      r0,[r5,#0]
002710  6a00              LDR      r0,[r0,#0x20]
002712  6028              STR      r0,[r5,#0]
;;;1956   		    (yaffs_Object *) (dev->freeObjects->siblings.next);
;;;1957   		dev->nFreeObjects--;
002714  6868              LDR      r0,[r5,#4]
002716  1e40              SUBS     r0,r0,#1
002718  6068              STR      r0,[r5,#4]
00271a  f5a57592          SUB      r5,r5,#0x124
                  |L1.10014|
;;;1958   	}
;;;1959   #endif
;;;1960   	if(tn){
00271e  2c00              CMP      r4,#0
002720  d037              BEQ      |L1.10130|
;;;1961   		/* Now sweeten it up... */
;;;1962   
;;;1963   		memset(tn, 0, sizeof(yaffs_Object));
002722  216c              MOVS     r1,#0x6c
002724  4620              MOV      r0,r4
002726  f7fffffe          BL       __aeabi_memclr4
;;;1964   		tn->beingCreated = 1;
00272a  7860              LDRB     r0,[r4,#1]
00272c  f0200004          BIC      r0,r0,#4
002730  1d00              ADDS     r0,r0,#4
002732  7060              STRB     r0,[r4,#1]
;;;1965   		
;;;1966   		tn->myDev = dev;
002734  60a5              STR      r5,[r4,#8]
;;;1967   		tn->hdrChunk = 0;
002736  2000              MOVS     r0,#0
002738  62a0              STR      r0,[r4,#0x28]
;;;1968   		tn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;
00273a  f8840054          STRB     r0,[r4,#0x54]
;;;1969   		YINIT_LIST_HEAD(&(tn->hardLinks));
00273e  bf00              NOP      
002740  f1040014          ADD      r0,r4,#0x14
002744  6160              STR      r0,[r4,#0x14]
002746  61a0              STR      r0,[r4,#0x18]
002748  bf00              NOP      
;;;1970   		YINIT_LIST_HEAD(&(tn->hashLink));
00274a  bf00              NOP      
00274c  3808              SUBS     r0,r0,#8
00274e  60e0              STR      r0,[r4,#0xc]
002750  6120              STR      r0,[r4,#0x10]
002752  bf00              NOP      
;;;1971   		YINIT_LIST_HEAD(&tn->siblings);
002754  bf00              NOP      
002756  3014              ADDS     r0,r0,#0x14
002758  6220              STR      r0,[r4,#0x20]
00275a  6260              STR      r0,[r4,#0x24]
00275c  bf00              NOP      
;;;1972   		
;;;1973   
;;;1974   		/* Now make the directory sane */
;;;1975   		if(dev->rootDir){
00275e  f8d50d84          LDR      r0,[r5,#0xd84]
002762  b150              CBZ      r0,|L1.10106|
;;;1976   			tn->parent = dev->rootDir;
002764  f8d50d84          LDR      r0,[r5,#0xd84]
002768  61e0              STR      r0,[r4,#0x1c]
;;;1977   			ylist_add(&(tn->siblings),&dev->rootDir->variant.directoryVariant.children);
00276a  f8d50d84          LDR      r0,[r5,#0xd84]
00276e  f1000158          ADD      r1,r0,#0x58
002772  f1040020          ADD      r0,r4,#0x20
002776  f7fffffe          BL       ylist_add
                  |L1.10106|
;;;1978   		}
;;;1979   
;;;1980                   /* Add it to the lost and found directory.
;;;1981                    * NB Can't put root or lostNFound in lostNFound so
;;;1982   		 * check if lostNFound exists first
;;;1983   		 */
;;;1984   		if (dev->lostNFoundDir) {
00277a  f8d50d88          LDR      r0,[r5,#0xd88]
00277e  b120              CBZ      r0,|L1.10122|
;;;1985   			yaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);
002780  4621              MOV      r1,r4
002782  f8d50d88          LDR      r0,[r5,#0xd88]
002786  f7fffffe          BL       yaffs_AddObjectToDirectory
                  |L1.10122|
;;;1986   		}
;;;1987   		
;;;1988   		tn->beingCreated = 0;
00278a  7860              LDRB     r0,[r4,#1]
00278c  f0200004          BIC      r0,r0,#4
002790  7060              STRB     r0,[r4,#1]
                  |L1.10130|
;;;1989   	}
;;;1990   	
;;;1991   	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
002792  2000              MOVS     r0,#0
002794  f8c500e0          STR      r0,[r5,#0xe0]
;;;1992   
;;;1993   	return tn;
002798  4620              MOV      r0,r4
;;;1994   }
00279a  bd70              POP      {r4-r6,pc}
;;;1995   
                          ENDP

                  yaffs_HashObject PROC
;;;2181   
;;;2182   static void yaffs_HashObject(yaffs_Object * in)
00279c  b570              PUSH     {r4-r6,lr}
;;;2183   {
00279e  4604              MOV      r4,r0
;;;2184           int bucket = yaffs_HashFunction(in->objectId);
0027a0  6b20              LDR      r0,[r4,#0x30]
0027a2  f7fffffe          BL       yaffs_HashFunction
0027a6  4605              MOV      r5,r0
;;;2185           yaffs_Device *dev = in->myDev;
0027a8  68a6              LDR      r6,[r4,#8]
;;;2186   
;;;2187           ylist_add(&in->hashLink, &dev->objectBucket[bucket].list);
0027aa  eb050245          ADD      r2,r5,r5,LSL #1
0027ae  f506709a          ADD      r0,r6,#0x134
0027b2  eb000182          ADD      r1,r0,r2,LSL #2
0027b6  f104000c          ADD      r0,r4,#0xc
0027ba  f7fffffe          BL       ylist_add
;;;2188           dev->objectBucket[bucket].count++;
0027be  eb050145          ADD      r1,r5,r5,LSL #1
0027c2  f506709a          ADD      r0,r6,#0x134
0027c6  eb000081          ADD      r0,r0,r1,LSL #2
0027ca  6880              LDR      r0,[r0,#8]
0027cc  1c40              ADDS     r0,r0,#1
0027ce  eb050245          ADD      r2,r5,r5,LSL #1
0027d2  f506719a          ADD      r1,r6,#0x134
0027d6  eb010182          ADD      r1,r1,r2,LSL #2
0027da  6088              STR      r0,[r1,#8]
;;;2189   
;;;2190   }
0027dc  bd70              POP      {r4-r6,pc}
;;;2191   
                          ENDP

                  yaffs_FindNiceObjectBucket PROC
;;;2111   
;;;2112   static int yaffs_FindNiceObjectBucket(yaffs_Device * dev)
0027de  b570              PUSH     {r4-r6,lr}
;;;2113   {
0027e0  4601              MOV      r1,r0
;;;2114   	static int x = 0;
;;;2115   	int i;
;;;2116   	int l = 999;
0027e2  f24034e7          MOV      r4,#0x3e7
;;;2117   	int lowest = 999999;
0027e6  4b44              LDR      r3,|L1.10488|
;;;2118   
;;;2119   	/* First let's see if we can find one that's empty. */
;;;2120   
;;;2121   	for (i = 0; i < 10 && lowest > 0; i++) {
0027e8  2200              MOVS     r2,#0
0027ea  e024              B        |L1.10294|
                  |L1.10220|
;;;2122   		x++;
0027ec  4843              LDR      r0,|L1.10492|
0027ee  6800              LDR      r0,[r0,#0]  ; x
0027f0  1c40              ADDS     r0,r0,#1
0027f2  4d42              LDR      r5,|L1.10492|
0027f4  6028              STR      r0,[r5,#0]  ; x
;;;2123   		x %= YAFFS_NOBJECT_BUCKETS;
0027f6  6828              LDR      r0,[r5,#0]  ; x
0027f8  17c5              ASRS     r5,r0,#31
0027fa  eb006515          ADD      r5,r0,r5,LSR #24
0027fe  122d              ASRS     r5,r5,#8
002800  eba02505          SUB      r5,r0,r5,LSL #8
002804  4e3d              LDR      r6,|L1.10492|
002806  6035              STR      r5,[r6,#0]  ; x
;;;2124   		if (dev->objectBucket[x].count < lowest) {
002808  4630              MOV      r0,r6
00280a  6800              LDR      r0,[r0,#0]  ; x
00280c  eb000540          ADD      r5,r0,r0,LSL #1
002810  f501709a          ADD      r0,r1,#0x134
002814  eb000085          ADD      r0,r0,r5,LSL #2
002818  6880              LDR      r0,[r0,#8]
00281a  4298              CMP      r0,r3
00281c  da0a              BGE      |L1.10292|
;;;2125   			lowest = dev->objectBucket[x].count;
00281e  4630              MOV      r0,r6
002820  6800              LDR      r0,[r0,#0]  ; x
002822  eb000540          ADD      r5,r0,r0,LSL #1
002826  f501709a          ADD      r0,r1,#0x134
00282a  eb000085          ADD      r0,r0,r5,LSL #2
00282e  6883              LDR      r3,[r0,#8]
;;;2126   			l = x;
002830  4630              MOV      r0,r6
002832  6804              LDR      r4,[r0,#0]  ; x
                  |L1.10292|
002834  1c52              ADDS     r2,r2,#1              ;2121
                  |L1.10294|
002836  2a0a              CMP      r2,#0xa               ;2121
002838  da01              BGE      |L1.10302|
00283a  2b00              CMP      r3,#0                 ;2121
00283c  dcd6              BGT      |L1.10220|
                  |L1.10302|
;;;2127   		}
;;;2128   
;;;2129   	}
;;;2130   
;;;2131   	/* If we didn't find an empty list, then try
;;;2132   	 * looking a bit further for a short one
;;;2133   	 */
;;;2134   
;;;2135   	for (i = 0; i < 10 && lowest > 3; i++) {
00283e  2200              MOVS     r2,#0
002840  e024              B        |L1.10380|
                  |L1.10306|
;;;2136   		x++;
002842  482e              LDR      r0,|L1.10492|
002844  6800              LDR      r0,[r0,#0]  ; x
002846  1c40              ADDS     r0,r0,#1
002848  4d2c              LDR      r5,|L1.10492|
00284a  6028              STR      r0,[r5,#0]  ; x
;;;2137   		x %= YAFFS_NOBJECT_BUCKETS;
00284c  6828              LDR      r0,[r5,#0]  ; x
00284e  17c5              ASRS     r5,r0,#31
002850  eb006515          ADD      r5,r0,r5,LSR #24
002854  122d              ASRS     r5,r5,#8
002856  eba02505          SUB      r5,r0,r5,LSL #8
00285a  4e28              LDR      r6,|L1.10492|
00285c  6035              STR      r5,[r6,#0]  ; x
;;;2138   		if (dev->objectBucket[x].count < lowest) {
00285e  4630              MOV      r0,r6
002860  6800              LDR      r0,[r0,#0]  ; x
002862  eb000540          ADD      r5,r0,r0,LSL #1
002866  f501709a          ADD      r0,r1,#0x134
00286a  eb000085          ADD      r0,r0,r5,LSL #2
00286e  6880              LDR      r0,[r0,#8]
002870  4298              CMP      r0,r3
002872  da0a              BGE      |L1.10378|
;;;2139   			lowest = dev->objectBucket[x].count;
002874  4630              MOV      r0,r6
002876  6800              LDR      r0,[r0,#0]  ; x
002878  eb000540          ADD      r5,r0,r0,LSL #1
00287c  f501709a          ADD      r0,r1,#0x134
002880  eb000085          ADD      r0,r0,r5,LSL #2
002884  6883              LDR      r3,[r0,#8]
;;;2140   			l = x;
002886  4630              MOV      r0,r6
002888  6804              LDR      r4,[r0,#0]  ; x
                  |L1.10378|
00288a  1c52              ADDS     r2,r2,#1              ;2135
                  |L1.10380|
00288c  2a0a              CMP      r2,#0xa               ;2135
00288e  da01              BGE      |L1.10388|
002890  2b03              CMP      r3,#3                 ;2135
002892  dcd6              BGT      |L1.10306|
                  |L1.10388|
;;;2141   		}
;;;2142   
;;;2143   	}
;;;2144   
;;;2145   	return l;
002894  4620              MOV      r0,r4
;;;2146   }
002896  bd70              POP      {r4-r6,pc}
;;;2147   
                          ENDP

                  yaffs_CreateNewObjectNumber PROC
;;;2148   static int yaffs_CreateNewObjectNumber(yaffs_Device * dev)
002898  e92d41f0          PUSH     {r4-r8,lr}
;;;2149   {
00289c  4605              MOV      r5,r0
;;;2150   	int bucket = yaffs_FindNiceObjectBucket(dev);
00289e  4628              MOV      r0,r5
0028a0  f7fffffe          BL       yaffs_FindNiceObjectBucket
0028a4  4606              MOV      r6,r0
;;;2151   
;;;2152   	/* Now find an object value that has not already been taken
;;;2153   	 * by scanning the list.
;;;2154            */
;;;2155   
;;;2156           int found = 0;
0028a6  f04f0800          MOV      r8,#0
;;;2157           struct ylist_head *i;
;;;2158   
;;;2159           __u32 n = (__u32) bucket;
0028aa  4637              MOV      r7,r6
;;;2160   
;;;2161   	/* yaffs_CheckObjectHashSanity();  */
;;;2162   
;;;2163   	while (!found) {
0028ac  e019              B        |L1.10466|
                  |L1.10414|
;;;2164                   found = 1;
0028ae  f04f0801          MOV      r8,#1
;;;2165                   n += YAFFS_NOBJECT_BUCKETS;
0028b2  f5077780          ADD      r7,r7,#0x100
;;;2166                   if (1 || dev->objectBucket[bucket].count > 0) {
;;;2167                           ylist_for_each(i, &dev->objectBucket[bucket].list) {
0028b6  eb060146          ADD      r1,r6,r6,LSL #1
0028ba  f505709a          ADD      r0,r5,#0x134
0028be  f8504021          LDR      r4,[r0,r1,LSL #2]
0028c2  e006              B        |L1.10450|
                  |L1.10436|
;;;2168                                   /* If there is already one in the list */
;;;2169                                   if (i
0028c4  b124              CBZ      r4,|L1.10448|
;;;2170                                       && ylist_entry(i, yaffs_Object,
0028c6  6a60              LDR      r0,[r4,#0x24]
0028c8  42b8              CMP      r0,r7
0028ca  d101              BNE      |L1.10448|
;;;2171                                                     hashLink)->objectId == n) {
;;;2172                                           found = 0;
0028cc  f04f0800          MOV      r8,#0
                  |L1.10448|
0028d0  6824              LDR      r4,[r4,#0]            ;2167
                  |L1.10450|
0028d2  eb060146          ADD      r1,r6,r6,LSL #1       ;2167
0028d6  f505709a          ADD      r0,r5,#0x134          ;2167
0028da  eb000081          ADD      r0,r0,r1,LSL #2       ;2167
0028de  42a0              CMP      r0,r4                 ;2167
0028e0  d1f0              BNE      |L1.10436|
                  |L1.10466|
0028e2  f1b80f00          CMP      r8,#0                 ;2163
0028e6  d0e2              BEQ      |L1.10414|
;;;2173                                   }
;;;2174   			}
;;;2175   		}
;;;2176   	}
;;;2177   
;;;2178   
;;;2179   	return n;
0028e8  4638              MOV      r0,r7
;;;2180   }
0028ea  e8bd81f0          POP      {r4-r8,pc}
0028ee  0000              DCW      0x0000
                  |L1.10480|
0028f0  64656c65          DCB      "deleted",0
0028f4  74656400
                  |L1.10488|
                          DCD      0x000f423f
                  |L1.10492|
                          DCD      x
                          ENDP

                  yaffs_CreateNewObject PROC
;;;2216   
;;;2217   yaffs_Object *yaffs_CreateNewObject(yaffs_Device * dev, int number,
002900  e92d41f0          PUSH     {r4-r8,lr}
;;;2218   				    yaffs_ObjectType type)
;;;2219   {
002904  4680              MOV      r8,r0
002906  460e              MOV      r6,r1
002908  4615              MOV      r5,r2
;;;2220   
;;;2221   	yaffs_Object *theObject;
;;;2222   	yaffs_Tnode *tn = NULL;
00290a  2700              MOVS     r7,#0
;;;2223   
;;;2224   	if (number < 0) {
00290c  2e00              CMP      r6,#0
00290e  da03              BGE      |L1.10520|
;;;2225   		number = yaffs_CreateNewObjectNumber(dev);
002910  4640              MOV      r0,r8
002912  f7fffffe          BL       yaffs_CreateNewObjectNumber
002916  4606              MOV      r6,r0
                  |L1.10520|
;;;2226   	}
;;;2227   
;;;2228   	theObject = yaffs_AllocateEmptyObject(dev);
002918  4640              MOV      r0,r8
00291a  f7fffffe          BL       yaffs_AllocateEmptyObject
00291e  4604              MOV      r4,r0
;;;2229   	if(!theObject)
002920  b914              CBNZ     r4,|L1.10536|
;;;2230   		return NULL;
002922  2000              MOVS     r0,#0
                  |L1.10532|
;;;2231   		
;;;2232   	if(type == YAFFS_OBJECT_TYPE_FILE){
;;;2233   		tn = yaffs_GetTnode(dev);
;;;2234   		if(!tn){
;;;2235   			yaffs_FreeObject(theObject);
;;;2236   			return NULL;
;;;2237   		}
;;;2238   	}
;;;2239   		
;;;2240   	
;;;2241   
;;;2242   	if (theObject) {
;;;2243   		theObject->fake = 0;
;;;2244   		theObject->renameAllowed = 1;
;;;2245   		theObject->unlinkAllowed = 1;
;;;2246   		theObject->objectId = number;
;;;2247   		yaffs_HashObject(theObject);
;;;2248   		theObject->variantType = type;
;;;2249   #ifdef CONFIG_YAFFS_WINCE
;;;2250   		yfsd_WinFileTimeNow(theObject->win_atime);
;;;2251   		theObject->win_ctime[0] = theObject->win_mtime[0] =
;;;2252   		    theObject->win_atime[0];
;;;2253   		theObject->win_ctime[1] = theObject->win_mtime[1] =
;;;2254   		    theObject->win_atime[1];
;;;2255   
;;;2256   #else
;;;2257   
;;;2258   		theObject->yst_atime = theObject->yst_mtime =
;;;2259   		    theObject->yst_ctime = Y_CURRENT_TIME;
;;;2260   #endif
;;;2261   		switch (type) {
;;;2262   		case YAFFS_OBJECT_TYPE_FILE:
;;;2263   			theObject->variant.fileVariant.fileSize = 0;
;;;2264   			theObject->variant.fileVariant.scannedFileSize = 0;
;;;2265   			theObject->variant.fileVariant.shrinkSize = 0xFFFFFFFF;	/* max __u32 */
;;;2266   			theObject->variant.fileVariant.topLevel = 0;
;;;2267                           theObject->variant.fileVariant.top = tn;
;;;2268                           break;
;;;2269                   case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;2270                           YINIT_LIST_HEAD(&theObject->variant.directoryVariant.
;;;2271                                          children);
;;;2272                           break;
;;;2273                   case YAFFS_OBJECT_TYPE_SYMLINK:
;;;2274   		case YAFFS_OBJECT_TYPE_HARDLINK:
;;;2275   		case YAFFS_OBJECT_TYPE_SPECIAL:
;;;2276   			/* No action required */
;;;2277   			break;
;;;2278   		case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;2279   			/* todo this should not happen */
;;;2280   			break;
;;;2281   		}
;;;2282   	}
;;;2283   
;;;2284   	return theObject;
;;;2285   }
002924  e8bd81f0          POP      {r4-r8,pc}
                  |L1.10536|
002928  2d01              CMP      r5,#1                 ;2232
00292a  d109              BNE      |L1.10560|
00292c  4640              MOV      r0,r8                 ;2233
00292e  f7fffffe          BL       yaffs_GetTnode
002932  4607              MOV      r7,r0                 ;2233
002934  b927              CBNZ     r7,|L1.10560|
002936  4620              MOV      r0,r4                 ;2235
002938  f7fffffe          BL       yaffs_FreeObject
00293c  2000              MOVS     r0,#0                 ;2236
00293e  e7f1              B        |L1.10532|
                  |L1.10560|
002940  2c00              CMP      r4,#0                 ;2242
002942  d035              BEQ      |L1.10672|
002944  7820              LDRB     r0,[r4,#0]            ;2243
002946  f0200008          BIC      r0,r0,#8              ;2243
00294a  7020              STRB     r0,[r4,#0]            ;2243
00294c  7820              LDRB     r0,[r4,#0]            ;2244
00294e  f0200010          BIC      r0,r0,#0x10           ;2244
002952  3010              ADDS     r0,r0,#0x10           ;2244
002954  7020              STRB     r0,[r4,#0]            ;2244
002956  7820              LDRB     r0,[r4,#0]            ;2245
002958  f0200020          BIC      r0,r0,#0x20           ;2245
00295c  3020              ADDS     r0,r0,#0x20           ;2245
00295e  7020              STRB     r0,[r4,#0]            ;2245
002960  6326              STR      r6,[r4,#0x30]         ;2246
002962  4620              MOV      r0,r4                 ;2247
002964  f7fffffe          BL       yaffs_HashObject
002968  f8845054          STRB     r5,[r4,#0x54]         ;2248
00296c  f7fffffe          BL       yaffsfs_CurrentTime
002970  64e0              STR      r0,[r4,#0x4c]         ;2258
002972  64a0              STR      r0,[r4,#0x48]         ;2258
002974  6460              STR      r0,[r4,#0x44]         ;2258
002976  2d06              CMP      r5,#6                 ;2261
002978  d219              BCS      |L1.10670|
00297a  e8dff005          TBB      [pc,r5]               ;2261
00297e  1703              DCB      0x17,0x03
002980  140d1516          DCB      0x14,0x0d,0x15,0x16
002984  2000              MOVS     r0,#0                 ;2263
002986  65a0              STR      r0,[r4,#0x58]         ;2263
002988  2100              MOVS     r1,#0                 ;2264
00298a  65e1              STR      r1,[r4,#0x5c]         ;2264
00298c  1e41              SUBS     r1,r0,#1              ;2265
00298e  6621              STR      r1,[r4,#0x60]         ;2265
002990  2100              MOVS     r1,#0                 ;2266
002992  6661              STR      r1,[r4,#0x64]         ;2266
002994  66a7              STR      r7,[r4,#0x68]         ;2267
002996  e00a              B        |L1.10670|
002998  bf00              NOP                            ;2270
00299a  f1040058          ADD      r0,r4,#0x58           ;2270
00299e  65a0              STR      r0,[r4,#0x58]         ;2270
0029a0  65e0              STR      r0,[r4,#0x5c]         ;2270
0029a2  bf00              NOP                            ;2270
0029a4  e003              B        |L1.10670|
0029a6  bf00              NOP                            ;2274
0029a8  bf00              NOP                            ;2275
0029aa  e000              B        |L1.10670|
0029ac  bf00              NOP                            ;2280
                  |L1.10670|
0029ae  bf00              NOP                            ;2268
                  |L1.10672|
0029b0  4620              MOV      r0,r4                 ;2284
0029b2  e7b7              B        |L1.10532|
;;;2286   
                          ENDP

                  yaffs_CreateFakeDirectory PROC
;;;1995   
;;;1996   static yaffs_Object *yaffs_CreateFakeDirectory(yaffs_Device * dev, int number,
0029b4  e92d41f0          PUSH     {r4-r8,lr}
;;;1997   					       __u32 mode)
;;;1998   {
0029b8  4605              MOV      r5,r0
0029ba  460f              MOV      r7,r1
0029bc  4616              MOV      r6,r2
;;;1999   
;;;2000   	yaffs_Object *obj =
0029be  2203              MOVS     r2,#3
0029c0  4639              MOV      r1,r7
0029c2  4628              MOV      r0,r5
0029c4  f7fffffe          BL       yaffs_CreateNewObject
0029c8  4604              MOV      r4,r0
;;;2001   	    yaffs_CreateNewObject(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
;;;2002   	if (obj) {
0029ca  b1c4              CBZ      r4,|L1.10750|
;;;2003   		obj->fake = 1;		/* it is fake so it might have no NAND presence... */
0029cc  7820              LDRB     r0,[r4,#0]
0029ce  f0200008          BIC      r0,r0,#8
0029d2  3008              ADDS     r0,r0,#8
0029d4  7020              STRB     r0,[r4,#0]
;;;2004   		obj->renameAllowed = 0;	/* ... and we're not allowed to rename it... */
0029d6  7820              LDRB     r0,[r4,#0]
0029d8  f0200010          BIC      r0,r0,#0x10
0029dc  7020              STRB     r0,[r4,#0]
;;;2005   		obj->unlinkAllowed = 0;	/* ... or unlink it */
0029de  7820              LDRB     r0,[r4,#0]
0029e0  f0200020          BIC      r0,r0,#0x20
0029e4  7020              STRB     r0,[r4,#0]
;;;2006   		obj->deleted = 0;
0029e6  7820              LDRB     r0,[r4,#0]
0029e8  f0200001          BIC      r0,r0,#1
0029ec  7020              STRB     r0,[r4,#0]
;;;2007   		obj->unlinked = 0;
0029ee  7820              LDRB     r0,[r4,#0]
0029f0  f0200004          BIC      r0,r0,#4
0029f4  7020              STRB     r0,[r4,#0]
;;;2008   		obj->yst_mode = mode;
0029f6  6366              STR      r6,[r4,#0x34]
;;;2009   		obj->myDev = dev;
0029f8  60a5              STR      r5,[r4,#8]
;;;2010   		obj->hdrChunk = 0;	/* Not a valid chunk. */
0029fa  2000              MOVS     r0,#0
0029fc  62a0              STR      r0,[r4,#0x28]
                  |L1.10750|
;;;2011   	}
;;;2012   
;;;2013   	return obj;
0029fe  4620              MOV      r0,r4
;;;2014   
;;;2015   }
002a00  e8bd81f0          POP      {r4-r8,pc}
;;;2016   
                          ENDP

                  yaffs_DeinitialiseObjects PROC
;;;2078   
;;;2079   static void yaffs_DeinitialiseObjects(yaffs_Device * dev)
002a04  b570              PUSH     {r4-r6,lr}
;;;2080   {
002a06  4604              MOV      r4,r0
;;;2081   	/* Free the list of allocated Objects */
;;;2082   
;;;2083   	yaffs_ObjectList *tmp;
;;;2084   
;;;2085   	while (dev->allocatedObjectList) {
002a08  e00d              B        |L1.10790|
                  |L1.10762|
;;;2086   		tmp = dev->allocatedObjectList->next;
002a0a  f8d40130          LDR      r0,[r4,#0x130]
002a0e  6845              LDR      r5,[r0,#4]
;;;2087   		YFREE(dev->allocatedObjectList->objects);
002a10  f8d41130          LDR      r1,[r4,#0x130]
002a14  6808              LDR      r0,[r1,#0]
002a16  f7fffffe          BL       free
;;;2088   		YFREE(dev->allocatedObjectList);
002a1a  f8d40130          LDR      r0,[r4,#0x130]
002a1e  f7fffffe          BL       free
;;;2089   
;;;2090   		dev->allocatedObjectList = tmp;
002a22  f8c45130          STR      r5,[r4,#0x130]
                  |L1.10790|
002a26  f8d40130          LDR      r0,[r4,#0x130]        ;2085
002a2a  2800              CMP      r0,#0                 ;2085
002a2c  d1ed              BNE      |L1.10762|
;;;2091   	}
;;;2092   
;;;2093   	dev->freeObjects = NULL;
002a2e  f8c40124          STR      r0,[r4,#0x124]
;;;2094   	dev->nFreeObjects = 0;
002a32  f8c40128          STR      r0,[r4,#0x128]
;;;2095   }
002a36  bd70              POP      {r4-r6,pc}
;;;2096   
                          ENDP

                  yaffs_InitialiseObjects PROC
;;;2097   static void yaffs_InitialiseObjects(yaffs_Device * dev)
002a38  b510              PUSH     {r4,lr}
;;;2098   {
;;;2099   	int i;
;;;2100   
;;;2101   	dev->allocatedObjectList = NULL;
002a3a  2200              MOVS     r2,#0
002a3c  f8c02130          STR      r2,[r0,#0x130]
;;;2102   	dev->freeObjects = NULL;
002a40  f8c02124          STR      r2,[r0,#0x124]
;;;2103           dev->nFreeObjects = 0;
002a44  f8c02128          STR      r2,[r0,#0x128]
;;;2104   
;;;2105           for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
002a48  2100              MOVS     r1,#0
002a4a  e01d              B        |L1.10888|
                  |L1.10828|
;;;2106                   YINIT_LIST_HEAD(&dev->objectBucket[i].list);
002a4c  bf00              NOP      
002a4e  eb010341          ADD      r3,r1,r1,LSL #1
002a52  f500729a          ADD      r2,r0,#0x134
002a56  eb020383          ADD      r3,r2,r3,LSL #2
002a5a  eb010441          ADD      r4,r1,r1,LSL #1
002a5e  f8423024          STR      r3,[r2,r4,LSL #2]
002a62  eb010341          ADD      r3,r1,r1,LSL #1
002a66  eb020383          ADD      r3,r2,r3,LSL #2
002a6a  eb010441          ADD      r4,r1,r1,LSL #1
002a6e  eb020284          ADD      r2,r2,r4,LSL #2
002a72  6053              STR      r3,[r2,#4]
002a74  bf00              NOP      
;;;2107                   dev->objectBucket[i].count = 0;
002a76  2300              MOVS     r3,#0
002a78  eb010441          ADD      r4,r1,r1,LSL #1
002a7c  f500729a          ADD      r2,r0,#0x134
002a80  eb020284          ADD      r2,r2,r4,LSL #2
002a84  6093              STR      r3,[r2,#8]
002a86  1c49              ADDS     r1,r1,#1              ;2105
                  |L1.10888|
002a88  29ff              CMP      r1,#0xff              ;2105
002a8a  dddf              BLE      |L1.10828|
;;;2108           }
;;;2109   
;;;2110   }
002a8c  bd10              POP      {r4,pc}
;;;2111   
                          ENDP

                  yaffs_FindOrCreateObjectByNumber PROC
;;;2286   
;;;2287   static yaffs_Object *yaffs_FindOrCreateObjectByNumber(yaffs_Device * dev,
002a8e  e92d41f0          PUSH     {r4-r8,lr}
;;;2288   						      int number,
;;;2289   						      yaffs_ObjectType type)
;;;2290   {
002a92  4606              MOV      r6,r0
002a94  460c              MOV      r4,r1
002a96  4617              MOV      r7,r2
;;;2291   	yaffs_Object *theObject = NULL;
002a98  2500              MOVS     r5,#0
;;;2292   
;;;2293   	if (number > 0) {
002a9a  2c00              CMP      r4,#0
002a9c  dd04              BLE      |L1.10920|
;;;2294   		theObject = yaffs_FindObjectByNumber(dev, number);
002a9e  4621              MOV      r1,r4
002aa0  4630              MOV      r0,r6
002aa2  f7fffffe          BL       yaffs_FindObjectByNumber
002aa6  4605              MOV      r5,r0
                  |L1.10920|
;;;2295   	}
;;;2296   
;;;2297   	if (!theObject) {
002aa8  b92d              CBNZ     r5,|L1.10934|
;;;2298   		theObject = yaffs_CreateNewObject(dev, number, type);
002aaa  463a              MOV      r2,r7
002aac  4621              MOV      r1,r4
002aae  4630              MOV      r0,r6
002ab0  f7fffffe          BL       yaffs_CreateNewObject
002ab4  4605              MOV      r5,r0
                  |L1.10934|
;;;2299   	}
;;;2300   
;;;2301   	return theObject;
002ab6  4628              MOV      r0,r5
;;;2302   
;;;2303   }
002ab8  e8bd81f0          POP      {r4-r8,pc}
;;;2304   			
                          ENDP

                  yaffs_DeleteHardLink PROC
;;;5323   
;;;5324   static int yaffs_DeleteHardLink(yaffs_Object * in)
002abc  b510              PUSH     {r4,lr}
;;;5325   {
002abe  4604              MOV      r4,r0
;;;5326           /* remove this hardlink from the list assocaited with the equivalent
;;;5327            * object
;;;5328            */
;;;5329           ylist_del_init(&in->hardLinks);
002ac0  f1040014          ADD      r0,r4,#0x14
002ac4  f7fffffe          BL       ylist_del_init
;;;5330           return yaffs_DoGenericObjectDeletion(in);
002ac8  4620              MOV      r0,r4
002aca  f7fffffe          BL       yaffs_DoGenericObjectDeletion
;;;5331   }
002ace  bd10              POP      {r4,pc}
;;;5332   
                          ENDP

                  yaffs_DeleteSymLink PROC
;;;5316   
;;;5317   static int yaffs_DeleteSymLink(yaffs_Object * in)
002ad0  b510              PUSH     {r4,lr}
;;;5318   {
002ad2  4604              MOV      r4,r0
;;;5319   	YFREE(in->variant.symLinkVariant.alias);
002ad4  6da0              LDR      r0,[r4,#0x58]
002ad6  f7fffffe          BL       free
;;;5320   
;;;5321   	return yaffs_DoGenericObjectDeletion(in);
002ada  4620              MOV      r0,r4
002adc  f7fffffe          BL       yaffs_DoGenericObjectDeletion
;;;5322   }
002ae0  bd10              POP      {r4,pc}
;;;5323   
                          ENDP

                  yaffs_DeleteDirectory PROC
;;;5305   
;;;5306   static int yaffs_DeleteDirectory(yaffs_Object * in)
002ae2  b510              PUSH     {r4,lr}
;;;5307   {
002ae4  4604              MOV      r4,r0
;;;5308           /* First check that the directory is empty. */
;;;5309           if (ylist_empty(&in->variant.directoryVariant.children)) {
002ae6  f1040058          ADD      r0,r4,#0x58
002aea  f7fffffe          BL       ylist_empty
002aee  b118              CBZ      r0,|L1.11000|
;;;5310                   return yaffs_DoGenericObjectDeletion(in);
002af0  4620              MOV      r0,r4
002af2  f7fffffe          BL       yaffs_DoGenericObjectDeletion
                  |L1.10998|
;;;5311           }
;;;5312   
;;;5313   	return YAFFS_FAIL;
;;;5314   
;;;5315   }
002af6  bd10              POP      {r4,pc}
                  |L1.11000|
002af8  2000              MOVS     r0,#0                 ;5313
002afa  e7fc              B        |L1.10998|
;;;5316   
                          ENDP

                  yaffs_WriteChunkDataToObject PROC
;;;3704   
;;;3705   static int yaffs_WriteChunkDataToObject(yaffs_Object * in, int chunkInInode,
002afc  e92d4ff0          PUSH     {r4-r11,lr}
;;;3706   					const __u8 * buffer, int nBytes,
;;;3707   					int useReserve)
;;;3708   {
002b00  b0a5              SUB      sp,sp,#0x94
002b02  4606              MOV      r6,r0
002b04  4688              MOV      r8,r1
002b06  4691              MOV      r9,r2
002b08  461c              MOV      r4,r3
002b0a  f8ddb0b8          LDR      r11,[sp,#0xb8]
;;;3709   	/* Find old chunk Need to do this to get serial number
;;;3710   	 * Write new one and patch into tree.
;;;3711   	 * Invalidate old tags.
;;;3712   	 */
;;;3713   
;;;3714   	int prevChunkId;
;;;3715   	yaffs_ExtendedTags prevTags;
;;;3716   
;;;3717   	int newChunkId;
;;;3718   	yaffs_ExtendedTags newTags;
;;;3719   
;;;3720   	yaffs_Device *dev = in->myDev;
002b0e  f8d6a008          LDR      r10,[r6,#8]
;;;3721   
;;;3722   	yaffs_CheckGarbageCollection(dev);
002b12  4650              MOV      r0,r10
002b14  f7fffffe          BL       yaffs_CheckGarbageCollection
;;;3723   
;;;3724   	/* Get the previous chunk at this location in the file if it exists */
;;;3725   	prevChunkId = yaffs_FindChunkInFile(in, chunkInInode, &prevTags);
002b18  aa13              ADD      r2,sp,#0x4c
002b1a  4641              MOV      r1,r8
002b1c  4630              MOV      r0,r6
002b1e  f7fffffe          BL       yaffs_FindChunkInFile
002b22  4607              MOV      r7,r0
;;;3726   
;;;3727   	/* Set up new tags */
;;;3728   	yaffs_InitialiseTags(&newTags);
002b24  a801              ADD      r0,sp,#4
002b26  f7fffffe          BL       yaffs_InitialiseTags
;;;3729   
;;;3730   	newTags.chunkId = chunkInInode;
002b2a  f8cd8010          STR      r8,[sp,#0x10]
;;;3731   	newTags.objectId = in->objectId;
002b2e  6b30              LDR      r0,[r6,#0x30]
002b30  9003              STR      r0,[sp,#0xc]
;;;3732   	newTags.serialNumber =
002b32  2f00              CMP      r7,#0
002b34  db02              BLT      |L1.11068|
;;;3733   	    (prevChunkId >= 0) ? prevTags.serialNumber + 1 : 1;
002b36  981b              LDR      r0,[sp,#0x6c]
002b38  1c40              ADDS     r0,r0,#1
002b3a  e000              B        |L1.11070|
                  |L1.11068|
002b3c  2001              MOVS     r0,#1
                  |L1.11070|
002b3e  9009              STR      r0,[sp,#0x24]
;;;3734   	newTags.byteCount = nBytes;
002b40  9405              STR      r4,[sp,#0x14]
;;;3735   	
;;;3736   	if(nBytes < 1 || nBytes > dev->totalBytesPerChunk){
002b42  2c01              CMP      r4,#1
002b44  db03              BLT      |L1.11086|
002b46  f8da0090          LDR      r0,[r10,#0x90]
002b4a  42a0              CMP      r0,r4
002b4c  d201              BCS      |L1.11090|
                  |L1.11086|
;;;3737   	  T(YAFFS_TRACE_ERROR,
002b4e  bf00              NOP      
002b50  bf00              NOP      
                  |L1.11090|
;;;3738   	  (TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), nBytes));
;;;3739   	  YBUG();
;;;3740        }
;;;3741   	
;;;3742   	
;;;3743   
;;;3744   	newChunkId =
002b52  465b              MOV      r3,r11
002b54  aa01              ADD      r2,sp,#4
002b56  4649              MOV      r1,r9
002b58  4650              MOV      r0,r10
002b5a  f7fffffe          BL       yaffs_WriteNewChunkWithTagsToNAND
002b5e  4605              MOV      r5,r0
;;;3745   	    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
;;;3746   					      useReserve);
;;;3747   
;;;3748   	if (newChunkId >= 0) {
002b60  2d00              CMP      r5,#0
002b62  db0e              BLT      |L1.11138|
;;;3749   		yaffs_PutChunkIntoFile(in, chunkInInode, newChunkId, 0);
002b64  2300              MOVS     r3,#0
002b66  462a              MOV      r2,r5
002b68  4641              MOV      r1,r8
002b6a  4630              MOV      r0,r6
002b6c  f7fffffe          BL       yaffs_PutChunkIntoFile
;;;3750   
;;;3751   		if (prevChunkId >= 0) {
002b70  2f00              CMP      r7,#0
002b72  db06              BLT      |L1.11138|
;;;3752   			yaffs_DeleteChunk(dev, prevChunkId, 1, __LINE__);
002b74  f64063a8          MOV      r3,#0xea8
002b78  2201              MOVS     r2,#1
002b7a  4639              MOV      r1,r7
002b7c  4650              MOV      r0,r10
002b7e  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.11138|
;;;3753   
;;;3754   		}
;;;3755   
;;;3756   		yaffs_CheckFileSanity(in);
;;;3757   	}
;;;3758   	return newChunkId;
002b82  4628              MOV      r0,r5
;;;3759   
;;;3760   }
002b84  b025              ADD      sp,sp,#0x94
002b86  e8bd8ff0          POP      {r4-r11,pc}
;;;3761   
                          ENDP

                  yaffs_ReadChunkDataFromObject PROC
;;;3620   
;;;3621   static int yaffs_ReadChunkDataFromObject(yaffs_Object * in, int chunkInInode,
002b8a  e92d41f0          PUSH     {r4-r8,lr}
;;;3622   					 __u8 * buffer)
;;;3623   {
002b8e  4604              MOV      r4,r0
002b90  460f              MOV      r7,r1
002b92  4615              MOV      r5,r2
;;;3624   	int chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, NULL);
002b94  2200              MOVS     r2,#0
002b96  4639              MOV      r1,r7
002b98  4620              MOV      r0,r4
002b9a  f7fffffe          BL       yaffs_FindChunkInFile
002b9e  4606              MOV      r6,r0
;;;3625           
;;;3626   	if (chunkInNAND >= 0) {
002ba0  2e00              CMP      r6,#0
002ba2  db07              BLT      |L1.11188|
;;;3627   		return yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND, buffer,NULL);
002ba4  2300              MOVS     r3,#0
002ba6  462a              MOV      r2,r5
002ba8  4631              MOV      r1,r6
002baa  68a0              LDR      r0,[r4,#8]
002bac  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
                  |L1.11184|
;;;3628   						      
;;;3629   	} else {
;;;3630   		T(YAFFS_TRACE_NANDACCESS,
;;;3631   		  (TSTR("Chunk %d not found zero instead" TENDSTR),
;;;3632   		   chunkInNAND));
;;;3633   		/* get sane (zero) data if you read a hole */
;;;3634   		memset(buffer, 0, in->myDev->nDataBytesPerChunk);	
;;;3635   		return 0;
;;;3636   	}
;;;3637   
;;;3638   }
002bb0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.11188|
002bb4  bf00              NOP                            ;3630
002bb6  bf00              NOP                            ;3630
002bb8  68a0              LDR      r0,[r4,#8]            ;3634
002bba  68c1              LDR      r1,[r0,#0xc]          ;3634
002bbc  4628              MOV      r0,r5                 ;3634
002bbe  f7fffffe          BL       __aeabi_memclr
002bc2  2000              MOVS     r0,#0                 ;3635
002bc4  e7f4              B        |L1.11184|
;;;3639   
                          ENDP

                  yaffs_FindAndDeleteChunkInFile PROC
;;;3395   
;;;3396   static int yaffs_FindAndDeleteChunkInFile(yaffs_Object * in, int chunkInInode,
002bc6  e92d47f0          PUSH     {r4-r10,lr}
;;;3397   					  yaffs_ExtendedTags * tags)
;;;3398   {
002bca  b094              SUB      sp,sp,#0x50
002bcc  4604              MOV      r4,r0
002bce  460e              MOV      r6,r1
002bd0  4617              MOV      r7,r2
;;;3399   	/* Get the Tnode, then get the level 0 offset chunk offset */
;;;3400   	yaffs_Tnode *tn;
;;;3401   	int theChunk = -1;
002bd2  f04f39ff          MOV      r9,#0xffffffff
;;;3402   	yaffs_ExtendedTags localTags;
;;;3403   
;;;3404   	yaffs_Device *dev = in->myDev;
002bd6  f8d4a008          LDR      r10,[r4,#8]
;;;3405   	int retVal = -1;
002bda  46c8              MOV      r8,r9
;;;3406   
;;;3407   	if (!tags) {
002bdc  b907              CBNZ     r7,|L1.11232|
;;;3408   		/* Passed a NULL, so use our own tags space */
;;;3409   		tags = &localTags;
002bde  af02              ADD      r7,sp,#8
                  |L1.11232|
;;;3410   	}
;;;3411   
;;;3412   	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
002be0  4632              MOV      r2,r6
002be2  f1040158          ADD      r1,r4,#0x58
002be6  4650              MOV      r0,r10
002be8  f7fffffe          BL       yaffs_FindLevel0Tnode
002bec  4605              MOV      r5,r0
;;;3413   
;;;3414   	if (tn) {
002bee  b1b5              CBZ      r5,|L1.11294|
;;;3415   
;;;3416   		theChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);
002bf0  4632              MOV      r2,r6
002bf2  4629              MOV      r1,r5
002bf4  4650              MOV      r0,r10
002bf6  f7fffffe          BL       yaffs_GetChunkGroupBase
002bfa  4681              MOV      r9,r0
;;;3417   
;;;3418   		retVal =
002bfc  9600              STR      r6,[sp,#0]
002bfe  463a              MOV      r2,r7
002c00  4649              MOV      r1,r9
002c02  4650              MOV      r0,r10
002c04  6b23              LDR      r3,[r4,#0x30]
002c06  f7fffffe          BL       yaffs_FindChunkInGroup
002c0a  4680              MOV      r8,r0
;;;3419   		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
;;;3420   					   chunkInInode);
;;;3421   
;;;3422   		/* Delete the entry in the filestructure (if found) */
;;;3423   		if (retVal != -1) {
002c0c  f1080001          ADD      r0,r8,#1
002c10  b128              CBZ      r0,|L1.11294|
;;;3424   			yaffs_PutLevel0Tnode(dev,tn,chunkInInode,0);
002c12  2300              MOVS     r3,#0
002c14  4632              MOV      r2,r6
002c16  4629              MOV      r1,r5
002c18  4650              MOV      r0,r10
002c1a  f7fffffe          BL       yaffs_PutLevel0Tnode
                  |L1.11294|
;;;3425   		}
;;;3426   	} else {
;;;3427   		/*T(("No level 0 found for %d\n", chunkInInode)); */
;;;3428   	}
;;;3429   
;;;3430   	if (retVal == -1) {
;;;3431   		/* T(("Could not find %d to delete\n",chunkInInode)); */
;;;3432   	}
;;;3433   	return retVal;
002c1e  4640              MOV      r0,r8
;;;3434   }
002c20  b014              ADD      sp,sp,#0x50
002c22  e8bd87f0          POP      {r4-r10,pc}
;;;3435   
                          ENDP

                  yaffs_PruneResizedChunks PROC
;;;5058   
;;;5059   static void yaffs_PruneResizedChunks(yaffs_Object * in, int newSize)
002c26  e92d5ff0          PUSH     {r4-r12,lr}
;;;5060   {
002c2a  4606              MOV      r6,r0
002c2c  4688              MOV      r8,r1
;;;5061   
;;;5062   	yaffs_Device *dev = in->myDev;
002c2e  68b4              LDR      r4,[r6,#8]
;;;5063   	int oldFileSize = in->variant.fileVariant.fileSize;
002c30  f8d69058          LDR      r9,[r6,#0x58]
;;;5064   
;;;5065   	int lastDel = 1 + (oldFileSize - 1) / dev->nDataBytesPerChunk;
002c34  f1a90001          SUB      r0,r9,#1
002c38  68e1              LDR      r1,[r4,#0xc]
002c3a  fb90f0f1          SDIV     r0,r0,r1
002c3e  f1000a01          ADD      r10,r0,#1
;;;5066   
;;;5067   	int startDel = 1 + (newSize + dev->nDataBytesPerChunk - 1) /
002c42  68e0              LDR      r0,[r4,#0xc]
002c44  4440              ADD      r0,r0,r8
002c46  1e40              SUBS     r0,r0,#1
002c48  68e1              LDR      r1,[r4,#0xc]
002c4a  fb90f0f1          SDIV     r0,r0,r1
002c4e  f1000b01          ADD      r11,r0,#1
;;;5068   	    dev->nDataBytesPerChunk;
;;;5069   	int i;
;;;5070   	int chunkId;
;;;5071   
;;;5072   	/* Delete backwards so that we don't end up with holes if
;;;5073   	 * power is lost part-way through the operation.
;;;5074   	 */
;;;5075   	for (i = lastDel; i >= startDel; i--) {
002c52  4657              MOV      r7,r10
002c54  e021              B        |L1.11418|
                  |L1.11350|
;;;5076   		/* NB this could be optimised somewhat,
;;;5077   		 * eg. could retrieve the tags and write them without
;;;5078   		 * using yaffs_DeleteChunk
;;;5079   		 */
;;;5080   
;;;5081   		chunkId = yaffs_FindAndDeleteChunkInFile(in, i, NULL);
002c56  2200              MOVS     r2,#0
002c58  4639              MOV      r1,r7
002c5a  4630              MOV      r0,r6
002c5c  f7fffffe          BL       yaffs_FindAndDeleteChunkInFile
002c60  4605              MOV      r5,r0
;;;5082   		if (chunkId > 0) {
002c62  2d00              CMP      r5,#0
002c64  dd18              BLE      |L1.11416|
;;;5083   			if (chunkId <
002c66  6921              LDR      r1,[r4,#0x10]
002c68  f8d4009c          LDR      r0,[r4,#0x9c]
002c6c  4348              MULS     r0,r1,r0
002c6e  42a8              CMP      r0,r5
002c70  dc06              BGT      |L1.11392|
;;;5084   			    (dev->internalStartBlock * dev->nChunksPerBlock)
;;;5085   			    || chunkId >=
002c72  f8d400a0          LDR      r0,[r4,#0xa0]
002c76  1c40              ADDS     r0,r0,#1
002c78  6921              LDR      r1,[r4,#0x10]
002c7a  4348              MULS     r0,r1,r0
002c7c  42a8              CMP      r0,r5
002c7e  dc01              BGT      |L1.11396|
                  |L1.11392|
;;;5086   			    ((dev->internalEndBlock +
;;;5087   			      1) * dev->nChunksPerBlock)) {
;;;5088   				T(YAFFS_TRACE_ALWAYS,
002c80  bf00              NOP      
002c82  e009              B        |L1.11416|
                  |L1.11396|
;;;5089   				  (TSTR("Found daft chunkId %d for %d" TENDSTR),
;;;5090   				   chunkId, i));
;;;5091   			} else {
;;;5092   				in->nDataChunks--;
002c84  6af0              LDR      r0,[r6,#0x2c]
002c86  1e40              SUBS     r0,r0,#1
002c88  62f0              STR      r0,[r6,#0x2c]
;;;5093   				yaffs_DeleteChunk(dev, chunkId, 1, __LINE__);
002c8a  f24133e5          MOV      r3,#0x13e5
002c8e  2201              MOVS     r2,#1
002c90  4629              MOV      r1,r5
002c92  4620              MOV      r0,r4
002c94  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.11416|
002c98  1e7f              SUBS     r7,r7,#1              ;5075
                  |L1.11418|
002c9a  455f              CMP      r7,r11                ;5075
002c9c  dadb              BGE      |L1.11350|
;;;5094   			}
;;;5095   		}
;;;5096   	}
;;;5097   
;;;5098   }
002c9e  e8bd9ff0          POP      {r4-r12,pc}
;;;5099   
                          ENDP

                  yaffs_FlushFilesChunkCache PROC
;;;3962   
;;;3963   static void yaffs_FlushFilesChunkCache(yaffs_Object * obj)
002ca2  e92d4ff8          PUSH     {r3-r11,lr}
;;;3964   {
002ca6  4606              MOV      r6,r0
;;;3965   	yaffs_Device *dev = obj->myDev;
002ca8  68b7              LDR      r7,[r6,#8]
;;;3966   	int lowest = -99;	/* Stop compiler whining. */
002caa  f06f0962          MVN      r9,#0x62
;;;3967   	int i;
;;;3968   	yaffs_ChunkCache *cache;
;;;3969   	int chunkWritten = 0;
002cae  f04f0a00          MOV      r10,#0
;;;3970   	int nCaches = obj->myDev->nShortOpCaches;
002cb2  68b0              LDR      r0,[r6,#8]
002cb4  f8d08024          LDR      r8,[r0,#0x24]
;;;3971   
;;;3972   	if (nCaches > 0) {
002cb8  f1b80f00          CMP      r8,#0
002cbc  dd3e              BLE      |L1.11580|
;;;3973   		do {
002cbe  bf00              NOP      
                  |L1.11456|
;;;3974   			cache = NULL;
002cc0  2400              MOVS     r4,#0
;;;3975   
;;;3976   			/* Find the dirty cache for this object with the lowest chunk id. */
;;;3977   			for (i = 0; i < nCaches; i++) {
002cc2  2500              MOVS     r5,#0
002cc4  e022              B        |L1.11532|
                  |L1.11462|
;;;3978   				if (dev->srCache[i].object == obj &&
002cc6  ebc501c5          RSB      r1,r5,r5,LSL #3
002cca  f8d70d94          LDR      r0,[r7,#0xd94]
002cce  f8500021          LDR      r0,[r0,r1,LSL #2]
002cd2  42b0              CMP      r0,r6
002cd4  d119              BNE      |L1.11530|
;;;3979   				    dev->srCache[i].dirty) {
002cd6  ebc501c5          RSB      r1,r5,r5,LSL #3
002cda  f8d70d94          LDR      r0,[r7,#0xd94]
002cde  eb000081          ADD      r0,r0,r1,LSL #2
002ce2  68c0              LDR      r0,[r0,#0xc]
002ce4  b188              CBZ      r0,|L1.11530|
;;;3980   					if (!cache
002ce6  b144              CBZ      r4,|L1.11514|
;;;3981   					    || dev->srCache[i].chunkId <
002ce8  ebc501c5          RSB      r1,r5,r5,LSL #3
002cec  f8d70d94          LDR      r0,[r7,#0xd94]
002cf0  eb000081          ADD      r0,r0,r1,LSL #2
002cf4  6840              LDR      r0,[r0,#4]
002cf6  4548              CMP      r0,r9
002cf8  da07              BGE      |L1.11530|
                  |L1.11514|
;;;3982   					    lowest) {
;;;3983   						cache = &dev->srCache[i];
002cfa  ebc501c5          RSB      r1,r5,r5,LSL #3
002cfe  f8d70d94          LDR      r0,[r7,#0xd94]
002d02  eb000481          ADD      r4,r0,r1,LSL #2
;;;3984   						lowest = cache->chunkId;
002d06  f8d49004          LDR      r9,[r4,#4]
                  |L1.11530|
002d0a  1c6d              ADDS     r5,r5,#1              ;3977
                  |L1.11532|
002d0c  4545              CMP      r5,r8                 ;3977
002d0e  dbda              BLT      |L1.11462|
;;;3985   					}
;;;3986   				}
;;;3987   			}
;;;3988   
;;;3989   			if (cache && !cache->locked) {
002d10  b16c              CBZ      r4,|L1.11566|
002d12  6960              LDR      r0,[r4,#0x14]
002d14  b958              CBNZ     r0,|L1.11566|
;;;3990   				/* Write it out and free it up */
;;;3991   
;;;3992   				chunkWritten =
002d16  2001              MOVS     r0,#1
002d18  9000              STR      r0,[sp,#0]
002d1a  6923              LDR      r3,[r4,#0x10]
002d1c  69a2              LDR      r2,[r4,#0x18]
002d1e  e9d40100          LDRD     r0,r1,[r4,#0]
002d22  f7fffffe          BL       yaffs_WriteChunkDataToObject
002d26  4682              MOV      r10,r0
;;;3993   				    yaffs_WriteChunkDataToObject(cache->object,
;;;3994   								 cache->chunkId,
;;;3995   								 cache->data,
;;;3996   								 cache->nBytes,
;;;3997   								 1);
;;;3998   				cache->dirty = 0;
002d28  2000              MOVS     r0,#0
002d2a  60e0              STR      r0,[r4,#0xc]
;;;3999   				cache->object = NULL;
002d2c  6020              STR      r0,[r4,#0]
                  |L1.11566|
;;;4000   			}
;;;4001   
;;;4002   		} while (cache && chunkWritten > 0);
002d2e  b114              CBZ      r4,|L1.11574|
002d30  f1ba0f00          CMP      r10,#0
002d34  dcc4              BGT      |L1.11456|
                  |L1.11574|
;;;4003   
;;;4004   		if (cache) {
002d36  b10c              CBZ      r4,|L1.11580|
;;;4005   			/* Hoosterman, disk full while writing cache out. */
;;;4006   			T(YAFFS_TRACE_ERROR,
002d38  bf00              NOP      
002d3a  bf00              NOP      
                  |L1.11580|
;;;4007   			  (TSTR("yaffs tragedy: no space during cache write" TENDSTR)));
;;;4008   
;;;4009   		}
;;;4010   	}
;;;4011   
;;;4012   }
002d3c  e8bd8ff8          POP      {r3-r11,pc}
;;;4013   
                          ENDP

                  yaffs_ResizeFile PROC
;;;5099   
;;;5100   int yaffs_ResizeFile(yaffs_Object * in, loff_t newSize)
002d40  e92d43fe          PUSH     {r1-r9,lr}
;;;5101   {
002d44  4604              MOV      r4,r0
002d46  460d              MOV      r5,r1
;;;5102   
;;;5103   	int oldFileSize = in->variant.fileVariant.fileSize;
002d48  6da6              LDR      r6,[r4,#0x58]
;;;5104   	__u32 newSizeOfPartialChunk;
;;;5105   	int newFullChunks;
;;;5106   	
;;;5107   	yaffs_Device *dev = in->myDev;
002d4a  f8d48008          LDR      r8,[r4,#8]
;;;5108   
;;;5109   	yaffs_AddrToChunk(dev, newSize, &newFullChunks, &newSizeOfPartialChunk);
002d4e  ab02              ADD      r3,sp,#8
002d50  aa01              ADD      r2,sp,#4
002d52  4629              MOV      r1,r5
002d54  4640              MOV      r0,r8
002d56  f7fffffe          BL       yaffs_AddrToChunk
;;;5110   
;;;5111   	yaffs_FlushFilesChunkCache(in);
002d5a  4620              MOV      r0,r4
002d5c  f7fffffe          BL       yaffs_FlushFilesChunkCache
;;;5112   	yaffs_InvalidateWholeChunkCache(in);
002d60  4620              MOV      r0,r4
002d62  f7fffffe          BL       yaffs_InvalidateWholeChunkCache
;;;5113   
;;;5114           yaffs_CheckGarbageCollection(dev);
002d66  4640              MOV      r0,r8
002d68  f7fffffe          BL       yaffs_CheckGarbageCollection
;;;5115   
;;;5116           if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
002d6c  f8940054          LDRB     r0,[r4,#0x54]
002d70  2801              CMP      r0,#1
002d72  d002              BEQ      |L1.11642|
;;;5117                   return YAFFS_FAIL;
002d74  2000              MOVS     r0,#0
                  |L1.11638|
;;;5118           }
;;;5119   
;;;5120           if (newSize == oldFileSize) {
;;;5121                   return YAFFS_OK;
;;;5122           }
;;;5123   
;;;5124           if (newSize < oldFileSize) {
;;;5125   
;;;5126   		yaffs_PruneResizedChunks(in, newSize);
;;;5127   
;;;5128   		if (newSizeOfPartialChunk != 0) {
;;;5129   			int lastChunk = 1 + newFullChunks;
;;;5130   			
;;;5131   			__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);
;;;5132   
;;;5133   			/* Got to read and rewrite the last chunk with its new size and zero pad */
;;;5134   			yaffs_ReadChunkDataFromObject(in, lastChunk,
;;;5135   						      localBuffer);
;;;5136   
;;;5137   			memset(localBuffer + newSizeOfPartialChunk, 0,
;;;5138   			       dev->nDataBytesPerChunk - newSizeOfPartialChunk);
;;;5139   
;;;5140   			yaffs_WriteChunkDataToObject(in, lastChunk, localBuffer,
;;;5141   						     newSizeOfPartialChunk, 1);
;;;5142   
;;;5143   			yaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);
;;;5144   		}
;;;5145   
;;;5146   		in->variant.fileVariant.fileSize = newSize;
;;;5147   
;;;5148   		yaffs_PruneFileStructure(dev, &in->variant.fileVariant);
;;;5149   	} else {
;;;5150   		/* newsSize > oldFileSize */
;;;5151   		in->variant.fileVariant.fileSize = newSize;
;;;5152   	}
;;;5153   
;;;5154   		
;;;5155   	
;;;5156   	/* Write a new object header.
;;;5157   	 * show we've shrunk the file, if need be
;;;5158   	 * Do this only if the file is not in the deleted directories.
;;;5159   	 */
;;;5160   	if (in->parent &&
;;;5161   	    in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
;;;5162   	    in->parent->objectId != YAFFS_OBJECTID_DELETED) {
;;;5163   		yaffs_UpdateObjectHeader(in, NULL, 0,
;;;5164   					 (newSize < oldFileSize) ? 1 : 0, 0);
;;;5165   	}
;;;5166   
;;;5167   	return YAFFS_OK;
;;;5168   }
002d76  e8bd83fe          POP      {r1-r9,pc}
                  |L1.11642|
002d7a  42b5              CMP      r5,r6                 ;5120
002d7c  d101              BNE      |L1.11650|
002d7e  2001              MOVS     r0,#1                 ;5121
002d80  e7f9              B        |L1.11638|
                  |L1.11650|
002d82  42b5              CMP      r5,r6                 ;5124
002d84  d230              BCS      |L1.11752|
002d86  4629              MOV      r1,r5                 ;5126
002d88  4620              MOV      r0,r4                 ;5126
002d8a  f7fffffe          BL       yaffs_PruneResizedChunks
002d8e  9802              LDR      r0,[sp,#8]            ;5128
002d90  b318              CBZ      r0,|L1.11738|
002d92  9801              LDR      r0,[sp,#4]            ;5129
002d94  f1000901          ADD      r9,r0,#1              ;5129
002d98  f241410b          MOV      r1,#0x140b            ;5131
002d9c  4640              MOV      r0,r8                 ;5131
002d9e  f7fffffe          BL       yaffs_GetTempBuffer
002da2  4607              MOV      r7,r0                 ;5131
002da4  463a              MOV      r2,r7                 ;5134
002da6  4649              MOV      r1,r9                 ;5134
002da8  4620              MOV      r0,r4                 ;5134
002daa  f7fffffe          BL       yaffs_ReadChunkDataFromObject
002dae  f8d8200c          LDR      r2,[r8,#0xc]          ;5137
002db2  9b02              LDR      r3,[sp,#8]            ;5137
002db4  1ad1              SUBS     r1,r2,r3              ;5137
002db6  18f8              ADDS     r0,r7,r3              ;5137
002db8  f7fffffe          BL       __aeabi_memclr
002dbc  2001              MOVS     r0,#1                 ;5140
002dbe  9000              STR      r0,[sp,#0]            ;5140
002dc0  463a              MOV      r2,r7                 ;5140
002dc2  4649              MOV      r1,r9                 ;5140
002dc4  4620              MOV      r0,r4                 ;5140
002dc6  9b02              LDR      r3,[sp,#8]            ;5140
002dc8  f7fffffe          BL       yaffs_WriteChunkDataToObject
002dcc  f2414217          MOV      r2,#0x1417            ;5143
002dd0  4639              MOV      r1,r7                 ;5143
002dd2  4640              MOV      r0,r8                 ;5143
002dd4  f7fffffe          BL       yaffs_ReleaseTempBuffer
002dd8  bf00              NOP                            ;5144
                  |L1.11738|
002dda  65a5              STR      r5,[r4,#0x58]         ;5146
002ddc  f1040158          ADD      r1,r4,#0x58           ;5148
002de0  4640              MOV      r0,r8                 ;5148
002de2  f7fffffe          BL       yaffs_PruneFileStructure
002de6  e000              B        |L1.11754|
                  |L1.11752|
002de8  65a5              STR      r5,[r4,#0x58]         ;5151
                  |L1.11754|
002dea  69e0              LDR      r0,[r4,#0x1c]         ;5160
002dec  b1a0              CBZ      r0,|L1.11800|
002dee  69e0              LDR      r0,[r4,#0x1c]         ;5161
002df0  6b00              LDR      r0,[r0,#0x30]         ;5161
002df2  2803              CMP      r0,#3                 ;5161
002df4  d010              BEQ      |L1.11800|
002df6  69e0              LDR      r0,[r4,#0x1c]         ;5162
002df8  6b00              LDR      r0,[r0,#0x30]         ;5162
002dfa  2804              CMP      r0,#4                 ;5162
002dfc  d00c              BEQ      |L1.11800|
002dfe  2000              MOVS     r0,#0                 ;5163
002e00  9000              STR      r0,[sp,#0]            ;5163
002e02  42b5              CMP      r5,r6                 ;5163
002e04  d201              BCS      |L1.11786|
002e06  2001              MOVS     r0,#1                 ;5164
002e08  e000              B        |L1.11788|
                  |L1.11786|
002e0a  2000              MOVS     r0,#0                 ;5164
                  |L1.11788|
002e0c  4603              MOV      r3,r0                 ;5164
002e0e  2200              MOVS     r2,#0                 ;5164
002e10  4611              MOV      r1,r2                 ;5164
002e12  4620              MOV      r0,r4                 ;5164
002e14  f7fffffe          BL       yaffs_UpdateObjectHeader
                  |L1.11800|
002e18  2001              MOVS     r0,#1                 ;5167
002e1a  e7ac              B        |L1.11638|
;;;5169   
                          ENDP

                  yaffs_UnlinkFile PROC
;;;5236    */
;;;5237   static int yaffs_UnlinkFile(yaffs_Object * in)
002e1c  b5f8              PUSH     {r3-r7,lr}
;;;5238   {
002e1e  4604              MOV      r4,r0
;;;5239   
;;;5240   	int retVal;
;;;5241   	int immediateDeletion = 0;
002e20  2600              MOVS     r6,#0
;;;5242   
;;;5243   #ifdef __KERNEL__
;;;5244   	if (!in->myInode) {
;;;5245   		immediateDeletion = 1;
;;;5246   	}
;;;5247   #else
;;;5248   	if (in->inUse <= 0) {
002e22  6ba0              LDR      r0,[r4,#0x38]
002e24  b900              CBNZ     r0,|L1.11816|
;;;5249   		immediateDeletion = 1;
002e26  2601              MOVS     r6,#1
                  |L1.11816|
;;;5250   	}
;;;5251   #endif
;;;5252   
;;;5253   	if (immediateDeletion) {
002e28  b30e              CBZ      r6,|L1.11886|
;;;5254   		retVal =
002e2a  2000              MOVS     r0,#0
002e2c  9000              STR      r0,[sp,#0]
002e2e  68a0              LDR      r0,[r4,#8]
002e30  2300              MOVS     r3,#0
002e32  f2af5244          ADR      r2,|L1.10480|
002e36  f8d01da4          LDR      r1,[r0,#0xda4]
002e3a  4620              MOV      r0,r4
002e3c  f7fffffe          BL       yaffs_ChangeObjectName
002e40  4605              MOV      r5,r0
;;;5255   		    yaffs_ChangeObjectName(in, in->myDev->deletedDir,
;;;5256   					   _Y("deleted"), 0, 0);
;;;5257   		T(YAFFS_TRACE_TRACING,
002e42  bf00              NOP      
002e44  bf00              NOP      
;;;5258   		  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
;;;5259   		   in->objectId));
;;;5260   		in->deleted = 1;
002e46  7820              LDRB     r0,[r4,#0]
002e48  f0200001          BIC      r0,r0,#1
002e4c  1c40              ADDS     r0,r0,#1
002e4e  7020              STRB     r0,[r4,#0]
;;;5261   		in->myDev->nDeletedFiles++;
002e50  68a0              LDR      r0,[r4,#8]
002e52  f8d00dac          LDR      r0,[r0,#0xdac]
002e56  1c40              ADDS     r0,r0,#1
002e58  68a1              LDR      r1,[r4,#8]
002e5a  f8c10dac          STR      r0,[r1,#0xdac]
;;;5262   		if (1 || in->myDev->isYaffs2) {
;;;5263   			yaffs_ResizeFile(in, 0);
002e5e  2100              MOVS     r1,#0
002e60  4620              MOV      r0,r4
002e62  f7fffffe          BL       yaffs_ResizeFile
;;;5264   		}
;;;5265   		yaffs_SoftDeleteFile(in);
002e66  4620              MOV      r0,r4
002e68  f7fffffe          BL       yaffs_SoftDeleteFile
002e6c  e00a              B        |L1.11908|
                  |L1.11886|
;;;5266   	} else {
;;;5267   		retVal =
002e6e  2000              MOVS     r0,#0
002e70  9000              STR      r0,[sp,#0]
002e72  68a0              LDR      r0,[r4,#8]
002e74  2300              MOVS     r3,#0
002e76  a2fb              ADR      r2,|L1.12900|
002e78  f8d01da0          LDR      r1,[r0,#0xda0]
002e7c  4620              MOV      r0,r4
002e7e  f7fffffe          BL       yaffs_ChangeObjectName
002e82  4605              MOV      r5,r0
                  |L1.11908|
;;;5268   		    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,
;;;5269   					   _Y("unlinked"), 0, 0);
;;;5270   	}
;;;5271   
;;;5272   
;;;5273   	return retVal;
002e84  4628              MOV      r0,r5
;;;5274   }
002e86  bdf8              POP      {r3-r7,pc}
;;;5275   
                          ENDP

                  yaffs_DeleteFile PROC
;;;5276   int yaffs_DeleteFile(yaffs_Object * in)
002e88  b570              PUSH     {r4-r6,lr}
;;;5277   {
002e8a  4604              MOV      r4,r0
;;;5278   	int retVal = YAFFS_OK;
002e8c  2601              MOVS     r6,#1
;;;5279   	int deleted = in->deleted;
002e8e  7820              LDRB     r0,[r4,#0]
002e90  f0000501          AND      r5,r0,#1
;;;5280   	
;;;5281   	yaffs_ResizeFile(in,0);
002e94  2100              MOVS     r1,#0
002e96  4620              MOV      r0,r4
002e98  f7fffffe          BL       yaffs_ResizeFile
;;;5282   
;;;5283   	if (in->nDataChunks > 0) {
002e9c  6ae0              LDR      r0,[r4,#0x2c]
002e9e  2800              CMP      r0,#0
002ea0  dd26              BLE      |L1.12016|
;;;5284   		/* Use soft deletion if there is data in the file.
;;;5285   		 * That won't be the case if it has been resized to zero.
;;;5286   		 */
;;;5287   		if (!in->unlinked) {
002ea2  7820              LDRB     r0,[r4,#0]
002ea4  f3c00080          UBFX     r0,r0,#2,#1
002ea8  b918              CBNZ     r0,|L1.11954|
;;;5288   			retVal = yaffs_UnlinkFile(in);
002eaa  4620              MOV      r0,r4
002eac  f7fffffe          BL       yaffs_UnlinkFile
002eb0  4606              MOV      r6,r0
                  |L1.11954|
;;;5289   		}
;;;5290   		if (retVal == YAFFS_OK && in->unlinked && !in->deleted) {
002eb2  2e01              CMP      r6,#1
002eb4  d117              BNE      |L1.12006|
002eb6  7820              LDRB     r0,[r4,#0]
002eb8  f3c00080          UBFX     r0,r0,#2,#1
002ebc  b198              CBZ      r0,|L1.12006|
002ebe  7820              LDRB     r0,[r4,#0]
002ec0  f0000001          AND      r0,r0,#1
002ec4  b978              CBNZ     r0,|L1.12006|
;;;5291   			in->deleted = deleted = 1;
002ec6  2001              MOVS     r0,#1
002ec8  4605              MOV      r5,r0
002eca  7820              LDRB     r0,[r4,#0]
002ecc  f3650000          BFI      r0,r5,#0,#1
002ed0  7020              STRB     r0,[r4,#0]
;;;5292   			in->myDev->nDeletedFiles++;
002ed2  68a0              LDR      r0,[r4,#8]
002ed4  f8d00dac          LDR      r0,[r0,#0xdac]
002ed8  1c40              ADDS     r0,r0,#1
002eda  68a1              LDR      r1,[r4,#8]
002edc  f8c10dac          STR      r0,[r1,#0xdac]
;;;5293   			yaffs_SoftDeleteFile(in);
002ee0  4620              MOV      r0,r4
002ee2  f7fffffe          BL       yaffs_SoftDeleteFile
                  |L1.12006|
;;;5294   		}
;;;5295   		return deleted ? YAFFS_OK : YAFFS_FAIL;
002ee6  b10d              CBZ      r5,|L1.12012|
002ee8  2001              MOVS     r0,#1
                  |L1.12010|
;;;5296   	} else {
;;;5297   		/* The file has no data chunks so we toss it immediately */
;;;5298   		yaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);
;;;5299   		in->variant.fileVariant.top = NULL;
;;;5300   		yaffs_DoGenericObjectDeletion(in);
;;;5301   
;;;5302   		return YAFFS_OK;
;;;5303   	}
;;;5304   }
002eea  bd70              POP      {r4-r6,pc}
                  |L1.12012|
002eec  2000              MOVS     r0,#0                 ;5295
002eee  e7fc              B        |L1.12010|
                  |L1.12016|
002ef0  6ea1              LDR      r1,[r4,#0x68]         ;5298
002ef2  68a0              LDR      r0,[r4,#8]            ;5298
002ef4  f7fffffe          BL       yaffs_FreeTnode
002ef8  2100              MOVS     r1,#0                 ;5299
002efa  66a1              STR      r1,[r4,#0x68]         ;5299
002efc  4620              MOV      r0,r4                 ;5300
002efe  f7fffffe          BL       yaffs_DoGenericObjectDeletion
002f02  2001              MOVS     r0,#1                 ;5302
002f04  e7f1              B        |L1.12010|
;;;5305   
                          ENDP

                  yaffs_DestroyObject PROC
;;;5332   
;;;5333   static void yaffs_DestroyObject(yaffs_Object * obj)
002f06  b510              PUSH     {r4,lr}
;;;5334   {
002f08  4604              MOV      r4,r0
;;;5335   	switch (obj->variantType) {
002f0a  f8940054          LDRB     r0,[r4,#0x54]
002f0e  2806              CMP      r0,#6
002f10  d219              BCS      |L1.12102|
002f12  e8dff000          TBB      [pc,r0]
002f16  1703              DCB      0x17,0x03
002f18  0b070f13          DCB      0x0b,0x07,0x0f,0x13
;;;5336   	case YAFFS_OBJECT_TYPE_FILE:
;;;5337   		yaffs_DeleteFile(obj);
002f1c  4620              MOV      r0,r4
002f1e  f7fffffe          BL       yaffs_DeleteFile
;;;5338   		break;
002f22  e010              B        |L1.12102|
;;;5339   	case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;5340   		yaffs_DeleteDirectory(obj);
002f24  4620              MOV      r0,r4
002f26  f7fffffe          BL       yaffs_DeleteDirectory
;;;5341   		break;
002f2a  e00c              B        |L1.12102|
;;;5342   	case YAFFS_OBJECT_TYPE_SYMLINK:
;;;5343   		yaffs_DeleteSymLink(obj);
002f2c  4620              MOV      r0,r4
002f2e  f7fffffe          BL       yaffs_DeleteSymLink
;;;5344   		break;
002f32  e008              B        |L1.12102|
;;;5345   	case YAFFS_OBJECT_TYPE_HARDLINK:
;;;5346   		yaffs_DeleteHardLink(obj);
002f34  4620              MOV      r0,r4
002f36  f7fffffe          BL       yaffs_DeleteHardLink
;;;5347   		break;
002f3a  e004              B        |L1.12102|
;;;5348   	case YAFFS_OBJECT_TYPE_SPECIAL:
;;;5349   		yaffs_DoGenericObjectDeletion(obj);
002f3c  4620              MOV      r0,r4
002f3e  f7fffffe          BL       yaffs_DoGenericObjectDeletion
;;;5350   		break;
002f42  e000              B        |L1.12102|
;;;5351   	case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;5352   		break;		/* should not happen. */
002f44  bf00              NOP      
                  |L1.12102|
002f46  bf00              NOP                            ;5338
;;;5353   	}
;;;5354   }
002f48  bd10              POP      {r4,pc}
;;;5355   
                          ENDP

                  yaffs_MknodObject PROC
;;;2326    
;;;2327   static yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,
002f4a  e92d5ffc          PUSH     {r2-r12,lr}
;;;2328   				       yaffs_Object * parent,
;;;2329   				       const YCHAR * name,
;;;2330   				       __u32 mode,
;;;2331   				       __u32 uid,
;;;2332   				       __u32 gid,
;;;2333   				       yaffs_Object * equivalentObject,
;;;2334   				       const YCHAR * aliasString, __u32 rdev)
;;;2335   {
002f4e  4605              MOV      r5,r0
002f50  460e              MOV      r6,r1
002f52  4690              MOV      r8,r2
002f54  4699              MOV      r9,r3
002f56  f8ddb030          LDR      r11,[sp,#0x30]
002f5a  9f0e              LDR      r7,[sp,#0x38]
;;;2336   	yaffs_Object *in;
;;;2337   	YCHAR *str = NULL;
002f5c  f04f0a00          MOV      r10,#0
;;;2338   
;;;2339   	yaffs_Device *dev = parent->myDev;
002f60  68b0              LDR      r0,[r6,#8]
002f62  9001              STR      r0,[sp,#4]
;;;2340    
;;;2341   	/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/
;;;2342   	if (yaffs_FindObjectByName(parent, name)) {
002f64  4641              MOV      r1,r8
002f66  4630              MOV      r0,r6
002f68  f7fffffe          BL       yaffs_FindObjectByName
002f6c  b110              CBZ      r0,|L1.12148|
;;;2343   		return NULL;
002f6e  2000              MOVS     r0,#0
                  |L1.12144|
;;;2344   	}
;;;2345   
;;;2346   	in = yaffs_CreateNewObject(dev, -1, type);
;;;2347   
;;;2348   	if(!in)
;;;2349   		return YAFFS_FAIL;
;;;2350   	 
;;;2351   	if(type == YAFFS_OBJECT_TYPE_SYMLINK)
;;;2352   	{
;;;2353   		str = yaffs_CloneString(aliasString);
;;;2354   	 
;;;2355   		if(!str)
;;;2356   		{
;;;2357   			yaffs_FreeObject(in);
;;;2358   			return NULL;
;;;2359   		}
;;;2360   	}
;;;2361    
;;;2362   	
;;;2363   
;;;2364   	if (in) {
;;;2365   		in->hdrChunk = 0;
;;;2366   		in->valid = 1;
;;;2367   		in->variantType = type;
;;;2368   
;;;2369   		in->yst_mode = mode;
;;;2370   
;;;2371   #ifdef CONFIG_YAFFS_WINCE
;;;2372   		yfsd_WinFileTimeNow(in->win_atime);
;;;2373   		in->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];
;;;2374   		in->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];
;;;2375   
;;;2376   #else
;;;2377   		in->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;
;;;2378   
;;;2379   		in->yst_rdev = rdev;
;;;2380   		in->yst_uid = uid;
;;;2381   		in->yst_gid = gid;
;;;2382   #endif
;;;2383   		in->nDataChunks = 0;
;;;2384   
;;;2385   		yaffs_SetObjectName(in, name);
;;;2386   		in->dirty = 1;
;;;2387   
;;;2388   		yaffs_AddObjectToDirectory(parent, in);
;;;2389   
;;;2390   		in->myDev = parent->myDev;
;;;2391    
;;;2392   		switch (type) {
;;;2393   		case YAFFS_OBJECT_TYPE_SYMLINK:
;;;2394   			in->variant.symLinkVariant.alias = str;
;;;2395   			break;
;;;2396   		case YAFFS_OBJECT_TYPE_HARDLINK:
;;;2397   			in->variant.hardLinkVariant.equivalentObject =
;;;2398                               equivalentObject;
;;;2399                           in->variant.hardLinkVariant.equivalentObjectId =
;;;2400                               equivalentObject->objectId;
;;;2401                           ylist_add(&in->hardLinks, &equivalentObject->hardLinks);
;;;2402                           break;
;;;2403                   case YAFFS_OBJECT_TYPE_FILE:    
;;;2404                   case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;2405   		case YAFFS_OBJECT_TYPE_SPECIAL:
;;;2406   		case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;2407   			/* do nothing */
;;;2408   			break;
;;;2409   		}
;;;2410    
;;;2411   		if (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {
;;;2412   			/* Could not create the object header, fail the creation */
;;;2413    
;;;2414   			yaffs_DestroyObject(in);
;;;2415   			in = NULL;
;;;2416   		}
;;;2417   
;;;2418   	}
;;;2419   
;;;2420   	return in;
;;;2421   }
002f70  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.12148|
002f74  462a              MOV      r2,r5                 ;2346
002f76  f04f31ff          MOV      r1,#0xffffffff        ;2346
002f7a  9801              LDR      r0,[sp,#4]            ;2346
002f7c  f7fffffe          BL       yaffs_CreateNewObject
002f80  4604              MOV      r4,r0                 ;2346
002f82  b90c              CBNZ     r4,|L1.12168|
002f84  2000              MOVS     r0,#0                 ;2349
002f86  e7f3              B        |L1.12144|
                  |L1.12168|
002f88  2d02              CMP      r5,#2                 ;2351
002f8a  d10b              BNE      |L1.12196|
002f8c  980f              LDR      r0,[sp,#0x3c]         ;2353
002f8e  f7fffffe          BL       yaffs_CloneString
002f92  4682              MOV      r10,r0                ;2353
002f94  f1ba0f00          CMP      r10,#0                ;2355
002f98  d104              BNE      |L1.12196|
002f9a  4620              MOV      r0,r4                 ;2357
002f9c  f7fffffe          BL       yaffs_FreeObject
002fa0  2000              MOVS     r0,#0                 ;2358
002fa2  e7e5              B        |L1.12144|
                  |L1.12196|
002fa4  2c00              CMP      r4,#0                 ;2364
002fa6  d04d              BEQ      |L1.12356|
002fa8  2000              MOVS     r0,#0                 ;2365
002faa  62a0              STR      r0,[r4,#0x28]         ;2365
002fac  7820              LDRB     r0,[r4,#0]            ;2366
002fae  f0200080          BIC      r0,r0,#0x80           ;2366
002fb2  3080              ADDS     r0,r0,#0x80           ;2366
002fb4  7020              STRB     r0,[r4,#0]            ;2366
002fb6  f8845054          STRB     r5,[r4,#0x54]         ;2367
002fba  f8c49034          STR      r9,[r4,#0x34]         ;2369
002fbe  f7fffffe          BL       yaffsfs_CurrentTime
002fc2  64e0              STR      r0,[r4,#0x4c]         ;2377
002fc4  64a0              STR      r0,[r4,#0x48]         ;2377
002fc6  6460              STR      r0,[r4,#0x44]         ;2377
002fc8  9810              LDR      r0,[sp,#0x40]         ;2379
002fca  6520              STR      r0,[r4,#0x50]         ;2379
002fcc  f8c4b03c          STR      r11,[r4,#0x3c]        ;2380
002fd0  980d              LDR      r0,[sp,#0x34]         ;2381
002fd2  6420              STR      r0,[r4,#0x40]         ;2381
002fd4  2000              MOVS     r0,#0                 ;2383
002fd6  62e0              STR      r0,[r4,#0x2c]         ;2383
002fd8  4641              MOV      r1,r8                 ;2385
002fda  4620              MOV      r0,r4                 ;2385
002fdc  f7fffffe          BL       yaffs_SetObjectName
002fe0  7820              LDRB     r0,[r4,#0]            ;2386
002fe2  f0200040          BIC      r0,r0,#0x40           ;2386
002fe6  3040              ADDS     r0,r0,#0x40           ;2386
002fe8  7020              STRB     r0,[r4,#0]            ;2386
002fea  4621              MOV      r1,r4                 ;2388
002fec  4630              MOV      r0,r6                 ;2388
002fee  f7fffffe          BL       yaffs_AddObjectToDirectory
002ff2  68b0              LDR      r0,[r6,#8]            ;2390
002ff4  60a0              STR      r0,[r4,#8]            ;2390
002ff6  2d06              CMP      r5,#6                 ;2392
002ff8  d215              BCS      |L1.12326|
002ffa  e8dff005          TBB      [pc,r5]               ;2392
002ffe  1310              DCB      0x13,0x10
003000  03110612          DCB      0x03,0x11,0x06,0x12
003004  f8c4a058          STR      r10,[r4,#0x58]        ;2394
003008  e00d              B        |L1.12326|
00300a  65a7              STR      r7,[r4,#0x58]         ;2397
00300c  6b39              LDR      r1,[r7,#0x30]         ;2399
00300e  65e1              STR      r1,[r4,#0x5c]         ;2399
003010  f1070114          ADD      r1,r7,#0x14           ;2401
003014  f1040014          ADD      r0,r4,#0x14           ;2401
003018  f7fffffe          BL       ylist_add
00301c  e003              B        |L1.12326|
00301e  bf00              NOP                            ;2404
003020  bf00              NOP                            ;2405
003022  bf00              NOP                            ;2406
003024  bf00              NOP                            ;2408
                  |L1.12326|
003026  bf00              NOP                            ;2395
003028  2000              MOVS     r0,#0                 ;2411
00302a  4603              MOV      r3,r0                 ;2411
00302c  4602              MOV      r2,r0                 ;2411
00302e  4641              MOV      r1,r8                 ;2411
003030  9000              STR      r0,[sp,#0]            ;2411
003032  4620              MOV      r0,r4                 ;2411
003034  f7fffffe          BL       yaffs_UpdateObjectHeader
003038  2800              CMP      r0,#0                 ;2411
00303a  da03              BGE      |L1.12356|
00303c  4620              MOV      r0,r4                 ;2414
00303e  f7fffffe          BL       yaffs_DestroyObject
003042  2400              MOVS     r4,#0                 ;2415
                  |L1.12356|
003044  4620              MOV      r0,r4                 ;2420
003046  e793              B        |L1.12144|
;;;2422   
                          ENDP

                  yaffs_MknodFile PROC
;;;2423   yaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,
003048  e92d41f0          PUSH     {r4-r8,lr}
;;;2424   			      __u32 mode, __u32 uid, __u32 gid)
;;;2425   {
00304c  b086              SUB      sp,sp,#0x18
00304e  4604              MOV      r4,r0
003050  460d              MOV      r5,r1
003052  4616              MOV      r6,r2
003054  461f              MOV      r7,r3
003056  f8dd8030          LDR      r8,[sp,#0x30]
;;;2426   	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
00305a  2000              MOVS     r0,#0
00305c  e9cd8001          STRD     r8,r0,[sp,#4]
003060  9003              STR      r0,[sp,#0xc]
003062  4633              MOV      r3,r6
003064  462a              MOV      r2,r5
003066  4621              MOV      r1,r4
003068  9700              STR      r7,[sp,#0]
00306a  9004              STR      r0,[sp,#0x10]
00306c  2001              MOVS     r0,#1
00306e  f7fffffe          BL       yaffs_MknodObject
;;;2427   				 uid, gid, NULL, NULL, 0);
;;;2428   }
003072  b006              ADD      sp,sp,#0x18
003074  e8bd81f0          POP      {r4-r8,pc}
;;;2429   
                          ENDP

                  yaffs_MknodDirectory PROC
;;;2430   yaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,
003078  e92d41f0          PUSH     {r4-r8,lr}
;;;2431   				   __u32 mode, __u32 uid, __u32 gid)
;;;2432   {
00307c  b086              SUB      sp,sp,#0x18
00307e  4604              MOV      r4,r0
003080  460d              MOV      r5,r1
003082  4616              MOV      r6,r2
003084  461f              MOV      r7,r3
003086  f8dd8030          LDR      r8,[sp,#0x30]
;;;2433   	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
00308a  2000              MOVS     r0,#0
00308c  e9cd8001          STRD     r8,r0,[sp,#4]
003090  9003              STR      r0,[sp,#0xc]
003092  4633              MOV      r3,r6
003094  462a              MOV      r2,r5
003096  4621              MOV      r1,r4
003098  9700              STR      r7,[sp,#0]
00309a  9004              STR      r0,[sp,#0x10]
00309c  2003              MOVS     r0,#3
00309e  f7fffffe          BL       yaffs_MknodObject
;;;2434   				 mode, uid, gid, NULL, NULL, 0);
;;;2435   }
0030a2  b006              ADD      sp,sp,#0x18
0030a4  e8bd81f0          POP      {r4-r8,pc}
;;;2436   
                          ENDP

                  yaffs_GetEquivalentObject PROC
;;;6985   
;;;6986   yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj)
0030a8  b510              PUSH     {r4,lr}
;;;6987   {
0030aa  4604              MOV      r4,r0
;;;6988   	if (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
0030ac  b13c              CBZ      r4,|L1.12478|
0030ae  f8940054          LDRB     r0,[r4,#0x54]
0030b2  2804              CMP      r0,#4
0030b4  d103              BNE      |L1.12478|
;;;6989   		/* We want the object id of the equivalent object, not this one */
;;;6990   		obj = obj->variant.hardLinkVariant.equivalentObject;
0030b6  6da4              LDR      r4,[r4,#0x58]
;;;6991   		yaffs_CheckObjectDetailsLoaded(obj);
0030b8  4620              MOV      r0,r4
0030ba  f7fffffe          BL       yaffs_CheckObjectDetailsLoaded
                  |L1.12478|
;;;6992   	}
;;;6993   	return obj;
0030be  4620              MOV      r0,r4
;;;6994   
;;;6995   }
0030c0  bd10              POP      {r4,pc}
;;;6996   
                          ENDP

                  yaffs_UnlinkWorker PROC
;;;5355   
;;;5356   static int yaffs_UnlinkWorker(yaffs_Object * obj)
0030c2  b570              PUSH     {r4-r6,lr}
;;;5357   {
0030c4  b0c2              SUB      sp,sp,#0x108
0030c6  4604              MOV      r4,r0
;;;5358   
;;;5359           if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
0030c8  f8940054          LDRB     r0,[r4,#0x54]
0030cc  2804              CMP      r0,#4
0030ce  d104              BNE      |L1.12506|
;;;5360                   return yaffs_DeleteHardLink(obj);
0030d0  4620              MOV      r0,r4
0030d2  f7fffffe          BL       yaffs_DeleteHardLink
                  |L1.12502|
;;;5361           } else if (!ylist_empty(&obj->hardLinks)) {
;;;5362                   /* Curve ball: We're unlinking an object that has a hardlink.
;;;5363                    *
;;;5364                    * This problem arises because we are not strictly following
;;;5365   		 * The Linux link/inode model.
;;;5366   		 *
;;;5367   		 * We can't really delete the object.
;;;5368   		 * Instead, we do the following:
;;;5369   		 * - Select a hardlink.
;;;5370   		 * - Unhook it from the hard links
;;;5371   		 * - Unhook it from its parent directory (so that the rename can work)
;;;5372   		 * - Rename the object to the hardlink's name.
;;;5373   		 * - Delete the hardlink
;;;5374   		 */
;;;5375   
;;;5376   		yaffs_Object *hl;
;;;5377                   int retVal;
;;;5378                   YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
;;;5379   
;;;5380                   hl = ylist_entry(obj->hardLinks.next, yaffs_Object, hardLinks);
;;;5381   
;;;5382                   ylist_del_init(&hl->hardLinks);
;;;5383                   ylist_del_init(&hl->siblings);
;;;5384   
;;;5385                   yaffs_GetObjectName(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
;;;5386   
;;;5387   		retVal = yaffs_ChangeObjectName(obj, hl->parent, name, 0, 0);
;;;5388   
;;;5389   		if (retVal == YAFFS_OK) {
;;;5390   			retVal = yaffs_DoGenericObjectDeletion(hl);
;;;5391   		}
;;;5392   		return retVal;
;;;5393   
;;;5394   	} else {
;;;5395   		switch (obj->variantType) {
;;;5396   		case YAFFS_OBJECT_TYPE_FILE:
;;;5397   			return yaffs_UnlinkFile(obj);
;;;5398   			break;
;;;5399   		case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;5400   			return yaffs_DeleteDirectory(obj);
;;;5401   			break;
;;;5402   		case YAFFS_OBJECT_TYPE_SYMLINK:
;;;5403   			return yaffs_DeleteSymLink(obj);
;;;5404   			break;
;;;5405   		case YAFFS_OBJECT_TYPE_SPECIAL:
;;;5406   			return yaffs_DoGenericObjectDeletion(obj);
;;;5407   			break;
;;;5408   		case YAFFS_OBJECT_TYPE_HARDLINK:
;;;5409   		case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;5410   		default:
;;;5411   			return YAFFS_FAIL;
;;;5412   		}
;;;5413   	}
;;;5414   }
0030d6  b042              ADD      sp,sp,#0x108
0030d8  bd70              POP      {r4-r6,pc}
                  |L1.12506|
0030da  f1040014          ADD      r0,r4,#0x14           ;5361
0030de  f7fffffe          BL       ylist_empty
0030e2  bb08              CBNZ     r0,|L1.12584|
0030e4  6960              LDR      r0,[r4,#0x14]         ;5380
0030e6  f1a00514          SUB      r5,r0,#0x14           ;5380
0030ea  f1050014          ADD      r0,r5,#0x14           ;5382
0030ee  f7fffffe          BL       ylist_del_init
0030f2  f1050020          ADD      r0,r5,#0x20           ;5383
0030f6  f7fffffe          BL       ylist_del_init
0030fa  f44f7280          MOV      r2,#0x100             ;5385
0030fe  a902              ADD      r1,sp,#8              ;5385
003100  4628              MOV      r0,r5                 ;5385
003102  f7fffffe          BL       yaffs_GetObjectName
003106  2000              MOVS     r0,#0                 ;5387
003108  9000              STR      r0,[sp,#0]            ;5387
00310a  4603              MOV      r3,r0                 ;5387
00310c  aa02              ADD      r2,sp,#8              ;5387
00310e  4620              MOV      r0,r4                 ;5387
003110  69e9              LDR      r1,[r5,#0x1c]         ;5387
003112  f7fffffe          BL       yaffs_ChangeObjectName
003116  4606              MOV      r6,r0                 ;5387
003118  2e01              CMP      r6,#1                 ;5389
00311a  d103              BNE      |L1.12580|
00311c  4628              MOV      r0,r5                 ;5390
00311e  f7fffffe          BL       yaffs_DoGenericObjectDeletion
003122  4606              MOV      r6,r0                 ;5390
                  |L1.12580|
003124  4630              MOV      r0,r6                 ;5392
003126  e7d6              B        |L1.12502|
                  |L1.12584|
003128  f8940054          LDRB     r0,[r4,#0x54]         ;5395
00312c  2806              CMP      r0,#6                 ;5395
00312e  d214              BCS      |L1.12634|
003130  e8dff000          TBB      [pc,r0]               ;5395
003134  15030b07          DCB      0x15,0x03,0x0b,0x07
003138  140f              DCB      0x14,0x0f
00313a  4620              MOV      r0,r4                 ;5397
00313c  f7fffffe          BL       yaffs_UnlinkFile
003140  e7c9              B        |L1.12502|
003142  4620              MOV      r0,r4                 ;5400
003144  f7fffffe          BL       yaffs_DeleteDirectory
003148  e7c5              B        |L1.12502|
00314a  4620              MOV      r0,r4                 ;5403
00314c  f7fffffe          BL       yaffs_DeleteSymLink
003150  e7c1              B        |L1.12502|
003152  4620              MOV      r0,r4                 ;5406
003154  f7fffffe          BL       yaffs_DoGenericObjectDeletion
003158  e7bd              B        |L1.12502|
                  |L1.12634|
00315a  bf00              NOP                            ;5408
00315c  bf00              NOP                            ;5409
00315e  2000              MOVS     r0,#0                 ;5411
003160  e7b9              B        |L1.12502|
;;;5415   
                          ENDP

                  yaffs_UnlinkObject PROC
;;;5416   
;;;5417   static int yaffs_UnlinkObject( yaffs_Object *obj)
003162  b510              PUSH     {r4,lr}
;;;5418   {
003164  4604              MOV      r4,r0
;;;5419   
;;;5420   	if (obj && obj->unlinkAllowed) {
003166  b13c              CBZ      r4,|L1.12664|
003168  7820              LDRB     r0,[r4,#0]
00316a  f3c01040          UBFX     r0,r0,#5,#1
00316e  b118              CBZ      r0,|L1.12664|
;;;5421   		return yaffs_UnlinkWorker(obj);
003170  4620              MOV      r0,r4
003172  f7fffffe          BL       yaffs_UnlinkWorker
                  |L1.12662|
;;;5422   	}
;;;5423   
;;;5424   	return YAFFS_FAIL;
;;;5425   
;;;5426   }
003176  bd10              POP      {r4,pc}
                  |L1.12664|
003178  2000              MOVS     r0,#0                 ;5424
00317a  e7fc              B        |L1.12662|
;;;5427   int yaffs_Unlink(yaffs_Object * dir, const YCHAR * name)
                          ENDP

                  yaffs_InitialiseBlocks PROC
;;;2582   
;;;2583   static int yaffs_InitialiseBlocks(yaffs_Device * dev)
00317c  b570              PUSH     {r4-r6,lr}
;;;2584   {
00317e  4604              MOV      r4,r0
;;;2585   	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
003180  349c              ADDS     r4,r4,#0x9c
003182  e9d41000          LDRD     r1,r0,[r4,#0]
003186  1a40              SUBS     r0,r0,r1
003188  1c45              ADDS     r5,r0,#1
;;;2586   
;;;2587       
;;;2588   	dev->blockInfo = NULL;
00318a  2000              MOVS     r0,#0
00318c  64a0              STR      r0,[r4,#0x48]
;;;2589   	dev->chunkBits = NULL;
00318e  64e0              STR      r0,[r4,#0x4c]
;;;2590   	
;;;2591   	dev->allocationBlock = -1;	/* force it to get a new one */
003190  1e40              SUBS     r0,r0,#1
003192  65e0              STR      r0,[r4,#0x5c]
;;;2592   
;;;2593   	/* If the first allocation strategy fails, thry the alternate one */
;;;2594   	dev->blockInfo = YMALLOC(nBlocks * sizeof(yaffs_BlockInfo));
003194  00e8              LSLS     r0,r5,#3
003196  f7fffffe          BL       yaffs_malloc
00319a  64a0              STR      r0,[r4,#0x48]
;;;2595       
;;;2596   	if(!dev->blockInfo){
00319c  6ca0              LDR      r0,[r4,#0x48]
00319e  3c9c              SUBS     r4,r4,#0x9c
0031a0  b958              CBNZ     r0,|L1.12730|
;;;2597   		dev->blockInfo = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockInfo));
0031a2  00e8              LSLS     r0,r5,#3
0031a4  f7fffffe          BL       yaffs_malloc
0031a8  f8440fe4          STR      r0,[r4,#0xe4]!
;;;2598   		dev->blockInfoAlt = 1;
0031ac  68a0              LDR      r0,[r4,#8]
0031ae  f0200001          BIC      r0,r0,#1
0031b2  1c40              ADDS     r0,r0,#1
0031b4  60a0              STR      r0,[r4,#8]
0031b6  3ce4              SUBS     r4,r4,#0xe4
0031b8  e005              B        |L1.12742|
                  |L1.12730|
;;;2599   	}
;;;2600   	else
;;;2601   		dev->blockInfoAlt = 0;
0031ba  f8d400ec          LDR      r0,[r4,#0xec]
0031be  f0200001          BIC      r0,r0,#1
0031c2  f8c400ec          STR      r0,[r4,#0xec]
                  |L1.12742|
;;;2602       
;;;2603   	if(dev->blockInfo){
0031c6  f8d400e4          LDR      r0,[r4,#0xe4]
0031ca  b328              CBZ      r0,|L1.12824|
;;;2604   	    
;;;2605   		/* Set up dynamic blockinfo stuff. */
;;;2606   		dev->chunkBitmapStride = (dev->nChunksPerBlock + 7) / 8; /* round up bytes */
0031cc  3474              ADDS     r4,r4,#0x74
0031ce  f8541c64          LDR      r1,[r4,#-0x64]
0031d2  1dc8              ADDS     r0,r1,#7
0031d4  17c1              ASRS     r1,r0,#31
0031d6  eb007151          ADD      r1,r0,r1,LSR #29
0031da  10c9              ASRS     r1,r1,#3
0031dc  67e1              STR      r1,[r4,#0x7c]
;;;2607   		dev->chunkBits = YMALLOC(dev->chunkBitmapStride * nBlocks);
0031de  6fe1              LDR      r1,[r4,#0x7c]
0031e0  fb01f005          MUL      r0,r1,r5
0031e4  f7fffffe          BL       yaffs_malloc
0031e8  6760              STR      r0,[r4,#0x74]
;;;2608   		if(!dev->chunkBits){
0031ea  6f60              LDR      r0,[r4,#0x74]
0031ec  3c74              SUBS     r4,r4,#0x74
0031ee  b968              CBNZ     r0,|L1.12812|
;;;2609   			dev->chunkBits = YMALLOC_ALT(dev->chunkBitmapStride * nBlocks);
0031f0  34e8              ADDS     r4,r4,#0xe8
0031f2  68a1              LDR      r1,[r4,#8]
0031f4  fb01f005          MUL      r0,r1,r5
0031f8  f7fffffe          BL       yaffs_malloc
0031fc  6020              STR      r0,[r4,#0]
;;;2610   			dev->chunkBitsAlt = 1;
0031fe  6860              LDR      r0,[r4,#4]
003200  f0200002          BIC      r0,r0,#2
003204  1c80              ADDS     r0,r0,#2
003206  6060              STR      r0,[r4,#4]
003208  3ce8              SUBS     r4,r4,#0xe8
00320a  e005              B        |L1.12824|
                  |L1.12812|
;;;2611   		}
;;;2612   		else
;;;2613   			dev->chunkBitsAlt = 0;
00320c  f8d400ec          LDR      r0,[r4,#0xec]
003210  f0200002          BIC      r0,r0,#2
003214  f8c400ec          STR      r0,[r4,#0xec]
                  |L1.12824|
;;;2614   	}
;;;2615   	
;;;2616   	if (dev->blockInfo && dev->chunkBits) {
003218  f8d400e4          LDR      r0,[r4,#0xe4]
00321c  b180              CBZ      r0,|L1.12864|
00321e  f8d400e8          LDR      r0,[r4,#0xe8]
003222  b168              CBZ      r0,|L1.12864|
;;;2617   		memset(dev->blockInfo, 0, nBlocks * sizeof(yaffs_BlockInfo));
003224  00e9              LSLS     r1,r5,#3
003226  f8540fe4          LDR      r0,[r4,#0xe4]!
00322a  f7fffffe          BL       __aeabi_memclr4
;;;2618   		memset(dev->chunkBits, 0, dev->chunkBitmapStride * nBlocks);
00322e  68e2              LDR      r2,[r4,#0xc]
003230  fb02f105          MUL      r1,r2,r5
003234  6860              LDR      r0,[r4,#4]
003236  3ce4              SUBS     r4,r4,#0xe4
003238  f7fffffe          BL       __aeabi_memclr
;;;2619   		return YAFFS_OK;
00323c  2001              MOVS     r0,#1
                  |L1.12862|
;;;2620   	}
;;;2621   
;;;2622       
;;;2623       
;;;2624   	return YAFFS_FAIL;
;;;2625   
;;;2626   }
00323e  bd70              POP      {r4-r6,pc}
                  |L1.12864|
003240  2000              MOVS     r0,#0                 ;2624
003242  e7fc              B        |L1.12862|
;;;2627   
                          ENDP

                  yaffs_DeinitialiseBlocks PROC
;;;2628   static void yaffs_DeinitialiseBlocks(yaffs_Device * dev)
003244  b510              PUSH     {r4,lr}
;;;2629   {
003246  4604              MOV      r4,r0
;;;2630   	if(dev->blockInfoAlt && dev->blockInfo)
003248  f89400ec          LDRB     r0,[r4,#0xec]
00324c  f0000001          AND      r0,r0,#1
003250  b170              CBZ      r0,|L1.12912|
003252  f8d400e4          LDR      r0,[r4,#0xe4]
003256  b158              CBZ      r0,|L1.12912|
;;;2631   		YFREE_ALT(dev->blockInfo);
003258  f8d400e4          LDR      r0,[r4,#0xe4]
00325c  f7fffffe          BL       free
003260  e00d              B        |L1.12926|
003262  0000              DCW      0x0000
                  |L1.12900|
003264  756e6c69          DCB      "unlinked",0
003268  6e6b6564
00326c  00      
00326d  00                DCB      0
00326e  00                DCB      0
00326f  00                DCB      0
                  |L1.12912|
;;;2632   	else if(dev->blockInfo)
003270  f8d400e4          LDR      r0,[r4,#0xe4]
003274  b118              CBZ      r0,|L1.12926|
;;;2633   		YFREE(dev->blockInfo);
003276  f8d400e4          LDR      r0,[r4,#0xe4]
00327a  f7fffffe          BL       free
                  |L1.12926|
;;;2634   
;;;2635   	dev->blockInfoAlt = 0;
00327e  34e4              ADDS     r4,r4,#0xe4
003280  68a0              LDR      r0,[r4,#8]
003282  f0200001          BIC      r0,r0,#1
003286  60a0              STR      r0,[r4,#8]
;;;2636   
;;;2637   	dev->blockInfo = NULL;
003288  2000              MOVS     r0,#0
00328a  6020              STR      r0,[r4,#0]
;;;2638   	
;;;2639   	if(dev->chunkBitsAlt && dev->chunkBits)
00328c  7a20              LDRB     r0,[r4,#8]
00328e  3ce4              SUBS     r4,r4,#0xe4
003290  f3c00040          UBFX     r0,r0,#1,#1
003294  b138              CBZ      r0,|L1.12966|
003296  f8d400e8          LDR      r0,[r4,#0xe8]
00329a  b120              CBZ      r0,|L1.12966|
;;;2640   		YFREE_ALT(dev->chunkBits);
00329c  f8d400e8          LDR      r0,[r4,#0xe8]
0032a0  f7fffffe          BL       free
0032a4  e006              B        |L1.12980|
                  |L1.12966|
;;;2641   	else if(dev->chunkBits)
0032a6  f8d400e8          LDR      r0,[r4,#0xe8]
0032aa  b118              CBZ      r0,|L1.12980|
;;;2642   		YFREE(dev->chunkBits);
0032ac  f8d400e8          LDR      r0,[r4,#0xe8]
0032b0  f7fffffe          BL       free
                  |L1.12980|
;;;2643   	dev->chunkBitsAlt = 0;
0032b4  34e8              ADDS     r4,r4,#0xe8
0032b6  6860              LDR      r0,[r4,#4]
0032b8  f0200002          BIC      r0,r0,#2
0032bc  6060              STR      r0,[r4,#4]
;;;2644   	dev->chunkBits = NULL;
0032be  2000              MOVS     r0,#0
0032c0  f84409e8          STR      r0,[r4],#-0xe8
;;;2645   }
0032c4  bd10              POP      {r4,pc}
;;;2646   
                          ENDP

                  yaffs_GrabChunkCacheWorker PROC
;;;4048    */
;;;4049   static yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device * dev)
0032c6  4601              MOV      r1,r0
;;;4050   {
;;;4051   	int i;
;;;4052   
;;;4053   	if (dev->nShortOpCaches > 0) {
0032c8  6a48              LDR      r0,[r1,#0x24]
0032ca  2800              CMP      r0,#0
0032cc  dd13              BLE      |L1.13046|
;;;4054   		for (i = 0; i < dev->nShortOpCaches; i++) {
0032ce  2200              MOVS     r2,#0
0032d0  e00e              B        |L1.13040|
                  |L1.13010|
;;;4055   			if (!dev->srCache[i].object) 
0032d2  ebc203c2          RSB      r3,r2,r2,LSL #3
0032d6  f8d10d94          LDR      r0,[r1,#0xd94]
0032da  f8500023          LDR      r0,[r0,r3,LSL #2]
0032de  b930              CBNZ     r0,|L1.13038|
;;;4056   				return &dev->srCache[i];
0032e0  ebc203c2          RSB      r3,r2,r2,LSL #3
0032e4  f8d10d94          LDR      r0,[r1,#0xd94]
0032e8  eb000083          ADD      r0,r0,r3,LSL #2
                  |L1.13036|
;;;4057   		}
;;;4058   	}
;;;4059   
;;;4060   	return NULL;
;;;4061   }
0032ec  4770              BX       lr
                  |L1.13038|
0032ee  1c52              ADDS     r2,r2,#1              ;4054
                  |L1.13040|
0032f0  6a48              LDR      r0,[r1,#0x24]         ;4054
0032f2  4290              CMP      r0,r2                 ;4054
0032f4  dced              BGT      |L1.13010|
                  |L1.13046|
0032f6  2000              MOVS     r0,#0                 ;4060
0032f8  e7f8              B        |L1.13036|
;;;4062   
                          ENDP

                  yaffs_GrabChunkCache PROC
;;;4063   static yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device * dev)
0032fa  e92d47f0          PUSH     {r4-r10,lr}
;;;4064   {
0032fe  4605              MOV      r5,r0
;;;4065   	yaffs_ChunkCache *cache;
;;;4066   	yaffs_Object *theObj;
;;;4067   	int usage;
;;;4068   	int i;
;;;4069   	int pushout;
;;;4070   
;;;4071   	if (dev->nShortOpCaches > 0) {
003300  6a68              LDR      r0,[r5,#0x24]
003302  2800              CMP      r0,#0
003304  dd4c              BLE      |L1.13216|
;;;4072   		/* Try find a non-dirty one... */
;;;4073   
;;;4074   		cache = yaffs_GrabChunkCacheWorker(dev);
003306  4628              MOV      r0,r5
003308  f7fffffe          BL       yaffs_GrabChunkCacheWorker
00330c  4606              MOV      r6,r0
;;;4075   
;;;4076   		if (!cache) {
00330e  2e00              CMP      r6,#0
003310  d143              BNE      |L1.13210|
;;;4077   			/* They were all dirty, find the last recently used object and flush
;;;4078   			 * its cache, then  find again.
;;;4079   			 * NB what's here is not very accurate, we actually flush the object
;;;4080   			 * the last recently used page.
;;;4081   			 */
;;;4082   
;;;4083   			/* With locking we can't assume we can use entry zero */
;;;4084   
;;;4085   			theObj = NULL;
003312  2700              MOVS     r7,#0
;;;4086   			usage = -1;
003314  f04f38ff          MOV      r8,#0xffffffff
;;;4087   			cache = NULL;
003318  bf00              NOP      
;;;4088   			pushout = -1;
00331a  f04f39ff          MOV      r9,#0xffffffff
;;;4089   
;;;4090   			for (i = 0; i < dev->nShortOpCaches; i++) {
00331e  2400              MOVS     r4,#0
003320  e02e              B        |L1.13184|
                  |L1.13090|
;;;4091   				if (dev->srCache[i].object &&
003322  ebc401c4          RSB      r1,r4,r4,LSL #3
003326  f8d50d94          LDR      r0,[r5,#0xd94]
00332a  f8500021          LDR      r0,[r0,r1,LSL #2]
00332e  b330              CBZ      r0,|L1.13182|
;;;4092   				    !dev->srCache[i].locked &&
003330  ebc401c4          RSB      r1,r4,r4,LSL #3
003334  f8d50d94          LDR      r0,[r5,#0xd94]
003338  eb000081          ADD      r0,r0,r1,LSL #2
00333c  6940              LDR      r0,[r0,#0x14]
00333e  b9f0              CBNZ     r0,|L1.13182|
;;;4093   				    (dev->srCache[i].lastUse < usage || !cache))
003340  ebc401c4          RSB      r1,r4,r4,LSL #3
003344  f8d50d94          LDR      r0,[r5,#0xd94]
003348  eb000081          ADD      r0,r0,r1,LSL #2
00334c  6880              LDR      r0,[r0,#8]
00334e  4540              CMP      r0,r8
003350  db00              BLT      |L1.13140|
003352  b9a6              CBNZ     r6,|L1.13182|
                  |L1.13140|
;;;4094   				{
;;;4095   					usage = dev->srCache[i].lastUse;
003354  ebc401c4          RSB      r1,r4,r4,LSL #3
003358  f8d50d94          LDR      r0,[r5,#0xd94]
00335c  eb000081          ADD      r0,r0,r1,LSL #2
003360  f8d08008          LDR      r8,[r0,#8]
;;;4096   					theObj = dev->srCache[i].object;
003364  ebc401c4          RSB      r1,r4,r4,LSL #3
003368  f8d50d94          LDR      r0,[r5,#0xd94]
00336c  f8507021          LDR      r7,[r0,r1,LSL #2]
;;;4097   					cache = &dev->srCache[i];
003370  ebc401c4          RSB      r1,r4,r4,LSL #3
003374  f8d50d94          LDR      r0,[r5,#0xd94]
003378  eb000681          ADD      r6,r0,r1,LSL #2
;;;4098   					pushout = i;
00337c  46a1              MOV      r9,r4
                  |L1.13182|
00337e  1c64              ADDS     r4,r4,#1              ;4090
                  |L1.13184|
003380  6a68              LDR      r0,[r5,#0x24]         ;4090
003382  42a0              CMP      r0,r4                 ;4090
003384  dccd              BGT      |L1.13090|
;;;4099   				}
;;;4100   			}
;;;4101   
;;;4102   			if (!cache || cache->dirty) {
003386  b10e              CBZ      r6,|L1.13196|
003388  68f0              LDR      r0,[r6,#0xc]
00338a  b130              CBZ      r0,|L1.13210|
                  |L1.13196|
;;;4103   				/* Flush and try again */
;;;4104   				yaffs_FlushFilesChunkCache(theObj);
00338c  4638              MOV      r0,r7
00338e  f7fffffe          BL       yaffs_FlushFilesChunkCache
;;;4105   				cache = yaffs_GrabChunkCacheWorker(dev);
003392  4628              MOV      r0,r5
003394  f7fffffe          BL       yaffs_GrabChunkCacheWorker
003398  4606              MOV      r6,r0
                  |L1.13210|
;;;4106   			}
;;;4107   
;;;4108   		}
;;;4109   		return cache;
00339a  4630              MOV      r0,r6
                  |L1.13212|
;;;4110   	} else
;;;4111   		return NULL;
;;;4112   
;;;4113   }
00339c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.13216|
0033a0  2000              MOVS     r0,#0                 ;4111
0033a2  e7fb              B        |L1.13212|
;;;4114   
                          ENDP

                  yaffs_FindChunkCache PROC
;;;4115   /* Find a cached chunk */
;;;4116   static yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object * obj,
0033a4  b530              PUSH     {r4,r5,lr}
;;;4117   					      int chunkId)
;;;4118   {
0033a6  4603              MOV      r3,r0
0033a8  460c              MOV      r4,r1
;;;4119   	yaffs_Device *dev = obj->myDev;
0033aa  6899              LDR      r1,[r3,#8]
;;;4120   	int i;
;;;4121   	if (dev->nShortOpCaches > 0) {
0033ac  6a48              LDR      r0,[r1,#0x24]
0033ae  2800              CMP      r0,#0
0033b0  dd22              BLE      |L1.13304|
;;;4122   		for (i = 0; i < dev->nShortOpCaches; i++) {
0033b2  2200              MOVS     r2,#0
0033b4  e01d              B        |L1.13298|
                  |L1.13238|
;;;4123   			if (dev->srCache[i].object == obj &&
0033b6  ebc205c2          RSB      r5,r2,r2,LSL #3
0033ba  f8d10d94          LDR      r0,[r1,#0xd94]
0033be  f8500025          LDR      r0,[r0,r5,LSL #2]
0033c2  4298              CMP      r0,r3
0033c4  d114              BNE      |L1.13296|
;;;4124   			    dev->srCache[i].chunkId == chunkId) {
0033c6  ebc205c2          RSB      r5,r2,r2,LSL #3
0033ca  f8d10d94          LDR      r0,[r1,#0xd94]
0033ce  eb000085          ADD      r0,r0,r5,LSL #2
0033d2  6840              LDR      r0,[r0,#4]
0033d4  42a0              CMP      r0,r4
0033d6  d10b              BNE      |L1.13296|
;;;4125   				dev->cacheHits++;
0033d8  f8d10d9c          LDR      r0,[r1,#0xd9c]
0033dc  1c40              ADDS     r0,r0,#1
0033de  f8c10d9c          STR      r0,[r1,#0xd9c]
;;;4126   
;;;4127   				return &dev->srCache[i];
0033e2  ebc205c2          RSB      r5,r2,r2,LSL #3
0033e6  f8d10d94          LDR      r0,[r1,#0xd94]
0033ea  eb000085          ADD      r0,r0,r5,LSL #2
                  |L1.13294|
;;;4128   			}
;;;4129   		}
;;;4130   	}
;;;4131   	return NULL;
;;;4132   }
0033ee  bd30              POP      {r4,r5,pc}
                  |L1.13296|
0033f0  1c52              ADDS     r2,r2,#1              ;4122
                  |L1.13298|
0033f2  6a48              LDR      r0,[r1,#0x24]         ;4122
0033f4  4290              CMP      r0,r2                 ;4122
0033f6  dcde              BGT      |L1.13238|
                  |L1.13304|
0033f8  2000              MOVS     r0,#0                 ;4131
0033fa  e7f8              B        |L1.13294|
;;;4133   
                          ENDP

                  yaffs_UseChunkCache PROC
;;;4134   /* Mark the chunk for the least recently used algorithym */
;;;4135   static void yaffs_UseChunkCache(yaffs_Device * dev, yaffs_ChunkCache * cache,
0033fc  b570              PUSH     {r4-r6,lr}
;;;4136   				int isAWrite)
;;;4137   {
0033fe  4613              MOV      r3,r2
;;;4138   
;;;4139   	if (dev->nShortOpCaches > 0) {
003400  6a42              LDR      r2,[r0,#0x24]
003402  2a00              CMP      r2,#0
003404  dd25              BLE      |L1.13394|
;;;4140   		if (dev->srLastUse < 0 || dev->srLastUse > 100000000) {
003406  f8d02d98          LDR      r2,[r0,#0xd98]
00340a  2a00              CMP      r2,#0
00340c  db04              BLT      |L1.13336|
00340e  4cfe              LDR      r4,|L1.14344|
003410  f8d02d98          LDR      r2,[r0,#0xd98]
003414  42a2              CMP      r2,r4
003416  dd11              BLE      |L1.13372|
                  |L1.13336|
;;;4141   			/* Reset the cache usages */
;;;4142   			int i;
;;;4143   			for (i = 1; i < dev->nShortOpCaches; i++) {
003418  2201              MOVS     r2,#1
00341a  e008              B        |L1.13358|
                  |L1.13340|
;;;4144   				dev->srCache[i].lastUse = 0;
00341c  2400              MOVS     r4,#0
00341e  ebc206c2          RSB      r6,r2,r2,LSL #3
003422  f8d05d94          LDR      r5,[r0,#0xd94]
003426  eb050586          ADD      r5,r5,r6,LSL #2
00342a  60ac              STR      r4,[r5,#8]
00342c  1c52              ADDS     r2,r2,#1              ;4143
                  |L1.13358|
00342e  6a44              LDR      r4,[r0,#0x24]         ;4143
003430  4294              CMP      r4,r2                 ;4143
003432  dcf3              BGT      |L1.13340|
;;;4145   			}
;;;4146   			dev->srLastUse = 0;
003434  2400              MOVS     r4,#0
003436  f8c04d98          STR      r4,[r0,#0xd98]
;;;4147   		}
00343a  bf00              NOP      
                  |L1.13372|
;;;4148   
;;;4149   		dev->srLastUse++;
00343c  f8d02d98          LDR      r2,[r0,#0xd98]
003440  1c52              ADDS     r2,r2,#1
003442  f8c02d98          STR      r2,[r0,#0xd98]
;;;4150   
;;;4151   		cache->lastUse = dev->srLastUse;
003446  f8d02d98          LDR      r2,[r0,#0xd98]
00344a  608a              STR      r2,[r1,#8]
;;;4152   
;;;4153   		if (isAWrite) {
00344c  b10b              CBZ      r3,|L1.13394|
;;;4154   			cache->dirty = 1;
00344e  2201              MOVS     r2,#1
003450  60ca              STR      r2,[r1,#0xc]
                  |L1.13394|
;;;4155   		}
;;;4156   	}
;;;4157   }
003452  bd70              POP      {r4-r6,pc}
;;;4158   
                          ENDP

                  yaffs_InvalidateChunkCache PROC
;;;4162    */
;;;4163   static void yaffs_InvalidateChunkCache(yaffs_Object * object, int chunkId)
003454  b570              PUSH     {r4-r6,lr}
;;;4164   {
003456  4604              MOV      r4,r0
003458  460e              MOV      r6,r1
;;;4165   	if (object->myDev->nShortOpCaches > 0) {
00345a  68a0              LDR      r0,[r4,#8]
00345c  6a40              LDR      r0,[r0,#0x24]
00345e  2800              CMP      r0,#0
003460  dd08              BLE      |L1.13428|
;;;4166   		yaffs_ChunkCache *cache = yaffs_FindChunkCache(object, chunkId);
003462  4631              MOV      r1,r6
003464  4620              MOV      r0,r4
003466  f7fffffe          BL       yaffs_FindChunkCache
00346a  4605              MOV      r5,r0
;;;4167   
;;;4168   		if (cache) {
00346c  b10d              CBZ      r5,|L1.13426|
;;;4169   			cache->object = NULL;
00346e  2000              MOVS     r0,#0
003470  6028              STR      r0,[r5,#0]
                  |L1.13426|
;;;4170   		}
;;;4171   	}
003472  bf00              NOP      
                  |L1.13428|
;;;4172   }
003474  bd70              POP      {r4-r6,pc}
;;;4173   
                          ENDP

                  yaffs_WriteCheckpointValidityMarker PROC
;;;4194   
;;;4195   static int yaffs_WriteCheckpointValidityMarker(yaffs_Device *dev,int head)
003476  b57f              PUSH     {r0-r6,lr}
;;;4196   {
003478  4605              MOV      r5,r0
00347a  460c              MOV      r4,r1
;;;4197   	yaffs_CheckpointValidity cp;
;;;4198   	
;;;4199   	memset(&cp,0,sizeof(cp));
00347c  2000              MOVS     r0,#0
00347e  9000              STR      r0,[sp,#0]
003480  9001              STR      r0,[sp,#4]
003482  9002              STR      r0,[sp,#8]
003484  9003              STR      r0,[sp,#0xc]
;;;4200   	
;;;4201   	cp.structType = sizeof(cp);
003486  2010              MOVS     r0,#0x10
003488  9000              STR      r0,[sp,#0]
;;;4202   	cp.magic = YAFFS_MAGIC;
00348a  48e0              LDR      r0,|L1.14348|
00348c  9001              STR      r0,[sp,#4]
;;;4203   	cp.version = YAFFS_CHECKPOINT_VERSION;
00348e  2003              MOVS     r0,#3
003490  9002              STR      r0,[sp,#8]
;;;4204   	cp.head = (head) ? 1 : 0;
003492  b10c              CBZ      r4,|L1.13464|
003494  2001              MOVS     r0,#1
003496  e000              B        |L1.13466|
                  |L1.13464|
003498  2000              MOVS     r0,#0
                  |L1.13466|
00349a  9003              STR      r0,[sp,#0xc]
;;;4205   	
;;;4206   	return (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp))?
00349c  2210              MOVS     r2,#0x10
00349e  4669              MOV      r1,sp
0034a0  4628              MOV      r0,r5
0034a2  f7fffffe          BL       yaffs_CheckpointWrite
0034a6  2810              CMP      r0,#0x10
0034a8  d102              BNE      |L1.13488|
;;;4207   		1 : 0;
0034aa  2001              MOVS     r0,#1
                  |L1.13484|
;;;4208   }
0034ac  b004              ADD      sp,sp,#0x10
0034ae  bd70              POP      {r4-r6,pc}
                  |L1.13488|
0034b0  2000              MOVS     r0,#0                 ;4207
0034b2  e7fb              B        |L1.13484|
;;;4209   
                          ENDP

                  yaffs_ReadCheckpointValidityMarker PROC
;;;4210   static int yaffs_ReadCheckpointValidityMarker(yaffs_Device *dev, int head)
0034b4  b57f              PUSH     {r0-r6,lr}
;;;4211   {
0034b6  4606              MOV      r6,r0
0034b8  460c              MOV      r4,r1
;;;4212   	yaffs_CheckpointValidity cp;
;;;4213   	int ok;
;;;4214   
;;;4215       
;;;4216   	ok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));
0034ba  2210              MOVS     r2,#0x10
0034bc  4669              MOV      r1,sp
0034be  4630              MOV      r0,r6
0034c0  f7fffffe          BL       yaffs_CheckpointRead
0034c4  2810              CMP      r0,#0x10
0034c6  d101              BNE      |L1.13516|
0034c8  2001              MOVS     r0,#1
0034ca  e000              B        |L1.13518|
                  |L1.13516|
0034cc  2000              MOVS     r0,#0
                  |L1.13518|
0034ce  4605              MOV      r5,r0
;;;4217       
;;;4218   	if(ok)
0034d0  b1a5              CBZ      r5,|L1.13564|
;;;4219   		ok = (cp.structType == sizeof(cp)) &&
0034d2  9800              LDR      r0,[sp,#0]
0034d4  2810              CMP      r0,#0x10
0034d6  d10f              BNE      |L1.13560|
;;;4220   		     (cp.magic == YAFFS_MAGIC) &&
0034d8  49cc              LDR      r1,|L1.14348|
0034da  9801              LDR      r0,[sp,#4]
0034dc  4288              CMP      r0,r1
0034de  d10b              BNE      |L1.13560|
;;;4221   		     (cp.version == YAFFS_CHECKPOINT_VERSION) &&
0034e0  9802              LDR      r0,[sp,#8]
0034e2  2803              CMP      r0,#3
0034e4  d108              BNE      |L1.13560|
;;;4222   		     (cp.head == ((head) ? 1 : 0));
0034e6  9803              LDR      r0,[sp,#0xc]
0034e8  b10c              CBZ      r4,|L1.13550|
0034ea  2101              MOVS     r1,#1
0034ec  e000              B        |L1.13552|
                  |L1.13550|
0034ee  2100              MOVS     r1,#0
                  |L1.13552|
0034f0  4288              CMP      r0,r1
0034f2  d101              BNE      |L1.13560|
0034f4  2001              MOVS     r0,#1
0034f6  e000              B        |L1.13562|
                  |L1.13560|
0034f8  2000              MOVS     r0,#0
                  |L1.13562|
0034fa  4605              MOV      r5,r0
                  |L1.13564|
;;;4223   	return ok ? 1 : 0;
0034fc  b115              CBZ      r5,|L1.13572|
0034fe  2001              MOVS     r0,#1
                  |L1.13568|
;;;4224   }
003500  b004              ADD      sp,sp,#0x10
003502  bd70              POP      {r4-r6,pc}
                  |L1.13572|
003504  2000              MOVS     r0,#0                 ;4223
003506  e7fb              B        |L1.13568|
;;;4225   
                          ENDP

                  yaffs_DeviceToCheckpointDevice PROC
;;;4226   static void yaffs_DeviceToCheckpointDevice(yaffs_CheckpointDevice *cp, 
003508  f8512ff4          LDR      r2,[r1,#0xf4]!
;;;4227   					   yaffs_Device *dev)
;;;4228   {
;;;4229   	cp->nErasedBlocks = dev->nErasedBlocks;
00350c  6042              STR      r2,[r0,#4]
;;;4230   	cp->allocationBlock = dev->allocationBlock;
00350e  684a              LDR      r2,[r1,#4]
003510  6082              STR      r2,[r0,#8]
;;;4231   	cp->allocationPage = dev->allocationPage;
003512  688a              LDR      r2,[r1,#8]
003514  60c2              STR      r2,[r0,#0xc]
;;;4232   	cp->nFreeChunks = dev->nFreeChunks;
003516  f8d12c40          LDR      r2,[r1,#0xc40]
00351a  6102              STR      r2,[r0,#0x10]
;;;4233   	
;;;4234   	cp->nDeletedFiles = dev->nDeletedFiles;
00351c  f8d12cb8          LDR      r2,[r1,#0xcb8]
003520  6142              STR      r2,[r0,#0x14]
;;;4235   	cp->nUnlinkedFiles = dev->nUnlinkedFiles;
003522  f8d12cbc          LDR      r2,[r1,#0xcbc]
003526  6182              STR      r2,[r0,#0x18]
;;;4236   	cp->nBackgroundDeletions = dev->nBackgroundDeletions;
003528  f8d12cc0          LDR      r2,[r1,#0xcc0]
00352c  61c2              STR      r2,[r0,#0x1c]
;;;4237   	cp->sequenceNumber = dev->sequenceNumber;
00352e  f8d12d1c          LDR      r2,[r1,#0xd1c]
003532  6202              STR      r2,[r0,#0x20]
;;;4238   	cp->oldestDirtySequence = dev->oldestDirtySequence;
003534  f8d12d20          LDR      r2,[r1,#0xd20]
003538  39f4              SUBS     r1,r1,#0xf4
00353a  6242              STR      r2,[r0,#0x24]
;;;4239   	
;;;4240   }
00353c  4770              BX       lr
;;;4241   
                          ENDP

                  yaffs_CheckpointDeviceToDevice PROC
;;;4242   static void yaffs_CheckpointDeviceToDevice(yaffs_Device *dev,
00353e  684a              LDR      r2,[r1,#4]
;;;4243   					   yaffs_CheckpointDevice *cp)
;;;4244   {
;;;4245   	dev->nErasedBlocks = cp->nErasedBlocks;
003540  f8402ff4          STR      r2,[r0,#0xf4]!
;;;4246   	dev->allocationBlock = cp->allocationBlock;
003544  688a              LDR      r2,[r1,#8]
003546  6042              STR      r2,[r0,#4]
;;;4247   	dev->allocationPage = cp->allocationPage;
003548  68ca              LDR      r2,[r1,#0xc]
00354a  6082              STR      r2,[r0,#8]
;;;4248   	dev->nFreeChunks = cp->nFreeChunks;
00354c  690a              LDR      r2,[r1,#0x10]
00354e  f8c02c40          STR      r2,[r0,#0xc40]
;;;4249   	
;;;4250   	dev->nDeletedFiles = cp->nDeletedFiles;
003552  694a              LDR      r2,[r1,#0x14]
003554  f8c02cb8          STR      r2,[r0,#0xcb8]
;;;4251   	dev->nUnlinkedFiles = cp->nUnlinkedFiles;
003558  698a              LDR      r2,[r1,#0x18]
00355a  f8c02cbc          STR      r2,[r0,#0xcbc]
;;;4252   	dev->nBackgroundDeletions = cp->nBackgroundDeletions;
00355e  69ca              LDR      r2,[r1,#0x1c]
003560  f8c02cc0          STR      r2,[r0,#0xcc0]
;;;4253   	dev->sequenceNumber = cp->sequenceNumber;
003564  6a0a              LDR      r2,[r1,#0x20]
003566  f8c02d1c          STR      r2,[r0,#0xd1c]
;;;4254   	dev->oldestDirtySequence = cp->oldestDirtySequence;
00356a  6a4a              LDR      r2,[r1,#0x24]
00356c  f8c02d20          STR      r2,[r0,#0xd20]
003570  38f4              SUBS     r0,r0,#0xf4
;;;4255   }
003572  4770              BX       lr
;;;4256   
                          ENDP

                  yaffs_WriteCheckpointDevice PROC
;;;4257   
;;;4258   static int yaffs_WriteCheckpointDevice(yaffs_Device *dev)
003574  b5f0              PUSH     {r4-r7,lr}
;;;4259   {
003576  b08b              SUB      sp,sp,#0x2c
003578  4604              MOV      r4,r0
;;;4260   	yaffs_CheckpointDevice cp;
;;;4261   	__u32 nBytes;
;;;4262   	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
00357a  e9d41027          LDRD     r1,r0,[r4,#0x9c]
00357e  1a40              SUBS     r0,r0,r1
003580  1c47              ADDS     r7,r0,#1
;;;4263   
;;;4264   	int ok;
;;;4265   		
;;;4266   	/* Write device runtime values*/
;;;4267   	yaffs_DeviceToCheckpointDevice(&cp,dev);
003582  4621              MOV      r1,r4
003584  a801              ADD      r0,sp,#4
003586  f7fffffe          BL       yaffs_DeviceToCheckpointDevice
;;;4268   	cp.structType = sizeof(cp);
00358a  2028              MOVS     r0,#0x28
00358c  9001              STR      r0,[sp,#4]
;;;4269   	
;;;4270   	ok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));
00358e  2228              MOVS     r2,#0x28
003590  a901              ADD      r1,sp,#4
003592  4620              MOV      r0,r4
003594  f7fffffe          BL       yaffs_CheckpointWrite
003598  2828              CMP      r0,#0x28
00359a  d101              BNE      |L1.13728|
00359c  2001              MOVS     r0,#1
00359e  e000              B        |L1.13730|
                  |L1.13728|
0035a0  2000              MOVS     r0,#0
                  |L1.13730|
0035a2  4606              MOV      r6,r0
;;;4271   	
;;;4272   	/* Write block info */
;;;4273   	if(ok) {
0035a4  b166              CBZ      r6,|L1.13760|
;;;4274   		nBytes = nBlocks * sizeof(yaffs_BlockInfo);
0035a6  00fd              LSLS     r5,r7,#3
;;;4275   		ok = (yaffs_CheckpointWrite(dev,dev->blockInfo,nBytes) == nBytes);
0035a8  462a              MOV      r2,r5
0035aa  4620              MOV      r0,r4
0035ac  f8d410e4          LDR      r1,[r4,#0xe4]
0035b0  f7fffffe          BL       yaffs_CheckpointWrite
0035b4  42a8              CMP      r0,r5
0035b6  d101              BNE      |L1.13756|
0035b8  2001              MOVS     r0,#1
0035ba  e000              B        |L1.13758|
                  |L1.13756|
0035bc  2000              MOVS     r0,#0
                  |L1.13758|
0035be  4606              MOV      r6,r0
                  |L1.13760|
;;;4276   	}
;;;4277   		
;;;4278   	/* Write chunk bits */		
;;;4279   	if(ok) {
0035c0  b17e              CBZ      r6,|L1.13794|
;;;4280   		nBytes = nBlocks * dev->chunkBitmapStride;
0035c2  f8d400f0          LDR      r0,[r4,#0xf0]
0035c6  fb00f507          MUL      r5,r0,r7
;;;4281   		ok = (yaffs_CheckpointWrite(dev,dev->chunkBits,nBytes) == nBytes);
0035ca  462a              MOV      r2,r5
0035cc  4620              MOV      r0,r4
0035ce  f8d410e8          LDR      r1,[r4,#0xe8]
0035d2  f7fffffe          BL       yaffs_CheckpointWrite
0035d6  42a8              CMP      r0,r5
0035d8  d101              BNE      |L1.13790|
0035da  2001              MOVS     r0,#1
0035dc  e000              B        |L1.13792|
                  |L1.13790|
0035de  2000              MOVS     r0,#0
                  |L1.13792|
0035e0  4606              MOV      r6,r0
                  |L1.13794|
;;;4282   	}
;;;4283   	return	 ok ? 1 : 0;
0035e2  b116              CBZ      r6,|L1.13802|
0035e4  2001              MOVS     r0,#1
                  |L1.13798|
;;;4284   
;;;4285   }
0035e6  b00b              ADD      sp,sp,#0x2c
0035e8  bdf0              POP      {r4-r7,pc}
                  |L1.13802|
0035ea  2000              MOVS     r0,#0                 ;4283
0035ec  e7fb              B        |L1.13798|
;;;4286   
                          ENDP

                  yaffs_ReadCheckpointDevice PROC
;;;4287   static int yaffs_ReadCheckpointDevice(yaffs_Device *dev)
0035ee  b5f0              PUSH     {r4-r7,lr}
;;;4288   {
0035f0  b08b              SUB      sp,sp,#0x2c
0035f2  4604              MOV      r4,r0
;;;4289   	yaffs_CheckpointDevice cp;
;;;4290   	__u32 nBytes;
;;;4291   	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
0035f4  e9d41027          LDRD     r1,r0,[r4,#0x9c]
0035f8  1a40              SUBS     r0,r0,r1
0035fa  1c47              ADDS     r7,r0,#1
;;;4292   
;;;4293   	int ok;	
;;;4294   	
;;;4295   	ok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));
0035fc  2228              MOVS     r2,#0x28
0035fe  a901              ADD      r1,sp,#4
003600  4620              MOV      r0,r4
003602  f7fffffe          BL       yaffs_CheckpointRead
003606  2828              CMP      r0,#0x28
003608  d101              BNE      |L1.13838|
00360a  2001              MOVS     r0,#1
00360c  e000              B        |L1.13840|
                  |L1.13838|
00360e  2000              MOVS     r0,#0
                  |L1.13840|
003610  4606              MOV      r6,r0
;;;4296   	if(!ok)
003612  b916              CBNZ     r6,|L1.13850|
;;;4297   		return 0;
003614  2000              MOVS     r0,#0
                  |L1.13846|
;;;4298   		
;;;4299   	if(cp.structType != sizeof(cp))
;;;4300   		return 0;
;;;4301   		
;;;4302   	
;;;4303   	yaffs_CheckpointDeviceToDevice(dev,&cp);
;;;4304   	
;;;4305   	nBytes = nBlocks * sizeof(yaffs_BlockInfo);
;;;4306   	
;;;4307   	ok = (yaffs_CheckpointRead(dev,dev->blockInfo,nBytes) == nBytes);
;;;4308   	
;;;4309   	if(!ok)
;;;4310   		return 0;
;;;4311   	nBytes = nBlocks * dev->chunkBitmapStride;
;;;4312   	
;;;4313   	ok = (yaffs_CheckpointRead(dev,dev->chunkBits,nBytes) == nBytes);
;;;4314   	
;;;4315   	return ok ? 1 : 0;
;;;4316   }
003616  b00b              ADD      sp,sp,#0x2c
003618  bdf0              POP      {r4-r7,pc}
                  |L1.13850|
00361a  9801              LDR      r0,[sp,#4]            ;4299
00361c  2828              CMP      r0,#0x28              ;4299
00361e  d001              BEQ      |L1.13860|
003620  2000              MOVS     r0,#0                 ;4300
003622  e7f8              B        |L1.13846|
                  |L1.13860|
003624  a901              ADD      r1,sp,#4              ;4303
003626  4620              MOV      r0,r4                 ;4303
003628  f7fffffe          BL       yaffs_CheckpointDeviceToDevice
00362c  00fd              LSLS     r5,r7,#3              ;4305
00362e  462a              MOV      r2,r5                 ;4307
003630  4620              MOV      r0,r4                 ;4307
003632  f8d410e4          LDR      r1,[r4,#0xe4]         ;4307
003636  f7fffffe          BL       yaffs_CheckpointRead
00363a  42a8              CMP      r0,r5                 ;4307
00363c  d101              BNE      |L1.13890|
00363e  2001              MOVS     r0,#1                 ;4307
003640  e000              B        |L1.13892|
                  |L1.13890|
003642  2000              MOVS     r0,#0                 ;4307
                  |L1.13892|
003644  4606              MOV      r6,r0                 ;4307
003646  b90e              CBNZ     r6,|L1.13900|
003648  2000              MOVS     r0,#0                 ;4310
00364a  e7e4              B        |L1.13846|
                  |L1.13900|
00364c  f8d400f0          LDR      r0,[r4,#0xf0]         ;4311
003650  fb00f507          MUL      r5,r0,r7              ;4311
003654  462a              MOV      r2,r5                 ;4313
003656  4620              MOV      r0,r4                 ;4313
003658  f8d410e8          LDR      r1,[r4,#0xe8]         ;4313
00365c  f7fffffe          BL       yaffs_CheckpointRead
003660  42a8              CMP      r0,r5                 ;4313
003662  d101              BNE      |L1.13928|
003664  2001              MOVS     r0,#1                 ;4313
003666  e000              B        |L1.13930|
                  |L1.13928|
003668  2000              MOVS     r0,#0                 ;4313
                  |L1.13930|
00366a  4606              MOV      r6,r0                 ;4313
00366c  b10e              CBZ      r6,|L1.13938|
00366e  2001              MOVS     r0,#1                 ;4315
003670  e7d1              B        |L1.13846|
                  |L1.13938|
003672  2000              MOVS     r0,#0                 ;4315
003674  e7cf              B        |L1.13846|
;;;4317   
                          ENDP

                  yaffs_ObjectToCheckpointObject PROC
;;;4318   static void yaffs_ObjectToCheckpointObject(yaffs_CheckpointObject *cp,
003676  6b0a              LDR      r2,[r1,#0x30]
;;;4319   					   yaffs_Object *obj)
;;;4320   {
;;;4321   
;;;4322   	cp->objectId = obj->objectId;
003678  6042              STR      r2,[r0,#4]
;;;4323   	cp->parentId = (obj->parent) ? obj->parent->objectId : 0;
00367a  69ca              LDR      r2,[r1,#0x1c]
00367c  b112              CBZ      r2,|L1.13956|
00367e  69ca              LDR      r2,[r1,#0x1c]
003680  6b12              LDR      r2,[r2,#0x30]
003682  e000              B        |L1.13958|
                  |L1.13956|
003684  2200              MOVS     r2,#0
                  |L1.13958|
003686  6082              STR      r2,[r0,#8]
;;;4324   	cp->hdrChunk = obj->hdrChunk;
003688  6a8a              LDR      r2,[r1,#0x28]
00368a  60c2              STR      r2,[r0,#0xc]
;;;4325   	cp->variantType = obj->variantType;
00368c  f8913054          LDRB     r3,[r1,#0x54]
003690  7c02              LDRB     r2,[r0,#0x10]
003692  f3630202          BFI      r2,r3,#0,#3
003696  7402              STRB     r2,[r0,#0x10]
;;;4326   	cp->deleted = obj->deleted;
003698  780a              LDRB     r2,[r1,#0]
00369a  7c03              LDRB     r3,[r0,#0x10]
00369c  f36203c3          BFI      r3,r2,#3,#1
0036a0  7403              STRB     r3,[r0,#0x10]
;;;4327   	cp->softDeleted = obj->softDeleted;
0036a2  780a              LDRB     r2,[r1,#0]
0036a4  0853              LSRS     r3,r2,#1
0036a6  7c02              LDRB     r2,[r0,#0x10]
0036a8  f3631204          BFI      r2,r3,#4,#1
0036ac  7402              STRB     r2,[r0,#0x10]
;;;4328   	cp->unlinked = obj->unlinked;
0036ae  780a              LDRB     r2,[r1,#0]
0036b0  0893              LSRS     r3,r2,#2
0036b2  7c02              LDRB     r2,[r0,#0x10]
0036b4  f3631245          BFI      r2,r3,#5,#1
0036b8  7402              STRB     r2,[r0,#0x10]
;;;4329   	cp->fake = obj->fake;
0036ba  780a              LDRB     r2,[r1,#0]
0036bc  08d3              LSRS     r3,r2,#3
0036be  7c02              LDRB     r2,[r0,#0x10]
0036c0  f3631286          BFI      r2,r3,#6,#1
0036c4  7402              STRB     r2,[r0,#0x10]
;;;4330   	cp->renameAllowed = obj->renameAllowed;
0036c6  780a              LDRB     r2,[r1,#0]
0036c8  0913              LSRS     r3,r2,#4
0036ca  7c02              LDRB     r2,[r0,#0x10]
0036cc  f36312c7          BFI      r2,r3,#7,#1
0036d0  7402              STRB     r2,[r0,#0x10]
;;;4331   	cp->unlinkAllowed = obj->unlinkAllowed;
0036d2  780a              LDRB     r2,[r1,#0]
0036d4  f3c21240          UBFX     r2,r2,#5,#1
0036d8  7442              STRB     r2,[r0,#0x11]
;;;4332   	cp->serial = obj->serial;
0036da  788a              LDRB     r2,[r1,#2]
0036dc  7482              STRB     r2,[r0,#0x12]
;;;4333   	cp->nDataChunks = obj->nDataChunks;
0036de  6aca              LDR      r2,[r1,#0x2c]
0036e0  6142              STR      r2,[r0,#0x14]
;;;4334   	
;;;4335   	if(obj->variantType == YAFFS_OBJECT_TYPE_FILE)
0036e2  f8912054          LDRB     r2,[r1,#0x54]
0036e6  2a01              CMP      r2,#1
0036e8  d102              BNE      |L1.14064|
;;;4336   		cp->fileSizeOrEquivalentObjectId = obj->variant.fileVariant.fileSize;
0036ea  6d8a              LDR      r2,[r1,#0x58]
0036ec  6182              STR      r2,[r0,#0x18]
0036ee  e005              B        |L1.14076|
                  |L1.14064|
;;;4337   	else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
0036f0  f8912054          LDRB     r2,[r1,#0x54]
0036f4  2a04              CMP      r2,#4
0036f6  d101              BNE      |L1.14076|
;;;4338   		cp->fileSizeOrEquivalentObjectId = obj->variant.hardLinkVariant.equivalentObjectId;
0036f8  6dca              LDR      r2,[r1,#0x5c]
0036fa  6182              STR      r2,[r0,#0x18]
                  |L1.14076|
;;;4339   }
0036fc  4770              BX       lr
;;;4340   
                          ENDP

                  yaffs_CheckpointObjectToObject PROC
;;;4341   static int yaffs_CheckpointObjectToObject( yaffs_Object *obj,yaffs_CheckpointObject *cp)
0036fe  b570              PUSH     {r4-r6,lr}
;;;4342   {
003700  4604              MOV      r4,r0
003702  460d              MOV      r5,r1
;;;4343   
;;;4344   	yaffs_Object *parent;
;;;4345   
;;;4346   	if (obj->variantType != cp->variantType) {
003704  f8940054          LDRB     r0,[r4,#0x54]
003708  7c29              LDRB     r1,[r5,#0x10]
00370a  f0010107          AND      r1,r1,#7
00370e  4288              CMP      r0,r1
003710  d003              BEQ      |L1.14106|
;;;4347   		T(YAFFS_TRACE_ERROR,(TSTR("Checkpoint read object %d type %d "
003712  bf00              NOP      
003714  bf00              NOP      
;;;4348   			TCONT("chunk %d does not match existing object type %d")
;;;4349   			TENDSTR), cp->objectId, cp->variantType, cp->hdrChunk,
;;;4350   			obj->variantType));
;;;4351   		return 0;
003716  2000              MOVS     r0,#0
                  |L1.14104|
;;;4352   	}
;;;4353   	
;;;4354   	obj->objectId = cp->objectId;
;;;4355   	
;;;4356   	if(cp->parentId)
;;;4357   		parent = yaffs_FindOrCreateObjectByNumber(
;;;4358   					obj->myDev,
;;;4359   					cp->parentId,
;;;4360   					YAFFS_OBJECT_TYPE_DIRECTORY);
;;;4361   	else
;;;4362   		parent = NULL;
;;;4363   		
;;;4364   	if(parent) {
;;;4365   		if (parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
;;;4366   			T(YAFFS_TRACE_ALWAYS,(TSTR("Checkpoint read object %d parent %d type %d"
;;;4367   				TCONT(" chunk %d Parent type, %d, not directory")
;;;4368   				TENDSTR),
;;;4369   				cp->objectId,cp->parentId,cp->variantType,cp->hdrChunk,parent->variantType));
;;;4370   			return 0;
;;;4371   		}
;;;4372   		yaffs_AddObjectToDirectory(parent, obj);
;;;4373   	}
;;;4374   
;;;4375   	obj->hdrChunk = cp->hdrChunk;
;;;4376   	obj->variantType = cp->variantType;
;;;4377   	obj->deleted = cp->deleted;
;;;4378   	obj->softDeleted = cp->softDeleted;
;;;4379   	obj->unlinked = cp->unlinked;
;;;4380   	obj->fake = cp->fake;
;;;4381   	obj->renameAllowed = cp->renameAllowed;
;;;4382   	obj->unlinkAllowed = cp->unlinkAllowed;
;;;4383   	obj->serial = cp->serial;
;;;4384   	obj->nDataChunks = cp->nDataChunks;
;;;4385   	
;;;4386   	if(obj->variantType == YAFFS_OBJECT_TYPE_FILE)
;;;4387   		obj->variant.fileVariant.fileSize = cp->fileSizeOrEquivalentObjectId;
;;;4388   	else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
;;;4389   		obj->variant.hardLinkVariant.equivalentObjectId = cp->fileSizeOrEquivalentObjectId;
;;;4390   
;;;4391   	if(obj->hdrChunk > 0)
;;;4392   		obj->lazyLoaded = 1;
;;;4393   	return 1;
;;;4394   }
003718  bd70              POP      {r4-r6,pc}
                  |L1.14106|
00371a  6868              LDR      r0,[r5,#4]            ;4354
00371c  6320              STR      r0,[r4,#0x30]         ;4354
00371e  68a8              LDR      r0,[r5,#8]            ;4356
003720  b130              CBZ      r0,|L1.14128|
003722  68a9              LDR      r1,[r5,#8]            ;4357
003724  2203              MOVS     r2,#3                 ;4357
003726  68a0              LDR      r0,[r4,#8]            ;4357
003728  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
00372c  4606              MOV      r6,r0                 ;4357
00372e  e000              B        |L1.14130|
                  |L1.14128|
003730  2600              MOVS     r6,#0                 ;4362
                  |L1.14130|
003732  b15e              CBZ      r6,|L1.14156|
003734  f8960054          LDRB     r0,[r6,#0x54]         ;4365
003738  2803              CMP      r0,#3                 ;4365
00373a  d003              BEQ      |L1.14148|
00373c  bf00              NOP                            ;4366
00373e  bf00              NOP                            ;4366
003740  2000              MOVS     r0,#0                 ;4370
003742  e7e9              B        |L1.14104|
                  |L1.14148|
003744  4621              MOV      r1,r4                 ;4372
003746  4630              MOV      r0,r6                 ;4372
003748  f7fffffe          BL       yaffs_AddObjectToDirectory
                  |L1.14156|
00374c  68e8              LDR      r0,[r5,#0xc]          ;4375
00374e  62a0              STR      r0,[r4,#0x28]         ;4375
003750  7c28              LDRB     r0,[r5,#0x10]         ;4376
003752  f0000007          AND      r0,r0,#7              ;4376
003756  f8840054          STRB     r0,[r4,#0x54]         ;4376
00375a  7c28              LDRB     r0,[r5,#0x10]         ;4377
00375c  08c1              LSRS     r1,r0,#3              ;4377
00375e  7820              LDRB     r0,[r4,#0]            ;4377
003760  f3610000          BFI      r0,r1,#0,#1           ;4377
003764  7020              STRB     r0,[r4,#0]            ;4377
003766  7c28              LDRB     r0,[r5,#0x10]         ;4378
003768  0901              LSRS     r1,r0,#4              ;4378
00376a  7820              LDRB     r0,[r4,#0]            ;4378
00376c  f3610041          BFI      r0,r1,#1,#1           ;4378
003770  7020              STRB     r0,[r4,#0]            ;4378
003772  7c28              LDRB     r0,[r5,#0x10]         ;4379
003774  0941              LSRS     r1,r0,#5              ;4379
003776  7820              LDRB     r0,[r4,#0]            ;4379
003778  f3610082          BFI      r0,r1,#2,#1           ;4379
00377c  7020              STRB     r0,[r4,#0]            ;4379
00377e  7c28              LDRB     r0,[r5,#0x10]         ;4380
003780  0981              LSRS     r1,r0,#6              ;4380
003782  7820              LDRB     r0,[r4,#0]            ;4380
003784  f36100c3          BFI      r0,r1,#3,#1           ;4380
003788  7020              STRB     r0,[r4,#0]            ;4380
00378a  7c28              LDRB     r0,[r5,#0x10]         ;4381
00378c  09c1              LSRS     r1,r0,#7              ;4381
00378e  7820              LDRB     r0,[r4,#0]            ;4381
003790  f3611004          BFI      r0,r1,#4,#1           ;4381
003794  7020              STRB     r0,[r4,#0]            ;4381
003796  7c68              LDRB     r0,[r5,#0x11]         ;4382
003798  7821              LDRB     r1,[r4,#0]            ;4382
00379a  f3601145          BFI      r1,r0,#5,#1           ;4382
00379e  7021              STRB     r1,[r4,#0]            ;4382
0037a0  7ca8              LDRB     r0,[r5,#0x12]         ;4383
0037a2  70a0              STRB     r0,[r4,#2]            ;4383
0037a4  6968              LDR      r0,[r5,#0x14]         ;4384
0037a6  62e0              STR      r0,[r4,#0x2c]         ;4384
0037a8  f8940054          LDRB     r0,[r4,#0x54]         ;4386
0037ac  2801              CMP      r0,#1                 ;4386
0037ae  d102              BNE      |L1.14262|
0037b0  69a8              LDR      r0,[r5,#0x18]         ;4387
0037b2  65a0              STR      r0,[r4,#0x58]         ;4387
0037b4  e005              B        |L1.14274|
                  |L1.14262|
0037b6  f8940054          LDRB     r0,[r4,#0x54]         ;4388
0037ba  2804              CMP      r0,#4                 ;4388
0037bc  d101              BNE      |L1.14274|
0037be  69a9              LDR      r1,[r5,#0x18]         ;4389
0037c0  65e1              STR      r1,[r4,#0x5c]         ;4389
                  |L1.14274|
0037c2  6aa0              LDR      r0,[r4,#0x28]         ;4391
0037c4  2800              CMP      r0,#0                 ;4391
0037c6  dd04              BLE      |L1.14290|
0037c8  7860              LDRB     r0,[r4,#1]            ;4392
0037ca  f0200001          BIC      r0,r0,#1              ;4392
0037ce  1c40              ADDS     r0,r0,#1              ;4392
0037d0  7060              STRB     r0,[r4,#1]            ;4392
                  |L1.14290|
0037d2  2001              MOVS     r0,#1                 ;4393
0037d4  e7a0              B        |L1.14104|
;;;4395   
                          ENDP

                  yaffs_CheckpointTnodeWorker PROC
;;;4397   
;;;4398   static int yaffs_CheckpointTnodeWorker(yaffs_Object * in, yaffs_Tnode * tn,
0037d6  e92d4ff8          PUSH     {r3-r11,lr}
;;;4399   				  	__u32 level, int chunkOffset)
;;;4400   {
0037da  4682              MOV      r10,r0
0037dc  460d              MOV      r5,r1
0037de  4616              MOV      r6,r2
0037e0  461f              MOV      r7,r3
;;;4401   	int i;
;;;4402   	yaffs_Device *dev = in->myDev;
0037e2  f8dab008          LDR      r11,[r10,#8]
;;;4403   	int ok = 1;
0037e6  f04f0801          MOV      r8,#1
;;;4404   	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
0037ea  f8db0078          LDR      r0,[r11,#0x78]
0037ee  0100              LSLS     r0,r0,#4
0037f0  ea4f09d0          LSR      r9,r0,#3
;;;4405   
;;;4406   	if(tnodeSize < sizeof(yaffs_Tnode))
0037f4  f1b90f20          CMP      r9,#0x20
0037f8  d201              BCS      |L1.14334|
;;;4407   		tnodeSize = sizeof(yaffs_Tnode);
0037fa  f04f0920          MOV      r9,#0x20
                  |L1.14334|
;;;4408   	
;;;4409   
;;;4410   	if (tn) {
0037fe  b3a5              CBZ      r5,|L1.14442|
;;;4411   		if (level > 0) {
003800  b1ce              CBZ      r6,|L1.14390|
;;;4412   
;;;4413   			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){
003802  2400              MOVS     r4,#0
003804  e011              B        |L1.14378|
003806  0000              DCW      0x0000
                  |L1.14344|
                          DCD      0x05f5e100
                  |L1.14348|
                          DCD      0x5941ff53
                  |L1.14352|
;;;4414   				if (tn->internal[i]) {
003810  f8550024          LDR      r0,[r5,r4,LSL #2]
003814  b140              CBZ      r0,|L1.14376|
;;;4415   					ok = yaffs_CheckpointTnodeWorker(in,
003816  eb0403c7          ADD      r3,r4,r7,LSL #3
00381a  1e72              SUBS     r2,r6,#1
00381c  f8551024          LDR      r1,[r5,r4,LSL #2]
003820  4650              MOV      r0,r10
003822  f7fffffe          BL       yaffs_CheckpointTnodeWorker
003826  4680              MOV      r8,r0
                  |L1.14376|
003828  1c64              ADDS     r4,r4,#1              ;4413
                  |L1.14378|
00382a  2c08              CMP      r4,#8                 ;4413
00382c  da21              BGE      |L1.14450|
00382e  f1b80f00          CMP      r8,#0                 ;4413
003832  d1ed              BNE      |L1.14352|
003834  e01d              B        |L1.14450|
                  |L1.14390|
;;;4416   							tn->internal[i],
;;;4417   							level - 1,
;;;4418   							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
;;;4419   				}
;;;4420   			}
;;;4421   		} else if (level == 0) {
003836  b9c6              CBNZ     r6,|L1.14442|
;;;4422   			__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;
003838  0138              LSLS     r0,r7,#4
00383a  9000              STR      r0,[sp,#0]
;;;4423   			ok = (yaffs_CheckpointWrite(dev,&baseOffset,sizeof(baseOffset)) == sizeof(baseOffset));
00383c  2204              MOVS     r2,#4
00383e  4669              MOV      r1,sp
003840  4658              MOV      r0,r11
003842  f7fffffe          BL       yaffs_CheckpointWrite
003846  2804              CMP      r0,#4
003848  d101              BNE      |L1.14414|
00384a  2001              MOVS     r0,#1
00384c  e000              B        |L1.14416|
                  |L1.14414|
00384e  2000              MOVS     r0,#0
                  |L1.14416|
003850  4680              MOV      r8,r0
;;;4424   			if(ok)
003852  f1b80f00          CMP      r8,#0
003856  d00b              BEQ      |L1.14448|
;;;4425   				ok = (yaffs_CheckpointWrite(dev,tn,tnodeSize) == tnodeSize);
003858  464a              MOV      r2,r9
00385a  4629              MOV      r1,r5
00385c  4658              MOV      r0,r11
00385e  f7fffffe          BL       yaffs_CheckpointWrite
003862  4548              CMP      r0,r9
003864  d102              BNE      |L1.14444|
003866  2001              MOVS     r0,#1
003868  e001              B        |L1.14446|
                  |L1.14442|
00386a  e002              B        |L1.14450|
                  |L1.14444|
00386c  2000              MOVS     r0,#0
                  |L1.14446|
00386e  4680              MOV      r8,r0
                  |L1.14448|
;;;4426   		}
003870  bf00              NOP      
                  |L1.14450|
;;;4427   	}
;;;4428   
;;;4429   	return ok;
003872  4640              MOV      r0,r8
;;;4430   
;;;4431   }
003874  e8bd8ff8          POP      {r3-r11,pc}
;;;4432   
                          ENDP

                  yaffs_WriteCheckpointTnodes PROC
;;;4433   static int yaffs_WriteCheckpointTnodes(yaffs_Object *obj)
003878  b538              PUSH     {r3-r5,lr}
;;;4434   {
00387a  4604              MOV      r4,r0
;;;4435   	__u32 endMarker = ~0;
00387c  f04f30ff          MOV      r0,#0xffffffff
003880  9000              STR      r0,[sp,#0]
;;;4436   	int ok = 1;
003882  2501              MOVS     r5,#1
;;;4437   	
;;;4438   	if(obj->variantType == YAFFS_OBJECT_TYPE_FILE){
003884  f8940054          LDRB     r0,[r4,#0x54]
003888  2801              CMP      r0,#1
00388a  d112              BNE      |L1.14514|
;;;4439   		ok = yaffs_CheckpointTnodeWorker(obj,
00388c  2300              MOVS     r3,#0
00388e  4620              MOV      r0,r4
003890  e9d42119          LDRD     r2,r1,[r4,#0x64]
003894  f7fffffe          BL       yaffs_CheckpointTnodeWorker
003898  4605              MOV      r5,r0
;;;4440   					    obj->variant.fileVariant.top,
;;;4441   					    obj->variant.fileVariant.topLevel,
;;;4442   					    0);
;;;4443   		if(ok)
00389a  b155              CBZ      r5,|L1.14514|
;;;4444   			ok = (yaffs_CheckpointWrite(obj->myDev,&endMarker,sizeof(endMarker)) == 
00389c  2204              MOVS     r2,#4
00389e  4669              MOV      r1,sp
0038a0  68a0              LDR      r0,[r4,#8]
0038a2  f7fffffe          BL       yaffs_CheckpointWrite
0038a6  2804              CMP      r0,#4
0038a8  d101              BNE      |L1.14510|
0038aa  2001              MOVS     r0,#1
0038ac  e000              B        |L1.14512|
                  |L1.14510|
0038ae  2000              MOVS     r0,#0
                  |L1.14512|
0038b0  4605              MOV      r5,r0
                  |L1.14514|
;;;4445   				sizeof(endMarker));
;;;4446   	}
;;;4447   	
;;;4448   	return ok ? 1 : 0;
0038b2  b10d              CBZ      r5,|L1.14520|
0038b4  2001              MOVS     r0,#1
                  |L1.14518|
;;;4449   }
0038b6  bd38              POP      {r3-r5,pc}
                  |L1.14520|
0038b8  2000              MOVS     r0,#0                 ;4448
0038ba  e7fc              B        |L1.14518|
;;;4450   
                          ENDP

                  yaffs_ReadCheckpointTnodes PROC
;;;4451   static int yaffs_ReadCheckpointTnodes(yaffs_Object *obj)
0038bc  e92d4ff8          PUSH     {r3-r11,lr}
;;;4452   {
0038c0  4606              MOV      r6,r0
;;;4453   	__u32 baseChunk;
;;;4454   	int ok = 1;
0038c2  2501              MOVS     r5,#1
;;;4455   	yaffs_Device *dev = obj->myDev;
0038c4  f8d68008          LDR      r8,[r6,#8]
;;;4456   	yaffs_FileStructure *fileStructPtr = &obj->variant.fileVariant;
0038c8  f1060958          ADD      r9,r6,#0x58
;;;4457   	yaffs_Tnode *tn;
;;;4458   	int nread = 0;
0038cc  f04f0a00          MOV      r10,#0
;;;4459   	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
0038d0  f8d80078          LDR      r0,[r8,#0x78]
0038d4  0100              LSLS     r0,r0,#4
0038d6  08c7              LSRS     r7,r0,#3
;;;4460   
;;;4461   	if(tnodeSize < sizeof(yaffs_Tnode))
0038d8  2f20              CMP      r7,#0x20
0038da  d200              BCS      |L1.14558|
;;;4462   		tnodeSize = sizeof(yaffs_Tnode);
0038dc  2720              MOVS     r7,#0x20
                  |L1.14558|
;;;4463   
;;;4464   	ok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));
0038de  2204              MOVS     r2,#4
0038e0  4669              MOV      r1,sp
0038e2  4640              MOV      r0,r8
0038e4  f7fffffe          BL       yaffs_CheckpointRead
0038e8  2804              CMP      r0,#4
0038ea  d101              BNE      |L1.14576|
0038ec  2001              MOVS     r0,#1
0038ee  e000              B        |L1.14578|
                  |L1.14576|
0038f0  2000              MOVS     r0,#0
                  |L1.14578|
0038f2  4605              MOV      r5,r0
;;;4465   	
;;;4466   	while(ok && (~baseChunk)){
0038f4  e02c              B        |L1.14672|
                  |L1.14582|
;;;4467   		nread++;
0038f6  f10a0a01          ADD      r10,r10,#1
;;;4468   		/* Read level 0 tnode */
;;;4469   		
;;;4470   		
;;;4471   		tn = yaffs_GetTnodeRaw(dev);
0038fa  4640              MOV      r0,r8
0038fc  f7fffffe          BL       yaffs_GetTnodeRaw
003900  4604              MOV      r4,r0
;;;4472   		if(tn)
003902  b15c              CBZ      r4,|L1.14620|
;;;4473   			ok = (yaffs_CheckpointRead(dev,tn,tnodeSize) == tnodeSize);
003904  463a              MOV      r2,r7
003906  4621              MOV      r1,r4
003908  4640              MOV      r0,r8
00390a  f7fffffe          BL       yaffs_CheckpointRead
00390e  42b8              CMP      r0,r7
003910  d101              BNE      |L1.14614|
003912  2001              MOVS     r0,#1
003914  e000              B        |L1.14616|
                  |L1.14614|
003916  2000              MOVS     r0,#0
                  |L1.14616|
003918  4605              MOV      r5,r0
00391a  e000              B        |L1.14622|
                  |L1.14620|
;;;4474   		else
;;;4475   			ok = 0;
00391c  2500              MOVS     r5,#0
                  |L1.14622|
;;;4476   			
;;;4477   		if(tn && ok){
00391e  b15c              CBZ      r4,|L1.14648|
003920  b155              CBZ      r5,|L1.14648|
;;;4478   			ok = yaffs_AddOrFindLevel0Tnode(dev,
003922  4623              MOV      r3,r4
003924  4649              MOV      r1,r9
003926  4640              MOV      r0,r8
003928  9a00              LDR      r2,[sp,#0]
00392a  f7fffffe          BL       yaffs_AddOrFindLevel0Tnode
00392e  b108              CBZ      r0,|L1.14644|
;;;4479   					       		fileStructPtr,
;;;4480   					       		baseChunk,
;;;4481   					       		tn) ? 1 : 0;
003930  2001              MOVS     r0,#1
003932  e000              B        |L1.14646|
                  |L1.14644|
003934  2000              MOVS     r0,#0
                  |L1.14646|
003936  4605              MOV      r5,r0
                  |L1.14648|
;;;4482   					       		
;;;4483   		}
;;;4484   			
;;;4485   		if(ok)
003938  b155              CBZ      r5,|L1.14672|
;;;4486   			ok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));
00393a  2204              MOVS     r2,#4
00393c  4669              MOV      r1,sp
00393e  4640              MOV      r0,r8
003940  f7fffffe          BL       yaffs_CheckpointRead
003944  2804              CMP      r0,#4
003946  d101              BNE      |L1.14668|
003948  2001              MOVS     r0,#1
00394a  e000              B        |L1.14670|
                  |L1.14668|
00394c  2000              MOVS     r0,#0
                  |L1.14670|
00394e  4605              MOV      r5,r0
                  |L1.14672|
003950  b11d              CBZ      r5,|L1.14682|
003952  9800              LDR      r0,[sp,#0]            ;4466
003954  43c0              MVNS     r0,r0                 ;4466
003956  2800              CMP      r0,#0                 ;4466
003958  d1cd              BNE      |L1.14582|
                  |L1.14682|
;;;4487   		
;;;4488   	}
;;;4489   
;;;4490   	T(YAFFS_TRACE_CHECKPOINT,(
00395a  bf00              NOP      
00395c  bf00              NOP      
;;;4491   		TSTR("Checkpoint read tnodes %d records, last %d. ok %d" TENDSTR),
;;;4492   		nread,baseChunk,ok));
;;;4493   
;;;4494   	return ok ? 1 : 0;	
00395e  b115              CBZ      r5,|L1.14694|
003960  2001              MOVS     r0,#1
                  |L1.14690|
;;;4495   }
003962  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.14694|
003966  2000              MOVS     r0,#0                 ;4494
003968  e7fb              B        |L1.14690|
;;;4496    
                          ENDP

                  yaffs_WriteCheckpointObjects PROC
;;;4497   
;;;4498   static int yaffs_WriteCheckpointObjects(yaffs_Device *dev)
00396a  e92d41f0          PUSH     {r4-r8,lr}
;;;4499   {
00396e  b088              SUB      sp,sp,#0x20
003970  4680              MOV      r8,r0
;;;4500   	yaffs_Object *obj;
;;;4501           yaffs_CheckpointObject cp;
;;;4502           int i;
;;;4503           int ok = 1;
003972  2601              MOVS     r6,#1
;;;4504           struct ylist_head *lh;
;;;4505   
;;;4506           
;;;4507           /* Iterate through the objects in each hash entry,
;;;4508   	 * dumping them to the checkpointing stream.
;;;4509            */
;;;4510            
;;;4511            for(i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++){
003974  2500              MOVS     r5,#0
003976  e033              B        |L1.14816|
                  |L1.14712|
;;;4512                   ylist_for_each(lh, &dev->objectBucket[i].list) {
003978  eb050145          ADD      r1,r5,r5,LSL #1
00397c  f508709a          ADD      r0,r8,#0x134
003980  f8507021          LDR      r7,[r0,r1,LSL #2]
003984  e023              B        |L1.14798|
                  |L1.14726|
;;;4513                           if (lh) {
003986  b30f              CBZ      r7,|L1.14796|
;;;4514                                   obj = ylist_entry(lh, yaffs_Object, hashLink);
003988  f1a7040c          SUB      r4,r7,#0xc
;;;4515                                   if (!obj->deferedFree) {
00398c  7860              LDRB     r0,[r4,#1]
00398e  f3c00040          UBFX     r0,r0,#1,#1
003992  b9d8              CBNZ     r0,|L1.14796|
;;;4516                                           yaffs_ObjectToCheckpointObject(&cp,obj);
003994  4621              MOV      r1,r4
003996  a801              ADD      r0,sp,#4
003998  f7fffffe          BL       yaffs_ObjectToCheckpointObject
;;;4517                                           cp.structType = sizeof(cp);
00399c  201c              MOVS     r0,#0x1c
00399e  9001              STR      r0,[sp,#4]
;;;4518   
;;;4519   					T(YAFFS_TRACE_CHECKPOINT,(
0039a0  bf00              NOP      
0039a2  bf00              NOP      
;;;4520   						TSTR("Checkpoint write object %d parent %d type %d chunk %d obj addr %x" TENDSTR),
;;;4521   						cp.objectId,cp.parentId,cp.variantType,cp.hdrChunk,(unsigned) obj));
;;;4522   
;;;4523   					ok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));
0039a4  221c              MOVS     r2,#0x1c
0039a6  a901              ADD      r1,sp,#4
0039a8  4640              MOV      r0,r8
0039aa  f7fffffe          BL       yaffs_CheckpointWrite
0039ae  281c              CMP      r0,#0x1c
0039b0  d101              BNE      |L1.14774|
0039b2  2001              MOVS     r0,#1
0039b4  e000              B        |L1.14776|
                  |L1.14774|
0039b6  2000              MOVS     r0,#0
                  |L1.14776|
0039b8  4606              MOV      r6,r0
;;;4524   					
;;;4525   					if(ok && obj->variantType == YAFFS_OBJECT_TYPE_FILE){
0039ba  b13e              CBZ      r6,|L1.14796|
0039bc  f8940054          LDRB     r0,[r4,#0x54]
0039c0  2801              CMP      r0,#1
0039c2  d103              BNE      |L1.14796|
;;;4526   						ok = yaffs_WriteCheckpointTnodes(obj);
0039c4  4620              MOV      r0,r4
0039c6  f7fffffe          BL       yaffs_WriteCheckpointTnodes
0039ca  4606              MOV      r6,r0
                  |L1.14796|
0039cc  683f              LDR      r7,[r7,#0]            ;4512
                  |L1.14798|
0039ce  eb050145          ADD      r1,r5,r5,LSL #1       ;4512
0039d2  f508709a          ADD      r0,r8,#0x134          ;4512
0039d6  eb000081          ADD      r0,r0,r1,LSL #2       ;4512
0039da  42b8              CMP      r0,r7                 ;4512
0039dc  d1d3              BNE      |L1.14726|
0039de  1c6d              ADDS     r5,r5,#1              ;4511
                  |L1.14816|
0039e0  b10e              CBZ      r6,|L1.14822|
0039e2  2dff              CMP      r5,#0xff              ;4511
0039e4  ddc8              BLE      |L1.14712|
                  |L1.14822|
;;;4527   					}
;;;4528   				}
;;;4529   			}
;;;4530   		}
;;;4531   	 }
;;;4532   	 
;;;4533   	 /* Dump end of list */
;;;4534   	memset(&cp,0xFF,sizeof(yaffs_CheckpointObject));
0039e6  22ff              MOVS     r2,#0xff
0039e8  211c              MOVS     r1,#0x1c
0039ea  a801              ADD      r0,sp,#4
0039ec  f7fffffe          BL       __aeabi_memset
;;;4535   	cp.structType = sizeof(cp);
0039f0  201c              MOVS     r0,#0x1c
0039f2  9001              STR      r0,[sp,#4]
;;;4536   	
;;;4537   	if(ok)
0039f4  b156              CBZ      r6,|L1.14860|
;;;4538   		ok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));
0039f6  221c              MOVS     r2,#0x1c
0039f8  a901              ADD      r1,sp,#4
0039fa  4640              MOV      r0,r8
0039fc  f7fffffe          BL       yaffs_CheckpointWrite
003a00  281c              CMP      r0,#0x1c
003a02  d101              BNE      |L1.14856|
003a04  2001              MOVS     r0,#1
003a06  e000              B        |L1.14858|
                  |L1.14856|
003a08  2000              MOVS     r0,#0
                  |L1.14858|
003a0a  4606              MOV      r6,r0
                  |L1.14860|
;;;4539   		
;;;4540   	return ok ? 1 : 0;
003a0c  b11e              CBZ      r6,|L1.14870|
003a0e  2001              MOVS     r0,#1
                  |L1.14864|
;;;4541   }
003a10  b008              ADD      sp,sp,#0x20
003a12  e8bd81f0          POP      {r4-r8,pc}
                  |L1.14870|
003a16  2000              MOVS     r0,#0                 ;4540
003a18  e7fa              B        |L1.14864|
;;;4542   
                          ENDP

                  yaffs_HardlinkFixup PROC
;;;5475   
;;;5476   static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList)
003a1a  e92d41f0          PUSH     {r4-r8,lr}
;;;5477   {
003a1e  4607              MOV      r7,r0
003a20  460e              MOV      r6,r1
;;;5478   	yaffs_Object *hl;
;;;5479   	yaffs_Object *in;
;;;5480   	
;;;5481   	while (hardList) {
003a22  e017              B        |L1.14932|
                  |L1.14884|
;;;5482   		hl = hardList;
003a24  4634              MOV      r4,r6
;;;5483   		hardList = (yaffs_Object *) (hardList->hardLinks.next);
003a26  6976              LDR      r6,[r6,#0x14]
;;;5484   
;;;5485   		in = yaffs_FindObjectByNumber(dev,
003a28  4638              MOV      r0,r7
003a2a  6de1              LDR      r1,[r4,#0x5c]
003a2c  f7fffffe          BL       yaffs_FindObjectByNumber
003a30  4605              MOV      r5,r0
;;;5486   					      hl->variant.hardLinkVariant.
;;;5487   					      equivalentObjectId);
;;;5488   
;;;5489                   if (in) {
003a32  b13d              CBZ      r5,|L1.14916|
;;;5490                           /* Add the hardlink pointers */
;;;5491                           hl->variant.hardLinkVariant.equivalentObject = in;
003a34  65a5              STR      r5,[r4,#0x58]
;;;5492                           ylist_add(&hl->hardLinks, &in->hardLinks);
003a36  f1050114          ADD      r1,r5,#0x14
003a3a  f1040014          ADD      r0,r4,#0x14
003a3e  f7fffffe          BL       ylist_add
003a42  e007              B        |L1.14932|
                  |L1.14916|
;;;5493                   } else {
;;;5494                           /* Todo Need to report/handle this better.
;;;5495                            * Got a problem... hardlink to a non-existant object
;;;5496                            */
;;;5497                           hl->variant.hardLinkVariant.equivalentObject = NULL;
003a44  2000              MOVS     r0,#0
003a46  65a0              STR      r0,[r4,#0x58]
;;;5498                           YINIT_LIST_HEAD(&hl->hardLinks);
003a48  bf00              NOP      
003a4a  f1040014          ADD      r0,r4,#0x14
003a4e  6160              STR      r0,[r4,#0x14]
003a50  61a0              STR      r0,[r4,#0x18]
003a52  bf00              NOP      
                  |L1.14932|
003a54  2e00              CMP      r6,#0                 ;5481
003a56  d1e5              BNE      |L1.14884|
;;;5499   
;;;5500                   }
;;;5501   
;;;5502   	}
;;;5503   
;;;5504   }
003a58  e8bd81f0          POP      {r4-r8,pc}
;;;5505   
                          ENDP

                  yaffs_ReadCheckpointObjects PROC
;;;4542   
;;;4543   static int yaffs_ReadCheckpointObjects(yaffs_Device *dev)
003a5c  e92d41f0          PUSH     {r4-r8,lr}
;;;4544   {
003a60  b088              SUB      sp,sp,#0x20
003a62  4607              MOV      r7,r0
;;;4545   	yaffs_Object *obj;
;;;4546   	yaffs_CheckpointObject cp;
;;;4547   	int ok = 1;
003a64  2501              MOVS     r5,#1
;;;4548   	int done = 0;
003a66  f04f0800          MOV      r8,#0
;;;4549   	yaffs_Object *hardList = NULL;
003a6a  2600              MOVS     r6,#0
;;;4550   	
;;;4551   	while(ok && !done) {
003a6c  e03c              B        |L1.15080|
                  |L1.14958|
;;;4552   		ok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));
003a6e  221c              MOVS     r2,#0x1c
003a70  a901              ADD      r1,sp,#4
003a72  4638              MOV      r0,r7
003a74  f7fffffe          BL       yaffs_CheckpointRead
003a78  281c              CMP      r0,#0x1c
003a7a  d101              BNE      |L1.14976|
003a7c  2001              MOVS     r0,#1
003a7e  e000              B        |L1.14978|
                  |L1.14976|
003a80  2000              MOVS     r0,#0
                  |L1.14978|
003a82  4605              MOV      r5,r0
;;;4553   		if(cp.structType != sizeof(cp)) {
003a84  9801              LDR      r0,[sp,#4]
003a86  281c              CMP      r0,#0x1c
003a88  d002              BEQ      |L1.14992|
;;;4554   			T(YAFFS_TRACE_CHECKPOINT,(TSTR("struct size %d instead of %d ok %d"TENDSTR),
003a8a  bf00              NOP      
003a8c  bf00              NOP      
;;;4555   				cp.structType,sizeof(cp),ok));
;;;4556   			ok = 0;
003a8e  2500              MOVS     r5,#0
                  |L1.14992|
;;;4557   		}
;;;4558   			
;;;4559   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("Checkpoint read object %d parent %d type %d chunk %d " TENDSTR),
003a90  bf00              NOP      
003a92  bf00              NOP      
;;;4560   			cp.objectId,cp.parentId,cp.variantType,cp.hdrChunk));
;;;4561   
;;;4562   		if(ok && cp.objectId == ~0)
003a94  b12d              CBZ      r5,|L1.15010|
003a96  9802              LDR      r0,[sp,#8]
003a98  1c40              ADDS     r0,r0,#1
003a9a  b910              CBNZ     r0,|L1.15010|
;;;4563   			done = 1;
003a9c  f04f0801          MOV      r8,#1
003aa0  e022              B        |L1.15080|
                  |L1.15010|
;;;4564   		else if(ok){
003aa2  b1fd              CBZ      r5,|L1.15076|
;;;4565   			obj = yaffs_FindOrCreateObjectByNumber(dev,cp.objectId, cp.variantType);
003aa4  f89d0014          LDRB     r0,[sp,#0x14]
003aa8  f0000207          AND      r2,r0,#7
003aac  4638              MOV      r0,r7
003aae  9902              LDR      r1,[sp,#8]
003ab0  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
003ab4  4604              MOV      r4,r0
;;;4566   			if(obj) {
003ab6  b1b4              CBZ      r4,|L1.15078|
;;;4567   				ok = yaffs_CheckpointObjectToObject(obj,&cp);
003ab8  a901              ADD      r1,sp,#4
003aba  4620              MOV      r0,r4
003abc  f7fffffe          BL       yaffs_CheckpointObjectToObject
003ac0  4605              MOV      r5,r0
;;;4568   				if (!ok)
003ac2  b905              CBNZ     r5,|L1.15046|
;;;4569   					break;
003ac4  e014              B        |L1.15088|
                  |L1.15046|
;;;4570   				if(obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
003ac6  f8940054          LDRB     r0,[r4,#0x54]
003aca  2801              CMP      r0,#1
003acc  d104              BNE      |L1.15064|
;;;4571                                           ok = yaffs_ReadCheckpointTnodes(obj);
003ace  4620              MOV      r0,r4
003ad0  f7fffffe          BL       yaffs_ReadCheckpointTnodes
003ad4  4605              MOV      r5,r0
003ad6  e007              B        |L1.15080|
                  |L1.15064|
;;;4572                                   } else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
003ad8  f8940054          LDRB     r0,[r4,#0x54]
003adc  2804              CMP      r0,#4
003ade  d103              BNE      |L1.15080|
;;;4573                                           obj->hardLinks.next =
003ae0  6166              STR      r6,[r4,#0x14]
;;;4574                                                       (struct ylist_head *)
;;;4575                                                       hardList;
;;;4576                                           hardList = obj;
003ae2  4626              MOV      r6,r4
                  |L1.15076|
003ae4  e000              B        |L1.15080|
                  |L1.15078|
;;;4577                                   }
;;;4578   			   
;;;4579   			}
;;;4580   			else
;;;4581   				ok = 0;
003ae6  2500              MOVS     r5,#0
                  |L1.15080|
003ae8  b115              CBZ      r5,|L1.15088|
003aea  f1b80f00          CMP      r8,#0                 ;4551
003aee  d0be              BEQ      |L1.14958|
                  |L1.15088|
003af0  bf00              NOP                            ;4569
;;;4582   		}
;;;4583   	}
;;;4584   	
;;;4585   	if(ok)
003af2  b11d              CBZ      r5,|L1.15100|
;;;4586   		yaffs_HardlinkFixup(dev,hardList);
003af4  4631              MOV      r1,r6
003af6  4638              MOV      r0,r7
003af8  f7fffffe          BL       yaffs_HardlinkFixup
                  |L1.15100|
;;;4587   	
;;;4588   	return ok ? 1 : 0;
003afc  b11d              CBZ      r5,|L1.15110|
003afe  2001              MOVS     r0,#1
                  |L1.15104|
;;;4589   }
003b00  b008              ADD      sp,sp,#0x20
003b02  e8bd81f0          POP      {r4-r8,pc}
                  |L1.15110|
003b06  2000              MOVS     r0,#0                 ;4588
003b08  e7fa              B        |L1.15104|
;;;4590   
                          ENDP

                  yaffs_WriteCheckpointSum PROC
;;;4591   static int yaffs_WriteCheckpointSum(yaffs_Device *dev)
003b0a  b538              PUSH     {r3-r5,lr}
;;;4592   {
003b0c  4604              MOV      r4,r0
;;;4593   	__u32 checkpointSum;
;;;4594   	int ok;
;;;4595   	
;;;4596   	yaffs_GetCheckpointSum(dev,&checkpointSum);
003b0e  4669              MOV      r1,sp
003b10  4620              MOV      r0,r4
003b12  f7fffffe          BL       yaffs_GetCheckpointSum
;;;4597   	
;;;4598   	ok = (yaffs_CheckpointWrite(dev,&checkpointSum,sizeof(checkpointSum)) == sizeof(checkpointSum));
003b16  2204              MOVS     r2,#4
003b18  4669              MOV      r1,sp
003b1a  4620              MOV      r0,r4
003b1c  f7fffffe          BL       yaffs_CheckpointWrite
003b20  2804              CMP      r0,#4
003b22  d101              BNE      |L1.15144|
003b24  2001              MOVS     r0,#1
003b26  e000              B        |L1.15146|
                  |L1.15144|
003b28  2000              MOVS     r0,#0
                  |L1.15146|
003b2a  4605              MOV      r5,r0
;;;4599   	
;;;4600   	if(!ok)
003b2c  b90d              CBNZ     r5,|L1.15154|
;;;4601   		return 0;
003b2e  2000              MOVS     r0,#0
                  |L1.15152|
;;;4602   	
;;;4603   	return 1;
;;;4604   }
003b30  bd38              POP      {r3-r5,pc}
                  |L1.15154|
003b32  2001              MOVS     r0,#1                 ;4603
003b34  e7fc              B        |L1.15152|
;;;4605   
                          ENDP

                  yaffs_ReadCheckpointSum PROC
;;;4606   static int yaffs_ReadCheckpointSum(yaffs_Device *dev)
003b36  b57c              PUSH     {r2-r6,lr}
;;;4607   {
003b38  4604              MOV      r4,r0
;;;4608   	__u32 checkpointSum0;
;;;4609   	__u32 checkpointSum1;
;;;4610   	int ok;
;;;4611   	
;;;4612   	yaffs_GetCheckpointSum(dev,&checkpointSum0);
003b3a  a901              ADD      r1,sp,#4
003b3c  4620              MOV      r0,r4
003b3e  f7fffffe          BL       yaffs_GetCheckpointSum
;;;4613   	
;;;4614   	ok = (yaffs_CheckpointRead(dev,&checkpointSum1,sizeof(checkpointSum1)) == sizeof(checkpointSum1));
003b42  2204              MOVS     r2,#4
003b44  4669              MOV      r1,sp
003b46  4620              MOV      r0,r4
003b48  f7fffffe          BL       yaffs_CheckpointRead
003b4c  2804              CMP      r0,#4
003b4e  d101              BNE      |L1.15188|
003b50  2001              MOVS     r0,#1
003b52  e000              B        |L1.15190|
                  |L1.15188|
003b54  2000              MOVS     r0,#0
                  |L1.15190|
003b56  4605              MOV      r5,r0
;;;4615   	
;;;4616   	if(!ok)
003b58  b90d              CBNZ     r5,|L1.15198|
;;;4617   		return 0;
003b5a  2000              MOVS     r0,#0
                  |L1.15196|
;;;4618   		
;;;4619   	if(checkpointSum0 != checkpointSum1)
;;;4620   		return 0;
;;;4621   	
;;;4622   	return 1;
;;;4623   }
003b5c  bd7c              POP      {r2-r6,pc}
                  |L1.15198|
003b5e  e9dd1000          LDRD     r1,r0,[sp,#0]         ;4619
003b62  4288              CMP      r0,r1                 ;4619
003b64  d001              BEQ      |L1.15210|
003b66  2000              MOVS     r0,#0                 ;4620
003b68  e7f8              B        |L1.15196|
                  |L1.15210|
003b6a  2001              MOVS     r0,#1                 ;4622
003b6c  e7f6              B        |L1.15196|
;;;4624   
                          ENDP

                  yaffs_WriteCheckpointData PROC
;;;4625   
;;;4626   static int yaffs_WriteCheckpointData(yaffs_Device *dev)
003b6e  b570              PUSH     {r4-r6,lr}
;;;4627   {
003b70  4605              MOV      r5,r0
;;;4628   
;;;4629   	int ok = 1;
003b72  2401              MOVS     r4,#1
;;;4630   	
;;;4631   	if(dev->skipCheckpointWrite || !dev->isYaffs2){
003b74  f8950071          LDRB     r0,[r5,#0x71]
003b78  b908              CBNZ     r0,|L1.15230|
003b7a  6de8              LDR      r0,[r5,#0x5c]
003b7c  b910              CBNZ     r0,|L1.15236|
                  |L1.15230|
;;;4632   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("skipping checkpoint write" TENDSTR)));
003b7e  bf00              NOP      
003b80  bf00              NOP      
;;;4633   		ok = 0;
003b82  2400              MOVS     r4,#0
                  |L1.15236|
;;;4634   	}
;;;4635   		
;;;4636   	if(ok)
003b84  b124              CBZ      r4,|L1.15248|
;;;4637   		ok = yaffs_CheckpointOpen(dev,1);
003b86  2101              MOVS     r1,#1
003b88  4628              MOV      r0,r5
003b8a  f7fffffe          BL       yaffs_CheckpointOpen
003b8e  4604              MOV      r4,r0
                  |L1.15248|
;;;4638   	
;;;4639   	if(ok){
003b90  b134              CBZ      r4,|L1.15264|
;;;4640   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint validity" TENDSTR)));
003b92  bf00              NOP      
003b94  bf00              NOP      
;;;4641   		ok = yaffs_WriteCheckpointValidityMarker(dev,1);
003b96  2101              MOVS     r1,#1
003b98  4628              MOV      r0,r5
003b9a  f7fffffe          BL       yaffs_WriteCheckpointValidityMarker
003b9e  4604              MOV      r4,r0
                  |L1.15264|
;;;4642   	}
;;;4643   	if(ok){
003ba0  b12c              CBZ      r4,|L1.15278|
;;;4644   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint device" TENDSTR)));
003ba2  bf00              NOP      
003ba4  bf00              NOP      
;;;4645   		ok = yaffs_WriteCheckpointDevice(dev);
003ba6  4628              MOV      r0,r5
003ba8  f7fffffe          BL       yaffs_WriteCheckpointDevice
003bac  4604              MOV      r4,r0
                  |L1.15278|
;;;4646   	}
;;;4647   	if(ok){
003bae  b12c              CBZ      r4,|L1.15292|
;;;4648   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint objects" TENDSTR)));
003bb0  bf00              NOP      
003bb2  bf00              NOP      
;;;4649   		ok = yaffs_WriteCheckpointObjects(dev);
003bb4  4628              MOV      r0,r5
003bb6  f7fffffe          BL       yaffs_WriteCheckpointObjects
003bba  4604              MOV      r4,r0
                  |L1.15292|
;;;4650   	}
;;;4651   	if(ok){
003bbc  b134              CBZ      r4,|L1.15308|
;;;4652   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint validity" TENDSTR)));
003bbe  bf00              NOP      
003bc0  bf00              NOP      
;;;4653   		ok = yaffs_WriteCheckpointValidityMarker(dev,0);
003bc2  2100              MOVS     r1,#0
003bc4  4628              MOV      r0,r5
003bc6  f7fffffe          BL       yaffs_WriteCheckpointValidityMarker
003bca  4604              MOV      r4,r0
                  |L1.15308|
;;;4654   	}
;;;4655   	
;;;4656   	if(ok){
003bcc  b11c              CBZ      r4,|L1.15318|
;;;4657   		ok = yaffs_WriteCheckpointSum(dev);
003bce  4628              MOV      r0,r5
003bd0  f7fffffe          BL       yaffs_WriteCheckpointSum
003bd4  4604              MOV      r4,r0
                  |L1.15318|
;;;4658   	}
;;;4659   	
;;;4660   	
;;;4661   	if(!yaffs_CheckpointClose(dev))
003bd6  4628              MOV      r0,r5
003bd8  f7fffffe          BL       yaffs_CheckpointClose
003bdc  b900              CBNZ     r0,|L1.15328|
;;;4662   		 ok = 0;
003bde  2400              MOVS     r4,#0
                  |L1.15328|
;;;4663   		 
;;;4664   	if(ok)
003be0  b11c              CBZ      r4,|L1.15338|
;;;4665   	    	dev->isCheckpointed = 1;
003be2  2001              MOVS     r0,#1
003be4  f8c50098          STR      r0,[r5,#0x98]
003be8  e002              B        |L1.15344|
                  |L1.15338|
;;;4666   	 else 
;;;4667   	 	dev->isCheckpointed = 0;
003bea  2000              MOVS     r0,#0
003bec  f8c50098          STR      r0,[r5,#0x98]
                  |L1.15344|
;;;4668   
;;;4669   	return dev->isCheckpointed;
003bf0  f8d50098          LDR      r0,[r5,#0x98]
;;;4670   }
003bf4  bd70              POP      {r4-r6,pc}
;;;4671   
                          ENDP

                  yaffs_ReadCheckpointData PROC
;;;4672   static int yaffs_ReadCheckpointData(yaffs_Device *dev)
003bf6  b570              PUSH     {r4-r6,lr}
;;;4673   {
003bf8  4605              MOV      r5,r0
;;;4674   	int ok = 1;
003bfa  2401              MOVS     r4,#1
;;;4675   
;;;4676   	if(dev->skipCheckpointRead || !dev->isYaffs2){
003bfc  f8950070          LDRB     r0,[r5,#0x70]
003c00  b908              CBNZ     r0,|L1.15366|
003c02  6de8              LDR      r0,[r5,#0x5c]
003c04  b910              CBNZ     r0,|L1.15372|
                  |L1.15366|
;;;4677   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("skipping checkpoint read" TENDSTR)));
003c06  bf00              NOP      
003c08  bf00              NOP      
;;;4678   		ok = 0;
003c0a  2400              MOVS     r4,#0
                  |L1.15372|
;;;4679   	}
;;;4680       
;;;4681   	if(ok)
003c0c  b124              CBZ      r4,|L1.15384|
;;;4682   		ok = yaffs_CheckpointOpen(dev,0); /* open for read */
003c0e  2100              MOVS     r1,#0
003c10  4628              MOV      r0,r5
003c12  f7fffffe          BL       yaffs_CheckpointOpen
003c16  4604              MOV      r4,r0
                  |L1.15384|
;;;4683       
;;;4684   	if(ok){
003c18  b134              CBZ      r4,|L1.15400|
;;;4685   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint validity" TENDSTR)));	
003c1a  bf00              NOP      
003c1c  bf00              NOP      
;;;4686   		ok = yaffs_ReadCheckpointValidityMarker(dev,1);
003c1e  2101              MOVS     r1,#1
003c20  4628              MOV      r0,r5
003c22  f7fffffe          BL       yaffs_ReadCheckpointValidityMarker
003c26  4604              MOV      r4,r0
                  |L1.15400|
;;;4687   	}
;;;4688       
;;;4689   	if(ok){
003c28  b12c              CBZ      r4,|L1.15414|
;;;4690   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint device" TENDSTR)));
003c2a  bf00              NOP      
003c2c  bf00              NOP      
;;;4691   		ok = yaffs_ReadCheckpointDevice(dev);
003c2e  4628              MOV      r0,r5
003c30  f7fffffe          BL       yaffs_ReadCheckpointDevice
003c34  4604              MOV      r4,r0
                  |L1.15414|
;;;4692   	}
;;;4693       
;;;4694   	if(ok){
003c36  b12c              CBZ      r4,|L1.15428|
;;;4695   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint objects" TENDSTR)));	
003c38  bf00              NOP      
003c3a  bf00              NOP      
;;;4696   		ok = yaffs_ReadCheckpointObjects(dev);
003c3c  4628              MOV      r0,r5
003c3e  f7fffffe          BL       yaffs_ReadCheckpointObjects
003c42  4604              MOV      r4,r0
                  |L1.15428|
;;;4697   	}
;;;4698       
;;;4699   	if(ok){
003c44  b134              CBZ      r4,|L1.15444|
;;;4700   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint validity" TENDSTR)));
003c46  bf00              NOP      
003c48  bf00              NOP      
;;;4701   		ok = yaffs_ReadCheckpointValidityMarker(dev,0);
003c4a  2100              MOVS     r1,#0
003c4c  4628              MOV      r0,r5
003c4e  f7fffffe          BL       yaffs_ReadCheckpointValidityMarker
003c52  4604              MOV      r4,r0
                  |L1.15444|
;;;4702   	}
;;;4703    
;;;4704   	if(ok){
003c54  b12c              CBZ      r4,|L1.15458|
;;;4705   		ok = yaffs_ReadCheckpointSum(dev);
003c56  4628              MOV      r0,r5
003c58  f7fffffe          BL       yaffs_ReadCheckpointSum
003c5c  4604              MOV      r4,r0
;;;4706   		T(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint checksum %d" TENDSTR),ok));
003c5e  bf00              NOP      
003c60  bf00              NOP      
                  |L1.15458|
;;;4707   	}
;;;4708    
;;;4709   	if(!yaffs_CheckpointClose(dev))
003c62  4628              MOV      r0,r5
003c64  f7fffffe          BL       yaffs_CheckpointClose
003c68  b900              CBNZ     r0,|L1.15468|
;;;4710   		ok = 0;
003c6a  2400              MOVS     r4,#0
                  |L1.15468|
;;;4711    
;;;4712   	if(ok)
003c6c  b11c              CBZ      r4,|L1.15478|
;;;4713   	    	dev->isCheckpointed = 1;
003c6e  2001              MOVS     r0,#1
003c70  f8c50098          STR      r0,[r5,#0x98]
003c74  e002              B        |L1.15484|
                  |L1.15478|
;;;4714   	 else 
;;;4715   	 	dev->isCheckpointed = 0;
003c76  2000              MOVS     r0,#0
003c78  f8c50098          STR      r0,[r5,#0x98]
                  |L1.15484|
;;;4716   
;;;4717   	return ok ? 1 : 0;
003c7c  b10c              CBZ      r4,|L1.15490|
003c7e  2001              MOVS     r0,#1
                  |L1.15488|
;;;4718   
;;;4719   }
003c80  bd70              POP      {r4-r6,pc}
                  |L1.15490|
003c82  2000              MOVS     r0,#0                 ;4717
003c84  e7fc              B        |L1.15488|
;;;4720   
                          ENDP

                  yaffs_CountFreeChunks PROC
;;;7609   
;;;7610   static int yaffs_CountFreeChunks(yaffs_Device * dev)
003c86  e92d41f0          PUSH     {r4-r8,lr}
;;;7611   {
003c8a  4605              MOV      r5,r0
;;;7612   	int nFree;
;;;7613   	int b;
;;;7614   
;;;7615   	yaffs_BlockInfo *blk;
;;;7616   
;;;7617   	for (nFree = 0, b = dev->internalStartBlock; b <= dev->internalEndBlock;
003c8c  2700              MOVS     r7,#0
003c8e  f8d5609c          LDR      r6,[r5,#0x9c]
003c92  e021              B        |L1.15576|
                  |L1.15508|
;;;7618   	     b++) {
;;;7619   		blk = yaffs_GetBlockInfo(dev, b);
003c94  4631              MOV      r1,r6
003c96  4628              MOV      r0,r5
003c98  f7fffffe          BL       yaffs_GetBlockInfo
003c9c  4604              MOV      r4,r0
;;;7620   
;;;7621   		switch (blk->blockState) {
003c9e  6820              LDR      r0,[r4,#0]
003ca0  f3c05003          UBFX     r0,r0,#20,#4
003ca4  2803              CMP      r0,#3
003ca6  d006              BEQ      |L1.15542|
003ca8  2804              CMP      r0,#4
003caa  d005              BEQ      |L1.15544|
003cac  2805              CMP      r0,#5
003cae  d005              BEQ      |L1.15548|
003cb0  2808              CMP      r0,#8
003cb2  d10e              BNE      |L1.15570|
003cb4  e001              B        |L1.15546|
                  |L1.15542|
;;;7622   		case YAFFS_BLOCK_STATE_EMPTY:
;;;7623   		case YAFFS_BLOCK_STATE_ALLOCATING:
003cb6  bf00              NOP      
                  |L1.15544|
;;;7624   		case YAFFS_BLOCK_STATE_COLLECTING:
003cb8  bf00              NOP      
                  |L1.15546|
;;;7625   		case YAFFS_BLOCK_STATE_FULL:
003cba  bf00              NOP      
                  |L1.15548|
;;;7626   			nFree +=
003cbc  6928              LDR      r0,[r5,#0x10]
003cbe  6821              LDR      r1,[r4,#0]
003cc0  f3c12189          UBFX     r1,r1,#10,#10
003cc4  1a40              SUBS     r0,r0,r1
003cc6  8821              LDRH     r1,[r4,#0]
003cc8  f3c10109          UBFX     r1,r1,#0,#10
003ccc  4408              ADD      r0,r0,r1
003cce  4407              ADD      r7,r7,r0
;;;7627   			    (dev->nChunksPerBlock - blk->pagesInUse +
;;;7628   			     blk->softDeletions);
;;;7629   			break;
003cd0  e000              B        |L1.15572|
                  |L1.15570|
;;;7630   		default:
;;;7631   			break;
003cd2  bf00              NOP      
                  |L1.15572|
003cd4  bf00              NOP                            ;7629
003cd6  1c76              ADDS     r6,r6,#1              ;7618
                  |L1.15576|
003cd8  f8d500a0          LDR      r0,[r5,#0xa0]         ;7617
003cdc  42b0              CMP      r0,r6                 ;7617
003cde  dad9              BGE      |L1.15508|
;;;7632   		}
;;;7633   
;;;7634   	}
;;;7635   
;;;7636   	return nFree;
003ce0  4638              MOV      r0,r7
;;;7637   }
003ce2  e8bd81f0          POP      {r4-r8,pc}
;;;7638   
                          ENDP

                  yaffs_VerifyFreeChunks PROC
;;;7684   
;;;7685   static void yaffs_VerifyFreeChunks(yaffs_Device * dev)
003ce6  b570              PUSH     {r4-r6,lr}
;;;7686   {
003ce8  4605              MOV      r5,r0
;;;7687   	int counted;
;;;7688   	int difference;
;;;7689   	
;;;7690   	if(yaffs_SkipVerification(dev))
003cea  4628              MOV      r0,r5
003cec  f7fffffe          BL       yaffs_SkipVerification
003cf0  b100              CBZ      r0,|L1.15604|
                  |L1.15602|
;;;7691   		return;
;;;7692   	
;;;7693   	counted = yaffs_CountFreeChunks(dev);
;;;7694   
;;;7695   	difference = dev->nFreeChunks - counted;
;;;7696   
;;;7697   	if (difference) {
;;;7698   		T(YAFFS_TRACE_ALWAYS,
;;;7699   		  (TSTR("Freechunks verification failure %d %d %d" TENDSTR),
;;;7700   		   dev->nFreeChunks, counted, difference));
;;;7701   		yaffs_freeVerificationFailures++;
;;;7702   	}
;;;7703   }
003cf2  bd70              POP      {r4-r6,pc}
                  |L1.15604|
003cf4  4628              MOV      r0,r5                 ;7693
003cf6  f7fffffe          BL       yaffs_CountFreeChunks
003cfa  4604              MOV      r4,r0                 ;7693
003cfc  f8d50d34          LDR      r0,[r5,#0xd34]        ;7695
003d00  1b06              SUBS     r6,r0,r4              ;7695
003d02  b136              CBZ      r6,|L1.15634|
003d04  bf00              NOP                            ;7698
003d06  bf00              NOP                            ;7698
003d08  48fd              LDR      r0,|L1.16640|
003d0a  6800              LDR      r0,[r0,#0]            ;7701  ; yaffs_freeVerificationFailures
003d0c  1c40              ADDS     r0,r0,#1              ;7701
003d0e  49fc              LDR      r1,|L1.16640|
003d10  6008              STR      r0,[r1,#0]            ;7701  ; yaffs_freeVerificationFailures
                  |L1.15634|
003d12  bf00              NOP      
003d14  e7ed              B        |L1.15602|
;;;7704   
                          ENDP

                  yaffs_CheckpointRestore PROC
;;;4751   
;;;4752   int yaffs_CheckpointRestore(yaffs_Device *dev)
003d16  b570              PUSH     {r4-r6,lr}
;;;4753   {
003d18  4604              MOV      r4,r0
;;;4754   	int retval;
;;;4755   	T(YAFFS_TRACE_CHECKPOINT,(TSTR("restore entry: isCheckpointed %d"TENDSTR),dev->isCheckpointed));
003d1a  bf00              NOP      
003d1c  bf00              NOP      
;;;4756                   
;;;4757   	retval = yaffs_ReadCheckpointData(dev);
003d1e  4620              MOV      r0,r4
003d20  f7fffffe          BL       yaffs_ReadCheckpointData
003d24  4605              MOV      r5,r0
;;;4758       
;;;4759   	if(dev->isCheckpointed){
003d26  f8d40098          LDR      r0,[r4,#0x98]
003d2a  b140              CBZ      r0,|L1.15678|
;;;4760   		yaffs_VerifyObjects(dev);
003d2c  4620              MOV      r0,r4
003d2e  f7fffffe          BL       yaffs_VerifyObjects
;;;4761   		yaffs_VerifyBlocks(dev);
003d32  4620              MOV      r0,r4
003d34  f7fffffe          BL       yaffs_VerifyBlocks
;;;4762   		yaffs_VerifyFreeChunks(dev);
003d38  4620              MOV      r0,r4
003d3a  f7fffffe          BL       yaffs_VerifyFreeChunks
                  |L1.15678|
;;;4763   	}
;;;4764   
;;;4765   	T(YAFFS_TRACE_CHECKPOINT,(TSTR("restore exit: isCheckpointed %d"TENDSTR),dev->isCheckpointed));
003d3e  bf00              NOP      
003d40  bf00              NOP      
;;;4766   	
;;;4767   	return retval;
003d42  4628              MOV      r0,r5
;;;4768   }
003d44  bd70              POP      {r4-r6,pc}
;;;4769   
                          ENDP

                  yaffs_ReadDataFromFile PROC
;;;4779   
;;;4780   int yaffs_ReadDataFromFile(yaffs_Object * in, __u8 * buffer, loff_t offset,
003d46  e92d4fff          PUSH     {r0-r11,lr}
;;;4781   			   int nBytes)
;;;4782   {
003d4a  b083              SUB      sp,sp,#0xc
003d4c  4607              MOV      r7,r0
003d4e  4688              MOV      r8,r1
003d50  4692              MOV      r10,r2
;;;4783   
;;;4784   	int chunk;
;;;4785   	__u32 start;
;;;4786   	int nToCopy;
;;;4787   	int n = nBytes;
003d52  f8dd9018          LDR      r9,[sp,#0x18]
;;;4788   	int nDone = 0;
003d56  2000              MOVS     r0,#0
003d58  9000              STR      r0,[sp,#0]
;;;4789   	yaffs_ChunkCache *cache;
;;;4790   
;;;4791   	yaffs_Device *dev;
;;;4792   
;;;4793   	dev = in->myDev;
003d5a  68be              LDR      r6,[r7,#8]
;;;4794   
;;;4795   	while (n > 0) {
003d5c  e06a              B        |L1.15924|
                  |L1.15710|
;;;4796   		//chunk = offset / dev->nDataBytesPerChunk + 1;
;;;4797   		//start = offset % dev->nDataBytesPerChunk;
;;;4798   		yaffs_AddrToChunk(dev,offset,&chunk,&start);
003d5e  ab01              ADD      r3,sp,#4
003d60  aa02              ADD      r2,sp,#8
003d62  4651              MOV      r1,r10
003d64  4630              MOV      r0,r6
003d66  f7fffffe          BL       yaffs_AddrToChunk
;;;4799   		chunk++;
003d6a  9802              LDR      r0,[sp,#8]
003d6c  1c40              ADDS     r0,r0,#1
003d6e  9002              STR      r0,[sp,#8]
;;;4800   
;;;4801   		/* OK now check for the curveball where the start and end are in
;;;4802   		 * the same chunk.      
;;;4803   		 */
;;;4804   		if ((start + n) < dev->nDataBytesPerChunk) {
003d70  9801              LDR      r0,[sp,#4]
003d72  4448              ADD      r0,r0,r9
003d74  68f1              LDR      r1,[r6,#0xc]
003d76  4288              CMP      r0,r1
003d78  d201              BCS      |L1.15742|
;;;4805   			nToCopy = n;
003d7a  464d              MOV      r5,r9
003d7c  e002              B        |L1.15748|
                  |L1.15742|
;;;4806   		} else {
;;;4807   			nToCopy = dev->nDataBytesPerChunk - start;
003d7e  68f0              LDR      r0,[r6,#0xc]
003d80  9901              LDR      r1,[sp,#4]
003d82  1a45              SUBS     r5,r0,r1
                  |L1.15748|
;;;4808   		}
;;;4809   
;;;4810   		cache = yaffs_FindChunkCache(in, chunk);
003d84  4638              MOV      r0,r7
003d86  9902              LDR      r1,[sp,#8]
003d88  f7fffffe          BL       yaffs_FindChunkCache
003d8c  4604              MOV      r4,r0
;;;4811   
;;;4812   		/* If the chunk is already in the cache or it is less than a whole chunk
;;;4813   		 * or we're using inband tags then use the cache (if there is caching)
;;;4814   		 * else bypass the cache.
;;;4815   		 */
;;;4816   		if (cache || nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
003d8e  b934              CBNZ     r4,|L1.15774|
003d90  68f0              LDR      r0,[r6,#0xc]
003d92  42a8              CMP      r0,r5
003d94  d103              BNE      |L1.15774|
003d96  f8d6008c          LDR      r0,[r6,#0x8c]
003d9a  2800              CMP      r0,#0
003d9c  d03e              BEQ      |L1.15900|
                  |L1.15774|
;;;4817   			if (dev->nShortOpCaches > 0) {
003d9e  6a70              LDR      r0,[r6,#0x24]
003da0  2800              CMP      r0,#0
003da2  dd22              BLE      |L1.15850|
;;;4818   
;;;4819   				/* If we can't find the data in the cache, then load it up. */
;;;4820   
;;;4821   				if (!cache) {
003da4  b984              CBNZ     r4,|L1.15816|
;;;4822   					cache = yaffs_GrabChunkCache(in->myDev);
003da6  68b8              LDR      r0,[r7,#8]
003da8  f7fffffe          BL       yaffs_GrabChunkCache
003dac  4604              MOV      r4,r0
;;;4823   					cache->object = in;
003dae  6027              STR      r7,[r4,#0]
;;;4824   					cache->chunkId = chunk;
003db0  9802              LDR      r0,[sp,#8]
003db2  6060              STR      r0,[r4,#4]
;;;4825   					cache->dirty = 0;
003db4  2000              MOVS     r0,#0
003db6  60e0              STR      r0,[r4,#0xc]
;;;4826   					cache->locked = 0;
003db8  6160              STR      r0,[r4,#0x14]
;;;4827   					yaffs_ReadChunkDataFromObject(in, chunk,
003dba  69a2              LDR      r2,[r4,#0x18]
003dbc  4638              MOV      r0,r7
003dbe  9902              LDR      r1,[sp,#8]
003dc0  f7fffffe          BL       yaffs_ReadChunkDataFromObject
;;;4828   								      cache->
;;;4829   								      data);
;;;4830   					cache->nBytes = 0;
003dc4  2000              MOVS     r0,#0
003dc6  6120              STR      r0,[r4,#0x10]
                  |L1.15816|
;;;4831   				}
;;;4832   
;;;4833   				yaffs_UseChunkCache(dev, cache, 0);
003dc8  2200              MOVS     r2,#0
003dca  4621              MOV      r1,r4
003dcc  4630              MOV      r0,r6
003dce  f7fffffe          BL       yaffs_UseChunkCache
;;;4834   
;;;4835   				cache->locked = 1;
003dd2  2001              MOVS     r0,#1
003dd4  6160              STR      r0,[r4,#0x14]
;;;4836   
;;;4837   
;;;4838   				memcpy(buffer, &cache->data[start], nToCopy);
003dd6  69a0              LDR      r0,[r4,#0x18]
003dd8  9a01              LDR      r2,[sp,#4]
003dda  1881              ADDS     r1,r0,r2
003ddc  462a              MOV      r2,r5
003dde  4640              MOV      r0,r8
003de0  f7fffffe          BL       __aeabi_memcpy
;;;4839   
;;;4840   				cache->locked = 0;
003de4  2000              MOVS     r0,#0
003de6  6160              STR      r0,[r4,#0x14]
003de8  e01d              B        |L1.15910|
                  |L1.15850|
;;;4841   			} else {
;;;4842   				/* Read into the local buffer then copy..*/
;;;4843   
;;;4844   				__u8 *localBuffer =
003dea  f24121ed          MOV      r1,#0x12ed
003dee  4630              MOV      r0,r6
003df0  f7fffffe          BL       yaffs_GetTempBuffer
003df4  4683              MOV      r11,r0
;;;4845   				    yaffs_GetTempBuffer(dev, __LINE__);
;;;4846   				yaffs_ReadChunkDataFromObject(in, chunk,
003df6  465a              MOV      r2,r11
003df8  4638              MOV      r0,r7
003dfa  9902              LDR      r1,[sp,#8]
003dfc  f7fffffe          BL       yaffs_ReadChunkDataFromObject
;;;4847   							      localBuffer);
;;;4848   
;;;4849   				memcpy(buffer, &localBuffer[start], nToCopy);
003e00  9801              LDR      r0,[sp,#4]
003e02  eb0b0100          ADD      r1,r11,r0
003e06  462a              MOV      r2,r5
003e08  4640              MOV      r0,r8
003e0a  f7fffffe          BL       __aeabi_memcpy
;;;4850   
;;;4851   
;;;4852   				yaffs_ReleaseTempBuffer(dev, localBuffer,
003e0e  f24122f5          MOV      r2,#0x12f5
003e12  4659              MOV      r1,r11
003e14  4630              MOV      r0,r6
003e16  f7fffffe          BL       yaffs_ReleaseTempBuffer
;;;4853   							__LINE__);
;;;4854   			}
003e1a  e004              B        |L1.15910|
                  |L1.15900|
;;;4855   
;;;4856   		} else {
;;;4857   
;;;4858   			/* A full chunk. Read directly into the supplied buffer. */
;;;4859   			yaffs_ReadChunkDataFromObject(in, chunk, buffer);
003e1c  4642              MOV      r2,r8
003e1e  4638              MOV      r0,r7
003e20  9902              LDR      r1,[sp,#8]
003e22  f7fffffe          BL       yaffs_ReadChunkDataFromObject
                  |L1.15910|
;;;4860   
;;;4861   		}
;;;4862   
;;;4863   		n -= nToCopy;
003e26  eba90905          SUB      r9,r9,r5
;;;4864   		offset += nToCopy;
003e2a  44aa              ADD      r10,r10,r5
;;;4865   		buffer += nToCopy;
003e2c  44a8              ADD      r8,r8,r5
;;;4866   		nDone += nToCopy;
003e2e  9800              LDR      r0,[sp,#0]
003e30  4428              ADD      r0,r0,r5
003e32  9000              STR      r0,[sp,#0]
                  |L1.15924|
003e34  f1b90f00          CMP      r9,#0                 ;4795
003e38  dc91              BGT      |L1.15710|
;;;4867   
;;;4868   	}
;;;4869   
;;;4870   	return nDone;
003e3a  9800              LDR      r0,[sp,#0]
;;;4871   }
003e3c  b007              ADD      sp,sp,#0x1c
003e3e  e8bd8ff0          POP      {r4-r11,pc}
;;;4872   
                          ENDP

                  yaffs_WriteDataToFile PROC
;;;4873   int yaffs_WriteDataToFile(yaffs_Object * in, const __u8 * buffer, loff_t offset,
003e42  e92d4fff          PUSH     {r0-r11,lr}
;;;4874   			  int nBytes, int writeThrough)
;;;4875   {
003e46  b089              SUB      sp,sp,#0x24
003e48  4606              MOV      r6,r0
003e4a  468b              MOV      r11,r1
003e4c  4691              MOV      r9,r2
;;;4876   
;;;4877   	int chunk;
;;;4878   	__u32 start;
;;;4879   	int nToCopy;
;;;4880           int n = nBytes;
003e4e  f8dd8030          LDR      r8,[sp,#0x30]
;;;4881           int nDone = 0;
003e52  f04f0a00          MOV      r10,#0
;;;4882           int nToWriteBack;
;;;4883           int startOfWrite = offset;
003e56  f8cd9014          STR      r9,[sp,#0x14]
;;;4884           int chunkWritten = 0;
003e5a  2000              MOVS     r0,#0
003e5c  9004              STR      r0,[sp,#0x10]
;;;4885           __u32 nBytesRead;
;;;4886           __u32 chunkStart;
;;;4887   
;;;4888   	yaffs_Device *dev;
;;;4889   
;;;4890   	dev = in->myDev;
003e5e  68b5              LDR      r5,[r6,#8]
;;;4891   
;;;4892   	while (n > 0 && chunkWritten >= 0) {
003e60  e0c9              B        |L1.16374|
                  |L1.15970|
;;;4893   		//chunk = offset / dev->nDataBytesPerChunk + 1;
;;;4894   		//start = offset % dev->nDataBytesPerChunk;
;;;4895   		yaffs_AddrToChunk(dev,offset,&chunk,&start);
003e62  ab07              ADD      r3,sp,#0x1c
003e64  aa08              ADD      r2,sp,#0x20
003e66  4649              MOV      r1,r9
003e68  4628              MOV      r0,r5
003e6a  f7fffffe          BL       yaffs_AddrToChunk
;;;4896   		
;;;4897   		if(chunk * dev->nDataBytesPerChunk + start != offset ||
003e6e  68e8              LDR      r0,[r5,#0xc]
003e70  e9dd1207          LDRD     r1,r2,[sp,#0x1c]
003e74  fb021000          MLA      r0,r2,r0,r1
003e78  4548              CMP      r0,r9
003e7a  d103              BNE      |L1.16004|
;;;4898   		   start >= dev->nDataBytesPerChunk){
003e7c  68e8              LDR      r0,[r5,#0xc]
003e7e  9907              LDR      r1,[sp,#0x1c]
003e80  4288              CMP      r0,r1
003e82  d801              BHI      |L1.16008|
                  |L1.16004|
;;;4899   		   T(YAFFS_TRACE_ERROR,(
003e84  bf00              NOP      
003e86  bf00              NOP      
                  |L1.16008|
;;;4900   			   TSTR("AddrToChunk of offset %d gives chunk %d start %d"
;;;4901   			   TENDSTR),
;;;4902   		   	   (int)offset, chunk,start));
;;;4903   		}
;;;4904   		chunk++;
003e88  9808              LDR      r0,[sp,#0x20]
003e8a  1c40              ADDS     r0,r0,#1
003e8c  9008              STR      r0,[sp,#0x20]
;;;4905   
;;;4906   		/* OK now check for the curveball where the start and end are in
;;;4907   		 * the same chunk.
;;;4908   		 */
;;;4909   
;;;4910   		if ((start + n) < dev->nDataBytesPerChunk) {
003e8e  9807              LDR      r0,[sp,#0x1c]
003e90  4440              ADD      r0,r0,r8
003e92  68e9              LDR      r1,[r5,#0xc]
003e94  4288              CMP      r0,r1
003e96  d222              BCS      |L1.16094|
;;;4911   			nToCopy = n;
003e98  4647              MOV      r7,r8
;;;4912   
;;;4913   			/* Now folks, to calculate how many bytes to write back....
;;;4914   			 * If we're overwriting and not writing to then end of file then
;;;4915   			 * we need to write back as much as was there before.
;;;4916   			 */
;;;4917   
;;;4918   			chunkStart = ((chunk - 1) * dev->nDataBytesPerChunk);
003e9a  9808              LDR      r0,[sp,#0x20]
003e9c  1e40              SUBS     r0,r0,#1
003e9e  68e9              LDR      r1,[r5,#0xc]
003ea0  4348              MULS     r0,r1,r0
003ea2  9002              STR      r0,[sp,#8]
;;;4919   
;;;4920   			if(chunkStart > in->variant.fileVariant.fileSize)
003ea4  6db1              LDR      r1,[r6,#0x58]
003ea6  9802              LDR      r0,[sp,#8]
003ea8  4281              CMP      r1,r0
003eaa  d202              BCS      |L1.16050|
;;;4921   				nBytesRead = 0; /* Past end of file */
003eac  2000              MOVS     r0,#0
003eae  9003              STR      r0,[sp,#0xc]
003eb0  e003              B        |L1.16058|
                  |L1.16050|
;;;4922   			else
;;;4923   				nBytesRead = in->variant.fileVariant.fileSize - chunkStart;
003eb2  6db1              LDR      r1,[r6,#0x58]
003eb4  9802              LDR      r0,[sp,#8]
003eb6  1a08              SUBS     r0,r1,r0
003eb8  9003              STR      r0,[sp,#0xc]
                  |L1.16058|
;;;4924   
;;;4925   			if (nBytesRead > dev->nDataBytesPerChunk) {
003eba  68e9              LDR      r1,[r5,#0xc]
003ebc  9803              LDR      r0,[sp,#0xc]
003ebe  4281              CMP      r1,r0
003ec0  d201              BCS      |L1.16070|
;;;4926   				nBytesRead = dev->nDataBytesPerChunk;
003ec2  68e8              LDR      r0,[r5,#0xc]
003ec4  9003              STR      r0,[sp,#0xc]
                  |L1.16070|
;;;4927   			}
;;;4928   
;;;4929   			nToWriteBack =
003ec6  9807              LDR      r0,[sp,#0x1c]
003ec8  eb000108          ADD      r1,r0,r8
003ecc  9803              LDR      r0,[sp,#0xc]
003ece  4281              CMP      r1,r0
003ed0  d201              BCS      |L1.16086|
;;;4930   			    (nBytesRead >
;;;4931   			     (start + n)) ? nBytesRead : (start + n);
003ed2  9803              LDR      r0,[sp,#0xc]
003ed4  e001              B        |L1.16090|
                  |L1.16086|
003ed6  9807              LDR      r0,[sp,#0x1c]
003ed8  4440              ADD      r0,r0,r8
                  |L1.16090|
003eda  9006              STR      r0,[sp,#0x18]
;;;4932   			
;;;4933   			if(nToWriteBack < 0 || nToWriteBack > dev->nDataBytesPerChunk)
003edc  e004              B        |L1.16104|
                  |L1.16094|
;;;4934   				YBUG();
;;;4935   
;;;4936   		} else {
;;;4937   			nToCopy = dev->nDataBytesPerChunk - start;
003ede  68e8              LDR      r0,[r5,#0xc]
003ee0  9907              LDR      r1,[sp,#0x1c]
003ee2  1a47              SUBS     r7,r0,r1
;;;4938   			nToWriteBack = dev->nDataBytesPerChunk;
003ee4  68e8              LDR      r0,[r5,#0xc]
003ee6  9006              STR      r0,[sp,#0x18]
                  |L1.16104|
;;;4939   		}
;;;4940   
;;;4941   		if (nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
003ee8  68e8              LDR      r0,[r5,#0xc]
003eea  42b8              CMP      r0,r7
003eec  d103              BNE      |L1.16118|
003eee  f8d5008c          LDR      r0,[r5,#0x8c]
003ef2  2800              CMP      r0,#0
003ef4  d06a              BEQ      |L1.16332|
                  |L1.16118|
;;;4942   			/* An incomplete start or end chunk (or maybe both start and end chunk), 
;;;4943   			 * or we're using inband tags, so we want to use the cache buffers.
;;;4944   			 */
;;;4945   			if (dev->nShortOpCaches > 0) {
003ef6  6a68              LDR      r0,[r5,#0x24]
003ef8  2800              CMP      r0,#0
003efa  dd46              BLE      |L1.16266|
;;;4946   				yaffs_ChunkCache *cache;
;;;4947   				/* If we can't find the data in the cache, then load the cache */
;;;4948   				cache = yaffs_FindChunkCache(in, chunk);
003efc  4630              MOV      r0,r6
003efe  9908              LDR      r1,[sp,#0x20]
003f00  f7fffffe          BL       yaffs_FindChunkCache
003f04  4604              MOV      r4,r0
;;;4949   				
;;;4950   				if (!cache
003f06  b99c              CBNZ     r4,|L1.16176|
;;;4951   				    && yaffs_CheckSpaceForAllocation(in->
003f08  68b0              LDR      r0,[r6,#8]
003f0a  f7fffffe          BL       yaffs_CheckSpaceForAllocation
003f0e  b178              CBZ      r0,|L1.16176|
;;;4952   								     myDev)) {
;;;4953   					cache = yaffs_GrabChunkCache(in->myDev);
003f10  68b0              LDR      r0,[r6,#8]
003f12  f7fffffe          BL       yaffs_GrabChunkCache
003f16  4604              MOV      r4,r0
;;;4954   					cache->object = in;
003f18  6026              STR      r6,[r4,#0]
;;;4955   					cache->chunkId = chunk;
003f1a  9808              LDR      r0,[sp,#0x20]
003f1c  6060              STR      r0,[r4,#4]
;;;4956   					cache->dirty = 0;
003f1e  2000              MOVS     r0,#0
003f20  60e0              STR      r0,[r4,#0xc]
;;;4957   					cache->locked = 0;
003f22  6160              STR      r0,[r4,#0x14]
;;;4958   					yaffs_ReadChunkDataFromObject(in, chunk,
003f24  69a2              LDR      r2,[r4,#0x18]
003f26  4630              MOV      r0,r6
003f28  9908              LDR      r1,[sp,#0x20]
003f2a  f7fffffe          BL       yaffs_ReadChunkDataFromObject
003f2e  e007              B        |L1.16192|
                  |L1.16176|
;;;4959   								      cache->
;;;4960   								      data);
;;;4961   				}
;;;4962   				else if(cache && 
003f30  b134              CBZ      r4,|L1.16192|
;;;4963   				        !cache->dirty &&
003f32  68e0              LDR      r0,[r4,#0xc]
003f34  b920              CBNZ     r0,|L1.16192|
;;;4964   					!yaffs_CheckSpaceForAllocation(in->myDev)){
003f36  68b0              LDR      r0,[r6,#8]
003f38  f7fffffe          BL       yaffs_CheckSpaceForAllocation
003f3c  b900              CBNZ     r0,|L1.16192|
;;;4965   					/* Drop the cache if it was a read cache item and
;;;4966   					 * no space check has been made for it.
;;;4967   					 */ 
;;;4968   					 cache = NULL;
003f3e  2400              MOVS     r4,#0
                  |L1.16192|
;;;4969   				}
;;;4970   
;;;4971   				if (cache) {
003f40  b1fc              CBZ      r4,|L1.16258|
;;;4972   					yaffs_UseChunkCache(dev, cache, 1);
003f42  2201              MOVS     r2,#1
003f44  4621              MOV      r1,r4
003f46  4628              MOV      r0,r5
003f48  f7fffffe          BL       yaffs_UseChunkCache
;;;4973   					cache->locked = 1;
003f4c  2001              MOVS     r0,#1
003f4e  6160              STR      r0,[r4,#0x14]
;;;4974   
;;;4975   
;;;4976   					memcpy(&cache->data[start], buffer,
003f50  69a1              LDR      r1,[r4,#0x18]
003f52  9a07              LDR      r2,[sp,#0x1c]
003f54  1888              ADDS     r0,r1,r2
003f56  463a              MOV      r2,r7
003f58  4659              MOV      r1,r11
003f5a  f7fffffe          BL       __aeabi_memcpy
;;;4977   					       nToCopy);
;;;4978   
;;;4979   
;;;4980   					cache->locked = 0;
003f5e  2000              MOVS     r0,#0
003f60  6160              STR      r0,[r4,#0x14]
;;;4981   					cache->nBytes = nToWriteBack;
003f62  9806              LDR      r0,[sp,#0x18]
003f64  6120              STR      r0,[r4,#0x10]
;;;4982   
;;;4983   					if (writeThrough) {
003f66  9816              LDR      r0,[sp,#0x58]
003f68  b170              CBZ      r0,|L1.16264|
;;;4984   						chunkWritten =
003f6a  2001              MOVS     r0,#1
003f6c  9000              STR      r0,[sp,#0]
003f6e  6923              LDR      r3,[r4,#0x10]
003f70  69a2              LDR      r2,[r4,#0x18]
003f72  e9d40100          LDRD     r0,r1,[r4,#0]
003f76  f7fffffe          BL       yaffs_WriteChunkDataToObject
003f7a  9004              STR      r0,[sp,#0x10]
;;;4985   						    yaffs_WriteChunkDataToObject
;;;4986   						    (cache->object,
;;;4987   						     cache->chunkId,
;;;4988   						     cache->data, cache->nBytes,
;;;4989   						     1);
;;;4990   						cache->dirty = 0;
003f7c  2000              MOVS     r0,#0
003f7e  60e0              STR      r0,[r4,#0xc]
003f80  e002              B        |L1.16264|
                  |L1.16258|
;;;4991   					}
;;;4992   
;;;4993   				} else {
;;;4994   					chunkWritten = -1;	/* fail the write */
003f82  f04f30ff          MOV      r0,#0xffffffff
003f86  9004              STR      r0,[sp,#0x10]
                  |L1.16264|
;;;4995   				}
;;;4996   			} else {
003f88  e02d              B        |L1.16358|
                  |L1.16266|
;;;4997   				/* An incomplete start or end chunk (or maybe both start and end chunk)
;;;4998   				 * Read into the local buffer then copy, then copy over and write back.
;;;4999   				 */
;;;5000   
;;;5001   				__u8 *localBuffer =
003f8a  f241318a          MOV      r1,#0x138a
003f8e  4628              MOV      r0,r5
003f90  f7fffffe          BL       yaffs_GetTempBuffer
003f94  4604              MOV      r4,r0
;;;5002   				    yaffs_GetTempBuffer(dev, __LINE__);
;;;5003   
;;;5004   				yaffs_ReadChunkDataFromObject(in, chunk,
003f96  4622              MOV      r2,r4
003f98  4630              MOV      r0,r6
003f9a  9908              LDR      r1,[sp,#0x20]
003f9c  f7fffffe          BL       yaffs_ReadChunkDataFromObject
;;;5005   							      localBuffer);
;;;5006   
;;;5007   
;;;5008   
;;;5009   				memcpy(&localBuffer[start], buffer, nToCopy);
003fa0  9907              LDR      r1,[sp,#0x1c]
003fa2  1860              ADDS     r0,r4,r1
003fa4  463a              MOV      r2,r7
003fa6  4659              MOV      r1,r11
003fa8  f7fffffe          BL       __aeabi_memcpy
;;;5010   
;;;5011   				chunkWritten =
003fac  2000              MOVS     r0,#0
003fae  9000              STR      r0,[sp,#0]
003fb0  4622              MOV      r2,r4
003fb2  4630              MOV      r0,r6
003fb4  9b06              LDR      r3,[sp,#0x18]
003fb6  9908              LDR      r1,[sp,#0x20]
003fb8  f7fffffe          BL       yaffs_WriteChunkDataToObject
003fbc  9004              STR      r0,[sp,#0x10]
;;;5012   				    yaffs_WriteChunkDataToObject(in, chunk,
;;;5013   								 localBuffer,
;;;5014   								 nToWriteBack,
;;;5015   								 0);
;;;5016   
;;;5017   				yaffs_ReleaseTempBuffer(dev, localBuffer,
003fbe  f241329a          MOV      r2,#0x139a
003fc2  4621              MOV      r1,r4
003fc4  4628              MOV      r0,r5
003fc6  f7fffffe          BL       yaffs_ReleaseTempBuffer
;;;5018   							__LINE__);
;;;5019   
;;;5020   			}
003fca  e00c              B        |L1.16358|
                  |L1.16332|
;;;5021   
;;;5022   		} else {
;;;5023   			/* A full chunk. Write directly from the supplied buffer. */
;;;5024   			
;;;5025   
;;;5026   
;;;5027   			chunkWritten =
003fcc  2000              MOVS     r0,#0
003fce  9000              STR      r0,[sp,#0]
003fd0  465a              MOV      r2,r11
003fd2  68eb              LDR      r3,[r5,#0xc]
003fd4  4630              MOV      r0,r6
003fd6  9908              LDR      r1,[sp,#0x20]
003fd8  f7fffffe          BL       yaffs_WriteChunkDataToObject
003fdc  9004              STR      r0,[sp,#0x10]
;;;5028   			    yaffs_WriteChunkDataToObject(in, chunk, buffer,
;;;5029   							 dev->nDataBytesPerChunk,
;;;5030   							 0);
;;;5031   
;;;5032   			/* Since we've overwritten the cached data, we better invalidate it. */
;;;5033   			yaffs_InvalidateChunkCache(in, chunk);
003fde  4630              MOV      r0,r6
003fe0  9908              LDR      r1,[sp,#0x20]
003fe2  f7fffffe          BL       yaffs_InvalidateChunkCache
                  |L1.16358|
;;;5034   		}
;;;5035   
;;;5036   		if (chunkWritten >= 0) {
003fe6  9804              LDR      r0,[sp,#0x10]
003fe8  2800              CMP      r0,#0
003fea  db04              BLT      |L1.16374|
;;;5037   			n -= nToCopy;
003fec  eba80807          SUB      r8,r8,r7
;;;5038   			offset += nToCopy;
003ff0  44b9              ADD      r9,r9,r7
;;;5039   			buffer += nToCopy;
003ff2  44bb              ADD      r11,r11,r7
;;;5040   			nDone += nToCopy;
003ff4  44ba              ADD      r10,r10,r7
                  |L1.16374|
003ff6  f1b80f00          CMP      r8,#0                 ;4892
003ffa  dd03              BLE      |L1.16388|
003ffc  9804              LDR      r0,[sp,#0x10]         ;4892
003ffe  2800              CMP      r0,#0                 ;4892
004000  f6bfaf2f          BGE      |L1.15970|
                  |L1.16388|
;;;5041   		}
;;;5042   
;;;5043   	}
;;;5044   
;;;5045   	/* Update file object */
;;;5046   
;;;5047   	if ((startOfWrite + nDone) > in->variant.fileVariant.fileSize) {
004004  9805              LDR      r0,[sp,#0x14]
004006  4450              ADD      r0,r0,r10
004008  6db1              LDR      r1,[r6,#0x58]
00400a  4288              CMP      r0,r1
00400c  d902              BLS      |L1.16404|
;;;5048   		in->variant.fileVariant.fileSize = (startOfWrite + nDone);
00400e  9805              LDR      r0,[sp,#0x14]
004010  4450              ADD      r0,r0,r10
004012  65b0              STR      r0,[r6,#0x58]
                  |L1.16404|
;;;5049   	}
;;;5050   
;;;5051   	in->dirty = 1;
004014  7830              LDRB     r0,[r6,#0]
004016  f0200040          BIC      r0,r0,#0x40
00401a  3040              ADDS     r0,r0,#0x40
00401c  7030              STRB     r0,[r6,#0]
;;;5052   
;;;5053   	return nDone;
00401e  4650              MOV      r0,r10
;;;5054   }
004020  b00d              ADD      sp,sp,#0x34
004022  e8bd8ff0          POP      {r4-r11,pc}
;;;5055   
                          ENDP

                  yaffs_FlushFile PROC
;;;5185   
;;;5186   int yaffs_FlushFile(yaffs_Object * in, int updateTime)
004026  b5f8              PUSH     {r3-r7,lr}
;;;5187   {
004028  4604              MOV      r4,r0
00402a  460e              MOV      r6,r1
;;;5188   	int retVal;
;;;5189   	if (in->dirty) {
00402c  7820              LDRB     r0,[r4,#0]
00402e  f3c01080          UBFX     r0,r0,#6,#1
004032  b190              CBZ      r0,|L1.16474|
;;;5190   		yaffs_FlushFilesChunkCache(in);
004034  4620              MOV      r0,r4
004036  f7fffffe          BL       yaffs_FlushFilesChunkCache
;;;5191   		if (updateTime) {
00403a  b116              CBZ      r6,|L1.16450|
;;;5192   #ifdef CONFIG_YAFFS_WINCE
;;;5193   			yfsd_WinFileTimeNow(in->win_mtime);
;;;5194   #else
;;;5195   
;;;5196   			in->yst_mtime = Y_CURRENT_TIME;
00403c  f7fffffe          BL       yaffsfs_CurrentTime
004040  64a0              STR      r0,[r4,#0x48]
                  |L1.16450|
;;;5197   
;;;5198   #endif
;;;5199   		}
;;;5200   
;;;5201   		retVal =
004042  2000              MOVS     r0,#0
004044  4603              MOV      r3,r0
004046  4602              MOV      r2,r0
004048  4601              MOV      r1,r0
00404a  9000              STR      r0,[sp,#0]
00404c  4620              MOV      r0,r4
00404e  f7fffffe          BL       yaffs_UpdateObjectHeader
004052  2101              MOVS     r1,#1
004054  eb0175e0          ADD      r5,r1,r0,ASR #31
004058  e000              B        |L1.16476|
                  |L1.16474|
;;;5202   		    (yaffs_UpdateObjectHeader(in, NULL, 0, 0, 0) >=
;;;5203   		     0) ? YAFFS_OK : YAFFS_FAIL;
;;;5204   	} else {
;;;5205   		retVal = YAFFS_OK;
00405a  2501              MOVS     r5,#1
                  |L1.16476|
;;;5206   	}
;;;5207   
;;;5208   	return retVal;
00405c  4628              MOV      r0,r5
;;;5209   
;;;5210   }
00405e  bdf8              POP      {r3-r7,pc}
;;;5211   
                          ENDP

                  yaffs_HandleShadowedObject PROC
;;;5436   
;;;5437   static void yaffs_HandleShadowedObject(yaffs_Device * dev, int objId,
004060  e92d41f0          PUSH     {r4-r8,lr}
;;;5438   				       int backwardScanning)
;;;5439   {
004064  4605              MOV      r5,r0
004066  460f              MOV      r7,r1
004068  4616              MOV      r6,r2
;;;5440   	yaffs_Object *obj;
;;;5441   
;;;5442   	if (!backwardScanning) {
00406a  b136              CBZ      r6,|L1.16506|
;;;5443   		/* Handle YAFFS1 forward scanning case
;;;5444   		 * For YAFFS1 we always do the deletion
;;;5445   		 */
;;;5446   
;;;5447   	} else {
;;;5448   		/* Handle YAFFS2 case (backward scanning)
;;;5449   		 * If the shadowed object exists then ignore.
;;;5450   		 */
;;;5451   		if (yaffs_FindObjectByNumber(dev, objId)) {
00406c  4639              MOV      r1,r7
00406e  4628              MOV      r0,r5
004070  f7fffffe          BL       yaffs_FindObjectByNumber
004074  b108              CBZ      r0,|L1.16506|
                  |L1.16502|
;;;5452   			return;
;;;5453   		}
;;;5454   	}
;;;5455   
;;;5456   	/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.
;;;5457   	 * We put it in unlinked dir to be cleaned up after the scanning
;;;5458   	 */
;;;5459   	obj =
;;;5460   	    yaffs_FindOrCreateObjectByNumber(dev, objId,
;;;5461   					     YAFFS_OBJECT_TYPE_FILE);
;;;5462   	if (!obj)
;;;5463   		return;
;;;5464   	yaffs_AddObjectToDirectory(dev->unlinkedDir, obj);
;;;5465   	obj->variant.fileVariant.shrinkSize = 0;
;;;5466   	obj->valid = 1;		/* So that we don't read any other info for this file */
;;;5467   
;;;5468   }
004076  e8bd81f0          POP      {r4-r8,pc}
                  |L1.16506|
00407a  2201              MOVS     r2,#1                 ;5459
00407c  4639              MOV      r1,r7                 ;5459
00407e  4628              MOV      r0,r5                 ;5459
004080  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
004084  4604              MOV      r4,r0                 ;5459
004086  b904              CBNZ     r4,|L1.16522|
004088  e7f5              B        |L1.16502|
                  |L1.16522|
00408a  4621              MOV      r1,r4                 ;5464
00408c  f8d50da0          LDR      r0,[r5,#0xda0]        ;5464
004090  f7fffffe          BL       yaffs_AddObjectToDirectory
004094  2100              MOVS     r1,#0                 ;5465
004096  6621              STR      r1,[r4,#0x60]         ;5465
004098  7820              LDRB     r0,[r4,#0]            ;5466
00409a  f0200080          BIC      r0,r0,#0x80           ;5466
00409e  3080              ADDS     r0,r0,#0x80           ;5466
0040a0  7020              STRB     r0,[r4,#0]            ;5466
0040a2  bf00              NOP      
0040a4  e7e7              B        |L1.16502|
;;;5469   
                          ENDP

                  ybicmp PROC
;;;5509   
;;;5510   static int ybicmp(const void *a, const void *b){
0040a6  b570              PUSH     {r4-r6,lr}
0040a8  4602              MOV      r2,r0
;;;5511       register int aseq = ((yaffs_BlockIndex *)a)->seq;
0040aa  6813              LDR      r3,[r2,#0]
;;;5512       register int bseq = ((yaffs_BlockIndex *)b)->seq;
0040ac  680c              LDR      r4,[r1,#0]
;;;5513       register int ablock = ((yaffs_BlockIndex *)a)->block;
0040ae  6855              LDR      r5,[r2,#4]
;;;5514       register int bblock = ((yaffs_BlockIndex *)b)->block;
0040b0  684e              LDR      r6,[r1,#4]
;;;5515       if( aseq == bseq )
0040b2  42a3              CMP      r3,r4
0040b4  d101              BNE      |L1.16570|
;;;5516           return ablock - bblock;
0040b6  1ba8              SUBS     r0,r5,r6
                  |L1.16568|
;;;5517       else
;;;5518           return aseq - bseq;
;;;5519   
;;;5520   }
0040b8  bd70              POP      {r4-r6,pc}
                  |L1.16570|
0040ba  1b18              SUBS     r0,r3,r4              ;5518
0040bc  e7fc              B        |L1.16568|
;;;5521   
                          ENDP

                  yaffs_StripDeletedObjects PROC
;;;5529   
;;;5530   static void yaffs_StripDeletedObjects(yaffs_Device *dev)
0040be  e92d41f0          PUSH     {r4-r8,lr}
;;;5531   {
0040c2  4605              MOV      r5,r0
;;;5532   	/*
;;;5533   	*  Sort out state of unlinked and deleted objects after scanning.
;;;5534   	*/
;;;5535   	struct ylist_head *i;
;;;5536   	struct ylist_head *n;
;;;5537   	yaffs_Object *l;
;;;5538   
;;;5539   	/* Soft delete all the unlinked files */
;;;5540   	ylist_for_each_safe(i, n,
0040c4  f8d50da0          LDR      r0,[r5,#0xda0]
0040c8  6d84              LDR      r4,[r0,#0x58]
0040ca  f8d50da0          LDR      r0,[r5,#0xda0]
0040ce  6d80              LDR      r0,[r0,#0x58]
0040d0  6806              LDR      r6,[r0,#0]
0040d2  e007              B        |L1.16612|
                  |L1.16596|
;;;5541   		&dev->unlinkedDir->variant.directoryVariant.children) {
;;;5542   		if (i) {
0040d4  b124              CBZ      r4,|L1.16608|
;;;5543   			l = ylist_entry(i, yaffs_Object, siblings);
0040d6  f1a40720          SUB      r7,r4,#0x20
;;;5544   			yaffs_DestroyObject(l);
0040da  4638              MOV      r0,r7
0040dc  f7fffffe          BL       yaffs_DestroyObject
                  |L1.16608|
0040e0  4634              MOV      r4,r6                 ;5540
0040e2  6836              LDR      r6,[r6,#0]            ;5540
                  |L1.16612|
0040e4  f8d50da0          LDR      r0,[r5,#0xda0]        ;5540
0040e8  3058              ADDS     r0,r0,#0x58           ;5540
0040ea  42a0              CMP      r0,r4                 ;5540
0040ec  d1f2              BNE      |L1.16596|
;;;5545   		}
;;;5546   	}
;;;5547   	
;;;5548   	ylist_for_each_safe(i, n,
0040ee  f8d50da4          LDR      r0,[r5,#0xda4]
0040f2  6d84              LDR      r4,[r0,#0x58]
0040f4  f8d50da4          LDR      r0,[r5,#0xda4]
0040f8  6d80              LDR      r0,[r0,#0x58]
0040fa  6806              LDR      r6,[r0,#0]
0040fc  e00a              B        |L1.16660|
0040fe  0000              DCW      0x0000
                  |L1.16640|
                          DCD      yaffs_freeVerificationFailures
                  |L1.16644|
;;;5549   		&dev->deletedDir->variant.directoryVariant.children) {
;;;5550   		if (i) {
004104  b124              CBZ      r4,|L1.16656|
;;;5551   			l = ylist_entry(i, yaffs_Object, siblings);
004106  f1a40720          SUB      r7,r4,#0x20
;;;5552   			yaffs_DestroyObject(l);
00410a  4638              MOV      r0,r7
00410c  f7fffffe          BL       yaffs_DestroyObject
                  |L1.16656|
004110  4634              MOV      r4,r6                 ;5548
004112  6836              LDR      r6,[r6,#0]            ;5548
                  |L1.16660|
004114  f8d50da4          LDR      r0,[r5,#0xda4]        ;5548
004118  3058              ADDS     r0,r0,#0x58           ;5548
00411a  42a0              CMP      r0,r4                 ;5548
00411c  d1f2              BNE      |L1.16644|
;;;5553   		}
;;;5554   	}
;;;5555   
;;;5556   }
00411e  e8bd81f0          POP      {r4-r8,pc}
;;;5557   
                          ENDP

                  yaffs_Scan PROC
;;;5558   static int yaffs_Scan(yaffs_Device * dev)
004122  e92d4ff0          PUSH     {r4-r11,lr}
;;;5559   {
004126  b0a1              SUB      sp,sp,#0x84
004128  4605              MOV      r5,r0
;;;5560   	yaffs_ExtendedTags tags;
;;;5561   	int blk;
;;;5562   	int blockIterator;
;;;5563   	int startIterator;
;;;5564   	int endIterator;
;;;5565   	int result;
;;;5566   
;;;5567   	int chunk;
;;;5568   	int c;
;;;5569   	int deleted;
;;;5570   	yaffs_BlockState state;
;;;5571   	yaffs_Object *hardList = NULL;
00412a  2000              MOVS     r0,#0
00412c  9007              STR      r0,[sp,#0x1c]
;;;5572   	yaffs_BlockInfo *bi;
;;;5573   	__u32 sequenceNumber;
;;;5574   	yaffs_ObjectHeader *oh;
;;;5575   	yaffs_Object *in;
;;;5576   	yaffs_Object *parent;
;;;5577   	
;;;5578   	int alloc_failed = 0;
00412e  9005              STR      r0,[sp,#0x14]
;;;5579   	
;;;5580   	struct yaffs_ShadowFixerStruct *shadowFixerList = NULL;
004130  4683              MOV      r11,r0
;;;5581   	
;;;5582   
;;;5583   	__u8 *chunkData;
;;;5584   
;;;5585   	
;;;5586   	
;;;5587   	T(YAFFS_TRACE_SCAN,
004132  bf00              NOP      
004134  bf00              NOP      
;;;5588   	  (TSTR("yaffs_Scan starts  intstartblk %d intendblk %d..." TENDSTR),
;;;5589   	   dev->internalStartBlock, dev->internalEndBlock));
;;;5590   
;;;5591   	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
004136  f24151d7          MOV      r1,#0x15d7
00413a  4628              MOV      r0,r5
00413c  f7fffffe          BL       yaffs_GetTempBuffer
004140  9004              STR      r0,[sp,#0x10]
;;;5592   
;;;5593   	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
004142  f44f5080          MOV      r0,#0x1000
004146  f8c50e10          STR      r0,[r5,#0xe10]
;;;5594   
;;;5595   	/* Scan all the blocks to determine their state */
;;;5596   	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
00414a  f8d5909c          LDR      r9,[r5,#0x9c]
00414e  e044              B        |L1.16858|
                  |L1.16720|
;;;5597   		bi = yaffs_GetBlockInfo(dev, blk);
004150  4649              MOV      r1,r9
004152  4628              MOV      r0,r5
004154  f7fffffe          BL       yaffs_GetBlockInfo
004158  4607              MOV      r7,r0
;;;5598   		yaffs_ClearChunkBits(dev, blk);
00415a  4649              MOV      r1,r9
00415c  4628              MOV      r0,r5
00415e  f7fffffe          BL       yaffs_ClearChunkBits
;;;5599   		bi->pagesInUse = 0;
004162  2100              MOVS     r1,#0
004164  6838              LDR      r0,[r7,#0]
004166  f3612093          BFI      r0,r1,#10,#10
00416a  6038              STR      r0,[r7,#0]
;;;5600   		bi->softDeletions = 0;
00416c  6838              LDR      r0,[r7,#0]
00416e  f36f0009          BFC      r0,#0,#10
004172  6038              STR      r0,[r7,#0]
;;;5601   
;;;5602   		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
004174  ab06              ADD      r3,sp,#0x18
004176  aa08              ADD      r2,sp,#0x20
004178  4649              MOV      r1,r9
00417a  4628              MOV      r0,r5
00417c  f7fffffe          BL       yaffs_QueryInitialBlockState
;;;5603   
;;;5604   		bi->blockState = state;
004180  f89d1020          LDRB     r1,[sp,#0x20]
004184  6838              LDR      r0,[r7,#0]
004186  f3615017          BFI      r0,r1,#20,#4
00418a  6038              STR      r0,[r7,#0]
;;;5605   		bi->sequenceNumber = sequenceNumber;
00418c  9806              LDR      r0,[sp,#0x18]
00418e  6078              STR      r0,[r7,#4]
;;;5606   
;;;5607   		if(bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
004190  6878              LDR      r0,[r7,#4]
004192  f5103f80          CMN      r0,#0x10000
004196  d105              BNE      |L1.16804|
;;;5608   			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
004198  2109              MOVS     r1,#9
00419a  9108              STR      r1,[sp,#0x20]
00419c  6838              LDR      r0,[r7,#0]
00419e  f3615017          BFI      r0,r1,#20,#4
0041a2  6038              STR      r0,[r7,#0]
                  |L1.16804|
;;;5609   
;;;5610   		T(YAFFS_TRACE_SCAN_DEBUG,
0041a4  bf00              NOP      
0041a6  bf00              NOP      
;;;5611   		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
;;;5612   		   state, sequenceNumber));
;;;5613   
;;;5614   		if (state == YAFFS_BLOCK_STATE_DEAD) {
0041a8  f89d0020          LDRB     r0,[sp,#0x20]
0041ac  2809              CMP      r0,#9
0041ae  d101              BNE      |L1.16820|
;;;5615   			T(YAFFS_TRACE_BAD_BLOCKS,
0041b0  bf00              NOP      
0041b2  e010              B        |L1.16854|
                  |L1.16820|
;;;5616   			  (TSTR("block %d is bad" TENDSTR), blk));
;;;5617   		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
0041b4  f89d0020          LDRB     r0,[sp,#0x20]
0041b8  2803              CMP      r0,#3
0041ba  d10c              BNE      |L1.16854|
;;;5618   			T(YAFFS_TRACE_SCAN_DEBUG,
0041bc  bf00              NOP      
0041be  bf00              NOP      
;;;5619   			  (TSTR("Block empty " TENDSTR)));
;;;5620   			dev->nErasedBlocks++;
0041c0  f8d500f4          LDR      r0,[r5,#0xf4]
0041c4  1c40              ADDS     r0,r0,#1
0041c6  f8c500f4          STR      r0,[r5,#0xf4]
;;;5621   			dev->nFreeChunks += dev->nChunksPerBlock;
0041ca  6929              LDR      r1,[r5,#0x10]
0041cc  f8d50d34          LDR      r0,[r5,#0xd34]
0041d0  4408              ADD      r0,r0,r1
0041d2  f8c50d34          STR      r0,[r5,#0xd34]
                  |L1.16854|
0041d6  f1090901          ADD      r9,r9,#1              ;5596
                  |L1.16858|
0041da  f8d500a0          LDR      r0,[r5,#0xa0]         ;5596
0041de  4548              CMP      r0,r9                 ;5596
0041e0  dab6              BGE      |L1.16720|
;;;5622   		} 
;;;5623   	}
;;;5624   
;;;5625   	startIterator = dev->internalStartBlock;
0041e2  f8d5009c          LDR      r0,[r5,#0x9c]
0041e6  900d              STR      r0,[sp,#0x34]
;;;5626   	endIterator = dev->internalEndBlock;
0041e8  f8d500a0          LDR      r0,[r5,#0xa0]
0041ec  900c              STR      r0,[sp,#0x30]
;;;5627   
;;;5628   	/* For each block.... */
;;;5629   	for (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;
0041ee  980d              LDR      r0,[sp,#0x34]
0041f0  900e              STR      r0,[sp,#0x38]
0041f2  e1c3              B        |L1.17788|
                  |L1.16884|
;;;5630   	     blockIterator++) {
;;;5631   		
;;;5632   		YYIELD();
0041f4  bf00              NOP      
0041f6  bf00              NOP      
;;;5633   
;;;5634   	     	YYIELD();
0041f8  bf00              NOP      
0041fa  bf00              NOP      
;;;5635   	     	
;;;5636   		blk = blockIterator;
0041fc  f8dd9038          LDR      r9,[sp,#0x38]
;;;5637   
;;;5638   		bi = yaffs_GetBlockInfo(dev, blk);
004200  4649              MOV      r1,r9
004202  4628              MOV      r0,r5
004204  f7fffffe          BL       yaffs_GetBlockInfo
004208  4607              MOV      r7,r0
;;;5639   		state = bi->blockState;
00420a  6838              LDR      r0,[r7,#0]
00420c  f3c05003          UBFX     r0,r0,#20,#4
004210  9008              STR      r0,[sp,#0x20]
;;;5640   
;;;5641   		deleted = 0;
004212  2000              MOVS     r0,#0
004214  9009              STR      r0,[sp,#0x24]
;;;5642   
;;;5643   		/* For each chunk in each block that needs scanning....*/
;;;5644   		for (c = 0; !alloc_failed && c < dev->nChunksPerBlock &&
004216  4682              MOV      r10,r0
004218  e186              B        |L1.17704|
                  |L1.16922|
;;;5645   		     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {
;;;5646   			/* Read the tags and decide what to do */
;;;5647   			chunk = blk * dev->nChunksPerBlock + c;
00421a  6928              LDR      r0,[r5,#0x10]
00421c  fb09a000          MLA      r0,r9,r0,r10
004220  900a              STR      r0,[sp,#0x28]
;;;5648   
;;;5649   			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
004222  ab0f              ADD      r3,sp,#0x3c
004224  2200              MOVS     r2,#0
004226  4628              MOV      r0,r5
004228  990a              LDR      r1,[sp,#0x28]
00422a  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
00422e  900b              STR      r0,[sp,#0x2c]
;;;5650   							&tags);
;;;5651   
;;;5652   			/* Let's have a good look at this chunk... */
;;;5653   
;;;5654   			if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED || tags.chunkDeleted) {
004230  f89d0050          LDRB     r0,[sp,#0x50]
004234  2803              CMP      r0,#3
004236  d001              BEQ      |L1.16956|
004238  9816              LDR      r0,[sp,#0x58]
00423a  b140              CBZ      r0,|L1.16974|
                  |L1.16956|
;;;5655   				/* YAFFS1 only...
;;;5656   				 * A deleted chunk
;;;5657   				 */
;;;5658   				deleted++;
00423c  9809              LDR      r0,[sp,#0x24]
00423e  1c40              ADDS     r0,r0,#1
004240  9009              STR      r0,[sp,#0x24]
;;;5659   				dev->nFreeChunks++;
004242  f8d50d34          LDR      r0,[r5,#0xd34]
004246  1c40              ADDS     r0,r0,#1
004248  f8c50d34          STR      r0,[r5,#0xd34]
00424c  e16a              B        |L1.17700|
                  |L1.16974|
;;;5660   				/*T((" %d %d deleted\n",blk,c)); */
;;;5661   			} else if (!tags.chunkUsed) {
00424e  9810              LDR      r0,[sp,#0x40]
004250  b9e8              CBNZ     r0,|L1.17038|
;;;5662   				/* An unassigned chunk in the block
;;;5663   				 * This means that either the block is empty or 
;;;5664   				 * this is the one being allocated from
;;;5665   				 */
;;;5666   
;;;5667   				if (c == 0) {
004252  f1ba0f00          CMP      r10,#0
004256  d107              BNE      |L1.17000|
;;;5668   					/* We're looking at the first chunk in the block so the block is unused */
;;;5669   					state = YAFFS_BLOCK_STATE_EMPTY;
004258  2003              MOVS     r0,#3
00425a  9008              STR      r0,[sp,#0x20]
;;;5670   					dev->nErasedBlocks++;
00425c  f8d500f4          LDR      r0,[r5,#0xf4]
004260  1c40              ADDS     r0,r0,#1
004262  f8c500f4          STR      r0,[r5,#0xf4]
004266  e009              B        |L1.17020|
                  |L1.17000|
;;;5671   				} else {
;;;5672   					/* this is the block being allocated from */
;;;5673   					T(YAFFS_TRACE_SCAN,
004268  bf00              NOP      
00426a  bf00              NOP      
;;;5674   					  (TSTR
;;;5675   					   (" Allocating from %d %d" TENDSTR),
;;;5676   					   blk, c));
;;;5677   					state = YAFFS_BLOCK_STATE_ALLOCATING;
00426c  2004              MOVS     r0,#4
00426e  9008              STR      r0,[sp,#0x20]
;;;5678   					dev->allocationBlock = blk;
004270  f8c590f8          STR      r9,[r5,#0xf8]
;;;5679   					dev->allocationPage = c;
004274  f8c5a0fc          STR      r10,[r5,#0xfc]
;;;5680   					dev->allocationBlockFinder = blk;	
004278  f8c59100          STR      r9,[r5,#0x100]
                  |L1.17020|
;;;5681   					/* Set it to here to encourage the allocator to go forth from here. */
;;;5682   					
;;;5683   				}
;;;5684   
;;;5685   				dev->nFreeChunks += (dev->nChunksPerBlock - c);
00427c  6929              LDR      r1,[r5,#0x10]
00427e  eba1010a          SUB      r1,r1,r10
004282  f8d50d34          LDR      r0,[r5,#0xd34]
004286  4408              ADD      r0,r0,r1
004288  f8c50d34          STR      r0,[r5,#0xd34]
00428c  e14a              B        |L1.17700|
                  |L1.17038|
;;;5686   			} else if (tags.chunkId > 0) {
00428e  9812              LDR      r0,[sp,#0x48]
004290  b3a8              CBZ      r0,|L1.17150|
;;;5687   				/* chunkId > 0 so it is a data chunk... */
;;;5688   				unsigned int endpos;
;;;5689   
;;;5690   				yaffs_SetChunkBit(dev, blk, c);
004292  4652              MOV      r2,r10
004294  4649              MOV      r1,r9
004296  4628              MOV      r0,r5
004298  f7fffffe          BL       yaffs_SetChunkBit
;;;5691   				bi->pagesInUse++;
00429c  6838              LDR      r0,[r7,#0]
00429e  0a80              LSRS     r0,r0,#10
0042a0  1c40              ADDS     r0,r0,#1
0042a2  6839              LDR      r1,[r7,#0]
0042a4  f3602193          BFI      r1,r0,#10,#10
0042a8  6039              STR      r1,[r7,#0]
;;;5692   
;;;5693   				in = yaffs_FindOrCreateObjectByNumber(dev,
0042aa  2201              MOVS     r2,#1
0042ac  4628              MOV      r0,r5
0042ae  9911              LDR      r1,[sp,#0x44]
0042b0  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
0042b4  4604              MOV      r4,r0
;;;5694   								      tags.
;;;5695   								      objectId,
;;;5696   								      YAFFS_OBJECT_TYPE_FILE);
;;;5697   				/* PutChunkIntoFile checks for a clash (two data chunks with
;;;5698   				 * the same chunkId).
;;;5699   				 */
;;;5700   				 
;;;5701   				if(!in)
0042b6  b90c              CBNZ     r4,|L1.17084|
;;;5702   					alloc_failed = 1;
0042b8  2001              MOVS     r0,#1
0042ba  9005              STR      r0,[sp,#0x14]
                  |L1.17084|
;;;5703   
;;;5704   				if(in){
0042bc  b144              CBZ      r4,|L1.17104|
;;;5705   					if(!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk,1))
0042be  2301              MOVS     r3,#1
0042c0  4620              MOV      r0,r4
0042c2  9a0a              LDR      r2,[sp,#0x28]
0042c4  9912              LDR      r1,[sp,#0x48]
0042c6  f7fffffe          BL       yaffs_PutChunkIntoFile
0042ca  b908              CBNZ     r0,|L1.17104|
;;;5706   						alloc_failed = 1;
0042cc  2001              MOVS     r0,#1
0042ce  9005              STR      r0,[sp,#0x14]
                  |L1.17104|
;;;5707   				}
;;;5708   				
;;;5709   				endpos =
0042d0  e9dd0112          LDRD     r0,r1,[sp,#0x48]
0042d4  1e40              SUBS     r0,r0,#1
0042d6  68ea              LDR      r2,[r5,#0xc]
0042d8  fb001002          MLA      r0,r0,r2,r1
0042dc  9003              STR      r0,[sp,#0xc]
;;;5710   				    (tags.chunkId - 1) * dev->nDataBytesPerChunk +
;;;5711   				    tags.byteCount;
;;;5712   				if (in && 
0042de  b16c              CBZ      r4,|L1.17148|
;;;5713   				    in->variantType == YAFFS_OBJECT_TYPE_FILE
0042e0  f8940054          LDRB     r0,[r4,#0x54]
0042e4  2801              CMP      r0,#1
0042e6  d109              BNE      |L1.17148|
;;;5714   				    && in->variant.fileVariant.scannedFileSize <
0042e8  6de1              LDR      r1,[r4,#0x5c]
0042ea  9803              LDR      r0,[sp,#0xc]
0042ec  4281              CMP      r1,r0
0042ee  d205              BCS      |L1.17148|
;;;5715   				    endpos) {
;;;5716   					in->variant.fileVariant.
0042f0  9803              LDR      r0,[sp,#0xc]
0042f2  65e0              STR      r0,[r4,#0x5c]
;;;5717   					    scannedFileSize = endpos;
;;;5718   					if (!dev->useHeaderFileSize) {
0042f4  6aa8              LDR      r0,[r5,#0x28]
0042f6  b908              CBNZ     r0,|L1.17148|
;;;5719   						in->variant.fileVariant.
0042f8  6de0              LDR      r0,[r4,#0x5c]
0042fa  65a0              STR      r0,[r4,#0x58]
                  |L1.17148|
;;;5720   						    fileSize =
;;;5721   						    in->variant.fileVariant.
;;;5722   						    scannedFileSize;
;;;5723   					}
;;;5724   
;;;5725   				}
;;;5726   				/* T((" %d %d data %d %d\n",blk,c,tags.objectId,tags.chunkId));   */
;;;5727   			} else {
0042fc  e112              B        |L1.17700|
                  |L1.17150|
0042fe  e7ff              B        |L1.17152|
                  |L1.17152|
;;;5728   				/* chunkId == 0, so it is an ObjectHeader.
;;;5729   				 * Thus, we read in the object header and make the object
;;;5730   				 */
;;;5731   				yaffs_SetChunkBit(dev, blk, c);
004300  4652              MOV      r2,r10
004302  4649              MOV      r1,r9
004304  4628              MOV      r0,r5
004306  f7fffffe          BL       yaffs_SetChunkBit
;;;5732   				bi->pagesInUse++;
00430a  6838              LDR      r0,[r7,#0]
00430c  0a80              LSRS     r0,r0,#10
00430e  1c40              ADDS     r0,r0,#1
004310  6839              LDR      r1,[r7,#0]
004312  f3602193          BFI      r1,r0,#10,#10
004316  6039              STR      r1,[r7,#0]
;;;5733   
;;;5734   				result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk,
004318  2300              MOVS     r3,#0
00431a  4628              MOV      r0,r5
00431c  9a04              LDR      r2,[sp,#0x10]
00431e  990a              LDR      r1,[sp,#0x28]
004320  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
004324  900b              STR      r0,[sp,#0x2c]
;;;5735   								chunkData,
;;;5736   								NULL);
;;;5737   
;;;5738   				oh = (yaffs_ObjectHeader *) chunkData;
004326  9e04              LDR      r6,[sp,#0x10]
;;;5739   
;;;5740   				in = yaffs_FindObjectByNumber(dev,
004328  4628              MOV      r0,r5
00432a  9911              LDR      r1,[sp,#0x44]
00432c  f7fffffe          BL       yaffs_FindObjectByNumber
004330  4604              MOV      r4,r0
;;;5741   							      tags.objectId);
;;;5742   				if (in && in->variantType != oh->type) {
004332  b144              CBZ      r4,|L1.17222|
004334  f8940054          LDRB     r0,[r4,#0x54]
004338  7831              LDRB     r1,[r6,#0]
00433a  4288              CMP      r0,r1
00433c  d003              BEQ      |L1.17222|
;;;5743   					/* This should not happen, but somehow
;;;5744   					 * Wev'e ended up with an objectId that has been reused but not yet 
;;;5745   					 * deleted, and worse still it has changed type. Delete the old object.
;;;5746   					 */
;;;5747   
;;;5748   					yaffs_DestroyObject(in);
00433e  4620              MOV      r0,r4
004340  f7fffffe          BL       yaffs_DestroyObject
;;;5749   
;;;5750   					in = 0;
004344  2400              MOVS     r4,#0
                  |L1.17222|
;;;5751   				}
;;;5752   
;;;5753   				in = yaffs_FindOrCreateObjectByNumber(dev,
004346  7832              LDRB     r2,[r6,#0]
004348  4628              MOV      r0,r5
00434a  9911              LDR      r1,[sp,#0x44]
00434c  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
004350  4604              MOV      r4,r0
;;;5754   								      tags.
;;;5755   								      objectId,
;;;5756   								      oh->type);
;;;5757   
;;;5758   				if(!in)
004352  b90c              CBNZ     r4,|L1.17240|
;;;5759   					alloc_failed = 1;
004354  2001              MOVS     r0,#1
004356  9005              STR      r0,[sp,#0x14]
                  |L1.17240|
;;;5760   					
;;;5761   				if (in && oh->shadowsObject > 0) {
004358  b1d4              CBZ      r4,|L1.17296|
00435a  f8d601f8          LDR      r0,[r6,#0x1f8]
00435e  2800              CMP      r0,#0
004360  dd16              BLE      |L1.17296|
;;;5762   				
;;;5763   					struct yaffs_ShadowFixerStruct *fixer;
;;;5764   					fixer = YMALLOC(sizeof(struct yaffs_ShadowFixerStruct));
004362  200c              MOVS     r0,#0xc
004364  f7fffffe          BL       yaffs_malloc
004368  9003              STR      r0,[sp,#0xc]
;;;5765   					if(fixer){
00436a  9803              LDR      r0,[sp,#0xc]
00436c  b178              CBZ      r0,|L1.17294|
;;;5766   						fixer-> next = shadowFixerList;
00436e  9803              LDR      r0,[sp,#0xc]
004370  f8c0b008          STR      r11,[r0,#8]
;;;5767   						shadowFixerList = fixer;
004374  f8ddb00c          LDR      r11,[sp,#0xc]
;;;5768   						fixer->objectId = tags.objectId;
004378  f8ddb00c          LDR      r11,[sp,#0xc]
00437c  9811              LDR      r0,[sp,#0x44]
00437e  f8cb0000          STR      r0,[r11,#0]
;;;5769   						fixer->shadowedId = oh->shadowsObject;
004382  f8d601f8          LDR      r0,[r6,#0x1f8]
004386  f8ddb00c          LDR      r11,[sp,#0xc]
00438a  f8cb0004          STR      r0,[r11,#4]
                  |L1.17294|
;;;5770   					}
;;;5771   					
;;;5772   				}
00438e  bf00              NOP      
                  |L1.17296|
;;;5773   
;;;5774   				if (in && in->valid) {
004390  b30c              CBZ      r4,|L1.17366|
004392  7820              LDRB     r0,[r4,#0]
004394  09c0              LSRS     r0,r0,#7
004396  b1f0              CBZ      r0,|L1.17366|
;;;5775   					/* We have already filled this one. We have a duplicate and need to resolve it. */
;;;5776   
;;;5777   					unsigned existingSerial = in->serial;
004398  78a0              LDRB     r0,[r4,#2]
00439a  9003              STR      r0,[sp,#0xc]
;;;5778   					unsigned newSerial = tags.serialNumber;
00439c  9817              LDR      r0,[sp,#0x5c]
00439e  9002              STR      r0,[sp,#8]
;;;5779   
;;;5780   					if (((existingSerial + 1) & 3) == newSerial) {
0043a0  9803              LDR      r0,[sp,#0xc]
0043a2  1c40              ADDS     r0,r0,#1
0043a4  f0000103          AND      r1,r0,#3
0043a8  9802              LDR      r0,[sp,#8]
0043aa  4281              CMP      r1,r0
0043ac  d10b              BNE      |L1.17350|
;;;5781   						/* Use new one - destroy the exisiting one */
;;;5782   						yaffs_DeleteChunk(dev,
0043ae  f2416398          MOV      r3,#0x1698
0043b2  2201              MOVS     r2,#1
0043b4  4628              MOV      r0,r5
0043b6  6aa1              LDR      r1,[r4,#0x28]
0043b8  f7fffffe          BL       yaffs_DeleteChunk
;;;5783   								  in->hdrChunk,
;;;5784   								  1, __LINE__);
;;;5785   						in->valid = 0;
0043bc  7820              LDRB     r0,[r4,#0]
0043be  f0200080          BIC      r0,r0,#0x80
0043c2  7020              STRB     r0,[r4,#0]
0043c4  e006              B        |L1.17364|
                  |L1.17350|
;;;5786   					} else {
;;;5787   						/* Use existing - destroy this one. */
;;;5788   						yaffs_DeleteChunk(dev, chunk, 1,
0043c6  f241639d          MOV      r3,#0x169d
0043ca  2201              MOVS     r2,#1
0043cc  4628              MOV      r0,r5
0043ce  990a              LDR      r1,[sp,#0x28]
0043d0  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.17364|
;;;5789   								  __LINE__);
;;;5790   					}
;;;5791   				}
0043d4  bf00              NOP      
                  |L1.17366|
;;;5792   
;;;5793   				if (in && !in->valid &&
0043d6  b33c              CBZ      r4,|L1.17448|
0043d8  7820              LDRB     r0,[r4,#0]
0043da  09c0              LSRS     r0,r0,#7
0043dc  bb20              CBNZ     r0,|L1.17448|
;;;5794   				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
0043de  9811              LDR      r0,[sp,#0x44]
0043e0  2801              CMP      r0,#1
0043e2  d002              BEQ      |L1.17386|
;;;5795   				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND)) {
0043e4  9811              LDR      r0,[sp,#0x44]
0043e6  2802              CMP      r0,#2
0043e8  d11e              BNE      |L1.17448|
                  |L1.17386|
;;;5796   					/* We only load some info, don't fiddle with directory structure */
;;;5797   					in->valid = 1;
0043ea  7820              LDRB     r0,[r4,#0]
0043ec  f0200080          BIC      r0,r0,#0x80
0043f0  3080              ADDS     r0,r0,#0x80
0043f2  7020              STRB     r0,[r4,#0]
;;;5798   					in->variantType = oh->type;
0043f4  36a4              ADDS     r6,r6,#0xa4
0043f6  f8160ca4          LDRB     r0,[r6,#-0xa4]
0043fa  f8840054          STRB     r0,[r4,#0x54]
;;;5799   
;;;5800   					in->yst_mode = oh->yst_mode;
0043fe  6eb0              LDR      r0,[r6,#0x68]
004400  6360              STR      r0,[r4,#0x34]
;;;5801   #ifdef CONFIG_YAFFS_WINCE
;;;5802   					in->win_atime[0] = oh->win_atime[0];
;;;5803   					in->win_ctime[0] = oh->win_ctime[0];
;;;5804   					in->win_mtime[0] = oh->win_mtime[0];
;;;5805   					in->win_atime[1] = oh->win_atime[1];
;;;5806   					in->win_ctime[1] = oh->win_ctime[1];
;;;5807   					in->win_mtime[1] = oh->win_mtime[1];
;;;5808   #else
;;;5809   					in->yst_uid = oh->yst_uid;
004402  6ef0              LDR      r0,[r6,#0x6c]
004404  63e0              STR      r0,[r4,#0x3c]
;;;5810   					in->yst_gid = oh->yst_gid;
004406  6f30              LDR      r0,[r6,#0x70]
004408  6420              STR      r0,[r4,#0x40]
;;;5811   					in->yst_atime = oh->yst_atime;
00440a  6f70              LDR      r0,[r6,#0x74]
00440c  6460              STR      r0,[r4,#0x44]
;;;5812   					in->yst_mtime = oh->yst_mtime;
00440e  6fb0              LDR      r0,[r6,#0x78]
004410  64a0              STR      r0,[r4,#0x48]
;;;5813   					in->yst_ctime = oh->yst_ctime;
004412  6ff0              LDR      r0,[r6,#0x7c]
004414  64e0              STR      r0,[r4,#0x4c]
;;;5814   					in->yst_rdev = oh->yst_rdev;
004416  f8d60128          LDR      r0,[r6,#0x128]
00441a  3ea4              SUBS     r6,r6,#0xa4
00441c  6520              STR      r0,[r4,#0x50]
;;;5815   #endif
;;;5816   					in->hdrChunk = chunk;
00441e  980a              LDR      r0,[sp,#0x28]
004420  62a0              STR      r0,[r4,#0x28]
;;;5817   					in->serial = tags.serialNumber;
004422  9817              LDR      r0,[sp,#0x5c]
004424  70a0              STRB     r0,[r4,#2]
004426  e07d              B        |L1.17700|
                  |L1.17448|
;;;5818   
;;;5819   				} else if (in && !in->valid) {
004428  2c00              CMP      r4,#0
00442a  d07b              BEQ      |L1.17700|
00442c  7820              LDRB     r0,[r4,#0]
00442e  09c0              LSRS     r0,r0,#7
004430  2800              CMP      r0,#0
004432  d177              BNE      |L1.17700|
;;;5820   					/* we need to load this info */
;;;5821   
;;;5822   					in->valid = 1;
004434  7820              LDRB     r0,[r4,#0]
004436  f0200080          BIC      r0,r0,#0x80
00443a  3080              ADDS     r0,r0,#0x80
00443c  7020              STRB     r0,[r4,#0]
;;;5823   					in->variantType = oh->type;
00443e  36a4              ADDS     r6,r6,#0xa4
004440  f8160ca4          LDRB     r0,[r6,#-0xa4]
004444  f8840054          STRB     r0,[r4,#0x54]
;;;5824   
;;;5825   					in->yst_mode = oh->yst_mode;
004448  6eb0              LDR      r0,[r6,#0x68]
00444a  6360              STR      r0,[r4,#0x34]
;;;5826   #ifdef CONFIG_YAFFS_WINCE
;;;5827   					in->win_atime[0] = oh->win_atime[0];
;;;5828   					in->win_ctime[0] = oh->win_ctime[0];
;;;5829   					in->win_mtime[0] = oh->win_mtime[0];
;;;5830   					in->win_atime[1] = oh->win_atime[1];
;;;5831   					in->win_ctime[1] = oh->win_ctime[1];
;;;5832   					in->win_mtime[1] = oh->win_mtime[1];
;;;5833   #else
;;;5834   					in->yst_uid = oh->yst_uid;
00444c  6ef0              LDR      r0,[r6,#0x6c]
00444e  63e0              STR      r0,[r4,#0x3c]
;;;5835   					in->yst_gid = oh->yst_gid;
004450  6f30              LDR      r0,[r6,#0x70]
004452  6420              STR      r0,[r4,#0x40]
;;;5836   					in->yst_atime = oh->yst_atime;
004454  6f70              LDR      r0,[r6,#0x74]
004456  6460              STR      r0,[r4,#0x44]
;;;5837   					in->yst_mtime = oh->yst_mtime;
004458  6fb0              LDR      r0,[r6,#0x78]
00445a  64a0              STR      r0,[r4,#0x48]
;;;5838   					in->yst_ctime = oh->yst_ctime;
00445c  6ff0              LDR      r0,[r6,#0x7c]
00445e  64e0              STR      r0,[r4,#0x4c]
;;;5839   					in->yst_rdev = oh->yst_rdev;
004460  f8d60128          LDR      r0,[r6,#0x128]
004464  3ea4              SUBS     r6,r6,#0xa4
004466  6520              STR      r0,[r4,#0x50]
;;;5840   #endif
;;;5841   					in->hdrChunk = chunk;
004468  980a              LDR      r0,[sp,#0x28]
00446a  62a0              STR      r0,[r4,#0x28]
;;;5842   					in->serial = tags.serialNumber;
00446c  9817              LDR      r0,[sp,#0x5c]
00446e  70a0              STRB     r0,[r4,#2]
;;;5843   
;;;5844   					yaffs_SetObjectName(in, oh->name);
004470  f106010a          ADD      r1,r6,#0xa
004474  4620              MOV      r0,r4
004476  f7fffffe          BL       yaffs_SetObjectName
;;;5845   					in->dirty = 0;
00447a  7820              LDRB     r0,[r4,#0]
00447c  f0200040          BIC      r0,r0,#0x40
004480  7020              STRB     r0,[r4,#0]
;;;5846   
;;;5847   					/* directory stuff...
;;;5848   					 * hook up to parent
;;;5849   					 */
;;;5850   
;;;5851   					parent =
004482  2203              MOVS     r2,#3
004484  4628              MOV      r0,r5
004486  6871              LDR      r1,[r6,#4]
004488  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
00448c  4680              MOV      r8,r0
;;;5852   					    yaffs_FindOrCreateObjectByNumber
;;;5853   					    (dev, oh->parentObjectId,
;;;5854   					     YAFFS_OBJECT_TYPE_DIRECTORY);
;;;5855   					if(!parent)
00448e  f1b80f00          CMP      r8,#0
004492  d101              BNE      |L1.17560|
;;;5856   						alloc_failed = 1;
004494  2001              MOVS     r0,#1
004496  9005              STR      r0,[sp,#0x14]
                  |L1.17560|
;;;5857   					if (parent && parent->variantType ==
004498  f1b80f00          CMP      r8,#0
00449c  d00d              BEQ      |L1.17594|
00449e  f8980054          LDRB     r0,[r8,#0x54]
0044a2  b950              CBNZ     r0,|L1.17594|
;;;5858   					    YAFFS_OBJECT_TYPE_UNKNOWN) {
;;;5859                                                   /* Set up as a directory */
;;;5860                                                   parent->variantType =
0044a4  2003              MOVS     r0,#3
0044a6  f8880054          STRB     r0,[r8,#0x54]
;;;5861                                                       YAFFS_OBJECT_TYPE_DIRECTORY;
;;;5862                                                   YINIT_LIST_HEAD(&parent->variant.
0044aa  bf00              NOP      
0044ac  f1080058          ADD      r0,r8,#0x58
0044b0  f8c80058          STR      r0,[r8,#0x58]
0044b4  f8c8005c          STR      r0,[r8,#0x5c]
0044b8  e00a              B        |L1.17616|
                  |L1.17594|
;;;5863                                                                  directoryVariant.
;;;5864                                                                  children);
;;;5865                                           } else if (!parent || parent->variantType !=
0044ba  f1b80f00          CMP      r8,#0
0044be  d003              BEQ      |L1.17608|
0044c0  f8980054          LDRB     r0,[r8,#0x54]
0044c4  2803              CMP      r0,#3
0044c6  d003              BEQ      |L1.17616|
                  |L1.17608|
;;;5866   						   YAFFS_OBJECT_TYPE_DIRECTORY)
;;;5867   					{
;;;5868   						/* Hoosterman, another problem....
;;;5869   						 * We're trying to use a non-directory as a directory
;;;5870   						 */
;;;5871   
;;;5872   						T(YAFFS_TRACE_ERROR,
0044c8  bf00              NOP      
0044ca  bf00              NOP      
;;;5873   						  (TSTR
;;;5874   						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
;;;5875   						    TENDSTR)));
;;;5876   						parent = dev->lostNFoundDir;
0044cc  f8d58d88          LDR      r8,[r5,#0xd88]
                  |L1.17616|
;;;5877   					}
;;;5878   
;;;5879   					yaffs_AddObjectToDirectory(parent, in);
0044d0  4621              MOV      r1,r4
0044d2  4640              MOV      r0,r8
0044d4  f7fffffe          BL       yaffs_AddObjectToDirectory
;;;5880   
;;;5881   					if (0 && (parent == dev->deletedDir ||
0044d8  bf00              NOP      
;;;5882   						  parent == dev->unlinkedDir)) {
;;;5883   						in->deleted = 1;	/* If it is unlinked at start up then it wants deleting */
;;;5884   						dev->nDeletedFiles++;
;;;5885   					}
;;;5886   					/* Note re hardlinks.
;;;5887   					 * Since we might scan a hardlink before its equivalent object is scanned
;;;5888   					 * we put them all in a list.
;;;5889   					 * After scanning is complete, we should have all the objects, so we run through this
;;;5890   					 * list and fix up all the chains.              
;;;5891   					 */
;;;5892   
;;;5893   					switch (in->variantType) {
0044da  f8940054          LDRB     r0,[r4,#0x54]
0044de  2806              CMP      r0,#6
0044e0  d21f              BCS      |L1.17698|
0044e2  e8dff000          TBB      [pc,r0]
0044e6  0304              DCB      0x03,0x04
0044e8  14110a13          DCB      0x14,0x11,0x0a,0x13
;;;5894   					case YAFFS_OBJECT_TYPE_UNKNOWN:	
;;;5895   						/* Todo got a problem */
;;;5896   						break;
0044ec  e019              B        |L1.17698|
;;;5897   					case YAFFS_OBJECT_TYPE_FILE:
;;;5898   						if (dev->useHeaderFileSize)
0044ee  6aa8              LDR      r0,[r5,#0x28]
0044f0  b110              CBZ      r0,|L1.17656|
;;;5899   
;;;5900   							in->variant.fileVariant.
0044f2  f8d60124          LDR      r0,[r6,#0x124]
0044f6  65a0              STR      r0,[r4,#0x58]
                  |L1.17656|
;;;5901   							    fileSize =
;;;5902   							    oh->fileSize;
;;;5903   
;;;5904   						break;
0044f8  e013              B        |L1.17698|
;;;5905   					case YAFFS_OBJECT_TYPE_HARDLINK:
;;;5906   						in->variant.hardLinkVariant.
0044fa  f8d61128          LDR      r1,[r6,#0x128]
0044fe  65e1              STR      r1,[r4,#0x5c]
;;;5907                                                       equivalentObjectId =
;;;5908                                                       oh->equivalentObjectId;
;;;5909                                                   in->hardLinks.next =
004500  9807              LDR      r0,[sp,#0x1c]
004502  6160              STR      r0,[r4,#0x14]
;;;5910                                                       (struct ylist_head *)
;;;5911                                                       hardList;
;;;5912                                                   hardList = in;
004504  9407              STR      r4,[sp,#0x1c]
;;;5913                                                   break;
004506  e00c              B        |L1.17698|
;;;5914   					case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;5915   						/* Do nothing */
;;;5916   						break;
004508  e00b              B        |L1.17698|
00450a  e00b              B        |L1.17700|
;;;5917   					case YAFFS_OBJECT_TYPE_SPECIAL:
;;;5918   						/* Do nothing */
;;;5919   						break;
00450c  e009              B        |L1.17698|
;;;5920   					case YAFFS_OBJECT_TYPE_SYMLINK:	
;;;5921   						in->variant.symLinkVariant.alias =
00450e  f5067096          ADD      r0,r6,#0x12c
004512  f7fffffe          BL       yaffs_CloneString
004516  65a0              STR      r0,[r4,#0x58]
;;;5922   						    yaffs_CloneString(oh->alias);
;;;5923   						if(!in->variant.symLinkVariant.alias)
004518  6da0              LDR      r0,[r4,#0x58]
00451a  b908              CBNZ     r0,|L1.17696|
;;;5924   							alloc_failed = 1;
00451c  2001              MOVS     r0,#1
00451e  9005              STR      r0,[sp,#0x14]
                  |L1.17696|
;;;5925   						break;
004520  bf00              NOP      
                  |L1.17698|
004522  bf00              NOP                            ;5896
                  |L1.17700|
004524  f10a0a01          ADD      r10,r10,#1            ;5645
                  |L1.17704|
004528  9805              LDR      r0,[sp,#0x14]         ;5644
00452a  b938              CBNZ     r0,|L1.17724|
00452c  6928              LDR      r0,[r5,#0x10]         ;5644
00452e  4550              CMP      r0,r10                ;5644
004530  dd04              BLE      |L1.17724|
004532  f89d0020          LDRB     r0,[sp,#0x20]         ;5645
004536  2802              CMP      r0,#2                 ;5645
004538  f43fae6f          BEQ      |L1.16922|
                  |L1.17724|
;;;5926   					}
;;;5927   
;;;5928   /*
;;;5929    					if (parent == dev->deletedDir) {
;;;5930   						yaffs_DestroyObject(in);
;;;5931   						bi->hasShrinkHeader = 1;
;;;5932   					}
;;;5933   */
;;;5934   				}
;;;5935   			}
;;;5936   		}
;;;5937   
;;;5938   		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
00453c  f89d0020          LDRB     r0,[sp,#0x20]
004540  2802              CMP      r0,#2
004542  d101              BNE      |L1.17736|
;;;5939   			/* If we got this far while scanning, then the block is fully allocated.*/
;;;5940   			state = YAFFS_BLOCK_STATE_FULL;
004544  2005              MOVS     r0,#5
004546  9008              STR      r0,[sp,#0x20]
                  |L1.17736|
;;;5941   		}
;;;5942   
;;;5943   		bi->blockState = state;
004548  f89d1020          LDRB     r1,[sp,#0x20]
00454c  6838              LDR      r0,[r7,#0]
00454e  f3615017          BFI      r0,r1,#20,#4
004552  6038              STR      r0,[r7,#0]
;;;5944   
;;;5945   		/* Now let's see if it was dirty */
;;;5946   		if (bi->pagesInUse == 0 &&
004554  6838              LDR      r0,[r7,#0]
004556  f3c02089          UBFX     r0,r0,#10,#10
00455a  b960              CBNZ     r0,|L1.17782|
;;;5947   		    !bi->hasShrinkHeader &&
00455c  6838              LDR      r0,[r7,#0]
00455e  f3c07080          UBFX     r0,r0,#30,#1
004562  b940              CBNZ     r0,|L1.17782|
;;;5948   		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
004564  6838              LDR      r0,[r7,#0]
004566  f3c05003          UBFX     r0,r0,#20,#4
00456a  2805              CMP      r0,#5
00456c  d103              BNE      |L1.17782|
;;;5949   			yaffs_BlockBecameDirty(dev, blk);
00456e  4649              MOV      r1,r9
004570  4628              MOV      r0,r5
004572  f7fffffe          BL       yaffs_BlockBecameDirty
                  |L1.17782|
004576  980e              LDR      r0,[sp,#0x38]         ;5630
004578  1c40              ADDS     r0,r0,#1              ;5630
00457a  900e              STR      r0,[sp,#0x38]         ;5630
                  |L1.17788|
00457c  9805              LDR      r0,[sp,#0x14]         ;5629
00457e  b920              CBNZ     r0,|L1.17802|
004580  990c              LDR      r1,[sp,#0x30]         ;5629
004582  980e              LDR      r0,[sp,#0x38]         ;5629
004584  4288              CMP      r0,r1                 ;5629
004586  f77fae35          BLE      |L1.16884|
                  |L1.17802|
;;;5950   		}
;;;5951   
;;;5952   	}
;;;5953   
;;;5954   	
;;;5955   	/* Ok, we've done all the scanning.
;;;5956   	 * Fix up the hard link chains.
;;;5957   	 * We should now have scanned all the objects, now it's time to add these 
;;;5958   	 * hardlinks.
;;;5959   	 */
;;;5960   
;;;5961   	yaffs_HardlinkFixup(dev,hardList);
00458a  4628              MOV      r0,r5
00458c  9907              LDR      r1,[sp,#0x1c]
00458e  f7fffffe          BL       yaffs_HardlinkFixup
;;;5962   	
;;;5963   	/* Fix up any shadowed objects */
;;;5964   	{
;;;5965   		struct yaffs_ShadowFixerStruct *fixer;
;;;5966   		yaffs_Object *obj;
;;;5967   		
;;;5968   		while(shadowFixerList){
004592  e023              B        |L1.17884|
                  |L1.17812|
;;;5969   			fixer = shadowFixerList;
004594  f8cdb00c          STR      r11,[sp,#0xc]
;;;5970   			shadowFixerList = fixer->next;
004598  f8ddb00c          LDR      r11,[sp,#0xc]
00459c  f8dbb008          LDR      r11,[r11,#8]
;;;5971   			/* Complete the rename transaction by deleting the shadowed object
;;;5972   			 * then setting the object header to unshadowed.
;;;5973   			 */
;;;5974   			obj = yaffs_FindObjectByNumber(dev,fixer->shadowedId);
0045a0  9803              LDR      r0,[sp,#0xc]
0045a2  6841              LDR      r1,[r0,#4]
0045a4  4628              MOV      r0,r5
0045a6  f7fffffe          BL       yaffs_FindObjectByNumber
0045aa  9002              STR      r0,[sp,#8]
;;;5975   			if(obj)
0045ac  9802              LDR      r0,[sp,#8]
0045ae  b110              CBZ      r0,|L1.17846|
;;;5976   				yaffs_DestroyObject(obj);
0045b0  9802              LDR      r0,[sp,#8]
0045b2  f7fffffe          BL       yaffs_DestroyObject
                  |L1.17846|
;;;5977   	
;;;5978   			obj = yaffs_FindObjectByNumber(dev,fixer->objectId);
0045b6  9803              LDR      r0,[sp,#0xc]
0045b8  6801              LDR      r1,[r0,#0]
0045ba  4628              MOV      r0,r5
0045bc  f7fffffe          BL       yaffs_FindObjectByNumber
0045c0  9002              STR      r0,[sp,#8]
;;;5979   			if(obj){
0045c2  9802              LDR      r0,[sp,#8]
0045c4  b138              CBZ      r0,|L1.17878|
;;;5980   				yaffs_UpdateObjectHeader(obj,NULL,1,0,0);
0045c6  2000              MOVS     r0,#0
0045c8  4603              MOV      r3,r0
0045ca  2201              MOVS     r2,#1
0045cc  4601              MOV      r1,r0
0045ce  9000              STR      r0,[sp,#0]
0045d0  9802              LDR      r0,[sp,#8]
0045d2  f7fffffe          BL       yaffs_UpdateObjectHeader
                  |L1.17878|
;;;5981   			}
;;;5982   			
;;;5983   			YFREE(fixer);
0045d6  9803              LDR      r0,[sp,#0xc]
0045d8  f7fffffe          BL       free
                  |L1.17884|
0045dc  f1bb0f00          CMP      r11,#0                ;5968
0045e0  d1d8              BNE      |L1.17812|
;;;5984   		}
;;;5985   	}
;;;5986   
;;;5987   	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
0045e2  f2417263          MOV      r2,#0x1763
0045e6  4628              MOV      r0,r5
0045e8  9904              LDR      r1,[sp,#0x10]
0045ea  f7fffffe          BL       yaffs_ReleaseTempBuffer
;;;5988   
;;;5989   	if(alloc_failed){
0045ee  9805              LDR      r0,[sp,#0x14]
0045f0  b118              CBZ      r0,|L1.17914|
;;;5990   		return YAFFS_FAIL;
0045f2  2000              MOVS     r0,#0
                  |L1.17908|
;;;5991   	}
;;;5992   	
;;;5993   	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_Scan ends" TENDSTR)));
;;;5994   	
;;;5995   
;;;5996   	return YAFFS_OK;
;;;5997   }
0045f4  b021              ADD      sp,sp,#0x84
0045f6  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.17914|
0045fa  bf00              NOP                            ;5993
0045fc  bf00              NOP                            ;5993
0045fe  2001              MOVS     r0,#1                 ;5996
004600  e7f8              B        |L1.17908|
;;;5998   
                          ENDP

                  yaffs_ScanBackwards PROC
;;;6055   
;;;6056   static int yaffs_ScanBackwards(yaffs_Device * dev)
004602  e92d4ff0          PUSH     {r4-r11,lr}
;;;6057   {
004606  b0a7              SUB      sp,sp,#0x9c
004608  4606              MOV      r6,r0
;;;6058   	yaffs_ExtendedTags tags;
;;;6059   	int blk;
;;;6060   	int blockIterator;
;;;6061   	int startIterator;
;;;6062   	int endIterator;
;;;6063   	int nBlocksToScan = 0;
00460a  2000              MOVS     r0,#0
00460c  9011              STR      r0,[sp,#0x44]
;;;6064   
;;;6065   	int chunk;
;;;6066   	int result;
;;;6067   	int c;
;;;6068   	int deleted;
;;;6069   	yaffs_BlockState state;
;;;6070   	yaffs_Object *hardList = NULL;
00460e  900c              STR      r0,[sp,#0x30]
;;;6071   	yaffs_BlockInfo *bi;
;;;6072   	__u32 sequenceNumber;
;;;6073   	yaffs_ObjectHeader *oh;
;;;6074   	yaffs_Object *in;
;;;6075   	yaffs_Object *parent;
;;;6076   	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
004610  e9d61027          LDRD     r1,r0,[r6,#0x9c]
004614  1a40              SUBS     r0,r0,r1
004616  1c40              ADDS     r0,r0,#1
004618  900a              STR      r0,[sp,#0x28]
;;;6077   	int itsUnlinked;
;;;6078   	__u8 *chunkData;
;;;6079   	
;;;6080   	int fileSize;
;;;6081   	int isShrink;
;;;6082   	int foundChunksInBlock;
;;;6083   	int equivalentObjectId;
;;;6084   	int alloc_failed = 0;
00461a  2000              MOVS     r0,#0
00461c  9003              STR      r0,[sp,#0xc]
;;;6085   	
;;;6086   
;;;6087   	yaffs_BlockIndex *blockIndex = NULL;
00461e  4683              MOV      r11,r0
;;;6088   	int altBlockIndex = 0;
004620  9002              STR      r0,[sp,#8]
;;;6089   
;;;6090   	if (!dev->isYaffs2) {
004622  6df0              LDR      r0,[r6,#0x5c]
004624  b928              CBNZ     r0,|L1.17970|
;;;6091   		T(YAFFS_TRACE_SCAN,
004626  bf00              NOP      
004628  bf00              NOP      
;;;6092   		  (TSTR("yaffs_ScanBackwards is only for YAFFS2!" TENDSTR)));
;;;6093   		return YAFFS_FAIL;
00462a  2000              MOVS     r0,#0
                  |L1.17964|
;;;6094   	}
;;;6095   
;;;6096   	T(YAFFS_TRACE_SCAN,
;;;6097   	  (TSTR
;;;6098   	   ("yaffs_ScanBackwards starts  intstartblk %d intendblk %d..."
;;;6099   	    TENDSTR), dev->internalStartBlock, dev->internalEndBlock));
;;;6100   
;;;6101   
;;;6102   	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
;;;6103   
;;;6104   	blockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));
;;;6105   	
;;;6106   	if(!blockIndex) {
;;;6107   		blockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));
;;;6108   		altBlockIndex = 1;
;;;6109   	}
;;;6110   	
;;;6111   	if(!blockIndex) {
;;;6112   		T(YAFFS_TRACE_SCAN,
;;;6113   		  (TSTR("yaffs_Scan() could not allocate block index!" TENDSTR)));
;;;6114   		return YAFFS_FAIL;
;;;6115   	}
;;;6116   	
;;;6117   	dev->blocksInCheckpoint = 0;
;;;6118   	
;;;6119   	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
;;;6120   
;;;6121   	/* Scan all the blocks to determine their state */
;;;6122   	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
;;;6123   		bi = yaffs_GetBlockInfo(dev, blk);
;;;6124   		yaffs_ClearChunkBits(dev, blk);
;;;6125   		bi->pagesInUse = 0;
;;;6126   		bi->softDeletions = 0;
;;;6127   
;;;6128   		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
;;;6129   
;;;6130   		bi->blockState = state;
;;;6131   		bi->sequenceNumber = sequenceNumber;
;;;6132   
;;;6133   		if(bi->sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA)
;;;6134   			bi->blockState = state = YAFFS_BLOCK_STATE_CHECKPOINT;
;;;6135   		if(bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
;;;6136   			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
;;;6137   			
;;;6138   		T(YAFFS_TRACE_SCAN_DEBUG,
;;;6139   		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
;;;6140   		   state, sequenceNumber));
;;;6141   
;;;6142   		
;;;6143   		if(state == YAFFS_BLOCK_STATE_CHECKPOINT){
;;;6144   			dev->blocksInCheckpoint++;
;;;6145   			
;;;6146   		} else if (state == YAFFS_BLOCK_STATE_DEAD) {
;;;6147   			T(YAFFS_TRACE_BAD_BLOCKS,
;;;6148   			  (TSTR("block %d is bad" TENDSTR), blk));
;;;6149   		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
;;;6150   			T(YAFFS_TRACE_SCAN_DEBUG,
;;;6151   			  (TSTR("Block empty " TENDSTR)));
;;;6152   			dev->nErasedBlocks++;
;;;6153   			dev->nFreeChunks += dev->nChunksPerBlock;
;;;6154   		} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
;;;6155   
;;;6156   			/* Determine the highest sequence number */
;;;6157   			if (sequenceNumber >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
;;;6158   			    sequenceNumber < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
;;;6159   
;;;6160   				blockIndex[nBlocksToScan].seq = sequenceNumber;
;;;6161   				blockIndex[nBlocksToScan].block = blk;
;;;6162   
;;;6163   				nBlocksToScan++;
;;;6164   
;;;6165   				if (sequenceNumber >= dev->sequenceNumber) {
;;;6166   					dev->sequenceNumber = sequenceNumber;
;;;6167   				}
;;;6168   			} else {
;;;6169   				/* TODO: Nasty sequence number! */
;;;6170   				T(YAFFS_TRACE_SCAN,
;;;6171   				  (TSTR
;;;6172   				   ("Block scanning block %d has bad sequence number %d"
;;;6173   				    TENDSTR), blk, sequenceNumber));
;;;6174   
;;;6175   			}
;;;6176   		}
;;;6177   	}
;;;6178   
;;;6179   	T(YAFFS_TRACE_SCAN,
;;;6180   	(TSTR("%d blocks to be sorted..." TENDSTR), nBlocksToScan));
;;;6181   
;;;6182   
;;;6183   
;;;6184   	YYIELD();
;;;6185   
;;;6186   	/* Sort the blocks */
;;;6187   #ifndef CONFIG_YAFFS_USE_OWN_SORT
;;;6188   	{
;;;6189   		/* Use qsort now. */
;;;6190   		yaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), ybicmp);
;;;6191   	}
;;;6192   #else
;;;6193   	{
;;;6194   	 	/* Dungy old bubble sort... */
;;;6195   	 	
;;;6196   		yaffs_BlockIndex temp;
;;;6197   		int i;
;;;6198   		int j;
;;;6199   
;;;6200   		for (i = 0; i < nBlocksToScan; i++)
;;;6201   			for (j = i + 1; j < nBlocksToScan; j++)
;;;6202   				if (blockIndex[i].seq > blockIndex[j].seq) {
;;;6203   					temp = blockIndex[j];
;;;6204   					blockIndex[j] = blockIndex[i];
;;;6205   					blockIndex[i] = temp;
;;;6206   				}
;;;6207   	}
;;;6208   #endif
;;;6209   
;;;6210   	YYIELD();
;;;6211   
;;;6212       	T(YAFFS_TRACE_SCAN, (TSTR("...done" TENDSTR)));
;;;6213   
;;;6214   	/* Now scan the blocks looking at the data. */
;;;6215   	startIterator = 0;
;;;6216   	endIterator = nBlocksToScan - 1;
;;;6217   	T(YAFFS_TRACE_SCAN_DEBUG,
;;;6218   	  (TSTR("%d blocks to be scanned" TENDSTR), nBlocksToScan));
;;;6219   
;;;6220   	/* For each block.... backwards */
;;;6221   	for (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;
;;;6222   	     blockIterator--) {
;;;6223   	        /* Cooperative multitasking! This loop can run for so
;;;6224   		   long that watchdog timers expire. */
;;;6225   	        YYIELD();
;;;6226   
;;;6227   		/* get the block to scan in the correct order */
;;;6228   		blk = blockIndex[blockIterator].block;
;;;6229   
;;;6230   		bi = yaffs_GetBlockInfo(dev, blk);
;;;6231   		
;;;6232   		
;;;6233   		state = bi->blockState;
;;;6234   
;;;6235   		deleted = 0;
;;;6236   
;;;6237   		/* For each chunk in each block that needs scanning.... */
;;;6238   		foundChunksInBlock = 0;
;;;6239   		for (c = dev->nChunksPerBlock - 1; 
;;;6240   		     !alloc_failed && c >= 0 &&
;;;6241   		     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
;;;6242   		      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
;;;6243   			/* Scan backwards... 
;;;6244   			 * Read the tags and decide what to do
;;;6245   			 */
;;;6246   			
;;;6247   			chunk = blk * dev->nChunksPerBlock + c;
;;;6248   
;;;6249   			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
;;;6250   							&tags);
;;;6251   
;;;6252   			/* Let's have a good look at this chunk... */
;;;6253   
;;;6254   			if (!tags.chunkUsed) {
;;;6255   				/* An unassigned chunk in the block.
;;;6256   				 * If there are used chunks after this one, then
;;;6257   				 * it is a chunk that was skipped due to failing the erased
;;;6258   				 * check. Just skip it so that it can be deleted.
;;;6259   				 * But, more typically, We get here when this is an unallocated
;;;6260   				 * chunk and his means that either the block is empty or 
;;;6261   				 * this is the one being allocated from
;;;6262   				 */
;;;6263   
;;;6264   				if(foundChunksInBlock)
;;;6265   				{
;;;6266   					/* This is a chunk that was skipped due to failing the erased check */
;;;6267   					
;;;6268   				} else if (c == 0) {
;;;6269   					/* We're looking at the first chunk in the block so the block is unused */
;;;6270   					state = YAFFS_BLOCK_STATE_EMPTY;
;;;6271   					dev->nErasedBlocks++;
;;;6272   				} else {
;;;6273   					if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
;;;6274   					    state == YAFFS_BLOCK_STATE_ALLOCATING) {
;;;6275   					    	if(dev->sequenceNumber == bi->sequenceNumber) {
;;;6276   							/* this is the block being allocated from */
;;;6277   					    	
;;;6278   							T(YAFFS_TRACE_SCAN,
;;;6279   							  (TSTR
;;;6280   							   (" Allocating from %d %d"
;;;6281   							    TENDSTR), blk, c));
;;;6282   
;;;6283   							state = YAFFS_BLOCK_STATE_ALLOCATING;
;;;6284   							dev->allocationBlock = blk;
;;;6285   							dev->allocationPage = c;
;;;6286   							dev->allocationBlockFinder = blk;	
;;;6287   						}
;;;6288   						else {
;;;6289   							/* This is a partially written block that is not
;;;6290   							 * the current allocation block. This block must have
;;;6291   							 * had a write failure, so set up for retirement.
;;;6292   							 */
;;;6293   						  
;;;6294   							 /* bi->needsRetiring = 1; ??? TODO */
;;;6295   							 bi->gcPrioritise = 1;
;;;6296   							 						 
;;;6297   							 T(YAFFS_TRACE_ALWAYS,
;;;6298   							 (TSTR("Partially written block %d detected" TENDSTR),
;;;6299   							 blk));
;;;6300   						}
;;;6301   
;;;6302   					}
;;;6303   					 
;;;6304   				}
;;;6305   
;;;6306   				dev->nFreeChunks++;
;;;6307   				
;;;6308   			} else if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED){
;;;6309   				T(YAFFS_TRACE_SCAN,
;;;6310   				  (TSTR(" Unfixed ECC in chunk(%d:%d), chunk ignored"TENDSTR),
;;;6311   				  blk, c));
;;;6312   
;;;6313   				  dev->nFreeChunks++;
;;;6314   
;;;6315   			}else if (tags.chunkId > 0) {
;;;6316   				/* chunkId > 0 so it is a data chunk... */
;;;6317   				unsigned int endpos;
;;;6318   				__u32 chunkBase =
;;;6319   				    (tags.chunkId - 1) * dev->nDataBytesPerChunk;
;;;6320   								
;;;6321   				foundChunksInBlock = 1;
;;;6322   
;;;6323   
;;;6324   				yaffs_SetChunkBit(dev, blk, c);
;;;6325   				bi->pagesInUse++;
;;;6326   
;;;6327   				in = yaffs_FindOrCreateObjectByNumber(dev,
;;;6328   								      tags.
;;;6329   								      objectId,
;;;6330   								      YAFFS_OBJECT_TYPE_FILE);
;;;6331   				if(!in){
;;;6332   					/* Out of memory */
;;;6333   					alloc_failed = 1;
;;;6334   				}
;;;6335   				
;;;6336   				if (in &&
;;;6337   				    in->variantType == YAFFS_OBJECT_TYPE_FILE
;;;6338   				    && chunkBase <
;;;6339   				    in->variant.fileVariant.shrinkSize) {
;;;6340   					/* This has not been invalidated by a resize */
;;;6341   					if(!yaffs_PutChunkIntoFile(in, tags.chunkId,
;;;6342   							       chunk, -1)){
;;;6343   						alloc_failed = 1;
;;;6344   					}
;;;6345   
;;;6346   					/* File size is calculated by looking at the data chunks if we have not 
;;;6347   					 * seen an object header yet. Stop this practice once we find an object header.
;;;6348   					 */
;;;6349   					endpos =
;;;6350   					    (tags.chunkId -
;;;6351   					     1) * dev->nDataBytesPerChunk +
;;;6352   					    tags.byteCount;
;;;6353   					    
;;;6354   					if (!in->valid &&	/* have not got an object header yet */
;;;6355   					    in->variant.fileVariant.
;;;6356   					    scannedFileSize < endpos) {
;;;6357   						in->variant.fileVariant.
;;;6358   						    scannedFileSize = endpos;
;;;6359   						in->variant.fileVariant.
;;;6360   						    fileSize =
;;;6361   						    in->variant.fileVariant.
;;;6362   						    scannedFileSize;
;;;6363   					}
;;;6364   
;;;6365   				} else if(in) {
;;;6366   					/* This chunk has been invalidated by a resize, so delete */
;;;6367   					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
;;;6368   
;;;6369   				}
;;;6370   			} else {
;;;6371   				/* chunkId == 0, so it is an ObjectHeader.
;;;6372   				 * Thus, we read in the object header and make the object
;;;6373   				 */
;;;6374   				foundChunksInBlock = 1;
;;;6375   
;;;6376   				yaffs_SetChunkBit(dev, blk, c);
;;;6377   				bi->pagesInUse++;
;;;6378   
;;;6379   				oh = NULL;
;;;6380   				in = NULL;
;;;6381   
;;;6382   				if (tags.extraHeaderInfoAvailable) {
;;;6383   					in = yaffs_FindOrCreateObjectByNumber
;;;6384   					    (dev, tags.objectId,
;;;6385   					     tags.extraObjectType);
;;;6386   					if (!in)
;;;6387   						alloc_failed = 1;
;;;6388   				}
;;;6389   
;;;6390   				if (!in ||
;;;6391   #ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
;;;6392   				    !in->valid ||
;;;6393   #endif
;;;6394   				    tags.extraShadows ||
;;;6395   				    (!in->valid &&
;;;6396   				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
;;;6397   				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND))
;;;6398   				    ) {
;;;6399   
;;;6400   					/* If we don't have  valid info then we need to read the chunk
;;;6401   					 * TODO In future we can probably defer reading the chunk and 
;;;6402   					 * living with invalid data until needed.
;;;6403   					 */
;;;6404   
;;;6405   					result = yaffs_ReadChunkWithTagsFromNAND(dev,
;;;6406   									chunk,
;;;6407   									chunkData,
;;;6408   									NULL);
;;;6409   
;;;6410   					oh = (yaffs_ObjectHeader *) chunkData;
;;;6411   					
;;;6412   					if(dev->inbandTags){
;;;6413   						/* Fix up the header if they got corrupted by inband tags */
;;;6414   						oh->shadowsObject = oh->inbandShadowsObject;
;;;6415   						oh->isShrink = oh->inbandIsShrink;
;;;6416   					}
;;;6417   
;;;6418   					if (!in) {
;;;6419   						in = yaffs_FindOrCreateObjectByNumber(dev, tags.objectId, oh->type);
;;;6420   						if (!in)
;;;6421   							alloc_failed = 1;
;;;6422   					}
;;;6423   
;;;6424   				}
;;;6425   
;;;6426   				if (!in) {
;;;6427   					/* TODO Hoosterman we have a problem! */
;;;6428   					T(YAFFS_TRACE_ERROR,
;;;6429   					  (TSTR
;;;6430   					   ("yaffs tragedy: Could not make object for object  %d at chunk %d during scan"
;;;6431   					    TENDSTR), tags.objectId, chunk));
;;;6432   					continue;
;;;6433   				}
;;;6434   
;;;6435   				if (in->valid) {
;;;6436   					/* We have already filled this one.
;;;6437   					 * We have a duplicate that will be discarded, but 
;;;6438   					 * we first have to suck out resize info if it is a file.
;;;6439   					 */
;;;6440   
;;;6441   					if ((in->variantType == YAFFS_OBJECT_TYPE_FILE) && 
;;;6442   					     ((oh && 
;;;6443   					       oh-> type == YAFFS_OBJECT_TYPE_FILE)||
;;;6444   					      (tags.extraHeaderInfoAvailable  &&
;;;6445   					       tags.extraObjectType == YAFFS_OBJECT_TYPE_FILE))
;;;6446   					    ) {
;;;6447   						__u32 thisSize =
;;;6448   						    (oh) ? oh->fileSize : tags.
;;;6449   						    extraFileLength;
;;;6450   						__u32 parentObjectId =
;;;6451   						    (oh) ? oh->
;;;6452   						    parentObjectId : tags.
;;;6453   						    extraParentObjectId;
;;;6454   						
;;;6455   						
;;;6456   						isShrink =
;;;6457   						    (oh) ? oh->isShrink : tags.
;;;6458   						    extraIsShrinkHeader;
;;;6459   
;;;6460   						/* If it is deleted (unlinked at start also means deleted)
;;;6461   						 * we treat the file size as being zeroed at this point.
;;;6462   						 */
;;;6463   						if (parentObjectId ==
;;;6464   						    YAFFS_OBJECTID_DELETED
;;;6465   						    || parentObjectId ==
;;;6466   						    YAFFS_OBJECTID_UNLINKED) {
;;;6467   							thisSize = 0;
;;;6468   							isShrink = 1;
;;;6469   						}
;;;6470   
;;;6471   						if (isShrink &&
;;;6472   						    in->variant.fileVariant.
;;;6473   						    shrinkSize > thisSize) {
;;;6474   							in->variant.fileVariant.
;;;6475   							    shrinkSize =
;;;6476   							    thisSize;
;;;6477   						}
;;;6478   
;;;6479   						if (isShrink) {
;;;6480   							bi->hasShrinkHeader = 1;
;;;6481   						}
;;;6482   
;;;6483   					}
;;;6484   					/* Use existing - destroy this one. */
;;;6485   					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
;;;6486   
;;;6487   				}
;;;6488   
;;;6489   				if (!in->valid && in->variantType !=
;;;6490   				    (oh ? oh->type : tags.extraObjectType))
;;;6491   					T(YAFFS_TRACE_ERROR, (
;;;6492   						TSTR("yaffs tragedy: Bad object type, "
;;;6493   					    TCONT("%d != %d, for object %d at chunk ")
;;;6494   					    TCONT("%d during scan")
;;;6495   						TENDSTR), oh ?
;;;6496   					    oh->type : tags.extraObjectType,
;;;6497   					    in->variantType, tags.objectId,
;;;6498   					    chunk));
;;;6499   
;;;6500   				if (!in->valid &&
;;;6501   				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
;;;6502   				     tags.objectId ==
;;;6503   				     YAFFS_OBJECTID_LOSTNFOUND)) {
;;;6504   					/* We only load some info, don't fiddle with directory structure */
;;;6505   					in->valid = 1;
;;;6506   					
;;;6507   					if(oh) {
;;;6508   						in->variantType = oh->type;
;;;6509   
;;;6510   						in->yst_mode = oh->yst_mode;
;;;6511   #ifdef CONFIG_YAFFS_WINCE
;;;6512   						in->win_atime[0] = oh->win_atime[0];
;;;6513   						in->win_ctime[0] = oh->win_ctime[0];
;;;6514   						in->win_mtime[0] = oh->win_mtime[0];
;;;6515   						in->win_atime[1] = oh->win_atime[1];
;;;6516   						in->win_ctime[1] = oh->win_ctime[1];
;;;6517   						in->win_mtime[1] = oh->win_mtime[1];
;;;6518   #else
;;;6519   						in->yst_uid = oh->yst_uid;
;;;6520   						in->yst_gid = oh->yst_gid;
;;;6521   						in->yst_atime = oh->yst_atime;
;;;6522   						in->yst_mtime = oh->yst_mtime;
;;;6523   						in->yst_ctime = oh->yst_ctime;
;;;6524   						in->yst_rdev = oh->yst_rdev;
;;;6525   		
;;;6526   #endif
;;;6527   					} else {
;;;6528   						in->variantType = tags.extraObjectType;
;;;6529   						in->lazyLoaded = 1;
;;;6530   					}
;;;6531   
;;;6532   					in->hdrChunk = chunk;
;;;6533   
;;;6534   				} else if (!in->valid) {
;;;6535   					/* we need to load this info */
;;;6536   
;;;6537   					in->valid = 1;
;;;6538   					in->hdrChunk = chunk;
;;;6539   
;;;6540   					if(oh) {
;;;6541   						in->variantType = oh->type;
;;;6542   
;;;6543   						in->yst_mode = oh->yst_mode;
;;;6544   #ifdef CONFIG_YAFFS_WINCE
;;;6545   						in->win_atime[0] = oh->win_atime[0];
;;;6546   						in->win_ctime[0] = oh->win_ctime[0];
;;;6547   						in->win_mtime[0] = oh->win_mtime[0];
;;;6548   						in->win_atime[1] = oh->win_atime[1];
;;;6549   						in->win_ctime[1] = oh->win_ctime[1];
;;;6550   						in->win_mtime[1] = oh->win_mtime[1];
;;;6551   #else
;;;6552   						in->yst_uid = oh->yst_uid;
;;;6553   						in->yst_gid = oh->yst_gid;
;;;6554   						in->yst_atime = oh->yst_atime;
;;;6555   						in->yst_mtime = oh->yst_mtime;
;;;6556   						in->yst_ctime = oh->yst_ctime;
;;;6557   						in->yst_rdev = oh->yst_rdev;
;;;6558   #endif
;;;6559   
;;;6560   						if (oh->shadowsObject > 0) 
;;;6561   							yaffs_HandleShadowedObject(dev,
;;;6562   									   oh->
;;;6563   									   shadowsObject,
;;;6564   									   1);
;;;6565   					
;;;6566   
;;;6567   						yaffs_SetObjectName(in, oh->name);
;;;6568   						parent =
;;;6569   						    yaffs_FindOrCreateObjectByNumber
;;;6570   					    		(dev, oh->parentObjectId,
;;;6571   					     		 YAFFS_OBJECT_TYPE_DIRECTORY);
;;;6572   
;;;6573   						 fileSize = oh->fileSize;
;;;6574    						 isShrink = oh->isShrink;
;;;6575   						 equivalentObjectId = oh->equivalentObjectId;
;;;6576   
;;;6577   					}
;;;6578   					else {
;;;6579   						in->variantType = tags.extraObjectType;
;;;6580   						parent =
;;;6581   						    yaffs_FindOrCreateObjectByNumber
;;;6582   					    		(dev, tags.extraParentObjectId,
;;;6583   					     		 YAFFS_OBJECT_TYPE_DIRECTORY);
;;;6584   						 fileSize = tags.extraFileLength;
;;;6585   						 isShrink = tags.extraIsShrinkHeader;
;;;6586   						 equivalentObjectId = tags.extraEquivalentObjectId;
;;;6587   						in->lazyLoaded = 1;
;;;6588   
;;;6589   					}
;;;6590   					in->dirty = 0;
;;;6591   
;;;6592   					if (!parent)
;;;6593   						alloc_failed = 1;
;;;6594   
;;;6595   					/* directory stuff...
;;;6596   					 * hook up to parent
;;;6597   					 */
;;;6598   
;;;6599   					if (parent && parent->variantType ==
;;;6600   					    YAFFS_OBJECT_TYPE_UNKNOWN) {
;;;6601                                                   /* Set up as a directory */
;;;6602                                                   parent->variantType =
;;;6603                                                       YAFFS_OBJECT_TYPE_DIRECTORY;
;;;6604                                                   YINIT_LIST_HEAD(&parent->variant.
;;;6605                                                                  directoryVariant.
;;;6606                                                                  children);
;;;6607                                           } else if (!parent || parent->variantType !=
;;;6608   						   YAFFS_OBJECT_TYPE_DIRECTORY)
;;;6609   					{
;;;6610   						/* Hoosterman, another problem....
;;;6611   						 * We're trying to use a non-directory as a directory
;;;6612   						 */
;;;6613   
;;;6614   						T(YAFFS_TRACE_ERROR,
;;;6615   						  (TSTR
;;;6616   						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
;;;6617   						    TENDSTR)));
;;;6618   						parent = dev->lostNFoundDir;
;;;6619   					}
;;;6620   
;;;6621   					yaffs_AddObjectToDirectory(parent, in);
;;;6622   
;;;6623   					itsUnlinked = (parent == dev->deletedDir) ||
;;;6624   						      (parent == dev->unlinkedDir);
;;;6625   
;;;6626   					if (isShrink) {
;;;6627   						/* Mark the block as having a shrinkHeader */
;;;6628   						bi->hasShrinkHeader = 1;
;;;6629   					}
;;;6630   
;;;6631   					/* Note re hardlinks.
;;;6632   					 * Since we might scan a hardlink before its equivalent object is scanned
;;;6633   					 * we put them all in a list.
;;;6634   					 * After scanning is complete, we should have all the objects, so we run
;;;6635   					 * through this list and fix up all the chains.              
;;;6636   					 */
;;;6637   
;;;6638   					switch (in->variantType) {
;;;6639   					case YAFFS_OBJECT_TYPE_UNKNOWN:	
;;;6640   						/* Todo got a problem */
;;;6641   						break;
;;;6642   					case YAFFS_OBJECT_TYPE_FILE:
;;;6643   
;;;6644   						if (in->variant.fileVariant.
;;;6645   						    scannedFileSize < fileSize) {
;;;6646   							/* This covers the case where the file size is greater
;;;6647   							 * than where the data is
;;;6648   							 * This will happen if the file is resized to be larger 
;;;6649   							 * than its current data extents.
;;;6650   							 */
;;;6651   							in->variant.fileVariant.fileSize = fileSize;
;;;6652   							in->variant.fileVariant.scannedFileSize =
;;;6653   							    in->variant.fileVariant.fileSize;
;;;6654   						}
;;;6655   
;;;6656   						if (isShrink &&
;;;6657   						    in->variant.fileVariant.shrinkSize > fileSize) {
;;;6658   							in->variant.fileVariant.shrinkSize = fileSize;
;;;6659   						}
;;;6660   
;;;6661   						break;
;;;6662   					case YAFFS_OBJECT_TYPE_HARDLINK:
;;;6663   						if(!itsUnlinked) {
;;;6664                                                     in->variant.hardLinkVariant.equivalentObjectId =
;;;6665                                                       equivalentObjectId;
;;;6666                                                     in->hardLinks.next =
;;;6667                                                       (struct ylist_head *) hardList;
;;;6668                                                     hardList = in;
;;;6669                                                   }
;;;6670                                                   break;
;;;6671   					case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;6672   						/* Do nothing */
;;;6673   						break;
;;;6674   					case YAFFS_OBJECT_TYPE_SPECIAL:
;;;6675   						/* Do nothing */
;;;6676   						break;
;;;6677   					case YAFFS_OBJECT_TYPE_SYMLINK:
;;;6678   						if(oh){
;;;6679   						   in->variant.symLinkVariant.alias =
;;;6680   						    yaffs_CloneString(oh->
;;;6681   								      alias);
;;;6682   						   if(!in->variant.symLinkVariant.alias)
;;;6683   						   	alloc_failed = 1;
;;;6684   						}
;;;6685   						break;
;;;6686   					}
;;;6687   
;;;6688   				}
;;;6689   				
;;;6690   			}
;;;6691   
;;;6692   		} /* End of scanning for each chunk */
;;;6693   
;;;6694   		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
;;;6695   			/* If we got this far while scanning, then the block is fully allocated. */
;;;6696   			state = YAFFS_BLOCK_STATE_FULL;
;;;6697   		}
;;;6698   
;;;6699   		bi->blockState = state;
;;;6700   
;;;6701   		/* Now let's see if it was dirty */
;;;6702   		if (bi->pagesInUse == 0 &&
;;;6703   		    !bi->hasShrinkHeader &&
;;;6704   		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
;;;6705   			yaffs_BlockBecameDirty(dev, blk);
;;;6706   		}
;;;6707   
;;;6708   	}
;;;6709   
;;;6710   	if (altBlockIndex) 
;;;6711   		YFREE_ALT(blockIndex);
;;;6712   	else
;;;6713   		YFREE(blockIndex);
;;;6714   	
;;;6715   	/* Ok, we've done all the scanning.
;;;6716   	 * Fix up the hard link chains.
;;;6717   	 * We should now have scanned all the objects, now it's time to add these 
;;;6718   	 * hardlinks.
;;;6719   	 */
;;;6720   	yaffs_HardlinkFixup(dev,hardList);
;;;6721   	
;;;6722   
;;;6723   	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
;;;6724   	
;;;6725   	if(alloc_failed){
;;;6726   		return YAFFS_FAIL;
;;;6727   	}
;;;6728   
;;;6729   	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_ScanBackwards ends" TENDSTR)));
;;;6730   
;;;6731   	return YAFFS_OK;
;;;6732   }
00462c  b027              ADD      sp,sp,#0x9c
00462e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.17970|
004632  bf00              NOP                            ;6096
004634  bf00              NOP                            ;6096
004636  f44f5080          MOV      r0,#0x1000            ;6102
00463a  f8c60e10          STR      r0,[r6,#0xe10]        ;6102
00463e  990a              LDR      r1,[sp,#0x28]         ;6104
004640  00c8              LSLS     r0,r1,#3              ;6104
004642  f7fffffe          BL       yaffs_malloc
004646  4683              MOV      r11,r0                ;6104
004648  f1bb0f00          CMP      r11,#0                ;6106
00464c  d106              BNE      |L1.18012|
00464e  990a              LDR      r1,[sp,#0x28]         ;6107
004650  00c8              LSLS     r0,r1,#3              ;6107
004652  f7fffffe          BL       yaffs_malloc
004656  4683              MOV      r11,r0                ;6107
004658  2001              MOVS     r0,#1                 ;6108
00465a  9002              STR      r0,[sp,#8]            ;6108
                  |L1.18012|
00465c  f1bb0f00          CMP      r11,#0                ;6111
004660  d103              BNE      |L1.18026|
004662  bf00              NOP                            ;6112
004664  bf00              NOP                            ;6112
004666  2000              MOVS     r0,#0                 ;6114
004668  e7e0              B        |L1.17964|
                  |L1.18026|
00466a  2000              MOVS     r0,#0                 ;6117
00466c  f8c600c0          STR      r0,[r6,#0xc0]         ;6117
004670  f24171e7          MOV      r1,#0x17e7            ;6119
004674  4630              MOV      r0,r6                 ;6119
004676  f7fffffe          BL       yaffs_GetTempBuffer
00467a  9008              STR      r0,[sp,#0x20]         ;6119
00467c  f8d6909c          LDR      r9,[r6,#0x9c]         ;6122
004680  e07b              B        |L1.18298|
                  |L1.18050|
004682  4649              MOV      r1,r9                 ;6123
004684  4630              MOV      r0,r6                 ;6123
004686  f7fffffe          BL       yaffs_GetBlockInfo
00468a  4607              MOV      r7,r0                 ;6123
00468c  4649              MOV      r1,r9                 ;6124
00468e  4630              MOV      r0,r6                 ;6124
004690  f7fffffe          BL       yaffs_ClearChunkBits
004694  2100              MOVS     r1,#0                 ;6125
004696  6838              LDR      r0,[r7,#0]            ;6125
004698  f3612093          BFI      r0,r1,#10,#10         ;6125
00469c  6038              STR      r0,[r7,#0]            ;6125
00469e  6838              LDR      r0,[r7,#0]            ;6126
0046a0  f36f0009          BFC      r0,#0,#10             ;6126
0046a4  6038              STR      r0,[r7,#0]            ;6126
0046a6  ab0b              ADD      r3,sp,#0x2c           ;6128
0046a8  aa0d              ADD      r2,sp,#0x34           ;6128
0046aa  4649              MOV      r1,r9                 ;6128
0046ac  4630              MOV      r0,r6                 ;6128
0046ae  f7fffffe          BL       yaffs_QueryInitialBlockState
0046b2  f89d1034          LDRB     r1,[sp,#0x34]         ;6130
0046b6  6838              LDR      r0,[r7,#0]            ;6130
0046b8  f3615017          BFI      r0,r1,#20,#4          ;6130
0046bc  6038              STR      r0,[r7,#0]            ;6130
0046be  980b              LDR      r0,[sp,#0x2c]         ;6131
0046c0  6078              STR      r0,[r7,#4]            ;6131
0046c2  6878              LDR      r0,[r7,#4]            ;6133
0046c4  2821              CMP      r0,#0x21              ;6133
0046c6  d105              BNE      |L1.18132|
0046c8  2107              MOVS     r1,#7                 ;6134
0046ca  910d              STR      r1,[sp,#0x34]         ;6134
0046cc  6838              LDR      r0,[r7,#0]            ;6134
0046ce  f3615017          BFI      r0,r1,#20,#4          ;6134
0046d2  6038              STR      r0,[r7,#0]            ;6134
                  |L1.18132|
0046d4  6878              LDR      r0,[r7,#4]            ;6135
0046d6  f5103f80          CMN      r0,#0x10000           ;6135
0046da  d105              BNE      |L1.18152|
0046dc  2109              MOVS     r1,#9                 ;6136
0046de  910d              STR      r1,[sp,#0x34]         ;6136
0046e0  6838              LDR      r0,[r7,#0]            ;6136
0046e2  f3615017          BFI      r0,r1,#20,#4          ;6136
0046e6  6038              STR      r0,[r7,#0]            ;6136
                  |L1.18152|
0046e8  bf00              NOP                            ;6138
0046ea  bf00              NOP                            ;6138
0046ec  f89d0034          LDRB     r0,[sp,#0x34]         ;6143
0046f0  2807              CMP      r0,#7                 ;6143
0046f2  d105              BNE      |L1.18176|
0046f4  f8d600c0          LDR      r0,[r6,#0xc0]         ;6144
0046f8  1c40              ADDS     r0,r0,#1              ;6144
0046fa  f8c600c0          STR      r0,[r6,#0xc0]         ;6144
0046fe  e03a              B        |L1.18294|
                  |L1.18176|
004700  f89d0034          LDRB     r0,[sp,#0x34]         ;6146
004704  2809              CMP      r0,#9                 ;6146
004706  d101              BNE      |L1.18188|
004708  bf00              NOP                            ;6147
00470a  e034              B        |L1.18294|
                  |L1.18188|
00470c  f89d0034          LDRB     r0,[sp,#0x34]         ;6149
004710  2803              CMP      r0,#3                 ;6149
004712  d10d              BNE      |L1.18224|
004714  bf00              NOP                            ;6150
004716  bf00              NOP                            ;6150
004718  f8d600f4          LDR      r0,[r6,#0xf4]         ;6152
00471c  1c40              ADDS     r0,r0,#1              ;6152
00471e  f8c600f4          STR      r0,[r6,#0xf4]         ;6152
004722  6931              LDR      r1,[r6,#0x10]         ;6153
004724  f8d60d34          LDR      r0,[r6,#0xd34]        ;6153
004728  4408              ADD      r0,r0,r1              ;6153
00472a  f8c60d34          STR      r0,[r6,#0xd34]        ;6153
00472e  e022              B        |L1.18294|
                  |L1.18224|
004730  f89d0034          LDRB     r0,[sp,#0x34]         ;6154
004734  2802              CMP      r0,#2                 ;6154
004736  d11e              BNE      |L1.18294|
004738  980b              LDR      r0,[sp,#0x2c]         ;6157
00473a  f5b05f80          CMP      r0,#0x1000            ;6157
00473e  d318              BCC      |L1.18290|
004740  49f9              LDR      r1,|L1.19240|
004742  980b              LDR      r0,[sp,#0x2c]         ;6158
004744  4288              CMP      r0,r1                 ;6158
004746  d214              BCS      |L1.18290|
004748  990b              LDR      r1,[sp,#0x2c]         ;6160
00474a  9811              LDR      r0,[sp,#0x44]         ;6160
00474c  f84b1030          STR      r1,[r11,r0,LSL #3]    ;6160
004750  9811              LDR      r0,[sp,#0x44]         ;6161
004752  eb0b00c0          ADD      r0,r11,r0,LSL #3      ;6161
004756  f8c09004          STR      r9,[r0,#4]            ;6161
00475a  9811              LDR      r0,[sp,#0x44]         ;6163
00475c  1c40              ADDS     r0,r0,#1              ;6163
00475e  9011              STR      r0,[sp,#0x44]         ;6163
004760  f8d60e10          LDR      r0,[r6,#0xe10]        ;6165
004764  990b              LDR      r1,[sp,#0x2c]         ;6165
004766  4288              CMP      r0,r1                 ;6165
004768  d805              BHI      |L1.18294|
00476a  980b              LDR      r0,[sp,#0x2c]         ;6166
00476c  f8c60e10          STR      r0,[r6,#0xe10]        ;6166
004770  e001              B        |L1.18294|
                  |L1.18290|
004772  bf00              NOP                            ;6170
004774  bf00              NOP                            ;6170
                  |L1.18294|
004776  f1090901          ADD      r9,r9,#1              ;6122
                  |L1.18298|
00477a  f8d600a0          LDR      r0,[r6,#0xa0]         ;6122
00477e  4548              CMP      r0,r9                 ;6122
004780  f6bfaf7f          BGE      |L1.18050|
004784  bf00              NOP                            ;6179
004786  bf00              NOP                            ;6179
004788  bf00              NOP                            ;6184
00478a  bf00              NOP                            ;6184
00478c  4be7              LDR      r3,|L1.19244|
00478e  2208              MOVS     r2,#8                 ;6190
004790  4658              MOV      r0,r11                ;6190
004792  9911              LDR      r1,[sp,#0x44]         ;6190
004794  f7fffffe          BL       yaffs_qsort
004798  bf00              NOP                            ;6210
00479a  bf00              NOP                            ;6210
00479c  bf00              NOP                            ;6212
00479e  bf00              NOP                            ;6212
0047a0  2000              MOVS     r0,#0                 ;6215
0047a2  9013              STR      r0,[sp,#0x4c]         ;6215
0047a4  9811              LDR      r0,[sp,#0x44]         ;6216
0047a6  1e40              SUBS     r0,r0,#1              ;6216
0047a8  9012              STR      r0,[sp,#0x48]         ;6216
0047aa  bf00              NOP                            ;6217
0047ac  bf00              NOP                            ;6217
0047ae  9812              LDR      r0,[sp,#0x48]         ;6221
0047b0  9014              STR      r0,[sp,#0x50]         ;6221
0047b2  e272              B        |L1.19610|
                  |L1.18356|
0047b4  bf00              NOP                            ;6225
0047b6  bf00              NOP                            ;6225
0047b8  9814              LDR      r0,[sp,#0x50]         ;6228
0047ba  eb0b00c0          ADD      r0,r11,r0,LSL #3      ;6228
0047be  f8d09004          LDR      r9,[r0,#4]            ;6228
0047c2  4649              MOV      r1,r9                 ;6230
0047c4  4630              MOV      r0,r6                 ;6230
0047c6  f7fffffe          BL       yaffs_GetBlockInfo
0047ca  4607              MOV      r7,r0                 ;6230
0047cc  6838              LDR      r0,[r7,#0]            ;6233
0047ce  f3c05003          UBFX     r0,r0,#20,#4          ;6233
0047d2  900d              STR      r0,[sp,#0x34]         ;6233
0047d4  2000              MOVS     r0,#0                 ;6235
0047d6  900e              STR      r0,[sp,#0x38]         ;6235
0047d8  9005              STR      r0,[sp,#0x14]         ;6238
0047da  6930              LDR      r0,[r6,#0x10]         ;6239
0047dc  f1a00a01          SUB      r10,r0,#1             ;6239
0047e0  e22d              B        |L1.19518|
                  |L1.18402|
0047e2  6930              LDR      r0,[r6,#0x10]         ;6247
0047e4  fb09a000          MLA      r0,r9,r0,r10          ;6247
0047e8  9010              STR      r0,[sp,#0x40]         ;6247
0047ea  ab15              ADD      r3,sp,#0x54           ;6249
0047ec  2200              MOVS     r2,#0                 ;6249
0047ee  4630              MOV      r0,r6                 ;6249
0047f0  9910              LDR      r1,[sp,#0x40]         ;6249
0047f2  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
0047f6  900f              STR      r0,[sp,#0x3c]         ;6249
0047f8  9816              LDR      r0,[sp,#0x58]         ;6254
0047fa  bb90              CBNZ     r0,|L1.18530|
0047fc  9805              LDR      r0,[sp,#0x14]         ;6264
0047fe  bb08              CBNZ     r0,|L1.18500|
004800  f1ba0f00          CMP      r10,#0                ;6268
004804  d107              BNE      |L1.18454|
004806  2003              MOVS     r0,#3                 ;6270
004808  900d              STR      r0,[sp,#0x34]         ;6270
00480a  f8d600f4          LDR      r0,[r6,#0xf4]         ;6271
00480e  1c40              ADDS     r0,r0,#1              ;6271
004810  f8c600f4          STR      r0,[r6,#0xf4]         ;6271
004814  e01f              B        |L1.18518|
                  |L1.18454|
004816  f89d0034          LDRB     r0,[sp,#0x34]         ;6273
00481a  2802              CMP      r0,#2                 ;6273
00481c  d003              BEQ      |L1.18470|
00481e  f89d0034          LDRB     r0,[sp,#0x34]         ;6274
004822  2804              CMP      r0,#4                 ;6274
004824  d117              BNE      |L1.18518|
                  |L1.18470|
004826  f8d60e10          LDR      r0,[r6,#0xe10]        ;6275
00482a  6879              LDR      r1,[r7,#4]            ;6275
00482c  4288              CMP      r0,r1                 ;6275
00482e  d10a              BNE      |L1.18502|
004830  bf00              NOP                            ;6278
004832  bf00              NOP                            ;6278
004834  2004              MOVS     r0,#4                 ;6283
004836  900d              STR      r0,[sp,#0x34]         ;6283
004838  f8c690f8          STR      r9,[r6,#0xf8]         ;6284
00483c  f8c6a0fc          STR      r10,[r6,#0xfc]        ;6285
004840  f8c69100          STR      r9,[r6,#0x100]        ;6286
                  |L1.18500|
004844  e007              B        |L1.18518|
                  |L1.18502|
004846  6838              LDR      r0,[r7,#0]            ;6295
004848  f0206080          BIC      r0,r0,#0x4000000      ;6295
00484c  f1006080          ADD      r0,r0,#0x4000000      ;6295
004850  6038              STR      r0,[r7,#0]            ;6295
004852  bf00              NOP                            ;6297
004854  bf00              NOP                            ;6297
                  |L1.18518|
004856  f8d60d34          LDR      r0,[r6,#0xd34]        ;6306
00485a  1c40              ADDS     r0,r0,#1              ;6306
00485c  f8c60d34          STR      r0,[r6,#0xd34]        ;6306
004860  e1ea              B        |L1.19512|
                  |L1.18530|
004862  e7ff              B        |L1.18532|
                  |L1.18532|
004864  f89d0068          LDRB     r0,[sp,#0x68]         ;6308
004868  2803              CMP      r0,#3                 ;6308
00486a  d107              BNE      |L1.18556|
00486c  bf00              NOP                            ;6309
00486e  bf00              NOP                            ;6309
004870  f8d60d34          LDR      r0,[r6,#0xd34]        ;6313
004874  1c40              ADDS     r0,r0,#1              ;6313
004876  f8c60d34          STR      r0,[r6,#0xd34]        ;6313
00487a  e1dd              B        |L1.19512|
                  |L1.18556|
00487c  9818              LDR      r0,[sp,#0x60]         ;6315
00487e  b3e8              CBZ      r0,|L1.18684|
004880  9818              LDR      r0,[sp,#0x60]         ;6318
004882  1e40              SUBS     r0,r0,#1              ;6318
004884  68f1              LDR      r1,[r6,#0xc]          ;6318
004886  4348              MULS     r0,r1,r0              ;6318
004888  9000              STR      r0,[sp,#0]            ;6318
00488a  2001              MOVS     r0,#1                 ;6321
00488c  9005              STR      r0,[sp,#0x14]         ;6321
00488e  4652              MOV      r2,r10                ;6324
004890  4649              MOV      r1,r9                 ;6324
004892  4630              MOV      r0,r6                 ;6324
004894  f7fffffe          BL       yaffs_SetChunkBit
004898  6838              LDR      r0,[r7,#0]            ;6325
00489a  0a80              LSRS     r0,r0,#10             ;6325
00489c  1c40              ADDS     r0,r0,#1              ;6325
00489e  6839              LDR      r1,[r7,#0]            ;6325
0048a0  f3602193          BFI      r1,r0,#10,#10         ;6325
0048a4  6039              STR      r1,[r7,#0]            ;6325
0048a6  2201              MOVS     r2,#1                 ;6327
0048a8  4630              MOV      r0,r6                 ;6327
0048aa  9917              LDR      r1,[sp,#0x5c]         ;6327
0048ac  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
0048b0  4604              MOV      r4,r0                 ;6327
0048b2  b90c              CBNZ     r4,|L1.18616|
0048b4  2001              MOVS     r0,#1                 ;6333
0048b6  9003              STR      r0,[sp,#0xc]          ;6333
                  |L1.18616|
0048b8  b334              CBZ      r4,|L1.18696|
0048ba  f8940054          LDRB     r0,[r4,#0x54]         ;6337
0048be  2801              CMP      r0,#1                 ;6337
0048c0  d122              BNE      |L1.18696|
0048c2  6e21              LDR      r1,[r4,#0x60]         ;6338
0048c4  9800              LDR      r0,[sp,#0]            ;6338
0048c6  4281              CMP      r1,r0                 ;6338
0048c8  d91e              BLS      |L1.18696|
0048ca  f04f33ff          MOV      r3,#0xffffffff        ;6341
0048ce  4620              MOV      r0,r4                 ;6341
0048d0  9a10              LDR      r2,[sp,#0x40]         ;6341
0048d2  9918              LDR      r1,[sp,#0x60]         ;6341
0048d4  f7fffffe          BL       yaffs_PutChunkIntoFile
0048d8  b908              CBNZ     r0,|L1.18654|
0048da  2001              MOVS     r0,#1                 ;6343
0048dc  9003              STR      r0,[sp,#0xc]          ;6343
                  |L1.18654|
0048de  e9dd0118          LDRD     r0,r1,[sp,#0x60]      ;6349
0048e2  1e40              SUBS     r0,r0,#1              ;6349
0048e4  68f2              LDR      r2,[r6,#0xc]          ;6349
0048e6  fb001002          MLA      r0,r0,r2,r1           ;6349
0048ea  9001              STR      r0,[sp,#4]            ;6349
0048ec  7820              LDRB     r0,[r4,#0]            ;6354
0048ee  09c0              LSRS     r0,r0,#7              ;6354
0048f0  b990              CBNZ     r0,|L1.18712|
0048f2  6de1              LDR      r1,[r4,#0x5c]         ;6355
0048f4  9801              LDR      r0,[sp,#4]            ;6355
0048f6  4281              CMP      r1,r0                 ;6355
0048f8  d20e              BCS      |L1.18712|
0048fa  e000              B        |L1.18686|
                  |L1.18684|
0048fc  e00d              B        |L1.18714|
                  |L1.18686|
0048fe  9801              LDR      r0,[sp,#4]            ;6357
004900  65e0              STR      r0,[r4,#0x5c]         ;6357
004902  6de0              LDR      r0,[r4,#0x5c]         ;6359
004904  65a0              STR      r0,[r4,#0x58]         ;6359
004906  e007              B        |L1.18712|
                  |L1.18696|
004908  b134              CBZ      r4,|L1.18712|
00490a  f64103df          MOV      r3,#0x18df            ;6367
00490e  2201              MOVS     r2,#1                 ;6367
004910  4630              MOV      r0,r6                 ;6367
004912  9910              LDR      r1,[sp,#0x40]         ;6367
004914  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.18712|
004918  e18e              B        |L1.19512|
                  |L1.18714|
00491a  2001              MOVS     r0,#1                 ;6374
00491c  9005              STR      r0,[sp,#0x14]         ;6374
00491e  4652              MOV      r2,r10                ;6376
004920  4649              MOV      r1,r9                 ;6376
004922  4630              MOV      r0,r6                 ;6376
004924  f7fffffe          BL       yaffs_SetChunkBit
004928  6838              LDR      r0,[r7,#0]            ;6377
00492a  0a80              LSRS     r0,r0,#10             ;6377
00492c  1c40              ADDS     r0,r0,#1              ;6377
00492e  6839              LDR      r1,[r7,#0]            ;6377
004930  f3602193          BFI      r1,r0,#10,#10         ;6377
004934  6039              STR      r1,[r7,#0]            ;6377
004936  2500              MOVS     r5,#0                 ;6379
004938  2400              MOVS     r4,#0                 ;6380
00493a  981f              LDR      r0,[sp,#0x7c]         ;6382
00493c  b148              CBZ      r0,|L1.18770|
00493e  f89d208c          LDRB     r2,[sp,#0x8c]         ;6383
004942  4630              MOV      r0,r6                 ;6383
004944  9917              LDR      r1,[sp,#0x5c]         ;6383
004946  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
00494a  4604              MOV      r4,r0                 ;6383
00494c  b90c              CBNZ     r4,|L1.18770|
00494e  2001              MOVS     r0,#1                 ;6387
004950  9003              STR      r0,[sp,#0xc]          ;6387
                  |L1.18770|
004952  b154              CBZ      r4,|L1.18794|
004954  9822              LDR      r0,[sp,#0x88]         ;6394
004956  b940              CBNZ     r0,|L1.18794|
004958  7820              LDRB     r0,[r4,#0]            ;6395
00495a  09c0              LSRS     r0,r0,#7              ;6395
00495c  bb10              CBNZ     r0,|L1.18852|
00495e  9817              LDR      r0,[sp,#0x5c]         ;6396
004960  2801              CMP      r0,#1                 ;6396
004962  d002              BEQ      |L1.18794|
004964  9817              LDR      r0,[sp,#0x5c]         ;6397
004966  2802              CMP      r0,#2                 ;6397
004968  d11c              BNE      |L1.18852|
                  |L1.18794|
00496a  2300              MOVS     r3,#0                 ;6405
00496c  4630              MOV      r0,r6                 ;6405
00496e  9a08              LDR      r2,[sp,#0x20]         ;6405
004970  9910              LDR      r1,[sp,#0x40]         ;6405
004972  f7fffffe          BL       yaffs_ReadChunkWithTagsFromNAND
004976  900f              STR      r0,[sp,#0x3c]         ;6405
004978  9d08              LDR      r5,[sp,#0x20]         ;6410
00497a  f8d6008c          LDR      r0,[r6,#0x8c]         ;6412
00497e  b138              CBZ      r0,|L1.18832|
004980  f8d501e8          LDR      r0,[r5,#0x1e8]        ;6414
004984  f8c501f8          STR      r0,[r5,#0x1f8]        ;6414
004988  f8d501ec          LDR      r0,[r5,#0x1ec]        ;6415
00498c  f8c501fc          STR      r0,[r5,#0x1fc]        ;6415
                  |L1.18832|
004990  b944              CBNZ     r4,|L1.18852|
004992  782a              LDRB     r2,[r5,#0]            ;6419
004994  4630              MOV      r0,r6                 ;6419
004996  9917              LDR      r1,[sp,#0x5c]         ;6419
004998  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
00499c  4604              MOV      r4,r0                 ;6419
00499e  b90c              CBNZ     r4,|L1.18852|
0049a0  2001              MOVS     r0,#1                 ;6421
0049a2  9003              STR      r0,[sp,#0xc]          ;6421
                  |L1.18852|
0049a4  b914              CBNZ     r4,|L1.18860|
0049a6  bf00              NOP                            ;6428
0049a8  bf00              NOP                            ;6428
0049aa  e146              B        |L1.19514|
                  |L1.18860|
0049ac  7820              LDRB     r0,[r4,#0]            ;6435
0049ae  09c0              LSRS     r0,r0,#7              ;6435
0049b0  b3d8              CBZ      r0,|L1.18986|
0049b2  f8940054          LDRB     r0,[r4,#0x54]         ;6441
0049b6  2801              CMP      r0,#1                 ;6441
0049b8  d130              BNE      |L1.18972|
0049ba  b115              CBZ      r5,|L1.18882|
0049bc  7828              LDRB     r0,[r5,#0]            ;6443
0049be  2801              CMP      r0,#1                 ;6443
0049c0  d005              BEQ      |L1.18894|
                  |L1.18882|
0049c2  981f              LDR      r0,[sp,#0x7c]         ;6444
0049c4  b350              CBZ      r0,|L1.18972|
0049c6  f89d008c          LDRB     r0,[sp,#0x8c]         ;6445
0049ca  2801              CMP      r0,#1                 ;6445
0049cc  d126              BNE      |L1.18972|
                  |L1.18894|
0049ce  b115              CBZ      r5,|L1.18902|
0049d0  f8d52124          LDR      r2,[r5,#0x124]        ;6448
0049d4  e000              B        |L1.18904|
                  |L1.18902|
0049d6  9a24              LDR      r2,[sp,#0x90]         ;6448
                  |L1.18904|
0049d8  4610              MOV      r0,r2                 ;6448
0049da  b10d              CBZ      r5,|L1.18912|
0049dc  686a              LDR      r2,[r5,#4]            ;6451
0049de  e000              B        |L1.18914|
                  |L1.18912|
0049e0  9a20              LDR      r2,[sp,#0x80]         ;6452
                  |L1.18914|
0049e2  4611              MOV      r1,r2                 ;6452
0049e4  b115              CBZ      r5,|L1.18924|
0049e6  f8d521fc          LDR      r2,[r5,#0x1fc]        ;6457
0049ea  e000              B        |L1.18926|
                  |L1.18924|
0049ec  9a21              LDR      r2,[sp,#0x84]         ;6457
                  |L1.18926|
0049ee  9206              STR      r2,[sp,#0x18]         ;6457
0049f0  2904              CMP      r1,#4                 ;6463
0049f2  d001              BEQ      |L1.18936|
0049f4  2903              CMP      r1,#3                 ;6465
0049f6  d102              BNE      |L1.18942|
                  |L1.18936|
0049f8  2000              MOVS     r0,#0                 ;6467
0049fa  2201              MOVS     r2,#1                 ;6468
0049fc  9206              STR      r2,[sp,#0x18]         ;6468
                  |L1.18942|
0049fe  9a06              LDR      r2,[sp,#0x18]         ;6471
004a00  b11a              CBZ      r2,|L1.18954|
004a02  6e22              LDR      r2,[r4,#0x60]         ;6472
004a04  4282              CMP      r2,r0                 ;6472
004a06  d900              BLS      |L1.18954|
004a08  6620              STR      r0,[r4,#0x60]         ;6474
                  |L1.18954|
004a0a  9a06              LDR      r2,[sp,#0x18]         ;6479
004a0c  b12a              CBZ      r2,|L1.18970|
004a0e  683a              LDR      r2,[r7,#0]            ;6480
004a10  f0224280          BIC      r2,r2,#0x40000000     ;6480
004a14  f1024280          ADD      r2,r2,#0x40000000     ;6480
004a18  603a              STR      r2,[r7,#0]            ;6480
                  |L1.18970|
004a1a  bf00              NOP                            ;6483
                  |L1.18972|
004a1c  f6411355          MOV      r3,#0x1955            ;6485
004a20  2201              MOVS     r2,#1                 ;6485
004a22  4630              MOV      r0,r6                 ;6485
004a24  9910              LDR      r1,[sp,#0x40]         ;6485
004a26  f7fffffe          BL       yaffs_DeleteChunk
                  |L1.18986|
004a2a  7820              LDRB     r0,[r4,#0]            ;6489
004a2c  09c0              LSRS     r0,r0,#7              ;6489
004a2e  b950              CBNZ     r0,|L1.19014|
004a30  f8941054          LDRB     r1,[r4,#0x54]         ;6489
004a34  b10d              CBZ      r5,|L1.19002|
004a36  7828              LDRB     r0,[r5,#0]            ;6490
004a38  e001              B        |L1.19006|
                  |L1.19002|
004a3a  f89d008c          LDRB     r0,[sp,#0x8c]         ;6490
                  |L1.19006|
004a3e  4281              CMP      r1,r0                 ;6490
004a40  d001              BEQ      |L1.19014|
004a42  bf00              NOP                            ;6491
004a44  bf00              NOP                            ;6491
                  |L1.19014|
004a46  7820              LDRB     r0,[r4,#0]            ;6500
004a48  09c0              LSRS     r0,r0,#7              ;6500
004a4a  bb68              CBNZ     r0,|L1.19112|
004a4c  9817              LDR      r0,[sp,#0x5c]         ;6501
004a4e  2801              CMP      r0,#1                 ;6501
004a50  d002              BEQ      |L1.19032|
004a52  9817              LDR      r0,[sp,#0x5c]         ;6502
004a54  2802              CMP      r0,#2                 ;6502
004a56  d127              BNE      |L1.19112|
                  |L1.19032|
004a58  7820              LDRB     r0,[r4,#0]            ;6505
004a5a  f0200080          BIC      r0,r0,#0x80           ;6505
004a5e  3080              ADDS     r0,r0,#0x80           ;6505
004a60  7020              STRB     r0,[r4,#0]            ;6505
004a62  b1ad              CBZ      r5,|L1.19088|
004a64  35a4              ADDS     r5,r5,#0xa4           ;6508
004a66  f8150ca4          LDRB     r0,[r5,#-0xa4]        ;6508
004a6a  f8840054          STRB     r0,[r4,#0x54]         ;6508
004a6e  6ea8              LDR      r0,[r5,#0x68]         ;6510
004a70  6360              STR      r0,[r4,#0x34]         ;6510
004a72  6ee8              LDR      r0,[r5,#0x6c]         ;6519
004a74  63e0              STR      r0,[r4,#0x3c]         ;6519
004a76  6f28              LDR      r0,[r5,#0x70]         ;6520
004a78  6420              STR      r0,[r4,#0x40]         ;6520
004a7a  6f68              LDR      r0,[r5,#0x74]         ;6521
004a7c  6460              STR      r0,[r4,#0x44]         ;6521
004a7e  6fa8              LDR      r0,[r5,#0x78]         ;6522
004a80  64a0              STR      r0,[r4,#0x48]         ;6522
004a82  6fe8              LDR      r0,[r5,#0x7c]         ;6523
004a84  64e0              STR      r0,[r4,#0x4c]         ;6523
004a86  f8d50128          LDR      r0,[r5,#0x128]        ;6524
004a8a  3da4              SUBS     r5,r5,#0xa4           ;6524
004a8c  6520              STR      r0,[r4,#0x50]         ;6524
004a8e  e008              B        |L1.19106|
                  |L1.19088|
004a90  f89d008c          LDRB     r0,[sp,#0x8c]         ;6528
004a94  f8840054          STRB     r0,[r4,#0x54]         ;6528
004a98  7860              LDRB     r0,[r4,#1]            ;6529
004a9a  f0200001          BIC      r0,r0,#1              ;6529
004a9e  1c40              ADDS     r0,r0,#1              ;6529
004aa0  7060              STRB     r0,[r4,#1]            ;6529
                  |L1.19106|
004aa2  9810              LDR      r0,[sp,#0x40]         ;6532
004aa4  62a0              STR      r0,[r4,#0x28]         ;6532
                  |L1.19110|
004aa6  e0c7              B        |L1.19512|
                  |L1.19112|
004aa8  7820              LDRB     r0,[r4,#0]            ;6534
004aaa  09c0              LSRS     r0,r0,#7              ;6534
004aac  2800              CMP      r0,#0                 ;6534
004aae  d1fa              BNE      |L1.19110|
004ab0  7820              LDRB     r0,[r4,#0]            ;6537
004ab2  f0200080          BIC      r0,r0,#0x80           ;6537
004ab6  3080              ADDS     r0,r0,#0x80           ;6537
004ab8  7020              STRB     r0,[r4,#0]            ;6537
004aba  9810              LDR      r0,[sp,#0x40]         ;6538
004abc  62a0              STR      r0,[r4,#0x28]         ;6538
004abe  b3bd              CBZ      r5,|L1.19248|
004ac0  35a4              ADDS     r5,r5,#0xa4           ;6541
004ac2  f8150ca4          LDRB     r0,[r5,#-0xa4]        ;6541
004ac6  f8840054          STRB     r0,[r4,#0x54]         ;6541
004aca  6ea8              LDR      r0,[r5,#0x68]         ;6543
004acc  6360              STR      r0,[r4,#0x34]         ;6543
004ace  6ee8              LDR      r0,[r5,#0x6c]         ;6552
004ad0  63e0              STR      r0,[r4,#0x3c]         ;6552
004ad2  6f28              LDR      r0,[r5,#0x70]         ;6553
004ad4  6420              STR      r0,[r4,#0x40]         ;6553
004ad6  6f68              LDR      r0,[r5,#0x74]         ;6554
004ad8  6460              STR      r0,[r4,#0x44]         ;6554
004ada  6fa8              LDR      r0,[r5,#0x78]         ;6555
004adc  64a0              STR      r0,[r4,#0x48]         ;6555
004ade  6fe8              LDR      r0,[r5,#0x7c]         ;6556
004ae0  64e0              STR      r0,[r4,#0x4c]         ;6556
004ae2  f8d50128          LDR      r0,[r5,#0x128]        ;6557
004ae6  6520              STR      r0,[r4,#0x50]         ;6557
004ae8  f8d50154          LDR      r0,[r5,#0x154]        ;6560
004aec  3da4              SUBS     r5,r5,#0xa4           ;6560
004aee  2800              CMP      r0,#0                 ;6560
004af0  dd05              BLE      |L1.19198|
004af2  2201              MOVS     r2,#1                 ;6561
004af4  4630              MOV      r0,r6                 ;6561
004af6  f8d511f8          LDR      r1,[r5,#0x1f8]        ;6561
004afa  f7fffffe          BL       yaffs_HandleShadowedObject
                  |L1.19198|
004afe  f105010a          ADD      r1,r5,#0xa            ;6567
004b02  4620              MOV      r0,r4                 ;6567
004b04  f7fffffe          BL       yaffs_SetObjectName
004b08  2203              MOVS     r2,#3                 ;6568
004b0a  4630              MOV      r0,r6                 ;6568
004b0c  6869              LDR      r1,[r5,#4]            ;6568
004b0e  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
004b12  4680              MOV      r8,r0                 ;6568
004b14  f8d50124          LDR      r0,[r5,#0x124]        ;6573
004b18  9007              STR      r0,[sp,#0x1c]         ;6573
004b1a  f8d501fc          LDR      r0,[r5,#0x1fc]        ;6574
004b1e  9006              STR      r0,[sp,#0x18]         ;6574
004b20  f8d50128          LDR      r0,[r5,#0x128]        ;6575
004b24  9004              STR      r0,[sp,#0x10]         ;6575
004b26  e019              B        |L1.19292|
                  |L1.19240|
                          DCD      0xefffff00
                  |L1.19244|
                          DCD      ybicmp
                  |L1.19248|
004b30  e7ff              B        |L1.19250|
                  |L1.19250|
004b32  f89d008c          LDRB     r0,[sp,#0x8c]         ;6579
004b36  f8840054          STRB     r0,[r4,#0x54]         ;6579
004b3a  2203              MOVS     r2,#3                 ;6580
004b3c  4630              MOV      r0,r6                 ;6580
004b3e  9920              LDR      r1,[sp,#0x80]         ;6580
004b40  f7fffffe          BL       yaffs_FindOrCreateObjectByNumber
004b44  4680              MOV      r8,r0                 ;6580
004b46  9824              LDR      r0,[sp,#0x90]         ;6584
004b48  9007              STR      r0,[sp,#0x1c]         ;6584
004b4a  9821              LDR      r0,[sp,#0x84]         ;6585
004b4c  9006              STR      r0,[sp,#0x18]         ;6585
004b4e  9825              LDR      r0,[sp,#0x94]         ;6586
004b50  9004              STR      r0,[sp,#0x10]         ;6586
004b52  7860              LDRB     r0,[r4,#1]            ;6587
004b54  f0200001          BIC      r0,r0,#1              ;6587
004b58  1c40              ADDS     r0,r0,#1              ;6587
004b5a  7060              STRB     r0,[r4,#1]            ;6587
                  |L1.19292|
004b5c  7820              LDRB     r0,[r4,#0]            ;6590
004b5e  f0200040          BIC      r0,r0,#0x40           ;6590
004b62  7020              STRB     r0,[r4,#0]            ;6590
004b64  f1b80f00          CMP      r8,#0                 ;6592
004b68  d101              BNE      |L1.19310|
004b6a  2001              MOVS     r0,#1                 ;6593
004b6c  9003              STR      r0,[sp,#0xc]          ;6593
                  |L1.19310|
004b6e  f1b80f00          CMP      r8,#0                 ;6599
004b72  d00d              BEQ      |L1.19344|
004b74  f8980054          LDRB     r0,[r8,#0x54]         ;6599
004b78  b950              CBNZ     r0,|L1.19344|
004b7a  2003              MOVS     r0,#3                 ;6602
004b7c  f8880054          STRB     r0,[r8,#0x54]         ;6602
004b80  bf00              NOP                            ;6604
004b82  f1080058          ADD      r0,r8,#0x58           ;6604
004b86  f8c80058          STR      r0,[r8,#0x58]         ;6604
004b8a  f8c8005c          STR      r0,[r8,#0x5c]         ;6604
004b8e  e00a              B        |L1.19366|
                  |L1.19344|
004b90  f1b80f00          CMP      r8,#0                 ;6607
004b94  d003              BEQ      |L1.19358|
004b96  f8980054          LDRB     r0,[r8,#0x54]         ;6607
004b9a  2803              CMP      r0,#3                 ;6607
004b9c  d003              BEQ      |L1.19366|
                  |L1.19358|
004b9e  bf00              NOP                            ;6614
004ba0  bf00              NOP                            ;6614
004ba2  f8d68d88          LDR      r8,[r6,#0xd88]        ;6618
                  |L1.19366|
004ba6  4621              MOV      r1,r4                 ;6621
004ba8  4640              MOV      r0,r8                 ;6621
004baa  f7fffffe          BL       yaffs_AddObjectToDirectory
004bae  f8d60da4          LDR      r0,[r6,#0xda4]        ;6623
004bb2  4540              CMP      r0,r8                 ;6623
004bb4  d003              BEQ      |L1.19390|
004bb6  f8d60da0          LDR      r0,[r6,#0xda0]        ;6624
004bba  4540              CMP      r0,r8                 ;6624
004bbc  d101              BNE      |L1.19394|
                  |L1.19390|
004bbe  2001              MOVS     r0,#1                 ;6624
004bc0  e000              B        |L1.19396|
                  |L1.19394|
004bc2  2000              MOVS     r0,#0                 ;6624
                  |L1.19396|
004bc4  9009              STR      r0,[sp,#0x24]         ;6624
004bc6  9806              LDR      r0,[sp,#0x18]         ;6626
004bc8  b128              CBZ      r0,|L1.19414|
004bca  6838              LDR      r0,[r7,#0]            ;6628
004bcc  f0204080          BIC      r0,r0,#0x40000000     ;6628
004bd0  f1004080          ADD      r0,r0,#0x40000000     ;6628
004bd4  6038              STR      r0,[r7,#0]            ;6628
                  |L1.19414|
004bd6  f8940054          LDRB     r0,[r4,#0x54]         ;6638
004bda  2806              CMP      r0,#6                 ;6638
004bdc  d22b              BCS      |L1.19510|
004bde  e8dff000          TBB      [pc,r0]               ;6638
004be2  0304              DCB      0x03,0x04
004be4  1f1d151e          DCB      0x1f,0x1d,0x15,0x1e
004be8  e025              B        |L1.19510|
004bea  6de1              LDR      r1,[r4,#0x5c]         ;6644
004bec  9807              LDR      r0,[sp,#0x1c]         ;6644
004bee  4281              CMP      r1,r0                 ;6644
004bf0  d203              BCS      |L1.19450|
004bf2  9807              LDR      r0,[sp,#0x1c]         ;6651
004bf4  65a0              STR      r0,[r4,#0x58]         ;6651
004bf6  6da1              LDR      r1,[r4,#0x58]         ;6652
004bf8  65e1              STR      r1,[r4,#0x5c]         ;6652
                  |L1.19450|
004bfa  9806              LDR      r0,[sp,#0x18]         ;6656
004bfc  b128              CBZ      r0,|L1.19466|
004bfe  6e21              LDR      r1,[r4,#0x60]         ;6657
004c00  9807              LDR      r0,[sp,#0x1c]         ;6657
004c02  4281              CMP      r1,r0                 ;6657
004c04  d901              BLS      |L1.19466|
004c06  9807              LDR      r0,[sp,#0x1c]         ;6658
004c08  6620              STR      r0,[r4,#0x60]         ;6658
                  |L1.19466|
004c0a  e014              B        |L1.19510|
004c0c  9809              LDR      r0,[sp,#0x24]         ;6663
004c0e  b920              CBNZ     r0,|L1.19482|
004c10  9804              LDR      r0,[sp,#0x10]         ;6664
004c12  65e0              STR      r0,[r4,#0x5c]         ;6664
004c14  980c              LDR      r0,[sp,#0x30]         ;6666
004c16  6160              STR      r0,[r4,#0x14]         ;6666
004c18  940c              STR      r4,[sp,#0x30]         ;6668
                  |L1.19482|
004c1a  e00c              B        |L1.19510|
004c1c  e00b              B        |L1.19510|
004c1e  e00a              B        |L1.19510|
004c20  b145              CBZ      r5,|L1.19508|
004c22  f5057096          ADD      r0,r5,#0x12c          ;6679
004c26  f7fffffe          BL       yaffs_CloneString
004c2a  65a0              STR      r0,[r4,#0x58]         ;6679
004c2c  6da0              LDR      r0,[r4,#0x58]         ;6682
004c2e  b908              CBNZ     r0,|L1.19508|
004c30  2001              MOVS     r0,#1                 ;6683
004c32  9003              STR      r0,[sp,#0xc]          ;6683
                  |L1.19508|
004c34  bf00              NOP                            ;6685
                  |L1.19510|
004c36  bf00              NOP                            ;6641
                  |L1.19512|
004c38  bf00              NOP                            ;6432
                  |L1.19514|
004c3a  f1aa0a01          SUB      r10,r10,#1            ;6242
                  |L1.19518|
004c3e  9803              LDR      r0,[sp,#0xc]          ;6240
004c40  b958              CBNZ     r0,|L1.19546|
004c42  f1ba0f00          CMP      r10,#0                ;6240
004c46  db08              BLT      |L1.19546|
004c48  f89d0034          LDRB     r0,[sp,#0x34]         ;6241
004c4c  2802              CMP      r0,#2                 ;6241
                  |L1.19534|
004c4e  f43fadc8          BEQ      |L1.18402|
004c52  f89d0034          LDRB     r0,[sp,#0x34]         ;6242
004c56  2804              CMP      r0,#4                 ;6242
004c58  d0f9              BEQ      |L1.19534|
                  |L1.19546|
004c5a  f89d0034          LDRB     r0,[sp,#0x34]         ;6694
004c5e  2802              CMP      r0,#2                 ;6694
004c60  d101              BNE      |L1.19558|
004c62  2005              MOVS     r0,#5                 ;6696
004c64  900d              STR      r0,[sp,#0x34]         ;6696
                  |L1.19558|
004c66  f89d1034          LDRB     r1,[sp,#0x34]         ;6699
004c6a  6838              LDR      r0,[r7,#0]            ;6699
004c6c  f3615017          BFI      r0,r1,#20,#4          ;6699
004c70  6038              STR      r0,[r7,#0]            ;6699
004c72  6838              LDR      r0,[r7,#0]            ;6702
004c74  f3c02089          UBFX     r0,r0,#10,#10         ;6702
004c78  b960              CBNZ     r0,|L1.19604|
004c7a  6838              LDR      r0,[r7,#0]            ;6703
004c7c  f3c07080          UBFX     r0,r0,#30,#1          ;6703
004c80  b940              CBNZ     r0,|L1.19604|
004c82  6838              LDR      r0,[r7,#0]            ;6704
004c84  f3c05003          UBFX     r0,r0,#20,#4          ;6704
004c88  2805              CMP      r0,#5                 ;6704
004c8a  d103              BNE      |L1.19604|
004c8c  4649              MOV      r1,r9                 ;6705
004c8e  4630              MOV      r0,r6                 ;6705
004c90  f7fffffe          BL       yaffs_BlockBecameDirty
                  |L1.19604|
004c94  9814              LDR      r0,[sp,#0x50]         ;6222
004c96  1e40              SUBS     r0,r0,#1              ;6222
004c98  9014              STR      r0,[sp,#0x50]         ;6222
                  |L1.19610|
004c9a  9803              LDR      r0,[sp,#0xc]          ;6221
004c9c  b920              CBNZ     r0,|L1.19624|
004c9e  e9dd1013          LDRD     r1,r0,[sp,#0x4c]      ;6221
004ca2  4288              CMP      r0,r1                 ;6221
004ca4  f6bfad86          BGE      |L1.18356|
                  |L1.19624|
004ca8  9802              LDR      r0,[sp,#8]            ;6710
004caa  b118              CBZ      r0,|L1.19636|
004cac  4658              MOV      r0,r11                ;6711
004cae  f7fffffe          BL       free
004cb2  e002              B        |L1.19642|
                  |L1.19636|
004cb4  4658              MOV      r0,r11                ;6713
004cb6  f7fffffe          BL       free
                  |L1.19642|
004cba  4630              MOV      r0,r6                 ;6720
004cbc  990c              LDR      r1,[sp,#0x30]         ;6720
004cbe  f7fffffe          BL       yaffs_HardlinkFixup
004cc2  f6412243          MOV      r2,#0x1a43            ;6723
004cc6  4630              MOV      r0,r6                 ;6723
004cc8  9908              LDR      r1,[sp,#0x20]         ;6723
004cca  f7fffffe          BL       yaffs_ReleaseTempBuffer
004cce  9803              LDR      r0,[sp,#0xc]          ;6725
004cd0  b108              CBZ      r0,|L1.19670|
004cd2  2000              MOVS     r0,#0                 ;6726
004cd4  e4aa              B        |L1.17964|
                  |L1.19670|
004cd6  bf00              NOP                            ;6729
004cd8  bf00              NOP                            ;6729
004cda  2001              MOVS     r0,#1                 ;6731
004cdc  e4a6              B        |L1.17964|
;;;6733   
                          ENDP

                  yaffs_GetObjectFileLength PROC
;;;7047   
;;;7048   int yaffs_GetObjectFileLength(yaffs_Object * obj)
004cde  b510              PUSH     {r4,lr}
;;;7049   {
004ce0  4604              MOV      r4,r0
;;;7050   
;;;7051   	/* Dereference any hard linking */
;;;7052   	obj = yaffs_GetEquivalentObject(obj);
004ce2  4620              MOV      r0,r4
004ce4  f7fffffe          BL       yaffs_GetEquivalentObject
004ce8  4604              MOV      r4,r0
;;;7053   
;;;7054   	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) 
004cea  f8940054          LDRB     r0,[r4,#0x54]
004cee  2801              CMP      r0,#1
004cf0  d101              BNE      |L1.19702|
;;;7055   	{
;;;7056   		 
;;;7057   		return obj->variant.fileVariant.fileSize;
004cf2  6da0              LDR      r0,[r4,#0x58]
                  |L1.19700|
;;;7058   	}
;;;7059   	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {
;;;7060   		return yaffs_strlen(obj->variant.symLinkVariant.alias);
;;;7061   	} else {
;;;7062   		/* Only a directory should drop through to here */
;;;7063   		return obj->myDev->nDataBytesPerChunk;
;;;7064   	}
;;;7065   }
004cf4  bd10              POP      {r4,pc}
                  |L1.19702|
004cf6  f8940054          LDRB     r0,[r4,#0x54]         ;7059
004cfa  2802              CMP      r0,#2                 ;7059
004cfc  d103              BNE      |L1.19718|
004cfe  6da0              LDR      r0,[r4,#0x58]         ;7060
004d00  f7fffffe          BL       strlen
004d04  e7f6              B        |L1.19700|
                  |L1.19718|
004d06  68a0              LDR      r0,[r4,#8]            ;7063
004d08  68c0              LDR      r0,[r0,#0xc]          ;7063
004d0a  e7f3              B        |L1.19700|
;;;7066   
                          ENDP

                  yaffs_CheckDevFunctions PROC
;;;7212   
;;;7213   static int yaffs_CheckDevFunctions(const yaffs_Device * dev)
004d0c  4601              MOV      r1,r0
;;;7214   {
;;;7215   
;;;7216   	/* Common functions, gotta have */
;;;7217   	if (!dev->eraseBlockInNAND || !dev->initialiseNAND)
004d0e  6c08              LDR      r0,[r1,#0x40]
004d10  b108              CBZ      r0,|L1.19734|
004d12  6c48              LDR      r0,[r1,#0x44]
004d14  b908              CBNZ     r0,|L1.19738|
                  |L1.19734|
;;;7218   		return 0;
004d16  2000              MOVS     r0,#0
                  |L1.19736|
;;;7219   
;;;7220   #ifdef CONFIG_YAFFS_YAFFS2
;;;7221   
;;;7222   	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
;;;7223   	if (dev->writeChunkWithTagsToNAND &&
;;;7224   	    dev->readChunkWithTagsFromNAND &&
;;;7225   	    !dev->writeChunkToNAND &&
;;;7226   	    !dev->readChunkFromNAND &&
;;;7227   	    dev->markNANDBlockBad && dev->queryNANDBlock)
;;;7228   		return 1;
;;;7229   #endif
;;;7230   
;;;7231   	/* Can use the "spare" style interface for yaffs1 */
;;;7232   	if (!dev->isYaffs2 &&
;;;7233   	    !dev->writeChunkWithTagsToNAND &&
;;;7234   	    !dev->readChunkWithTagsFromNAND &&
;;;7235   	    dev->writeChunkToNAND &&
;;;7236   	    dev->readChunkFromNAND &&
;;;7237   	    !dev->markNANDBlockBad && !dev->queryNANDBlock)
;;;7238   		return 1;
;;;7239   
;;;7240   	return 0;		/* bad */
;;;7241   }
004d18  4770              BX       lr
                  |L1.19738|
004d1a  6cc8              LDR      r0,[r1,#0x4c]         ;7223
004d1c  b158              CBZ      r0,|L1.19766|
004d1e  6d08              LDR      r0,[r1,#0x50]         ;7224
004d20  b148              CBZ      r0,|L1.19766|
004d22  6b88              LDR      r0,[r1,#0x38]         ;7225
004d24  b938              CBNZ     r0,|L1.19766|
004d26  6bc8              LDR      r0,[r1,#0x3c]         ;7226
004d28  b928              CBNZ     r0,|L1.19766|
004d2a  6d48              LDR      r0,[r1,#0x54]         ;7227
004d2c  b118              CBZ      r0,|L1.19766|
004d2e  6d88              LDR      r0,[r1,#0x58]         ;7227
004d30  b108              CBZ      r0,|L1.19766|
004d32  2001              MOVS     r0,#1                 ;7228
004d34  e7f0              B        |L1.19736|
                  |L1.19766|
004d36  6dc8              LDR      r0,[r1,#0x5c]         ;7232
004d38  b968              CBNZ     r0,|L1.19798|
004d3a  6cc8              LDR      r0,[r1,#0x4c]         ;7233
004d3c  b958              CBNZ     r0,|L1.19798|
004d3e  6d08              LDR      r0,[r1,#0x50]         ;7234
004d40  b948              CBNZ     r0,|L1.19798|
004d42  6b88              LDR      r0,[r1,#0x38]         ;7235
004d44  b138              CBZ      r0,|L1.19798|
004d46  6bc8              LDR      r0,[r1,#0x3c]         ;7236
004d48  b128              CBZ      r0,|L1.19798|
004d4a  6d48              LDR      r0,[r1,#0x54]         ;7237
004d4c  b918              CBNZ     r0,|L1.19798|
004d4e  6d88              LDR      r0,[r1,#0x58]         ;7237
004d50  b908              CBNZ     r0,|L1.19798|
004d52  2001              MOVS     r0,#1                 ;7238
004d54  e7e0              B        |L1.19736|
                  |L1.19798|
004d56  2000              MOVS     r0,#0                 ;7240
004d58  e7de              B        |L1.19736|
;;;7242   
                          ENDP

                  yaffs_CreateInitialDirectories PROC
;;;7243   
;;;7244   static int yaffs_CreateInitialDirectories(yaffs_Device *dev)
004d5a  b510              PUSH     {r4,lr}
;;;7245   {
004d5c  4604              MOV      r4,r0
;;;7246   	/* Initialise the unlinked, deleted, root and lost and found directories */
;;;7247   	
;;;7248   	dev->lostNFoundDir = dev->rootDir =  NULL;
004d5e  2000              MOVS     r0,#0
004d60  f8c40d84          STR      r0,[r4,#0xd84]
004d64  f8c40d88          STR      r0,[r4,#0xd88]
;;;7249   	dev->unlinkedDir = dev->deletedDir = NULL;
004d68  f8c40da4          STR      r0,[r4,#0xda4]
004d6c  f8c40da0          STR      r0,[r4,#0xda0]
;;;7250   
;;;7251   	dev->unlinkedDir =
004d70  f44f4280          MOV      r2,#0x4000
004d74  2103              MOVS     r1,#3
004d76  4620              MOV      r0,r4
004d78  f7fffffe          BL       yaffs_CreateFakeDirectory
004d7c  f8c40da0          STR      r0,[r4,#0xda0]
;;;7252   	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
;;;7253   	
;;;7254   	dev->deletedDir =
004d80  f44f4280          MOV      r2,#0x4000
004d84  2104              MOVS     r1,#4
004d86  4620              MOV      r0,r4
004d88  f7fffffe          BL       yaffs_CreateFakeDirectory
004d8c  f8c40da4          STR      r0,[r4,#0xda4]
;;;7255   	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
;;;7256   
;;;7257   	dev->rootDir =
004d90  f24412b6          MOV      r2,#0x41b6
004d94  2101              MOVS     r1,#1
004d96  4620              MOV      r0,r4
004d98  f7fffffe          BL       yaffs_CreateFakeDirectory
004d9c  f8c40d84          STR      r0,[r4,#0xd84]
;;;7258   	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_ROOT,
;;;7259   				      YAFFS_ROOT_MODE | S_IFDIR);
;;;7260   	dev->lostNFoundDir =
004da0  f24412b6          MOV      r2,#0x41b6
004da4  2102              MOVS     r1,#2
004da6  4620              MOV      r0,r4
004da8  f7fffffe          BL       yaffs_CreateFakeDirectory
004dac  f8c40d88          STR      r0,[r4,#0xd88]
;;;7261   	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_LOSTNFOUND,
;;;7262   				      YAFFS_LOSTNFOUND_MODE | S_IFDIR);
;;;7263   	
;;;7264   	if(dev->lostNFoundDir && dev->rootDir && dev->unlinkedDir && dev->deletedDir){
004db0  f8d40d88          LDR      r0,[r4,#0xd88]
004db4  b178              CBZ      r0,|L1.19926|
004db6  f8d40d84          LDR      r0,[r4,#0xd84]
004dba  b160              CBZ      r0,|L1.19926|
004dbc  f8d40da0          LDR      r0,[r4,#0xda0]
004dc0  b148              CBZ      r0,|L1.19926|
004dc2  f8d40da4          LDR      r0,[r4,#0xda4]
004dc6  b130              CBZ      r0,|L1.19926|
;;;7265   		yaffs_AddObjectToDirectory(dev->rootDir, dev->lostNFoundDir);
004dc8  f6045084          ADD      r0,r4,#0xd84
004dcc  c803              LDM      r0,{r0,r1}
004dce  f7fffffe          BL       yaffs_AddObjectToDirectory
;;;7266   		return YAFFS_OK;
004dd2  2001              MOVS     r0,#1
                  |L1.19924|
;;;7267   	}
;;;7268   	
;;;7269   	return YAFFS_FAIL;
;;;7270   }
004dd4  bd10              POP      {r4,pc}
                  |L1.19926|
004dd6  2000              MOVS     r0,#0                 ;7269
004dd8  e7fc              B        |L1.19924|
;;;7271   
                          ENDP

                  yaffs_Deinitialise PROC
;;;7573   
;;;7574   void yaffs_Deinitialise(yaffs_Device * dev)
004dda  b570              PUSH     {r4-r6,lr}
;;;7575   {
004ddc  4604              MOV      r4,r0
;;;7576   	if (dev->isMounted) {
004dde  f8d40094          LDR      r0,[r4,#0x94]
004de2  2800              CMP      r0,#0
004de4  d04e              BEQ      |L1.20100|
;;;7577   		int i;
;;;7578   
;;;7579   		yaffs_DeinitialiseBlocks(dev);
004de6  4620              MOV      r0,r4
004de8  f7fffffe          BL       yaffs_DeinitialiseBlocks
;;;7580   		yaffs_DeinitialiseTnodes(dev);
004dec  4620              MOV      r0,r4
004dee  f7fffffe          BL       yaffs_DeinitialiseTnodes
;;;7581   		yaffs_DeinitialiseObjects(dev);
004df2  4620              MOV      r0,r4
004df4  f7fffffe          BL       yaffs_DeinitialiseObjects
;;;7582   		if (dev->nShortOpCaches > 0 &&
004df8  6a60              LDR      r0,[r4,#0x24]
004dfa  2800              CMP      r0,#0
004dfc  dd28              BLE      |L1.20048|
;;;7583   		    dev->srCache) {
004dfe  f8d40d94          LDR      r0,[r4,#0xd94]
004e02  b328              CBZ      r0,|L1.20048|
;;;7584   
;;;7585   			for (i = 0; i < dev->nShortOpCaches; i++) {
004e04  2500              MOVS     r5,#0
004e06  e019              B        |L1.20028|
                  |L1.19976|
;;;7586   				if(dev->srCache[i].data)
004e08  ebc501c5          RSB      r1,r5,r5,LSL #3
004e0c  f8d40d94          LDR      r0,[r4,#0xd94]
004e10  eb000081          ADD      r0,r0,r1,LSL #2
004e14  6980              LDR      r0,[r0,#0x18]
004e16  b140              CBZ      r0,|L1.20010|
;;;7587   					YFREE(dev->srCache[i].data);
004e18  ebc502c5          RSB      r2,r5,r5,LSL #3
004e1c  f8d41d94          LDR      r1,[r4,#0xd94]
004e20  eb010182          ADD      r1,r1,r2,LSL #2
004e24  6988              LDR      r0,[r1,#0x18]
004e26  f7fffffe          BL       free
                  |L1.20010|
;;;7588   				dev->srCache[i].data = NULL;
004e2a  2000              MOVS     r0,#0
004e2c  ebc502c5          RSB      r2,r5,r5,LSL #3
004e30  f8d41d94          LDR      r1,[r4,#0xd94]
004e34  eb010182          ADD      r1,r1,r2,LSL #2
004e38  6188              STR      r0,[r1,#0x18]
004e3a  1c6d              ADDS     r5,r5,#1              ;7585
                  |L1.20028|
004e3c  6a60              LDR      r0,[r4,#0x24]         ;7585
004e3e  42a8              CMP      r0,r5                 ;7585
004e40  dce2              BGT      |L1.19976|
;;;7589   			}
;;;7590   
;;;7591   			YFREE(dev->srCache);
004e42  f8d40d94          LDR      r0,[r4,#0xd94]
004e46  f7fffffe          BL       free
;;;7592   			dev->srCache = NULL;
004e4a  2000              MOVS     r0,#0
004e4c  f8c40d94          STR      r0,[r4,#0xd94]
                  |L1.20048|
;;;7593   		}
;;;7594   
;;;7595   		YFREE(dev->gcCleanupList);
004e50  f8d40d3c          LDR      r0,[r4,#0xd3c]
004e54  f7fffffe          BL       free
;;;7596   
;;;7597   		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
004e58  2500              MOVS     r5,#0
004e5a  e008              B        |L1.20078|
                  |L1.20060|
;;;7598   			YFREE(dev->tempBuffer[i].buffer);
004e5c  eb050245          ADD      r2,r5,r5,LSL #1
004e60  f60451b8          ADD      r1,r4,#0xdb8
004e64  f8510022          LDR      r0,[r1,r2,LSL #2]
004e68  f7fffffe          BL       free
004e6c  1c6d              ADDS     r5,r5,#1              ;7597
                  |L1.20078|
004e6e  2d06              CMP      r5,#6                 ;7597
004e70  dbf4              BLT      |L1.20060|
;;;7599   		}
;;;7600   
;;;7601   
;;;7602   		dev->isMounted = 0;
004e72  2000              MOVS     r0,#0
004e74  f8c40094          STR      r0,[r4,#0x94]
;;;7603   		
;;;7604   		if(dev->deinitialiseNAND)
004e78  6ca0              LDR      r0,[r4,#0x48]
004e7a  b110              CBZ      r0,|L1.20098|
;;;7605   			dev->deinitialiseNAND(dev);
004e7c  4620              MOV      r0,r4
004e7e  6ca1              LDR      r1,[r4,#0x48]
004e80  4788              BLX      r1
                  |L1.20098|
;;;7606   	}
004e82  bf00              NOP      
                  |L1.20100|
;;;7607   
;;;7608   }
004e84  bd70              POP      {r4-r6,pc}
;;;7609   
                          ENDP

                  yaffs_CheckStructures PROC
;;;7716   
;;;7717   static int yaffs_CheckStructures(void)
004e86  bf00              NOP      
;;;7718   {
;;;7719   /*      yaffs_CheckStruct(yaffs_Tags,8,"yaffs_Tags"); */
;;;7720   /*      yaffs_CheckStruct(yaffs_TagsUnion,8,"yaffs_TagsUnion"); */
;;;7721   /*      yaffs_CheckStruct(yaffs_Spare,16,"yaffs_Spare"); */
;;;7722   #ifndef CONFIG_YAFFS_TNODE_LIST_DEBUG
;;;7723           yaffs_CheckStruct(yaffs_Tnode, 2 * YAFFS_NTNODES_LEVEL0, "yaffs_Tnode");
004e88  bf00              NOP      
;;;7724   #endif
;;;7725   #ifndef CONFIG_YAFFS_WINCE
;;;7726   		yaffs_CheckStruct(yaffs_ObjectHeader, 512, "yaffs_ObjectHeader");
004e8a  bf00              NOP      
004e8c  bf00              NOP      
;;;7727   #endif
;;;7728   	    return YAFFS_OK;
004e8e  2001              MOVS     r0,#1
;;;7729   }
004e90  4770              BX       lr
                          ENDP

                  yaffs_GutsInitialise PROC
;;;7271   
;;;7272   int yaffs_GutsInitialise(yaffs_Device * dev)
004e92  e92d47f0          PUSH     {r4-r10,lr}
;;;7273   {
004e96  4604              MOV      r4,r0
;;;7274   	int init_failed = 0;
004e98  2500              MOVS     r5,#0
;;;7275   	unsigned x;
;;;7276   	int bits;
;;;7277   
;;;7278   	T(YAFFS_TRACE_TRACING, (TSTR("yaffs: yaffs_GutsInitialise()" TENDSTR)));
004e9a  bf00              NOP      
004e9c  bf00              NOP      
;;;7279   
;;;7280   	/* Check stuff that must be set */
;;;7281   
;;;7282   	if (!dev) {
004e9e  b924              CBNZ     r4,|L1.20138|
;;;7283   		T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Need a device" TENDSTR)));
004ea0  bf00              NOP      
004ea2  bf00              NOP      
;;;7284   		return YAFFS_FAIL;
004ea4  2000              MOVS     r0,#0
                  |L1.20134|
;;;7285   	}
;;;7286   
;;;7287   	dev->internalStartBlock = dev->startBlock;
;;;7288   	dev->internalEndBlock = dev->endBlock;
;;;7289   	dev->blockOffset = 0;
;;;7290   	dev->chunkOffset = 0;
;;;7291   	dev->nFreeChunks = 0;
;;;7292   	
;;;7293   	dev->gcBlock = -1;
;;;7294   
;;;7295   	if (dev->startBlock == 0) {
;;;7296   		dev->internalStartBlock = dev->startBlock + 1;
;;;7297   		dev->internalEndBlock = dev->endBlock + 1;
;;;7298   		dev->blockOffset = 1;
;;;7299   		dev->chunkOffset = dev->nChunksPerBlock;
;;;7300   	}
;;;7301   
;;;7302   	/* Check geometry parameters. */
;;;7303   
;;;7304   	if ((!dev->inbandTags && dev->isYaffs2 && dev->totalBytesPerChunk < 1024) || 
;;;7305   	    (!dev->isYaffs2 && dev->totalBytesPerChunk < 512) || 
;;;7306   	    (dev->inbandTags && !dev->isYaffs2 ) ||
;;;7307   	     dev->nChunksPerBlock < 2 || 
;;;7308   	     dev->nReservedBlocks < 2 || 
;;;7309   	     dev->internalStartBlock <= 0 || 
;;;7310   	     dev->internalEndBlock <= 0 || 
;;;7311   	     dev->internalEndBlock <= (dev->internalStartBlock + dev->nReservedBlocks + 2)	// otherwise it is too small
;;;7312   	    ) {
;;;7313    		 
;;;7314    
;;;7315   		return YAFFS_FAIL;
;;;7316   	}
;;;7317       
;;;7318   	if (yaffs_InitialiseNAND(dev) != YAFFS_OK) {
;;;7319   		 
;;;7320   		 
;;;7321   		return YAFFS_FAIL;
;;;7322   	}
;;;7323   	
;;;7324   	/* Sort out space for inband tags, if required */
;;;7325   	if(dev->inbandTags)
;;;7326   		dev->nDataBytesPerChunk = dev->totalBytesPerChunk - sizeof(yaffs_PackedTags2TagsPart);
;;;7327   	else 
;;;7328   		dev->nDataBytesPerChunk = dev->totalBytesPerChunk;
;;;7329   
;;;7330   	/* Got the right mix of functions? */
;;;7331   	if (!yaffs_CheckDevFunctions(dev)) {
;;;7332   		/* Function missing */
;;;7333   		T(YAFFS_TRACE_ALWAYS,
;;;7334   		  (TSTR
;;;7335   		   ("yaffs: device function(s) missing or wrong\n" TENDSTR)));
;;;7336   
;;;7337   		return YAFFS_FAIL;
;;;7338   	}
;;;7339       
;;;7340   	/* This is really a compilation check. */
;;;7341   	if (!yaffs_CheckStructures()) {
;;;7342   		T(YAFFS_TRACE_ALWAYS,
;;;7343   		  (TSTR("yaffs_CheckStructures failed\n" TENDSTR)));
;;;7344   		return YAFFS_FAIL;
;;;7345   	}
;;;7346       
;;;7347   	if (dev->isMounted) {
;;;7348   		T(YAFFS_TRACE_ALWAYS,
;;;7349   		  (TSTR("yaffs: device already mounted\n" TENDSTR)));
;;;7350   		return YAFFS_FAIL;
;;;7351   	}
;;;7352       
;;;7353   	/* Finished with most checks. One or two more checks happen later on too. */
;;;7354   
;;;7355   	dev->isMounted = 1;
;;;7356   
;;;7357   	/* OK now calculate a few things for the device */
;;;7358   	
;;;7359   	/*
;;;7360   	 *  Calculate all the chunk size manipulation numbers: 	 
;;;7361   	 */
;;;7362   	x = dev->nDataBytesPerChunk;
;;;7363   	/* We always use dev->chunkShift and dev->chunkDiv */
;;;7364   	dev->chunkShift = Shifts(x);
;;;7365   	x >>= dev->chunkShift;
;;;7366   	dev->chunkDiv = x;
;;;7367   	/* We only use chunk mask if chunkDiv is 1 */
;;;7368   	dev->chunkMask = (1<<dev->chunkShift) - 1;
;;;7369   	 	
;;;7370   	/*
;;;7371   	 * Calculate chunkGroupBits.
;;;7372   	 * We need to find the next power of 2 > than internalEndBlock
;;;7373   	 */
;;;7374   
;;;7375   	x = dev->nChunksPerBlock * (dev->internalEndBlock + 1);
;;;7376   	
;;;7377   	bits = ShiftsGE(x);
;;;7378   	
;;;7379   	/* Set up tnode width if wide tnodes are enabled. */
;;;7380   	if(!dev->wideTnodesDisabled){
;;;7381   		/* bits must be even so that we end up with 32-bit words */
;;;7382   		if(bits & 1)
;;;7383   			bits++;
;;;7384   		if(bits < 16)
;;;7385   			dev->tnodeWidth = 16;
;;;7386   		else
;;;7387   			dev->tnodeWidth = bits;
;;;7388   	}
;;;7389   	else
;;;7390   		dev->tnodeWidth = 16;
;;;7391    
;;;7392   	dev->tnodeMask = (1<<dev->tnodeWidth)-1;
;;;7393   		
;;;7394   	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
;;;7395   	 * so if the bitwidth of the
;;;7396   	 * chunk range we're using is greater than 16 we need
;;;7397   	 * to figure out chunk shift and chunkGroupSize
;;;7398   	 */
;;;7399   		 
;;;7400   	if (bits <= dev->tnodeWidth)
;;;7401   		dev->chunkGroupBits = 0;
;;;7402   	else
;;;7403   		dev->chunkGroupBits = bits - dev->tnodeWidth;
;;;7404   		
;;;7405   
;;;7406   	dev->chunkGroupSize = 1 << dev->chunkGroupBits;
;;;7407   
;;;7408   	if (dev->nChunksPerBlock < dev->chunkGroupSize) {
;;;7409   		/* We have a problem because the soft delete won't work if
;;;7410   		 * the chunk group size > chunks per block.
;;;7411   		 * This can be remedied by using larger "virtual blocks".
;;;7412   		 */
;;;7413   		T(YAFFS_TRACE_ALWAYS,
;;;7414   		  (TSTR("yaffs: chunk group too large\n" TENDSTR)));
;;;7415   
;;;7416   		return YAFFS_FAIL;
;;;7417   	}
;;;7418       
;;;7419   	/* OK, we've finished verifying the device, lets continue with initialisation */
;;;7420   
;;;7421   	/* More device initialisation */
;;;7422   	dev->garbageCollections = 0;
;;;7423   	dev->passiveGarbageCollections = 0;
;;;7424   	dev->currentDirtyChecker = 0;
;;;7425   	dev->bufferedBlock = -1;
;;;7426   	dev->doingBufferedBlockRewrite = 0;
;;;7427   	dev->nDeletedFiles = 0;
;;;7428   	dev->nBackgroundDeletions = 0;
;;;7429   	dev->nUnlinkedFiles = 0;
;;;7430   	dev->eccFixed = 0;
;;;7431   	dev->eccUnfixed = 0;
;;;7432   	dev->tagsEccFixed = 0;
;;;7433   	dev->tagsEccUnfixed = 0;
;;;7434   	dev->nErasureFailures = 0;
;;;7435   	dev->nErasedBlocks = 0;
;;;7436   	dev->isDoingGC = 0;
;;;7437   	dev->hasPendingPrioritisedGCs = 1; /* Assume the worst for now, will get fixed on first GC */
;;;7438     
;;;7439   	/* Initialise temporary buffers and caches. */
;;;7440   	if(!yaffs_InitialiseTempBuffers(dev))
;;;7441   		init_failed = 1;
;;;7442       
;;;7443   	dev->srCache = NULL;
;;;7444   	dev->gcCleanupList = NULL;
;;;7445   	
;;;7446   	if (!init_failed &&
;;;7447   	    dev->nShortOpCaches > 0) {
;;;7448   		int i;
;;;7449   		void *buf;
;;;7450   		int srCacheBytes = dev->nShortOpCaches * sizeof(yaffs_ChunkCache);
;;;7451   
;;;7452   		if (dev->nShortOpCaches > YAFFS_MAX_SHORT_OP_CACHES) {
;;;7453   			dev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;
;;;7454   		}
;;;7455   
;;;7456   		dev->srCache =  YMALLOC(srCacheBytes);
;;;7457   		
;;;7458   		buf = (__u8 *) dev->srCache;
;;;7459   		    
;;;7460   		if(dev->srCache)
;;;7461   			memset(dev->srCache,0,srCacheBytes);
;;;7462   		   
;;;7463   		for (i = 0; i < dev->nShortOpCaches && buf; i++) {
;;;7464   			dev->srCache[i].object = NULL;
;;;7465   			dev->srCache[i].lastUse = 0;
;;;7466   			dev->srCache[i].dirty = 0;
;;;7467   			dev->srCache[i].data = buf = YMALLOC_DMA(dev->totalBytesPerChunk);
;;;7468   		}
;;;7469   		if(!buf)
;;;7470   			init_failed = 1;
;;;7471   			
;;;7472   		dev->srLastUse = 0;
;;;7473   	}
;;;7474   
;;;7475   	dev->cacheHits = 0;
;;;7476   	
;;;7477   	if(!init_failed){
;;;7478   		dev->gcCleanupList = YMALLOC(dev->nChunksPerBlock * sizeof(__u32));
;;;7479   		if(!dev->gcCleanupList)
;;;7480   			init_failed = 1;
;;;7481   	}
;;;7482      
;;;7483   	if (dev->isYaffs2) {
;;;7484   		dev->useHeaderFileSize = 1;
;;;7485   	}
;;;7486       
;;;7487       
;;;7488   	if(!init_failed && !yaffs_InitialiseBlocks(dev))
;;;7489   		init_failed = 1;
;;;7490   	
;;;7491   	yaffs_InitialiseTnodes(dev);
;;;7492   	yaffs_InitialiseObjects(dev);
;;;7493       
;;;7494   	if(!init_failed && !yaffs_CreateInitialDirectories(dev))
;;;7495   		init_failed = 1;
;;;7496       
;;;7497   	if(!init_failed){
;;;7498   		/* Now scan the flash. */
;;;7499   		if (dev->isYaffs2) {
;;;7500   		    
;;;7501   			if(yaffs_CheckpointRestore(dev)) {
;;;7502   			    
;;;7503   				yaffs_CheckObjectDetailsLoaded(dev->rootDir);
;;;7504   				T(YAFFS_TRACE_ALWAYS,
;;;7505   				  (TSTR("yaffs: restored from checkpoint" TENDSTR)));
;;;7506   			} else {
;;;7507                   
;;;7508   				/* Clean up the mess caused by an aborted checkpoint load 
;;;7509   				 * and scan backwards. 
;;;7510   				 */
;;;7511   				yaffs_DeinitialiseBlocks(dev);
;;;7512   				yaffs_DeinitialiseTnodes(dev);
;;;7513   				yaffs_DeinitialiseObjects(dev);
;;;7514   				
;;;7515   			
;;;7516   				dev->nErasedBlocks = 0;
;;;7517   				dev->nFreeChunks = 0;
;;;7518   				dev->allocationBlock = -1;
;;;7519   				dev->allocationPage = -1;
;;;7520   				dev->nDeletedFiles = 0;
;;;7521   				dev->nUnlinkedFiles = 0;
;;;7522   				dev->nBackgroundDeletions = 0;
;;;7523   				dev->oldestDirtySequence = 0;
;;;7524   
;;;7525   				if(!init_failed && !yaffs_InitialiseBlocks(dev))
;;;7526   					init_failed = 1;
;;;7527   					
;;;7528   				yaffs_InitialiseTnodes(dev);
;;;7529   				yaffs_InitialiseObjects(dev);
;;;7530   
;;;7531   				if(!init_failed && !yaffs_CreateInitialDirectories(dev))
;;;7532   					init_failed = 1;
;;;7533   
;;;7534   				if(!init_failed && !yaffs_ScanBackwards(dev))
;;;7535   					init_failed = 1;
;;;7536   			}
;;;7537   		}else
;;;7538   			if(!yaffs_Scan(dev))
;;;7539   				init_failed = 1;
;;;7540   
;;;7541   		yaffs_StripDeletedObjects(dev);
;;;7542   	}
;;;7543   	
;;;7544   	if(init_failed){
;;;7545           
;;;7546   		/* Clean up the mess */
;;;7547   		T(YAFFS_TRACE_TRACING,
;;;7548   		  (TSTR("yaffs: yaffs_GutsInitialise() aborted.\n" TENDSTR)));
;;;7549   
;;;7550   		yaffs_Deinitialise(dev);
;;;7551           
;;;7552   		return YAFFS_FAIL;
;;;7553   	}
;;;7554       
;;;7555   	/* Zero out stats */
;;;7556   	dev->nPageReads = 0;
;;;7557   	dev->nPageWrites = 0;
;;;7558   	dev->nBlockErasures = 0;
;;;7559   	dev->nGCCopies = 0;
;;;7560   	dev->nRetriedWrites = 0;
;;;7561   
;;;7562   	dev->nRetiredBlocks = 0;
;;;7563   
;;;7564   	yaffs_VerifyFreeChunks(dev);
;;;7565   	yaffs_VerifyBlocks(dev);
;;;7566   	
;;;7567   
;;;7568   	T(YAFFS_TRACE_TRACING,
;;;7569   	  (TSTR("yaffs: yaffs_GutsInitialise() done.\n" TENDSTR)));
;;;7570   	return YAFFS_OK;
;;;7571   
;;;7572   }
004ea6  e8bd87f0          POP      {r4-r10,pc}
                  |L1.20138|
004eaa  69a0              LDR      r0,[r4,#0x18]         ;7287
004eac  f8c4009c          STR      r0,[r4,#0x9c]         ;7287
004eb0  69e0              LDR      r0,[r4,#0x1c]         ;7288
004eb2  f8c400a0          STR      r0,[r4,#0xa0]         ;7288
004eb6  2000              MOVS     r0,#0                 ;7289
004eb8  f8c400a4          STR      r0,[r4,#0xa4]         ;7289
004ebc  f8c400a8          STR      r0,[r4,#0xa8]         ;7290
004ec0  f8c40d34          STR      r0,[r4,#0xd34]        ;7291
004ec4  1e40              SUBS     r0,r0,#1              ;7293
004ec6  f8c40118          STR      r0,[r4,#0x118]        ;7293
004eca  69a0              LDR      r0,[r4,#0x18]         ;7295
004ecc  b968              CBNZ     r0,|L1.20202|
004ece  69a0              LDR      r0,[r4,#0x18]         ;7296
004ed0  1c40              ADDS     r0,r0,#1              ;7296
004ed2  f8c4009c          STR      r0,[r4,#0x9c]         ;7296
004ed6  69e0              LDR      r0,[r4,#0x1c]         ;7297
004ed8  1c40              ADDS     r0,r0,#1              ;7297
004eda  f8c400a0          STR      r0,[r4,#0xa0]         ;7297
004ede  2001              MOVS     r0,#1                 ;7298
004ee0  f8c400a4          STR      r0,[r4,#0xa4]         ;7298
004ee4  6920              LDR      r0,[r4,#0x10]         ;7299
004ee6  f8c400a8          STR      r0,[r4,#0xa8]         ;7299
                  |L1.20202|
004eea  f8d4008c          LDR      r0,[r4,#0x8c]         ;7304
004eee  b930              CBNZ     r0,|L1.20222|
004ef0  6de0              LDR      r0,[r4,#0x5c]         ;7304
004ef2  b120              CBZ      r0,|L1.20222|
004ef4  f8d40090          LDR      r0,[r4,#0x90]         ;7304
004ef8  f5b06f80          CMP      r0,#0x400             ;7304
004efc  d322              BCC      |L1.20292|
                  |L1.20222|
004efe  6de0              LDR      r0,[r4,#0x5c]         ;7305
004f00  b920              CBNZ     r0,|L1.20236|
004f02  f8d40090          LDR      r0,[r4,#0x90]         ;7305
004f06  f5b07f00          CMP      r0,#0x200             ;7305
004f0a  d31b              BCC      |L1.20292|
                  |L1.20236|
004f0c  f8d4008c          LDR      r0,[r4,#0x8c]         ;7306
004f10  b108              CBZ      r0,|L1.20246|
004f12  6de0              LDR      r0,[r4,#0x5c]         ;7306
004f14  b1b0              CBZ      r0,|L1.20292|
                  |L1.20246|
004f16  6920              LDR      r0,[r4,#0x10]         ;7307
004f18  2802              CMP      r0,#2                 ;7307
004f1a  db13              BLT      |L1.20292|
004f1c  6a20              LDR      r0,[r4,#0x20]         ;7308
004f1e  2802              CMP      r0,#2                 ;7308
004f20  db10              BLT      |L1.20292|
004f22  f8d4009c          LDR      r0,[r4,#0x9c]         ;7309
004f26  2800              CMP      r0,#0                 ;7309
004f28  dd0c              BLE      |L1.20292|
004f2a  f8d400a0          LDR      r0,[r4,#0xa0]         ;7310
004f2e  2800              CMP      r0,#0                 ;7310
004f30  dd08              BLE      |L1.20292|
004f32  6a21              LDR      r1,[r4,#0x20]         ;7311
004f34  f8d4009c          LDR      r0,[r4,#0x9c]         ;7311
004f38  4408              ADD      r0,r0,r1              ;7311
004f3a  1c80              ADDS     r0,r0,#2              ;7311
004f3c  f8d410a0          LDR      r1,[r4,#0xa0]         ;7311
004f40  4288              CMP      r0,r1                 ;7311
004f42  db01              BLT      |L1.20296|
                  |L1.20292|
004f44  2000              MOVS     r0,#0                 ;7315
004f46  e7ae              B        |L1.20134|
                  |L1.20296|
004f48  4620              MOV      r0,r4                 ;7318
004f4a  f7fffffe          BL       yaffs_InitialiseNAND
004f4e  2801              CMP      r0,#1                 ;7318
004f50  d001              BEQ      |L1.20310|
004f52  2000              MOVS     r0,#0                 ;7321
004f54  e7a7              B        |L1.20134|
                  |L1.20310|
004f56  f8d4008c          LDR      r0,[r4,#0x8c]         ;7325
004f5a  b120              CBZ      r0,|L1.20326|
004f5c  f8d40090          LDR      r0,[r4,#0x90]         ;7326
004f60  3810              SUBS     r0,r0,#0x10           ;7326
004f62  60e0              STR      r0,[r4,#0xc]          ;7326
004f64  e002              B        |L1.20332|
                  |L1.20326|
004f66  f8d40090          LDR      r0,[r4,#0x90]         ;7328
004f6a  60e0              STR      r0,[r4,#0xc]          ;7328
                  |L1.20332|
004f6c  4620              MOV      r0,r4                 ;7331
004f6e  f7fffffe          BL       yaffs_CheckDevFunctions
004f72  b918              CBNZ     r0,|L1.20348|
004f74  bf00              NOP                            ;7333
004f76  bf00              NOP                            ;7333
004f78  2000              MOVS     r0,#0                 ;7337
004f7a  e794              B        |L1.20134|
                  |L1.20348|
004f7c  f7fffffe          BL       yaffs_CheckStructures
004f80  b918              CBNZ     r0,|L1.20362|
004f82  bf00              NOP                            ;7342
004f84  bf00              NOP                            ;7342
004f86  2000              MOVS     r0,#0                 ;7344
004f88  e78d              B        |L1.20134|
                  |L1.20362|
004f8a  f8d40094          LDR      r0,[r4,#0x94]         ;7347
004f8e  b118              CBZ      r0,|L1.20376|
004f90  bf00              NOP                            ;7348
004f92  bf00              NOP                            ;7348
004f94  2000              MOVS     r0,#0                 ;7350
004f96  e786              B        |L1.20134|
                  |L1.20376|
004f98  2001              MOVS     r0,#1                 ;7355
004f9a  3464              ADDS     r4,r4,#0x64           ;7355
004f9c  6320              STR      r0,[r4,#0x30]         ;7355
004f9e  f8548c58          LDR      r8,[r4,#-0x58]        ;7362
004fa2  4640              MOV      r0,r8                 ;7364
004fa4  f7fffffe          BL       Shifts
004fa8  61e0              STR      r0,[r4,#0x1c]         ;7364
004faa  7f20              LDRB     r0,[r4,#0x1c]         ;7365
004fac  fa28f800          LSR      r8,r8,r0              ;7365
004fb0  f8c48020          STR      r8,[r4,#0x20]         ;7366
004fb4  7f21              LDRB     r1,[r4,#0x1c]         ;7368
004fb6  2001              MOVS     r0,#1                 ;7368
004fb8  4088              LSLS     r0,r0,r1              ;7368
004fba  1e40              SUBS     r0,r0,#1              ;7368
004fbc  6260              STR      r0,[r4,#0x24]         ;7368
004fbe  f8540c54          LDR      r0,[r4,#-0x54]        ;7375
004fc2  6be1              LDR      r1,[r4,#0x3c]         ;7375
004fc4  1c49              ADDS     r1,r1,#1              ;7375
004fc6  fb00f801          MUL      r8,r0,r1              ;7375
004fca  4640              MOV      r0,r8                 ;7377
004fcc  f7fffffe          BL       ShiftsGE
004fd0  4606              MOV      r6,r0                 ;7377
004fd2  6860              LDR      r0,[r4,#4]            ;7380
004fd4  3c64              SUBS     r4,r4,#0x64           ;7380
004fd6  b950              CBNZ     r0,|L1.20462|
004fd8  f0060001          AND      r0,r6,#1              ;7382
004fdc  b100              CBZ      r0,|L1.20448|
004fde  1c76              ADDS     r6,r6,#1              ;7383
                  |L1.20448|
004fe0  2e10              CMP      r6,#0x10              ;7384
004fe2  da02              BGE      |L1.20458|
004fe4  2010              MOVS     r0,#0x10              ;7385
004fe6  67a0              STR      r0,[r4,#0x78]         ;7385
004fe8  e003              B        |L1.20466|
                  |L1.20458|
004fea  67a6              STR      r6,[r4,#0x78]         ;7387
004fec  e001              B        |L1.20466|
                  |L1.20462|
004fee  2010              MOVS     r0,#0x10              ;7390
004ff0  67a0              STR      r0,[r4,#0x78]         ;7390
                  |L1.20466|
004ff2  f8941078          LDRB     r1,[r4,#0x78]         ;7392
004ff6  2001              MOVS     r0,#1                 ;7392
004ff8  4088              LSLS     r0,r0,r1              ;7392
004ffa  1e40              SUBS     r0,r0,#1              ;7392
004ffc  67e0              STR      r0,[r4,#0x7c]         ;7392
004ffe  6fa0              LDR      r0,[r4,#0x78]         ;7400
005000  42b0              CMP      r0,r6                 ;7400
005002  d303              BCC      |L1.20492|
005004  2000              MOVS     r0,#0                 ;7401
005006  f8a40072          STRH     r0,[r4,#0x72]         ;7401
00500a  e004              B        |L1.20502|
                  |L1.20492|
00500c  f8b40078          LDRH     r0,[r4,#0x78]         ;7403
005010  1a30              SUBS     r0,r6,r0              ;7403
005012  f8a40072          STRH     r0,[r4,#0x72]         ;7403
                  |L1.20502|
005016  f8941072          LDRB     r1,[r4,#0x72]         ;7406
00501a  2001              MOVS     r0,#1                 ;7406
00501c  4088              LSLS     r0,r0,r1              ;7406
00501e  f8a40074          STRH     r0,[r4,#0x74]         ;7406
005022  f8b41074          LDRH     r1,[r4,#0x74]         ;7408
005026  6920              LDR      r0,[r4,#0x10]         ;7408
005028  4288              CMP      r0,r1                 ;7408
00502a  da03              BGE      |L1.20532|
00502c  bf00              NOP                            ;7413
00502e  bf00              NOP                            ;7413
005030  2000              MOVS     r0,#0                 ;7416
005032  e738              B        |L1.20134|
                  |L1.20532|
005034  2000              MOVS     r0,#0                 ;7422
005036  f8c40d58          STR      r0,[r4,#0xd58]        ;7422
00503a  f8c40d5c          STR      r0,[r4,#0xd5c]        ;7423
00503e  f8c40d38          STR      r0,[r4,#0xd38]        ;7424
005042  1e40              SUBS     r0,r0,#1              ;7425
005044  f8c40d8c          STR      r0,[r4,#0xd8c]        ;7425
005048  2000              MOVS     r0,#0                 ;7426
00504a  f8c40d90          STR      r0,[r4,#0xd90]        ;7426
00504e  f8c40dac          STR      r0,[r4,#0xdac]        ;7427
005052  f8c40db4          STR      r0,[r4,#0xdb4]        ;7428
005056  f8c40db0          STR      r0,[r4,#0xdb0]        ;7429
00505a  f8c40d68          STR      r0,[r4,#0xd68]        ;7430
00505e  f8c40d6c          STR      r0,[r4,#0xd6c]        ;7431
005062  f8c40d70          STR      r0,[r4,#0xd70]        ;7432
005066  f8c40d74          STR      r0,[r4,#0xd74]        ;7433
00506a  f8c40d50          STR      r0,[r4,#0xd50]        ;7434
00506e  f8c400f4          STR      r0,[r4,#0xf4]         ;7435
005072  f8c40114          STR      r0,[r4,#0x114]        ;7436
005076  2001              MOVS     r0,#1                 ;7437
005078  f8c40d80          STR      r0,[r4,#0xd80]        ;7437
00507c  4620              MOV      r0,r4                 ;7440
00507e  f7fffffe          BL       yaffs_InitialiseTempBuffers
005082  b900              CBNZ     r0,|L1.20614|
005084  2501              MOVS     r5,#1                 ;7441
                  |L1.20614|
005086  2000              MOVS     r0,#0                 ;7443
005088  f8c40d94          STR      r0,[r4,#0xd94]        ;7443
00508c  f8c40d3c          STR      r0,[r4,#0xd3c]        ;7444
005090  bbf5              CBNZ     r5,|L1.20752|
005092  6a60              LDR      r0,[r4,#0x24]         ;7447
005094  2800              CMP      r0,#0                 ;7447
005096  dd4c              BLE      |L1.20786|
005098  6a60              LDR      r0,[r4,#0x24]         ;7450
00509a  ebc000c0          RSB      r0,r0,r0,LSL #3       ;7450
00509e  ea4f0a80          LSL      r10,r0,#2             ;7450
0050a2  6a60              LDR      r0,[r4,#0x24]         ;7452
0050a4  2814              CMP      r0,#0x14              ;7452
0050a6  dd01              BLE      |L1.20652|
0050a8  2014              MOVS     r0,#0x14              ;7453
0050aa  6260              STR      r0,[r4,#0x24]         ;7453
                  |L1.20652|
0050ac  4650              MOV      r0,r10                ;7456
0050ae  f7fffffe          BL       yaffs_malloc
0050b2  f8c40d94          STR      r0,[r4,#0xd94]        ;7456
0050b6  f8d49d94          LDR      r9,[r4,#0xd94]        ;7458
0050ba  f8d40d94          LDR      r0,[r4,#0xd94]        ;7460
0050be  b120              CBZ      r0,|L1.20682|
0050c0  4651              MOV      r1,r10                ;7461
0050c2  f8d40d94          LDR      r0,[r4,#0xd94]        ;7461
0050c6  f7fffffe          BL       __aeabi_memclr4
                  |L1.20682|
0050ca  2700              MOVS     r7,#0                 ;7463
0050cc  e023              B        |L1.20758|
                  |L1.20686|
0050ce  2000              MOVS     r0,#0                 ;7464
0050d0  ebc702c7          RSB      r2,r7,r7,LSL #3       ;7464
0050d4  f8d41d94          LDR      r1,[r4,#0xd94]        ;7464
0050d8  f8410022          STR      r0,[r1,r2,LSL #2]     ;7464
0050dc  ebc702c7          RSB      r2,r7,r7,LSL #3       ;7465
0050e0  f8d41d94          LDR      r1,[r4,#0xd94]        ;7465
0050e4  eb010182          ADD      r1,r1,r2,LSL #2       ;7465
0050e8  6088              STR      r0,[r1,#8]            ;7465
0050ea  ebc702c7          RSB      r2,r7,r7,LSL #3       ;7466
0050ee  f8d41d94          LDR      r1,[r4,#0xd94]        ;7466
0050f2  eb010182          ADD      r1,r1,r2,LSL #2       ;7466
0050f6  60c8              STR      r0,[r1,#0xc]          ;7466
0050f8  f8d40090          LDR      r0,[r4,#0x90]         ;7467
0050fc  f7fffffe          BL       yaffs_malloc
005100  4681              MOV      r9,r0                 ;7467
005102  ebc702c7          RSB      r2,r7,r7,LSL #3       ;7467
005106  f8d41d94          LDR      r1,[r4,#0xd94]        ;7467
00510a  eb010182          ADD      r1,r1,r2,LSL #2       ;7467
00510e  e000              B        |L1.20754|
                  |L1.20752|
005110  e00f              B        |L1.20786|
                  |L1.20754|
005112  6188              STR      r0,[r1,#0x18]         ;7467
005114  1c7f              ADDS     r7,r7,#1              ;7463
                  |L1.20758|
005116  6a60              LDR      r0,[r4,#0x24]         ;7463
005118  42b8              CMP      r0,r7                 ;7463
00511a  dd02              BLE      |L1.20770|
00511c  f1b90f00          CMP      r9,#0                 ;7463
005120  d1d5              BNE      |L1.20686|
                  |L1.20770|
005122  f1b90f00          CMP      r9,#0                 ;7469
005126  d100              BNE      |L1.20778|
005128  2501              MOVS     r5,#1                 ;7470
                  |L1.20778|
00512a  2000              MOVS     r0,#0                 ;7472
00512c  f8c40d98          STR      r0,[r4,#0xd98]        ;7472
005130  bf00              NOP                            ;7473
                  |L1.20786|
005132  2000              MOVS     r0,#0                 ;7475
005134  f8c40d9c          STR      r0,[r4,#0xd9c]        ;7475
005138  b94d              CBNZ     r5,|L1.20814|
00513a  6921              LDR      r1,[r4,#0x10]         ;7478
00513c  0088              LSLS     r0,r1,#2              ;7478
00513e  f7fffffe          BL       yaffs_malloc
005142  f8c40d3c          STR      r0,[r4,#0xd3c]        ;7478
005146  f8d40d3c          LDR      r0,[r4,#0xd3c]        ;7479
00514a  b900              CBNZ     r0,|L1.20814|
00514c  2501              MOVS     r5,#1                 ;7480
                  |L1.20814|
00514e  6de0              LDR      r0,[r4,#0x5c]         ;7483
005150  b108              CBZ      r0,|L1.20822|
005152  2001              MOVS     r0,#1                 ;7484
005154  62a0              STR      r0,[r4,#0x28]         ;7484
                  |L1.20822|
005156  b925              CBNZ     r5,|L1.20834|
005158  4620              MOV      r0,r4                 ;7488
00515a  f7fffffe          BL       yaffs_InitialiseBlocks
00515e  b900              CBNZ     r0,|L1.20834|
005160  2501              MOVS     r5,#1                 ;7489
                  |L1.20834|
005162  4620              MOV      r0,r4                 ;7491
005164  f7fffffe          BL       yaffs_InitialiseTnodes
005168  4620              MOV      r0,r4                 ;7492
00516a  f7fffffe          BL       yaffs_InitialiseObjects
00516e  b925              CBNZ     r5,|L1.20858|
005170  4620              MOV      r0,r4                 ;7494
005172  f7fffffe          BL       yaffs_CreateInitialDirectories
005176  b900              CBNZ     r0,|L1.20858|
005178  2501              MOVS     r5,#1                 ;7495
                  |L1.20858|
00517a  bbed              CBNZ     r5,|L1.20984|
00517c  6de0              LDR      r0,[r4,#0x5c]         ;7499
00517e  b3e0              CBZ      r0,|L1.20986|
005180  4620              MOV      r0,r4                 ;7501
005182  f7fffffe          BL       yaffs_CheckpointRestore
005186  b128              CBZ      r0,|L1.20884|
005188  f8d40d84          LDR      r0,[r4,#0xd84]        ;7503
00518c  f7fffffe          BL       yaffs_CheckObjectDetailsLoaded
005190  bf00              NOP                            ;7504
005192  e03b              B        |L1.21004|
                  |L1.20884|
005194  4620              MOV      r0,r4                 ;7511
005196  f7fffffe          BL       yaffs_DeinitialiseBlocks
00519a  4620              MOV      r0,r4                 ;7512
00519c  f7fffffe          BL       yaffs_DeinitialiseTnodes
0051a0  4620              MOV      r0,r4                 ;7513
0051a2  f7fffffe          BL       yaffs_DeinitialiseObjects
0051a6  2000              MOVS     r0,#0                 ;7516
0051a8  f8440ff4          STR      r0,[r4,#0xf4]!        ;7516
0051ac  f8c40c40          STR      r0,[r4,#0xc40]        ;7517
0051b0  1e40              SUBS     r0,r0,#1              ;7518
0051b2  6060              STR      r0,[r4,#4]            ;7518
0051b4  60a0              STR      r0,[r4,#8]            ;7519
0051b6  2000              MOVS     r0,#0                 ;7520
0051b8  f8c40cb8          STR      r0,[r4,#0xcb8]        ;7520
0051bc  f8c40cbc          STR      r0,[r4,#0xcbc]        ;7521
0051c0  f8c40cc0          STR      r0,[r4,#0xcc0]        ;7522
0051c4  f8c40d20          STR      r0,[r4,#0xd20]        ;7523
0051c8  3cf4              SUBS     r4,r4,#0xf4           ;7523
0051ca  b925              CBNZ     r5,|L1.20950|
0051cc  4620              MOV      r0,r4                 ;7525
0051ce  f7fffffe          BL       yaffs_InitialiseBlocks
0051d2  b900              CBNZ     r0,|L1.20950|
0051d4  2501              MOVS     r5,#1                 ;7526
                  |L1.20950|
0051d6  4620              MOV      r0,r4                 ;7528
0051d8  f7fffffe          BL       yaffs_InitialiseTnodes
0051dc  4620              MOV      r0,r4                 ;7529
0051de  f7fffffe          BL       yaffs_InitialiseObjects
0051e2  b925              CBNZ     r5,|L1.20974|
0051e4  4620              MOV      r0,r4                 ;7531
0051e6  f7fffffe          BL       yaffs_CreateInitialDirectories
0051ea  b900              CBNZ     r0,|L1.20974|
0051ec  2501              MOVS     r5,#1                 ;7532
                  |L1.20974|
0051ee  b96d              CBNZ     r5,|L1.21004|
0051f0  4620              MOV      r0,r4                 ;7534
0051f2  f7fffffe          BL       yaffs_ScanBackwards
0051f6  e001              B        |L1.20988|
                  |L1.20984|
0051f8  e00b              B        |L1.21010|
                  |L1.20986|
0051fa  e002              B        |L1.20994|
                  |L1.20988|
0051fc  b930              CBNZ     r0,|L1.21004|
0051fe  2501              MOVS     r5,#1                 ;7535
005200  e004              B        |L1.21004|
                  |L1.20994|
005202  4620              MOV      r0,r4                 ;7538
005204  f7fffffe          BL       yaffs_Scan
005208  b900              CBNZ     r0,|L1.21004|
00520a  2501              MOVS     r5,#1                 ;7539
                  |L1.21004|
00520c  4620              MOV      r0,r4                 ;7541
00520e  f7fffffe          BL       yaffs_StripDeletedObjects
                  |L1.21010|
005212  b135              CBZ      r5,|L1.21026|
005214  bf00              NOP                            ;7547
005216  bf00              NOP                            ;7547
005218  4620              MOV      r0,r4                 ;7550
00521a  f7fffffe          BL       yaffs_Deinitialise
00521e  2000              MOVS     r0,#0                 ;7552
005220  e641              B        |L1.20134|
                  |L1.21026|
005222  2000              MOVS     r0,#0                 ;7556
005224  f6045444          ADD      r4,r4,#0xd44          ;7556
005228  6060              STR      r0,[r4,#4]            ;7556
00522a  6020              STR      r0,[r4,#0]            ;7557
00522c  60a0              STR      r0,[r4,#8]            ;7558
00522e  6120              STR      r0,[r4,#0x10]         ;7559
005230  61e0              STR      r0,[r4,#0x1c]         ;7560
005232  6220              STR      r0,[r4,#0x20]         ;7562
005234  f6a45444          SUB      r4,r4,#0xd44          ;7562
005238  4620              MOV      r0,r4                 ;7564
00523a  f7fffffe          BL       yaffs_VerifyFreeChunks
00523e  4620              MOV      r0,r4                 ;7565
005240  f7fffffe          BL       yaffs_VerifyBlocks
005244  bf00              NOP                            ;7568
005246  bf00              NOP                            ;7568
005248  2001              MOVS     r0,#1                 ;7570
00524a  e62c              B        |L1.20134|
;;;7573   
                          ENDP

                  ylist_empty PROC
;;;110    /* Test if the list is empty */
;;;111    static __inline__ int ylist_empty(struct ylist_head *entry)
00524c  4601              MOV      r1,r0
;;;112    {
;;;113            return (entry->next == entry);
00524e  6808              LDR      r0,[r1,#0]
005250  4288              CMP      r0,r1
005252  d101              BNE      |L1.21080|
005254  2001              MOVS     r0,#1
                  |L1.21078|
;;;114    }
005256  4770              BX       lr
                  |L1.21080|
005258  2000              MOVS     r0,#0                 ;113
00525a  e7fc              B        |L1.21078|
;;;115    
                          ENDP

                  yaffs_ClearChunkBits PROC
;;;334    
;;;335    static Y_INLINE void yaffs_ClearChunkBits(yaffs_Device * dev, int blk)
00525c  b570              PUSH     {r4-r6,lr}
;;;336    {
00525e  4604              MOV      r4,r0
005260  460d              MOV      r5,r1
;;;337    	__u8 *blkBits = yaffs_BlockBits(dev, blk);
005262  4629              MOV      r1,r5
005264  4620              MOV      r0,r4
005266  f7fffffe          BL       yaffs_BlockBits
00526a  4606              MOV      r6,r0
;;;338    
;;;339    	memset(blkBits, 0, dev->chunkBitmapStride);
00526c  4630              MOV      r0,r6
00526e  f8d410f0          LDR      r1,[r4,#0xf0]
005272  f7fffffe          BL       __aeabi_memclr
;;;340    }
005276  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP


                          AREA ||area_number.2||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.2||, ||.text||
                  yaffs_IsManagedTempBuffer PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;886    }
000006  2100              MOVS     r1,#0
000008  e00a              B        |L2.32|
                  |L2.10|
00000a  eb010441          ADD      r4,r1,r1,LSL #1
00000e  f60250b8          ADD      r0,r2,#0xdb8
000012  f8500024          LDR      r0,[r0,r4,LSL #2]
000016  4298              CMP      r0,r3
000018  d101              BNE      |L2.30|
00001a  2001              MOVS     r0,#1
                  |L2.28|
00001c  bd10              POP      {r4,pc}
                  |L2.30|
00001e  1c49              ADDS     r1,r1,#1
                  |L2.32|
000020  2906              CMP      r1,#6
000022  dbf2              BLT      |L2.10|
000024  2100              MOVS     r1,#0
000026  e00b              B        |L2.64|
                  |L2.40|
000028  ebc104c1          RSB      r4,r1,r1,LSL #3
00002c  f8d20d94          LDR      r0,[r2,#0xd94]
000030  eb000084          ADD      r0,r0,r4,LSL #2
000034  6980              LDR      r0,[r0,#0x18]
000036  4298              CMP      r0,r3
000038  d101              BNE      |L2.62|
00003a  2001              MOVS     r0,#1
00003c  e7ee              B        |L2.28|
                  |L2.62|
00003e  1c49              ADDS     r1,r1,#1
                  |L2.64|
000040  6a50              LDR      r0,[r2,#0x24]
000042  4288              CMP      r0,r1
000044  dcf0              BGT      |L2.40|
000046  f8d200b8          LDR      r0,[r2,#0xb8]
00004a  4298              CMP      r0,r3
00004c  d101              BNE      |L2.82|
00004e  2001              MOVS     r0,#1
000050  e7e4              B        |L2.28|
                  |L2.82|
000052  bf00              NOP      
000054  bf00              NOP      
000056  2000              MOVS     r0,#0
000058  e7e0              B        |L2.28|
;;;887    
                          ENDP


                          AREA ||area_number.3||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.3||, ||.text||
                  yaffs_Root PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  4601              MOV      r1,r0
;;;884    {
;;;885    	return dev->rootDir;
000002  f8d10d84          LDR      r0,[r1,#0xd84]
;;;886    }
000006  4770              BX       lr
;;;887    
                          ENDP


                          AREA ||area_number.4||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.4||, ||.text||
                  yaffs_LostNFound PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  4601              MOV      r1,r0
;;;884    {
;;;885    	return dev->rootDir;
000002  f8d10d88          LDR      r0,[r1,#0xd88]
;;;886    }
000006  4770              BX       lr
;;;887    
                          ENDP


                          AREA ||area_number.5||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.5||, ||.text||
                  yaffs_MknodSpecial PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;884    {
;;;885    	return dev->rootDir;
000004  b085              SUB      sp,sp,#0x14
;;;886    }
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  e9dd890c          LDRD     r8,r9,[sp,#0x30]
000012  2000              MOVS     r0,#0
000014  e9cd8001          STRD     r8,r0,[sp,#4]
000018  4633              MOV      r3,r6
00001a  462a              MOV      r2,r5
00001c  4621              MOV      r1,r4
00001e  e9cd0903          STRD     r0,r9,[sp,#0xc]
000022  9700              STR      r7,[sp,#0]
000024  2005              MOVS     r0,#5
000026  f7fffffe          BL       yaffs_MknodObject
00002a  b005              ADD      sp,sp,#0x14
00002c  e8bd83f0          POP      {r4-r9,pc}
;;;887    
                          ENDP


                          AREA ||area_number.6||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.6||, ||.text||
                  yaffs_MknodSymLink PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;884    {
;;;885    	return dev->rootDir;
000004  b085              SUB      sp,sp,#0x14
;;;886    }
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  e9dd890c          LDRD     r8,r9,[sp,#0x30]
000012  2000              MOVS     r0,#0
000014  e9cd8001          STRD     r8,r0,[sp,#4]
000018  4633              MOV      r3,r6
00001a  462a              MOV      r2,r5
00001c  4621              MOV      r1,r4
00001e  e9cd9003          STRD     r9,r0,[sp,#0xc]
000022  9700              STR      r7,[sp,#0]
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       yaffs_MknodObject
00002a  b005              ADD      sp,sp,#0x14
00002c  e8bd83f0          POP      {r4-r9,pc}
;;;887    
                          ENDP


                          AREA ||area_number.7||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.7||, ||.text||
                  yaffs_Link PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b570              PUSH     {r4-r6,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
;;;886    }
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       yaffs_GetEquivalentObject
000010  4604              MOV      r4,r0
000012  2000              MOVS     r0,#0
000014  e9cd0401          STRD     r0,r4,[sp,#4]
000018  9003              STR      r0,[sp,#0xc]
00001a  9004              STR      r0,[sp,#0x10]
00001c  4603              MOV      r3,r0
00001e  4632              MOV      r2,r6
000020  4629              MOV      r1,r5
000022  9000              STR      r0,[sp,#0]
000024  2004              MOVS     r0,#4
000026  f7fffffe          BL       yaffs_MknodObject
00002a  b110              CBZ      r0,|L7.50|
00002c  4620              MOV      r0,r4
                  |L7.46|
00002e  b006              ADD      sp,sp,#0x18
000030  bd70              POP      {r4-r6,pc}
                  |L7.50|
000032  2000              MOVS     r0,#0
000034  e7fb              B        |L7.46|
;;;887    
                          ENDP


                          AREA ||area_number.8||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.8||, ||.text||
                  yaffs_RenameObject PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;884    {
;;;885    	return dev->rootDir;
000004  4680              MOV      r8,r0
;;;886    }
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  2700              MOVS     r7,#0
00000e  2400              MOVS     r4,#0
000010  46a2              MOV      r10,r4
000012  b15d              CBZ      r5,|L8.44|
000014  f8950054          LDRB     r0,[r5,#0x54]
000018  2803              CMP      r0,#3
00001a  d107              BNE      |L8.44|
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       strlen
000022  28ff              CMP      r0,#0xff
000024  d902              BLS      |L8.44|
000026  2000              MOVS     r0,#0
                  |L8.40|
000028  e8bd8ff8          POP      {r3-r11,pc}
                  |L8.44|
00002c  4649              MOV      r1,r9
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       yaffs_FindObjectByName
000034  4607              MOV      r7,r0
000036  b35f              CBZ      r7,|L8.144|
000038  7838              LDRB     r0,[r7,#0]
00003a  f3c01000          UBFX     r0,r0,#4,#1
00003e  b338              CBZ      r0,|L8.144|
000040  4631              MOV      r1,r6
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       yaffs_FindObjectByName
000048  4604              MOV      r4,r0
00004a  b154              CBZ      r4,|L8.98|
00004c  f8940054          LDRB     r0,[r4,#0x54]
000050  2803              CMP      r0,#3
000052  d106              BNE      |L8.98|
000054  f1040058          ADD      r0,r4,#0x58
000058  f7fffffe          BL       ylist_empty
00005c  b908              CBNZ     r0,|L8.98|
00005e  2000              MOVS     r0,#0
000060  e7e2              B        |L8.40|
                  |L8.98|
000062  b164              CBZ      r4,|L8.126|
000064  42bc              CMP      r4,r7
000066  d00a              BEQ      |L8.126|
000068  6b20              LDR      r0,[r4,#0x30]
00006a  4653              MOV      r3,r10
00006c  4632              MOV      r2,r6
00006e  4629              MOV      r1,r5
000070  9000              STR      r0,[sp,#0]
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       yaffs_ChangeObjectName
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       yaffs_UnlinkObject
                  |L8.126|
00007e  2000              MOVS     r0,#0
000080  2301              MOVS     r3,#1
000082  4632              MOV      r2,r6
000084  4629              MOV      r1,r5
000086  9000              STR      r0,[sp,#0]
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       yaffs_ChangeObjectName
00008e  e7cb              B        |L8.40|
                  |L8.144|
000090  2000              MOVS     r0,#0
000092  e7c9              B        |L8.40|
;;;887    
                          ENDP


                          AREA ||area_number.9||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.text||
                  yaffs_FlushEntireDeviceCache PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;884    {
;;;885    	return dev->rootDir;
000004  4604              MOV      r4,r0
;;;886    }
000006  6a67              LDR      r7,[r4,#0x24]
000008  bf00              NOP      
                  |L9.10|
00000a  2600              MOVS     r6,#0
00000c  2500              MOVS     r5,#0
00000e  e015              B        |L9.60|
                  |L9.16|
000010  ebc501c5          RSB      r1,r5,r5,LSL #3
000014  f8d40d94          LDR      r0,[r4,#0xd94]
000018  f8500021          LDR      r0,[r0,r1,LSL #2]
00001c  b168              CBZ      r0,|L9.58|
00001e  ebc501c5          RSB      r1,r5,r5,LSL #3
000022  f8d40d94          LDR      r0,[r4,#0xd94]
000026  eb000081          ADD      r0,r0,r1,LSL #2
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  b128              CBZ      r0,|L9.58|
00002e  ebc501c5          RSB      r1,r5,r5,LSL #3
000032  f8d40d94          LDR      r0,[r4,#0xd94]
000036  f8506021          LDR      r6,[r0,r1,LSL #2]
                  |L9.58|
00003a  1c6d              ADDS     r5,r5,#1
                  |L9.60|
00003c  42bd              CMP      r5,r7
00003e  da01              BGE      |L9.68|
000040  2e00              CMP      r6,#0
000042  d0e5              BEQ      |L9.16|
                  |L9.68|
000044  b116              CBZ      r6,|L9.76|
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       yaffs_FlushFilesChunkCache
                  |L9.76|
00004c  2e00              CMP      r6,#0
00004e  d1dc              BNE      |L9.10|
000050  e8bd81f0          POP      {r4-r8,pc}
;;;887    
                          ENDP


                          AREA ||area_number.10||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.text||
                  yaffs_CheckpointSave PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4604              MOV      r4,r0
000004  bf00              NOP      
;;;886    }
000006  bf00              NOP      
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       yaffs_VerifyObjects
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       yaffs_VerifyBlocks
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       yaffs_VerifyFreeChunks
00001a  f8d40098          LDR      r0,[r4,#0x98]
00001e  b928              CBNZ     r0,|L10.44|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       yaffs_InvalidateCheckpoint
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       yaffs_WriteCheckpointData
                  |L10.44|
00002c  bf00              NOP      
00002e  bf00              NOP      
000030  f8d40098          LDR      r0,[r4,#0x98]
000034  bd10              POP      {r4,pc}
;;;887    
                          ENDP


                          AREA ||area_number.11||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.11||, ||.text||
                  yaffs_GetFileSize PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
;;;886    }
000006  f7fffffe          BL       yaffs_GetEquivalentObject
00000a  4604              MOV      r4,r0
00000c  f8940054          LDRB     r0,[r4,#0x54]
000010  2801              CMP      r0,#1
000012  d002              BEQ      |L11.26|
000014  2802              CMP      r0,#2
000016  d106              BNE      |L11.38|
000018  e001              B        |L11.30|
                  |L11.26|
00001a  6da0              LDR      r0,[r4,#0x58]
                  |L11.28|
00001c  bd10              POP      {r4,pc}
                  |L11.30|
00001e  6da0              LDR      r0,[r4,#0x58]
000020  f7fffffe          BL       strlen
000024  e7fa              B        |L11.28|
                  |L11.38|
000026  2000              MOVS     r0,#0
000028  e7f8              B        |L11.28|
;;;887    
                          ENDP


                          AREA ||area_number.12||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.12||, ||.text||
                  yaffs_Unlink PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b570              PUSH     {r4-r6,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;886    }
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       yaffs_FindObjectByName
00000e  4606              MOV      r6,r0
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       yaffs_UnlinkObject
000016  bd70              POP      {r4-r6,pc}
;;;887    
                          ENDP


                          AREA ||area_number.13||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.13||, ||.text||
                  yaffs_GetObjectLinkCount PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  4601              MOV      r1,r0
;;;884    {
;;;885    	return dev->rootDir;
000002  2000              MOVS     r0,#0
000004  780b              LDRB     r3,[r1,#0]
;;;886    }
000006  f3c30380          UBFX     r3,r3,#2,#1
00000a  b903              CBNZ     r3,|L13.14|
00000c  1c40              ADDS     r0,r0,#1
                  |L13.14|
00000e  694a              LDR      r2,[r1,#0x14]
000010  e001              B        |L13.22|
                  |L13.18|
000012  1c40              ADDS     r0,r0,#1
000014  6812              LDR      r2,[r2,#0]
                  |L13.22|
000016  f1010314          ADD      r3,r1,#0x14
00001a  429a              CMP      r2,r3
00001c  d1f9              BNE      |L13.18|
00001e  4770              BX       lr
;;;887    
                          ENDP


                          AREA ||area_number.14||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.text||
                  yaffs_GetObjectInode PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
;;;886    }
000006  f7fffffe          BL       yaffs_GetEquivalentObject
00000a  4604              MOV      r4,r0
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  bd10              POP      {r4,pc}
;;;887    
                          ENDP


                          AREA ||area_number.15||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.15||, ||.text||
                  yaffs_GetObjectType PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
;;;886    }
000006  f7fffffe          BL       yaffs_GetEquivalentObject
00000a  4604              MOV      r4,r0
00000c  f8940054          LDRB     r0,[r4,#0x54]
000010  2806              CMP      r0,#6
000012  d20c              BCS      |L15.46|
000014  e8dff000          TBB      [pc,r0]
000018  0b030705          DCB      0x0b,0x03,0x07,0x05
00001c  090c              DCB      0x09,0x0c
00001e  2008              MOVS     r0,#8
                  |L15.32|
000020  bd10              POP      {r4,pc}
000022  2004              MOVS     r0,#4
000024  e7fc              B        |L15.32|
000026  200a              MOVS     r0,#0xa
000028  e7fa              B        |L15.32|
00002a  2008              MOVS     r0,#8
00002c  e7f8              B        |L15.32|
                  |L15.46|
00002e  bf00              NOP      
000030  2008              MOVS     r0,#8
000032  e7f5              B        |L15.32|
;;;887    
                          ENDP


                          AREA ||area_number.16||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.text||
                  yaffs_GetSymlinkAlias PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4604              MOV      r4,r0
000004  4620              MOV      r0,r4
;;;886    }
000006  f7fffffe          BL       yaffs_GetEquivalentObject
00000a  4604              MOV      r4,r0
00000c  f8940054          LDRB     r0,[r4,#0x54]
000010  2802              CMP      r0,#2
000012  d103              BNE      |L16.28|
000014  6da0              LDR      r0,[r4,#0x58]
000016  f7fffffe          BL       yaffs_CloneString
                  |L16.26|
00001a  bd10              POP      {r4,pc}
                  |L16.28|
00001c  a001              ADR      r0,|L16.36|
00001e  f7fffffe          BL       yaffs_CloneString
000022  e7fa              B        |L16.26|
;;;887    
                          ENDP

                  |L16.36|
000024  00                DCB      0
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||area_number.17||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.17||, ||.text||
                  yaffs_SetAttributes PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;886    }
000006  6826              LDR      r6,[r4,#0]
000008  f0060001          AND      r0,r6,#1
00000c  b108              CBZ      r0,|L17.18|
00000e  6860              LDR      r0,[r4,#4]
000010  6368              STR      r0,[r5,#0x34]
                  |L17.18|
000012  f0060002          AND      r0,r6,#2
000016  b108              CBZ      r0,|L17.28|
000018  68a0              LDR      r0,[r4,#8]
00001a  63e8              STR      r0,[r5,#0x3c]
                  |L17.28|
00001c  f0060004          AND      r0,r6,#4
000020  b108              CBZ      r0,|L17.38|
000022  68e0              LDR      r0,[r4,#0xc]
000024  6428              STR      r0,[r5,#0x40]
                  |L17.38|
000026  f0060010          AND      r0,r6,#0x10
00002a  b108              CBZ      r0,|L17.48|
00002c  6960              LDR      r0,[r4,#0x14]
00002e  6468              STR      r0,[r5,#0x44]
                  |L17.48|
000030  f0060040          AND      r0,r6,#0x40
000034  b108              CBZ      r0,|L17.58|
000036  69e0              LDR      r0,[r4,#0x1c]
000038  64e8              STR      r0,[r5,#0x4c]
                  |L17.58|
00003a  f0060020          AND      r0,r6,#0x20
00003e  b108              CBZ      r0,|L17.68|
000040  69a0              LDR      r0,[r4,#0x18]
000042  64a8              STR      r0,[r5,#0x48]
                  |L17.68|
000044  f0060008          AND      r0,r6,#8
000048  b118              CBZ      r0,|L17.82|
00004a  4628              MOV      r0,r5
00004c  6921              LDR      r1,[r4,#0x10]
00004e  f7fffffe          BL       yaffs_ResizeFile
                  |L17.82|
000052  2000              MOVS     r0,#0
000054  4603              MOV      r3,r0
000056  2201              MOVS     r2,#1
000058  4601              MOV      r1,r0
00005a  9000              STR      r0,[sp,#0]
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       yaffs_UpdateObjectHeader
000062  2001              MOVS     r0,#1
000064  bdf8              POP      {r3-r7,pc}
;;;887    
                          ENDP


                          AREA ||area_number.18||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.18||, ||.text||
                  yaffs_GetAttributes PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  b570              PUSH     {r4-r6,lr}
;;;884    {
;;;885    	return dev->rootDir;
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;886    }
000006  2500              MOVS     r5,#0
000008  6b70              LDR      r0,[r6,#0x34]
00000a  6060              STR      r0,[r4,#4]
00000c  f0450501          ORR      r5,r5,#1
000010  6bf0              LDR      r0,[r6,#0x3c]
000012  60a0              STR      r0,[r4,#8]
000014  f0450502          ORR      r5,r5,#2
000018  6c30              LDR      r0,[r6,#0x40]
00001a  60e0              STR      r0,[r4,#0xc]
00001c  f0450504          ORR      r5,r5,#4
000020  6c70              LDR      r0,[r6,#0x44]
000022  6160              STR      r0,[r4,#0x14]
000024  f0450510          ORR      r5,r5,#0x10
000028  6cf0              LDR      r0,[r6,#0x4c]
00002a  61e0              STR      r0,[r4,#0x1c]
00002c  f0450540          ORR      r5,r5,#0x40
000030  6cb0              LDR      r0,[r6,#0x48]
000032  61a0              STR      r0,[r4,#0x18]
000034  f0450520          ORR      r5,r5,#0x20
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       yaffs_GetFileSize
00003e  6120              STR      r0,[r4,#0x10]
000040  f0450508          ORR      r5,r5,#8
000044  6025              STR      r5,[r4,#0]
000046  2001              MOVS     r0,#1
000048  bd70              POP      {r4-r6,pc}
;;;887    
                          ENDP


                          AREA ||area_number.19||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.19||, ||.text||
                  yaffs_GetNumberOfFreeChunks PROC
;;;882     
;;;883    yaffs_Object *yaffs_Root(yaffs_Device * dev)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;884    {
;;;885    	return dev->rootDir;
000004  4604              MOV      r4,r0
;;;886    }
000006  f8d45d34          LDR      r5,[r4,#0xd34]
00000a  f8d40dac          LDR      r0,[r4,#0xdac]
00000e  4405              ADD      r5,r5,r0
000010  2700              MOVS     r7,#0
000012  2000              MOVS     r0,#0
000014  e009              B        |L19.42|
                  |L19.22|
000016  ebc002c0          RSB      r2,r0,r0,LSL #3
00001a  f8d41d94          LDR      r1,[r4,#0xd94]
00001e  eb010182          ADD      r1,r1,r2,LSL #2
000022  68c9              LDR      r1,[r1,#0xc]
000024  b101              CBZ      r1,|L19.40|
000026  1c7f              ADDS     r7,r7,#1
                  |L19.40|
000028  1c40              ADDS     r0,r0,#1
                  |L19.42|
00002a  6a61              LDR      r1,[r4,#0x24]
00002c  4281              CMP      r1,r0
00002e  dcf2              BGT      |L19.22|
000030  1bed              SUBS     r5,r5,r7
000032  6a20              LDR      r0,[r4,#0x20]
000034  1c40              ADDS     r0,r0,#1
000036  6921              LDR      r1,[r4,#0x10]
000038  fb005511          MLS      r5,r0,r1,r5
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       yaffs_CalcCheckpointBlocksRequired
000042  f8d410c0          LDR      r1,[r4,#0xc0]
000046  1a46              SUBS     r6,r0,r1
000048  2e00              CMP      r6,#0
00004a  da00              BGE      |L19.78|
00004c  2600              MOVS     r6,#0
                  |L19.78|
00004e  6920              LDR      r0,[r4,#0x10]
000050  fb065510          MLS      r5,r6,r0,r5
000054  2d00              CMP      r5,#0
000056  da00              BGE      |L19.90|
000058  2500              MOVS     r5,#0
                  |L19.90|
00005a  4628              MOV      r0,r5
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;887    
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2449643a          DCB      "$$Id: yaffs_guts.c,v 1.78 2009/01/27 02:52:45 charles E"
000004  20796166
000008  66735f67
00000c  7574732e
000010  632c7620
000014  312e3738
000018  20323030
00001c  392f3031
000020  2f323720
000024  30323a35
000028  323a3435
00002c  20636861
000030  726c6573
000034  2045    
000036  78702024          DCB      "xp $$",0
00003a  00      
00003b  00                DCB      0
00003c  556e6b6e          DCB      "Unknown",0
000040  6f776e00
000044  4e656564          DCB      "Needs scanning",0
000048  73207363
00004c  616e6e69
000050  6e6700  
000053  00                DCB      0
000054  5363616e          DCB      "Scanning",0
000058  6e696e67
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
000060  456d7074          DCB      "Empty",0
000064  7900    
000066  00                DCB      0
000067  00                DCB      0
000068  416c6c6f          DCB      "Allocating",0
00006c  63617469
000070  6e6700  
000073  00                DCB      0
000074  46756c6c          DCB      "Full",0
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
00007c  44697274          DCB      "Dirty",0
000080  7900    
000082  00                DCB      0
000083  00                DCB      0
000084  43686563          DCB      "Checkpoint",0
000088  6b706f69
00008c  6e7400  
00008f  00                DCB      0
000090  436f6c6c          DCB      "Collecting",0
000094  65637469
000098  6e6700  
00009b  00                DCB      0
00009c  44656164          DCB      "Dead",0
0000a0  00      

                          AREA ||.data||, DATA, ALIGN=2

                  yaffs_guts_c_version
                          DCD      ||.conststring||
                  blockStateName
                          DCD      ||.conststring||+0x3c
                          DCD      ||.conststring||+0x44
                          DCD      ||.conststring||+0x54
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x68
                          DCD      ||.conststring||+0x74
                          DCD      ||.conststring||+0x7c
                          DCD      ||.conststring||+0x84
                          DCD      ||.conststring||+0x90
                          DCD      ||.conststring||+0x9c
                  yaffs_freeVerificationFailures
                          DCD      0x00000000
                  x
                          DCD      0x00000000

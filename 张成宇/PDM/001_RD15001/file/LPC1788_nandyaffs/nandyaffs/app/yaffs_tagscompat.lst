L 1 "..\fs\yaffs_tagscompat.c"
N/*
N * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N */
N
N#include "yaffs_guts.h"
L 1 "..\fs\yaffs_guts.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_GUTS_H__
N#define __YAFFS_GUTS_H__
N
N#include "devextras.h"
L 1 "..\fs\devextras.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * This file is just holds extra declarations of macros that would normally
N * be providesd in the Linux kernel. These macros have been written from
N * scratch but are functionally equivalent to the Linux ones.
N *
N */
N
N
N
N#ifndef __EXTRAS_H__
N#define __EXTRAS_H__
N#define    __inline__    __inline
N
N#define  CONFIG_YAFFS_PROVIDE_DEFS
N
N#if !(defined __KERNEL__) 
X#if !(0L) 
N
N/* Definition of types */
Ntypedef unsigned char __u8;
Ntypedef unsigned short __u16;
Ntypedef unsigned __u32;
N
N#endif
N
N/*
N * This is a simple doubly linked list implementation that matches the 
N * way the Linux kernel doubly linked list implementation works.
N */
N
Nstruct ylist_head {
N	struct ylist_head *next; /* next in chain */
N	struct ylist_head *prev; /* previous in chain */
N};
N
N
N/* Initialise a static list */
N#define YLIST_HEAD(name) \
Nstruct ylist_head name = { &(name),&(name)}
X#define YLIST_HEAD(name) struct ylist_head name = { &(name),&(name)}
N
N
N
N/* Initialise a list head to an empty list */
N#define YINIT_LIST_HEAD(p) \
Ndo { \
N (p)->next = (p);\
N (p)->prev = (p); \
N} while(0)
X#define YINIT_LIST_HEAD(p) do {  (p)->next = (p); (p)->prev = (p); } while(0)
N
N
N/* Add an element to a list */
Nstatic __inline__ void ylist_add(struct ylist_head *newEntry, 
Xstatic __inline void ylist_add(struct ylist_head *newEntry, 
N                                 struct ylist_head *list)
N{
N        struct ylist_head *listNext = list->next;
N        
N        list->next = newEntry;
N        newEntry->prev = list;
N	newEntry->next = listNext;
N	listNext->prev = newEntry;
N	
N}
N
Nstatic __inline__ void ylist_add_tail(struct ylist_head *newEntry, 
Xstatic __inline void ylist_add_tail(struct ylist_head *newEntry, 
N				 struct ylist_head *list)
N{
N	struct ylist_head *listPrev = list->prev;
N	
N	list->prev = newEntry;
N	newEntry->next = list;
N	newEntry->prev = listPrev;
N	listPrev->next = newEntry;
N	
N}
N
N
N/* Take an element out of its current list, with or without
N * reinitialising the links.of the entry*/
Nstatic __inline__ void ylist_del(struct ylist_head *entry)
Xstatic __inline void ylist_del(struct ylist_head *entry)
N{
N        struct ylist_head *listNext = entry->next;
N        struct ylist_head *listPrev = entry->prev;
N        
N        listNext->prev = listPrev;
N        listPrev->next = listNext;
N        
N}
N
Nstatic __inline__ void ylist_del_init(struct ylist_head *entry)
Xstatic __inline void ylist_del_init(struct ylist_head *entry)
N{
N        ylist_del(entry);
N        entry->next = entry->prev = entry;
N}
N
N
N/* Test if the list is empty */
Nstatic __inline__ int ylist_empty(struct ylist_head *entry)
Xstatic __inline int ylist_empty(struct ylist_head *entry)
N{
N        return (entry->next == entry);
N}
N
N
N/* ylist_entry takes a pointer to a list entry and offsets it to that
N * we can find a pointer to the object it is embedded in.
N */
N 
N 
N#define ylist_entry(entry, type, member) \
N        ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
X#define ylist_entry(entry, type, member)         ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
N
N
N/* ylist_for_each and list_for_each_safe  iterate over lists.
N * ylist_for_each_safe uses temporary storage to make the list delete safe
N */
N
N#define ylist_for_each(itervar, list) \
N        for (itervar = (list)->next; itervar != (list); itervar = itervar->next )
X#define ylist_for_each(itervar, list)         for (itervar = (list)->next; itervar != (list); itervar = itervar->next )
N
N#define ylist_for_each_safe(itervar,saveVar, list) \
N        for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list); \
N         itervar = saveVar, saveVar = saveVar->next)
X#define ylist_for_each_safe(itervar,saveVar, list)         for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list);          itervar = saveVar, saveVar = saveVar->next)
N
N
N#if !(defined __KERNEL__)
X#if !(0L)
N
N
N#ifdef WIN32
S#include <sys/stat.h>
N#endif
N
N
N#ifdef CONFIG_YAFFS_PROVIDE_DEFS
N/* File types */
N
N
N#define DT_UNKNOWN      0
N#define DT_FIFO         1
N#define DT_CHR          2
N#define DT_DIR		4
N#define DT_BLK		6
N#define DT_REG          8
N#define DT_LNK          10
N#define DT_SOCK         12
N#define DT_WHT          14
N
N
N#ifdef WIN32
S#include <sys/stat.h>
N#endif
N
N/*
N * Attribute flags.  These should be or-ed together to figure out what
N * has been changed!
N */
N#define ATTR_MODE       1
N#define ATTR_UID        2
N#define ATTR_GID	4
N#define ATTR_SIZE	8
N#define ATTR_ATIME	16
N#define ATTR_MTIME	32
N#define ATTR_CTIME	64
N
Nstruct iattr {
N	unsigned int ia_valid;
N	unsigned ia_mode;
N	unsigned ia_uid;
N	unsigned ia_gid;
N	unsigned ia_size;
N	unsigned ia_atime;
N	unsigned ia_mtime;
N	unsigned ia_ctime;
N        unsigned int ia_attr_flags;
N};
N
N#endif
N
N
N#define KERN_DEBUG
N
N#else
S
S#include <linux/types.h>
S#include <linux/fs.h>
S#include <linux/stat.h>
S
N#endif
N
N
N#endif
L 20 "..\fs\yaffs_guts.h" 2
N#include "yportenv.h"
L 1 "..\fs\yportenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N
N#ifndef __YPORTENV_H__
N#define __YPORTENV_H__
N
N//#include "2440lib.h"
N//#include <stdio.h>
N
N#define CONFIG_YAFFS_DIRECT
N/*
N * Define the MTD version in terms of Linux Kernel versions
N * This allows yaffs to be used independantly of the kernel
N * as well as with it.
N */
Ntypedef int off_t;
Ntypedef int dev_t;
Ntypedef unsigned int mode_t;
Ntypedef unsigned long loff_t;
N
N#define MTD_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
N
N#if defined CONFIG_YAFFS_WINCE
X#if 0L
S
S#include "ywinceenv.h"
S
S#elif  defined __KERNEL__
X#elif  0L
S
S#include "moduleconfig.h"
S
S/* Linux kernel */
S
S#include <linux/version.h>
S#define MTD_VERSION_CODE LINUX_VERSION_CODE
S
S#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
S#include <linux/config.h>
S#endif
S#include <linux/kernel.h>
S#include <linux/mm.h>
S#include <linux/sched.h>
S#include <linux/string.h>
S#include <linux/slab.h>
S#include <linux/vmalloc.h>
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S
S/* #define YPRINTF(x) printk x */
S#define YMALLOC(x) kmalloc(x,GFP_NOFS)
S#define YFREE(x)   kfree(x)
S#define YMALLOC_ALT(x) vmalloc(x)
S#define YFREE_ALT(x)   vfree(x)
S#define YMALLOC_DMA(x) YMALLOC(x)
S
S// KR - added for use in scan so processes aren't blocked indefinitely.
S#define YYIELD() schedule()
S
S#define YAFFS_ROOT_MODE			0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
S#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
S#define Y_TIME_CONVERT(x) (x).tv_sec
S#else
S#define Y_CURRENT_TIME CURRENT_TIME
S#define Y_TIME_CONVERT(x) (x)
S#endif
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#define TENDSTR "\n"
S#define TSTR(x) KERN_WARNING x
S#define TCONT(x) x
S#define TOUT(p) printk p
S
S#define yaffs_trace(mask, fmt, args...) \
S	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \
S		printk(KERN_WARNING "yaffs: " fmt, ## args); \
S	} while (0)
X#define yaffs_trace(mask, fmt, args...) 	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) 		printk(KERN_WARNING "yaffs: " fmt, ## args); 	} while (0)
S
S#define compile_time_assertion(assertion) \
S	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
X#define compile_time_assertion(assertion) 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
S
N#elif defined CONFIG_YAFFS_DIRECT
X#elif 1L
N
N#define MTD_VERSION_CODE MTD_VERSION(2,6,22)
N
N/* Direct interface */
N#include "ydirectenv.h"
L 1 "..\fs\ydirectenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * ydirectenv.h: Environment wrappers for YAFFS direct.
N */
N
N#ifndef __YDIRECTENV_H__
N#define __YDIRECTENV_H__
N
N// Direct interface
N
N#include "devextras.h"
N
N#include "stdlib.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 180254 $
N * Checkin $Date: 2013-06-03 17:00:28 +0100 (Mon, 03 Jun 2013) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_REALTIME_DIVIDE)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 28 "..\fs\ydirectenv.h" 2
N#include "stdio.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 29 "..\fs\ydirectenv.h" 2
N#include "string.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5040049
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "..\fs\ydirectenv.h" 2
N#include "yaffs_malloc.h"
L 1 "..\fs\yaffs_malloc.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N 
N#ifndef __YAFFS_MALLOC_H__
N#define __YAFFS_MALLOC_H__
N
N#include <stdlib.h>
N 
Nvoid *yaffs_malloc(size_t size); 
Nvoid yaffs_free(void *ptr);
N 
N#endif
N
L 31 "..\fs\ydirectenv.h" 2
N
N#include "assert.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5040049
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 33 "..\fs\ydirectenv.h" 2
N#define YBUG() //assert(0)
N//#define YBUG() do { *((int *)0) =1;} while(0)
N
N
N#define YCHAR char
N#define YUCHAR unsigned char
N#define _Y(x) x
N#define yaffs_strcat(a,b)    strcat(a,b)
N#define yaffs_strcpy(a,b)    strcpy(a,b)
N#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
N#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
N#define yaffs_strlen(s)	     strlen(s)
N#define yaffs_sprintf	     //sprintf
N#define yaffs_toupper(a)     toupper(a)
N
N#define YAFFS_PATH_DIVIDERS  "/"
N
N#ifdef NO_Y_INLINE
S#define Y_INLINE
N#else
N#define Y_INLINE  __inline
N#endif
N
N#define YMALLOC(x) yaffs_malloc(x)
N#define YFREE(x)   free(x)
N#define YMALLOC_ALT(x) yaffs_malloc(x)
N#define YFREE_ALT(x)   free(x)
N
N#define YMALLOC_DMA(x) yaffs_malloc(x)
N
N#define YYIELD()  do {} while(0)
N
N
N
N//#define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s))
N//#define YALERT(s) YINFO(s)
N
N
N#define TENDSTR "\n"
N#define TSTR(x) x
N#define TCONT(x) x
N#define TOUT(p) //printf p
N
N
N#define YAFFS_LOSTNFOUND_NAME		"lost+found"
N#define YAFFS_LOSTNFOUND_PREFIX		"obj"
N//#define YPRINTF(x) printf x
N
N#include "yaffscfg.h"
L 1 "..\fs\yaffscfg.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * Header file for using yaffs in an application via
N * a direct interface.
N */
N
N
N#ifndef __YAFFSCFG_H__
N#define __YAFFSCFG_H__
N
N
N#include "yportenv.h"
L 1 "..\fs\yportenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N
N#ifndef __YPORTENV_H__
S#define __YPORTENV_H__
S
S//#include "2440lib.h"
S//#include <stdio.h>
S
S#define CONFIG_YAFFS_DIRECT
S/*
S * Define the MTD version in terms of Linux Kernel versions
S * This allows yaffs to be used independantly of the kernel
S * as well as with it.
S */
Stypedef int off_t;
Stypedef int dev_t;
Stypedef unsigned int mode_t;
Stypedef unsigned long loff_t;
S
S#define MTD_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
S
S#if defined CONFIG_YAFFS_WINCE
S
S#include "ywinceenv.h"
S
S#elif  defined __KERNEL__
S
S#include "moduleconfig.h"
S
S/* Linux kernel */
S
S#include <linux/version.h>
S#define MTD_VERSION_CODE LINUX_VERSION_CODE
S
S#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
S#include <linux/config.h>
S#endif
S#include <linux/kernel.h>
S#include <linux/mm.h>
S#include <linux/sched.h>
S#include <linux/string.h>
S#include <linux/slab.h>
S#include <linux/vmalloc.h>
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S
S/* #define YPRINTF(x) printk x */
S#define YMALLOC(x) kmalloc(x,GFP_NOFS)
S#define YFREE(x)   kfree(x)
S#define YMALLOC_ALT(x) vmalloc(x)
S#define YFREE_ALT(x)   vfree(x)
S#define YMALLOC_DMA(x) YMALLOC(x)
S
S// KR - added for use in scan so processes aren't blocked indefinitely.
S#define YYIELD() schedule()
S
S#define YAFFS_ROOT_MODE			0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
S#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
S#define Y_TIME_CONVERT(x) (x).tv_sec
S#else
S#define Y_CURRENT_TIME CURRENT_TIME
S#define Y_TIME_CONVERT(x) (x)
S#endif
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#define TENDSTR "\n"
S#define TSTR(x) KERN_WARNING x
S#define TCONT(x) x
S#define TOUT(p) printk p
S
S#define yaffs_trace(mask, fmt, args...) \
S	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \
S		printk(KERN_WARNING "yaffs: " fmt, ## args); \
S	} while (0)
X#define yaffs_trace(mask, fmt, args...) 	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) 		printk(KERN_WARNING "yaffs: " fmt, ## args); 	} while (0)
S
S#define compile_time_assertion(assertion) \
S	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
X#define compile_time_assertion(assertion) 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
S
S#elif defined CONFIG_YAFFS_DIRECT
S
S#define MTD_VERSION_CODE MTD_VERSION(2,6,22)
S
S/* Direct interface */
S#include "ydirectenv.h"
S
S#elif defined CONFIG_YAFFS_UTIL
S
S/* Stuff for YAFFS utilities */
S
S#include "stdlib.h"
S#include "stdio.h"
S#include "string.h"
S
S#include "devextras.h"
S
S#define YMALLOC(x) malloc(x)
S#define YFREE(x)   free(x)
S#define YMALLOC_ALT(x) malloc(x)
S#define YFREE_ALT(x) free(x)
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
S/* #define YALERT(s) YINFO(s) */
S
S#define TENDSTR "\n"
S#define TSTR(x) x
S#define TOUT(p) printf p
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S/* #define YPRINTF(x) printf x */
S
S#define YAFFS_ROOT_MODE				0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#else
S/* Should have specified a configuration type */
S#error Unknown configuration
S
S#endif
S
S/* see yaffs_fs.c */
Sextern unsigned int yaffs_traceMask;
Sextern unsigned int yaffs_wr_attempts;
S
S/*
S * Tracing flags.
S * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
S */
S
S#define YAFFS_TRACE_OS			0x00000002
S#define YAFFS_TRACE_ALLOCATE		0x00000004
S#define YAFFS_TRACE_SCAN		0x00000008
S#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
S#define YAFFS_TRACE_ERASE		0x00000020
S#define YAFFS_TRACE_GC			0x00000040
S#define YAFFS_TRACE_WRITE		0x00000080
S#define YAFFS_TRACE_TRACING		0x00000100
S#define YAFFS_TRACE_DELETION		0x00000200
S#define YAFFS_TRACE_BUFFERS		0x00000400
S#define YAFFS_TRACE_NANDACCESS		0x00000800
S#define YAFFS_TRACE_GC_DETAIL		0x00001000
S#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
S#define YAFFS_TRACE_MTD			0x00004000
S#define YAFFS_TRACE_CHECKPOINT		0x00008000
S
S#define YAFFS_TRACE_VERIFY		0x00010000
S#define YAFFS_TRACE_VERIFY_NAND		0x00020000
S#define YAFFS_TRACE_VERIFY_FULL		0x00040000
S#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
S
S
S#define YAFFS_TRACE_ERROR		0x40000000
S#define YAFFS_TRACE_BUG			0x80000000
S#define YAFFS_TRACE_ALWAYS		0xF0000000
S
S
S#define T(mask,p) do{ if((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p);} while(0)
S
S#ifndef YBUG
S#define YBUG() do {T(YAFFS_TRACE_BUG,(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),__LINE__));} while(0)
S#endif
S
N#endif
L 27 "..\fs\yaffscfg.h" 2
N
N#define YAFFSFS_N_HANDLES 200
N
N
Ntypedef struct {
N	const YCHAR *prefix;
X	const char *prefix;
N	struct yaffs_DeviceStruct *dev;
N} yaffsfs_DeviceConfiguration;
N
N
Nvoid yaffsfs_Lock(void);
Nvoid yaffsfs_Unlock(void);
N__u32 yaffsfs_CurrentTime(void);
Nvoid yaffsfs_SetError(int err);
N
N#endif
N
L 82 "..\fs\ydirectenv.h" 2
N
N#define Y_CURRENT_TIME yaffsfs_CurrentTime()
N#define Y_TIME_CONVERT(x) x
N
N#define YAFFS_ROOT_MODE				0666
N#define YAFFS_LOSTNFOUND_MODE		0666
N
N#define yaffs_SumCompare(x,y) ((x) == (y))
N#define yaffs_strcmp(a,b) strcmp(a,b)
N
N#endif
N
N
L 118 "..\fs\yportenv.h" 2
N
N#elif defined CONFIG_YAFFS_UTIL
S
S/* Stuff for YAFFS utilities */
S
S#include "stdlib.h"
S#include "stdio.h"
S#include "string.h"
S
S#include "devextras.h"
S
S#define YMALLOC(x) malloc(x)
S#define YFREE(x)   free(x)
S#define YMALLOC_ALT(x) malloc(x)
S#define YFREE_ALT(x) free(x)
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
S/* #define YALERT(s) YINFO(s) */
S
S#define TENDSTR "\n"
S#define TSTR(x) x
S#define TOUT(p) printf p
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S/* #define YPRINTF(x) printf x */
S
S#define YAFFS_ROOT_MODE				0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#else
S/* Should have specified a configuration type */
S#error Unknown configuration
S
N#endif
N
N/* see yaffs_fs.c */
Nextern unsigned int yaffs_traceMask;
Nextern unsigned int yaffs_wr_attempts;
N
N/*
N * Tracing flags.
N * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
N */
N
N#define YAFFS_TRACE_OS			0x00000002
N#define YAFFS_TRACE_ALLOCATE		0x00000004
N#define YAFFS_TRACE_SCAN		0x00000008
N#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
N#define YAFFS_TRACE_ERASE		0x00000020
N#define YAFFS_TRACE_GC			0x00000040
N#define YAFFS_TRACE_WRITE		0x00000080
N#define YAFFS_TRACE_TRACING		0x00000100
N#define YAFFS_TRACE_DELETION		0x00000200
N#define YAFFS_TRACE_BUFFERS		0x00000400
N#define YAFFS_TRACE_NANDACCESS		0x00000800
N#define YAFFS_TRACE_GC_DETAIL		0x00001000
N#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
N#define YAFFS_TRACE_MTD			0x00004000
N#define YAFFS_TRACE_CHECKPOINT		0x00008000
N
N#define YAFFS_TRACE_VERIFY		0x00010000
N#define YAFFS_TRACE_VERIFY_NAND		0x00020000
N#define YAFFS_TRACE_VERIFY_FULL		0x00040000
N#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
N
N
N#define YAFFS_TRACE_ERROR		0x40000000
N#define YAFFS_TRACE_BUG			0x80000000
N#define YAFFS_TRACE_ALWAYS		0xF0000000
N
N
N#define T(mask,p) do{ if((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p);} while(0)
N
N#ifndef YBUG
S#define YBUG() do {T(YAFFS_TRACE_BUG,(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),__LINE__));} while(0)
N#endif
N
N#endif
L 21 "..\fs\yaffs_guts.h" 2
N
N#define YAFFS_OK	1
N#define YAFFS_FAIL  0
N#define CONFIG_YAFFS_YAFFS2  1
N/* Give us a  Y=0x59, 
N * Give us an A=0x41, 
N * Give us an FF=0xFF 
N * Give us an S=0x53
N * And what have we got... 
N */
N#define YAFFS_MAGIC			0x5941FF53
N
N#define YAFFS_NTNODES_LEVEL0	  	16
N#define YAFFS_TNODES_LEVEL0_BITS	4
N#define YAFFS_TNODES_LEVEL0_MASK	0xf
N
N#define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
N#define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
N#define YAFFS_TNODES_INTERNAL_MASK	0x7
N#define YAFFS_TNODES_MAX_LEVEL		6
N
N#ifndef CONFIG_YAFFS_NO_YAFFS1
N#define YAFFS_BYTES_PER_SPARE		16
N#define YAFFS_BYTES_PER_CHUNK		512
N#define YAFFS_CHUNK_SIZE_SHIFT		9
N#define YAFFS_CHUNKS_PER_BLOCK		32
N#define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
N#endif
N
N#define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
N#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
N
N#define YAFFS_MAX_CHUNK_ID		0x000FFFFF
N
N#define YAFFS_UNUSED_OBJECT_ID		0x0003FFFF
N
N#define YAFFS_ALLOCATION_NOBJECTS	100
N#define YAFFS_ALLOCATION_NTNODES	100
N#define YAFFS_ALLOCATION_NLINKS		100
N
N#define YAFFS_NOBJECT_BUCKETS		256
N
N
N#define YAFFS_OBJECT_SPACE		0x40000
N
N#define YAFFS_CHECKPOINT_VERSION 	3
N
N#ifdef CONFIG_YAFFS_UNICODE
S#define YAFFS_MAX_NAME_LENGTH		127
S#define YAFFS_MAX_ALIAS_LENGTH		79
N#else
N#define YAFFS_MAX_NAME_LENGTH		255
N#define YAFFS_MAX_ALIAS_LENGTH		159
N#endif
N
N#define YAFFS_SHORT_NAME_LENGTH		15
N
N/* Some special object ids for pseudo objects */
N#define YAFFS_OBJECTID_ROOT		1
N#define YAFFS_OBJECTID_LOSTNFOUND	2
N#define YAFFS_OBJECTID_UNLINKED		3
N#define YAFFS_OBJECTID_DELETED		4
N
N/* Sseudo object ids for checkpointing */
N#define YAFFS_OBJECTID_SB_HEADER	0x10
N#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
N#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
N
N/* */
N
N#define YAFFS_MAX_SHORT_OP_CACHES	20
N
N#define YAFFS_N_TEMP_BUFFERS		6
N
N/* We limit the number attempts at sucessfully saving a chunk of data.
N * Small-page devices have 32 pages per block; large-page devices have 64.
N * Default to something in the order of 5 to 10 blocks worth of chunks.
N */
N#define YAFFS_WR_ATTEMPTS		(5*64)
N
N/* Sequence numbers are used in YAFFS2 to determine block allocation order.
N * The range is limited slightly to help distinguish bad numbers from good.
N * This also allows us to perhaps in the future use special numbers for
N * special purposes.
N * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years, 
N * and is a larger number than the lifetime of a 2GB device.
N */
N#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
N#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
N
N/* Special sequence number for bad block that failed to be marked bad */
N#define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
N
N/* ChunkCache is used for short read/write operations.*/
Ntypedef struct {
N	struct yaffs_ObjectStruct *object;
N	int chunkId;
N	int lastUse;
N	int dirty;
N	int nBytes;		/* Only valid if the cache is dirty */
N	int locked;		/* Can't push out or flush while locked. */
N#ifdef CONFIG_YAFFS_YAFFS2
N	__u8 *data;
N#else
S	__u8 data[YAFFS_BYTES_PER_CHUNK];
N#endif
N} yaffs_ChunkCache;
N
N
N
N/* Tags structures in RAM
N * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
N * the structure size will get blown out.
N */
N
N#ifndef CONFIG_YAFFS_NO_YAFFS1
Ntypedef struct {
N        unsigned chunkId:20;
N        unsigned serialNumber:2;
N        unsigned byteCountLSB:10;
N        unsigned objectId:18;
N        unsigned ecc:12;
N        unsigned byteCountMSB:2;
N
N} yaffs_Tags;
N
Ntypedef union {
N	yaffs_Tags asTags;
N	__u8 asBytes[8];
N} yaffs_TagsUnion;
N
N#endif
N
N/* Stuff used for extended tags in YAFFS2 */
N
Ntypedef enum {
N	YAFFS_ECC_RESULT_UNKNOWN,
N	YAFFS_ECC_RESULT_NO_ERROR,
N	YAFFS_ECC_RESULT_FIXED,
N	YAFFS_ECC_RESULT_UNFIXED
N} yaffs_ECCResult;
N
Ntypedef enum {
N	YAFFS_OBJECT_TYPE_UNKNOWN,
N	YAFFS_OBJECT_TYPE_FILE,
N	YAFFS_OBJECT_TYPE_SYMLINK,
N	YAFFS_OBJECT_TYPE_DIRECTORY,
N	YAFFS_OBJECT_TYPE_HARDLINK,
N	YAFFS_OBJECT_TYPE_SPECIAL
N} yaffs_ObjectType;
N
N#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
N
Ntypedef struct {
N
N	unsigned validMarker0;
N	unsigned chunkUsed;	/*  Status of the chunk: used or unused */
N	unsigned objectId;	/* If 0 then this is not part of an object (unused) */
N	unsigned chunkId;	/* If 0 then this is a header, else a data chunk */
N	unsigned byteCount;	/* Only valid for data chunks */
N
N	/* The following stuff only has meaning when we read */
N	yaffs_ECCResult eccResult;
N	unsigned blockBad;	
N
N	/* YAFFS 1 stuff */
N	unsigned chunkDeleted;	/* The chunk is marked deleted */
N	unsigned serialNumber;	/* Yaffs1 2-bit serial number */
N
N	/* YAFFS2 stuff */
N	unsigned sequenceNumber;	/* The sequence number of this block */
N
N	/* Extra info if this is an object header (YAFFS2 only) */
N
N	unsigned extraHeaderInfoAvailable;	/* There is extra info available if this is not zero */
N	unsigned extraParentObjectId;	/* The parent object */
N	unsigned extraIsShrinkHeader;	/* Is it a shrink header? */
N	unsigned extraShadows;		/* Does this shadow another object? */
N
N	yaffs_ObjectType extraObjectType;	/* What object type? */
N
N	unsigned extraFileLength;		/* Length if it is a file */
N	unsigned extraEquivalentObjectId;	/* Equivalent object Id if it is a hard link */
N
N	unsigned validMarker1;
N
N} yaffs_ExtendedTags;
N
N/* Spare structure for YAFFS1 */
Ntypedef struct {
N	__u8 tagByte0;
N	__u8 tagByte1;
N	__u8 tagByte2;
N	__u8 tagByte3;
N	__u8 pageStatus;	/* set to 0 to delete the chunk */
N	__u8 blockStatus;
N	__u8 tagByte4;
N	__u8 tagByte5;
N	__u8 ecc1[3];
N	__u8 tagByte6;
N	__u8 tagByte7;
N	__u8 ecc2[3];
N} yaffs_Spare;
N
N/*Special structure for passing through to mtd */
Nstruct yaffs_NANDSpare {
N	yaffs_Spare spare;
N	int eccres1;
N	int eccres2;
N};
N
N/* Block data in RAM */
N
Ntypedef enum {
N	YAFFS_BLOCK_STATE_UNKNOWN = 0,
N
N	YAFFS_BLOCK_STATE_SCANNING,
N	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
N	/* The block might have something on it (ie it is allocating or full, perhaps empty)
N	 * but it needs to be scanned to determine its true state.
N	 * This state is only valid during yaffs_Scan.
N	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
N	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
N	 */
N
N	YAFFS_BLOCK_STATE_EMPTY,
N	/* This block is empty */
N
N	YAFFS_BLOCK_STATE_ALLOCATING,
N	/* This block is partially allocated. 
N	 * At least one page holds valid data.
N	 * This is the one currently being used for page
N	 * allocation. Should never be more than one of these
N	 */
N
N	YAFFS_BLOCK_STATE_FULL,	
N	/* All the pages in this block have been allocated.
N	 */
N
N	YAFFS_BLOCK_STATE_DIRTY,
N	/* All pages have been allocated and deleted. 
N	 * Erase me, reuse me.
N	 */
N
N	YAFFS_BLOCK_STATE_CHECKPOINT,	
N	/* This block is assigned to holding checkpoint data.
N	 */
N
N	YAFFS_BLOCK_STATE_COLLECTING,	
N	/* This block is being garbage collected */
N
N	YAFFS_BLOCK_STATE_DEAD	
N	/* This block has failed and is not in use */
N} yaffs_BlockState;
N
N#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
N
N
Ntypedef struct {
N
N	int softDeletions:10;	/* number of soft deleted pages */
N	int pagesInUse:10;	/* number of pages in use */
N	unsigned blockState:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
N	__u32 needsRetiring:1;	/* Data has failed on this block, need to get valid data off */
N                        	/* and retire the block. */
N	__u32 skipErasedCheck: 1; /* If this is set we can skip the erased check on this block */
N	__u32 gcPrioritise: 1; 	/* An ECC check or blank check has failed on this block. 
N				   It should be prioritised for GC */
N        __u32 chunkErrorStrikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */
N
N#ifdef CONFIG_YAFFS_YAFFS2
N	__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */
N	__u32 sequenceNumber;	 /* block sequence number for yaffs2 */
N#endif
N
N} yaffs_BlockInfo;
N
N/* -------------------------- Object structure -------------------------------*/
N/* This is the object structure as stored on NAND */
N
Ntypedef struct {
N	yaffs_ObjectType type;
N
N	/* Apply to everything  */
N	int parentObjectId;
N        __u16 sum__NoLongerUsed;        /* checksum of name. No longer used */
N        YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
X        char name[255 + 1];
N
N        /* The following apply to directories, files, symlinks - not hard links */
N        __u32 yst_mode;         /* protection */
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 notForWinCE[5];
N#else
N	__u32 yst_uid;
N	__u32 yst_gid;
N	__u32 yst_atime;
N	__u32 yst_mtime;
N	__u32 yst_ctime;
N#endif
N
N	/* File size  applies to files only */
N	int fileSize;
N
N	/* Equivalent object id applies to hard links only. */
N	int equivalentObjectId;
N
N	/* Alias is for symlinks only. */
N	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
X	char alias[159 + 1];
N
N	__u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 win_ctime[2];
S	__u32 win_atime[2];
S	__u32 win_mtime[2];
N#else
N	__u32 roomToGrow[6];
N
N#endif
N	__u32 inbandShadowsObject;
N	__u32 inbandIsShrink;
N
N	__u32 reservedSpace[2];
N	int shadowsObject;	/* This object header shadows the specified object if > 0 */
N
N	/* isShrink applies to object headers written when we shrink the file (ie resize) */
N	__u32 isShrink;
N
N} yaffs_ObjectHeader;
N
N/*--------------------------- Tnode -------------------------- */
N
Nunion yaffs_Tnode_union {
N#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
S	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];
N#else
N	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];
X	union yaffs_Tnode_union *internal[(16 / 2)];
N#endif
N/*	__u16 level0[YAFFS_NTNODES_LEVEL0]; */
N
N};
N
Ntypedef union yaffs_Tnode_union yaffs_Tnode;
N
Nstruct yaffs_TnodeList_struct {
N	struct yaffs_TnodeList_struct *next;
N	yaffs_Tnode *tnodes;
N};
N
Ntypedef struct yaffs_TnodeList_struct yaffs_TnodeList;
N
N/*------------------------  Object -----------------------------*/
N/* An object can be one of:
N * - a directory (no data, has children links
N * - a regular file (data.... not prunes :->).
N * - a symlink [symbolic link] (the alias).
N * - a hard link
N */
N
Ntypedef struct {
N	__u32 fileSize;
N	__u32 scannedFileSize;
N	__u32 shrinkSize;
N	int topLevel;
N	yaffs_Tnode *top;
N} yaffs_FileStructure;
N
Ntypedef struct {
N        struct ylist_head children;     /* list of child links */
N} yaffs_DirectoryStructure;
N
Ntypedef struct {
N	YCHAR *alias;
X	char *alias;
N} yaffs_SymLinkStructure;
N
Ntypedef struct {
N	struct yaffs_ObjectStruct *equivalentObject;
N	__u32 equivalentObjectId;
N} yaffs_HardLinkStructure;
N
Ntypedef union {
N	yaffs_FileStructure fileVariant;
N	yaffs_DirectoryStructure directoryVariant;
N	yaffs_SymLinkStructure symLinkVariant;
N	yaffs_HardLinkStructure hardLinkVariant;
N} yaffs_ObjectVariant;
N
Nstruct yaffs_ObjectStruct {
N	__u8 deleted:1;		/* This should only apply to unlinked files. */
N	__u8 softDeleted:1;	/* it has also been soft deleted */
N	__u8 unlinked:1;	/* An unlinked file. The file should be in the unlinked directory.*/
N	__u8 fake:1;		/* A fake object has no presence on NAND. */
N	__u8 renameAllowed:1;	/* Some objects are not allowed to be renamed. */
N	__u8 unlinkAllowed:1;
N	__u8 dirty:1;		/* the object needs to be written to flash */
N	__u8 valid:1;		/* When the file system is being loaded up, this 
N				 * object might be created before the data
N				 * is available (ie. file data records appear before the header).
N				 */
N	__u8 lazyLoaded:1;	/* This object has been lazy loaded and is missing some detail */
N
N	__u8 deferedFree:1;	/* For Linux kernel. Object is removed from NAND, but is
N				 * still in the inode cache. Free of object is defered.
N				 * until the inode is released.
N                                 */
N        __u8 beingCreated:1;	/* This object is still being created so skip some checks. */
N
N	__u8 serial;		/* serial number of chunk in NAND. Cached here */
N	__u16 sum;		/* sum of the name to speed searching */
N
N        struct yaffs_DeviceStruct *myDev;       /* The device I'm on */
N
N        struct ylist_head hashLink;     /* list of objects in this hash bucket */
N
N        struct ylist_head hardLinks;    /* all the equivalent hard linked objects */
N
N        /* directory structure stuff */
N        /* also used for linking up the free list */
N        struct yaffs_ObjectStruct *parent; 
N        struct ylist_head siblings;
N
N	/* Where's my object header in NAND? */
N	int hdrChunk;
N
N	int nDataChunks;	/* Number of data chunks attached to the file. */
N
N	__u32 objectId;		/* the object id value */
N
N	__u32 yst_mode;
N
N#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
S	YCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];
N#endif
N
N#ifndef __KERNEL__
N	__u32 inUse;
N#endif
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 win_ctime[2];
S	__u32 win_mtime[2];
S	__u32 win_atime[2];
N#else
N	__u32 yst_uid;
N	__u32 yst_gid;
N	__u32 yst_atime;
N	__u32 yst_mtime;
N	__u32 yst_ctime;
N#endif
N
N	__u32 yst_rdev;
N
N#ifdef __KERNEL__
S	struct inode *myInode;
S
N#endif
N
N	yaffs_ObjectType variantType;
N
N	yaffs_ObjectVariant variant;
N
N};
N
Ntypedef struct yaffs_ObjectStruct yaffs_Object;
N
Nstruct yaffs_ObjectList_struct {
N	yaffs_Object *objects;
N	struct yaffs_ObjectList_struct *next;
N};
N
Ntypedef struct yaffs_ObjectList_struct yaffs_ObjectList;
N
Ntypedef struct {
N        struct ylist_head list;
N        int count;
N} yaffs_ObjectBucket;
N
N
N/* yaffs_CheckpointObject holds the definition of an object as dumped 
N * by checkpointing.
N */
N
Ntypedef struct {
N        int structType;
N	__u32 objectId;		
N	__u32 parentId;
N	int hdrChunk;
N	yaffs_ObjectType variantType:3;
N	__u8 deleted:1;		
N	__u8 softDeleted:1;	
N	__u8 unlinked:1;	
N	__u8 fake:1;		
N	__u8 renameAllowed:1;
N	__u8 unlinkAllowed:1;
N	__u8 serial;		
N	
N	int nDataChunks;	
N	__u32 fileSizeOrEquivalentObjectId;
N
N}yaffs_CheckpointObject;
N
N/*--------------------- Temporary buffers ----------------
N *
N * These are chunk-sized working buffers. Each device has a few
N */
N
Ntypedef struct {
N	__u8 *buffer;
N	int line;	/* track from whence this buffer was allocated */
N	int maxLine;
N} yaffs_TempBuffer;
N
N/*----------------- Device ---------------------------------*/
N
Nstruct yaffs_DeviceStruct {
N        struct ylist_head devList;
N        const char *name;
N
N        /* Entry parameters set up way early. Yaffs sets up the rest.*/
N        int nDataBytesPerChunk; /* Should be a power of 2 >= 512 */
N        int nChunksPerBlock;    /* does not need to be a power of 2 */
N        int spareBytesPerChunk;/* spare area size */
N        int startBlock;         /* Start block we're allowed to use */
N        int endBlock;           /* End block we're allowed to use */
N        int nReservedBlocks;    /* We want this tuneable so that we can reduce */
N				/* reserved blocks on NOR and RAM. */
N	
N	
N	/* Stuff used by the shared space checkpointing mechanism */
N	/* If this value is zero, then this mechanism is disabled */
N	
N//	int nCheckpointReservedBlocks; /* Blocks to reserve for checkpoint data */
N
N	
N
N
N	int nShortOpCaches;	/* If <= 0, then short op caching is disabled, else
N				 * the number of short op caches (don't use too many)
N				 */
N
N	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
N
N	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
N
N	void *genericDevice;	/* Pointer to device context
N				 * On an mtd this holds the mtd pointer.
N				 */
N        void *superBlock;
N        
N	/* NAND access functions (Must be set before calling YAFFS)*/
N
N	int (*writeChunkToNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, const __u8 * data,const yaffs_Spare * spare);
N 	int (*readChunkFromNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, __u8 * data,yaffs_Spare * spare);
N        int (*eraseBlockInNAND) (struct yaffs_DeviceStruct * dev, int blockInNAND);                               
N        int (*initialiseNAND) (struct yaffs_DeviceStruct * dev);
N        int (*deinitialiseNAND) (struct yaffs_DeviceStruct * dev);
N        int (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct * dev, int chunkInNAND, const __u8 * data,const yaffs_ExtendedTags * tags);					 
N        int (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, __u8 * data,yaffs_ExtendedTags * tags);
N        int (*markNANDBlockBad) (struct yaffs_DeviceStruct * dev, int blockNo);
N        int (*queryNANDBlock) (struct yaffs_DeviceStruct * dev, int blockNo,yaffs_BlockState * state, __u32 *sequenceNumber);
N        //////////////////////////////////////////////
N        int isYaffs2;
N	
N	/* The removeObjectCallback function must be supplied by OS flavours that 
N	 * need it. The Linux kernel does not use this, but yaffs direct does use
N	 * it to implement the faster readdir
N	 */
N	void (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);
N	
N	/* Callback to mark the superblock dirsty */
N	void (*markSuperBlockDirty)(void * superblock);
N	
N	int wideTnodesDisabled; /* Set to disable wide tnodes */
N	
N	YCHAR *pathDividers;	/* String of legal path dividers */
X	char *pathDividers;	 
N	
N
N	/* End of stuff that must be set before initialisation. */
N	
N	/* Checkpoint control. Can be set before or after initialisation */
N	__u8 skipCheckpointRead;
N	__u8 skipCheckpointWrite;
N
N	/* Runtime parameters. Set up by YAFFS. */
N
N	__u16 chunkGroupBits;	/* 0 for devices <= 32MB. else log2(nchunks) - 16 */
N	__u16 chunkGroupSize;	/* == 2^^chunkGroupBits */
N	
N	/* Stuff to support wide tnodes */
N	__u32 tnodeWidth;
N	__u32 tnodeMask;
N	
N	/* Stuff for figuring out file offset to chunk conversions */
N	__u32 chunkShift; /* Shift value */
N	__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */
N	__u32 chunkMask;  /* Mask to use for power-of-2 case */
N
N	/* Stuff to handle inband tags */
N	int inbandTags;
N	__u32 totalBytesPerChunk;
N
N#ifdef __KERNEL__
S
S	struct semaphore sem;	/* Semaphore for waiting on erasure.*/
S	struct semaphore grossLock;	/* Gross locking semaphore */
S	__u8 *spareBuffer;	/* For mtdif2 use. Don't know the size of the buffer 
S				 * at compile time so we have to allocate it.
S				 */
S	void (*putSuperFunc) (struct super_block * sb);
N#endif
N
N	int isMounted;
N	
N	int isCheckpointed;
N
N
N	/* Stuff to support block offsetting to support start block zero */
N	int internalStartBlock;
N	int internalEndBlock;
N	int blockOffset;
N	int chunkOffset;
N	
N
N	/* Runtime checkpointing stuff */
N	int checkpointPageSequence;   /* running sequence number of checkpoint pages */
N	int checkpointByteCount;
N	int checkpointByteOffset;
N	__u8 *checkpointBuffer;
N	int checkpointOpenForWrite;
N	int blocksInCheckpoint;
N	int checkpointCurrentChunk;
N	int checkpointCurrentBlock;
N	int checkpointNextBlock;
N	int *checkpointBlockList;
N	int checkpointMaxBlocks;
N	__u32 checkpointSum;
N	__u32 checkpointXor;
N	
N	int nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */
N	
N	/* Block Info */
N	yaffs_BlockInfo *blockInfo;
N	__u8 *chunkBits;	/* bitmap of chunks in use */
N	unsigned blockInfoAlt:1;	/* was allocated using alternative strategy */
N	unsigned chunkBitsAlt:1;	/* was allocated using alternative strategy */
N	int chunkBitmapStride;	/* Number of bytes of chunkBits per block. 
N				 * Must be consistent with nChunksPerBlock.
N				 */
N
N	int nErasedBlocks;
N	int allocationBlock;	/* Current block being allocated off */
N	__u32 allocationPage;
N	int allocationBlockFinder;	/* Used to search for next allocation block */
N
N	/* Runtime state */
N	int nTnodesCreated;
N	yaffs_Tnode *freeTnodes;
N	int nFreeTnodes;
N	yaffs_TnodeList *allocatedTnodeList;
N
N	int isDoingGC;
N	int gcBlock;
N	int gcChunk;
N
N	int nObjectsCreated;
N	yaffs_Object *freeObjects;
N	int nFreeObjects;
N	
N	int nHardLinks;
N
N	yaffs_ObjectList *allocatedObjectList;
N
N	yaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];
X	yaffs_ObjectBucket objectBucket[256];
N
N	int nFreeChunks;
N
N	int currentDirtyChecker;	/* Used to find current dirtiest block */
N
N	__u32 *gcCleanupList;	/* objects to delete at the end of a GC. */
N	int nonAggressiveSkip;	/* GC state/mode */
N
N	/* Statistcs */
N	int nPageWrites;
N	int nPageReads;
N	int nBlockErasures;
N	int nErasureFailures;
N	int nGCCopies;
N	int garbageCollections;
N	int passiveGarbageCollections;
N	int nRetriedWrites;
N	int nRetiredBlocks;
N	int eccFixed;
N	int eccUnfixed;
N	int tagsEccFixed;
N	int tagsEccUnfixed;
N	int nDeletions;
N	int nUnmarkedDeletions;
N	
N	int hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */
N
N	/* Special directories */
N	yaffs_Object *rootDir;
N	yaffs_Object *lostNFoundDir;
N
N	/* Buffer areas for storing data to recover from write failures TODO
N	 *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
N	 *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];
N	 */
N	
N	int bufferedBlock;	/* Which block is buffered here? */
N	int doingBufferedBlockRewrite;
N
N	yaffs_ChunkCache *srCache;
N	int srLastUse;
N
N	int cacheHits;
N
N	/* Stuff for background deletion and unlinked files.*/
N	yaffs_Object *unlinkedDir;	/* Directory where unlinked and deleted files live. */
N	yaffs_Object *deletedDir;	/* Directory where deleted objects are sent to disappear. */
N	yaffs_Object *unlinkedDeletion;	/* Current file being background deleted.*/
N	int nDeletedFiles;		/* Count of files awaiting deletion;*/
N	int nUnlinkedFiles;		/* Count of unlinked files. */
N	int nBackgroundDeletions;	/* Count of background deletions. */
N
N	
N	/* Temporary buffer management */
N	yaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];
X	yaffs_TempBuffer tempBuffer[6];
N	int maxTemp;
N	int tempInUse;
N	int unmanagedTempAllocations;
N	int unmanagedTempDeallocations;
N
N	/* yaffs2 runtime stuff */
N	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
N	unsigned oldestDirtySequence;
N
N};
N
Ntypedef struct yaffs_DeviceStruct yaffs_Device;
N
N/* The static layout of block usage etc is stored in the super block header */
Ntypedef struct {
N        int StructType;
N        int version;
N	int checkpointStartBlock;
N	int checkpointEndBlock;
N	int startBlock;
N	int endBlock;
N	int rfu[100];
N} yaffs_SuperBlockHeader;
N	
N/* The CheckpointDevice structure holds the device information that changes at runtime and
N * must be preserved over unmount/mount cycles.
N */
Ntypedef struct {
N        int structType;
N	int nErasedBlocks;
N	int allocationBlock;	/* Current block being allocated off */
N	__u32 allocationPage;
N	int nFreeChunks;
N
N	int nDeletedFiles;		/* Count of files awaiting deletion;*/
N	int nUnlinkedFiles;		/* Count of unlinked files. */
N	int nBackgroundDeletions;	/* Count of background deletions. */
N
N	/* yaffs2 runtime stuff */
N	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
N	unsigned oldestDirtySequence;
N
N} yaffs_CheckpointDevice;
N
N
Ntypedef struct {
N    int structType;
N    __u32 magic;
N    __u32 version;
N    __u32 head;
N} yaffs_CheckpointValidity;
N
N
N/*----------------------- YAFFS Functions -----------------------*/
N
Nint yaffs_GutsInitialise(yaffs_Device * dev);
Nvoid yaffs_Deinitialise(yaffs_Device * dev);
N
Nint yaffs_GetNumberOfFreeChunks(yaffs_Device * dev);
N
Nint yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,
Xint yaffs_RenameObject(yaffs_Object * oldDir, const char * oldName,
N		       yaffs_Object * newDir, const YCHAR * newName);
X		       yaffs_Object * newDir, const char * newName);
N
Nint yaffs_Unlink(yaffs_Object * dir, const YCHAR * name);
Xint yaffs_Unlink(yaffs_Object * dir, const char * name);
Nint yaffs_DeleteFile(yaffs_Object * obj);
N
Nint yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize);
Xint yaffs_GetObjectName(yaffs_Object * obj, char * name, int buffSize);
Nint yaffs_GetObjectFileLength(yaffs_Object * obj);
Nint yaffs_GetObjectInode(yaffs_Object * obj);
Nunsigned yaffs_GetObjectType(yaffs_Object * obj);
Nint yaffs_GetObjectLinkCount(yaffs_Object * obj);
N
Nint yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr);
Nint yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr);
N
N/* File operations */
Nint yaffs_ReadDataFromFile(yaffs_Object * obj, __u8 * buffer, loff_t offset,
N                           int nBytes);
Nint yaffs_WriteDataToFile(yaffs_Object * obj, const __u8 * buffer, loff_t offset,
N                          int nBytes, int writeThrough);
Nint yaffs_ResizeFile(yaffs_Object * obj, loff_t newSize);
N
Nyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const char * name,
N                              __u32 mode, __u32 uid, __u32 gid);
Nint yaffs_FlushFile(yaffs_Object * obj, int updateTime);
N
N/* Flushing and checkpointing */
Nvoid yaffs_FlushEntireDeviceCache(yaffs_Device *dev);
N
Nint yaffs_CheckpointSave(yaffs_Device *dev);
Nint yaffs_CheckpointRestore(yaffs_Device *dev);
N
N/* Directory operations */
Nyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const char * name,
N				   __u32 mode, __u32 uid, __u32 gid);
Nyaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const YCHAR * name);
Xyaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const char * name);
Nint yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,
N				   int (*fn) (yaffs_Object *));
N
Nyaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number);
N
N/* Link operations */
Nyaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_Link(yaffs_Object * parent, const char * name,
N			 yaffs_Object * equivalentObject);
N
Nyaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj);
N
N/* Symlink operations */
Nyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid,
N				 const YCHAR * alias);
X				 const char * alias);
NYCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj);
Xchar *yaffs_GetSymlinkAlias(yaffs_Object * obj);
N
N/* Special inodes (fifos, sockets and devices) */
Nyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev);
N
N/* Special directories */
Nyaffs_Object *yaffs_Root(yaffs_Device * dev);
Nyaffs_Object *yaffs_LostNFound(yaffs_Device * dev);
N
N#ifdef CONFIG_YAFFS_WINCE
S/* CONFIG_YAFFS_WINCE special stuff */
Svoid yfsd_WinFileTimeNow(__u32 target[2]);
N#endif
N
N#ifdef __KERNEL__
S
Svoid yaffs_HandleDeferedFree(yaffs_Object * obj);
N#endif
N
N/* Debug dump  */
Nint yaffs_DumpObject(yaffs_Object * obj);
N
Nvoid yaffs_GutsTest(yaffs_Device * dev);
N
N/* A few useful functions */
Nvoid yaffs_InitialiseTags(yaffs_ExtendedTags * tags);
Nvoid yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn);
Nint yaffs_CheckFF(__u8 * buffer, int nBytes);
Nvoid yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);
N
N__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo);
Nvoid yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer, int lineNo);
N
N#endif
L 15 "..\fs\yaffs_tagscompat.c" 2
N#include "yaffs_tagscompat.h"
L 1 "..\fs\yaffs_tagscompat.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_TAGSCOMPAT_H__
N#define __YAFFS_TAGSCOMPAT_H__
N
N#include "yaffs_guts.h"
Nint yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,
N						    int chunkInNAND,
N						    const __u8 * data,
N						    const yaffs_ExtendedTags *
N						    tags);
Nint yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,
N						     int chunkInNAND,
N						     __u8 * data,
N						     yaffs_ExtendedTags *
N						     tags);
Nint yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
N					    int blockNo);
Nint yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
N					  int blockNo, 
N					  yaffs_BlockState *state,
N					  __u32 *sequenceNumber);
N
Nvoid yaffs_CalcTagsECC(yaffs_Tags * tags);
Nint yaffs_CheckECCOnTags(yaffs_Tags * tags);
Nint yaffs_CountBits(__u8 byte);
N
N#endif
L 16 "..\fs\yaffs_tagscompat.c" 2
N#include "yaffs_ecc.h"
L 1 "..\fs\yaffs_ecc.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N /*
N  * This code implements the ECC algorithm used in SmartMedia.
N  *
N  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
N  * The two unused bit are set to 1.
N  * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
N  * blocks are used on a 512-byte NAND page.
N  *
N  */
N
N#ifndef __YAFFS_ECC_H__
N#define __YAFFS_ECC_H__
N
Ntypedef struct {
N	unsigned char colParity;
N	unsigned lineParity;
N	unsigned lineParityPrime;
N} yaffs_ECCOther;
N
Nvoid yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc);
Nint yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
N		     const unsigned char *test_ecc);
N
Nvoid yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
N			     yaffs_ECCOther * ecc);
Nint yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
N			  yaffs_ECCOther * read_ecc,
N			  const yaffs_ECCOther * test_ecc);
N#endif
L 17 "..\fs\yaffs_tagscompat.c" 2
N#include "yaffs_getblockinfo.h"
L 1 "..\fs\yaffs_getblockinfo.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_GETBLOCKINFO_H__
N#define __YAFFS_GETBLOCKINFO_H__
N
N#include "yaffs_guts.h"
N
N/* Function to manipulate block info */
Nstatic Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
Xstatic __inline yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
N{
N	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
N		T(YAFFS_TRACE_ERROR,
N		  (TSTR
N		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
N		   blk));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		YBUG();
X		;
N	}
N	return &dev->blockInfo[blk - dev->internalStartBlock];
N}
N
N#endif
L 18 "..\fs\yaffs_tagscompat.c" 2
N
Nstatic void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND);
N#ifdef NOTYET
Sstatic void yaffs_CheckWrittenBlock(yaffs_Device * dev, int chunkInNAND);
Sstatic void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,
S				     const __u8 * data,
S				     const yaffs_Spare * spare);
Sstatic void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,
S				    const yaffs_Spare * spare);
Sstatic void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND);
N#endif
N
Nstatic const char yaffs_countBitsTable[256] = {
N	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
N	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
N	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
N	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
N	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
N	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
N	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
N	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
N	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
N	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
N	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
N	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
N	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
N	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
N	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
N	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
N};
N
Nint yaffs_CountBits(__u8 x)
N{
N	int retVal;
N	retVal = yaffs_countBitsTable[x];
N	return retVal;
N}
N
N/********** Tags ECC calculations  *********/
N
Nvoid yaffs_CalcECC(const __u8 * data, yaffs_Spare * spare)
N{
N	yaffs_ECCCalculate(data, spare->ecc1);
N	yaffs_ECCCalculate(&data[256], spare->ecc2);
N}
N
Nvoid yaffs_CalcTagsECC(yaffs_Tags * tags)
N{
N	/* Calculate an ecc */
N
N	unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
N	unsigned i, j;
N	unsigned ecc = 0;
N	unsigned bit = 0;
N
N	tags->ecc = 0;
N
N	for (i = 0; i < 8; i++) {
N		for (j = 1; j & 0xff; j <<= 1) {
N			bit++;
N			if (b[i] & j) {
N				ecc ^= bit;
N			}
N		}
N	}
N
N	tags->ecc = ecc;
N
N}
N
Nint yaffs_CheckECCOnTags(yaffs_Tags * tags)
N{
N	unsigned ecc = tags->ecc;
N
N	yaffs_CalcTagsECC(tags);
N
N	ecc ^= tags->ecc;
N
N	if (ecc && ecc <= 64) {
N		/* TODO: Handle the failure better. Retire? */
N		unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
N
N		ecc--;
N
N		b[ecc / 8] ^= (1 << (ecc & 7));
N
N		/* Now recvalc the ecc */
N		yaffs_CalcTagsECC(tags);
N
N		return 1;	/* recovered error */
N	} else if (ecc) {
N		/* Wierd ecc failure value */
N		/* TODO Need to do somethiong here */
N		return -1;	/* unrecovered error */
N	}
N
N	return 0;
N}
N
N/********** Tags **********/
N
Nstatic void yaffs_LoadTagsIntoSpare(yaffs_Spare * sparePtr,
N				    yaffs_Tags * tagsPtr)
N{
N	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
N
N	yaffs_CalcTagsECC(tagsPtr);
N
N	sparePtr->tagByte0 = tu->asBytes[0];
N	sparePtr->tagByte1 = tu->asBytes[1];
N	sparePtr->tagByte2 = tu->asBytes[2];
N	sparePtr->tagByte3 = tu->asBytes[3];
N	sparePtr->tagByte4 = tu->asBytes[4];
N	sparePtr->tagByte5 = tu->asBytes[5];
N	sparePtr->tagByte6 = tu->asBytes[6];
N	sparePtr->tagByte7 = tu->asBytes[7];
N}
N
Nstatic void yaffs_GetTagsFromSpare(yaffs_Device * dev, yaffs_Spare * sparePtr,
N				   yaffs_Tags * tagsPtr)
N{
N	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
N	int result;
N
N	tu->asBytes[0] = sparePtr->tagByte0;
N	tu->asBytes[1] = sparePtr->tagByte1;
N	tu->asBytes[2] = sparePtr->tagByte2;
N	tu->asBytes[3] = sparePtr->tagByte3;
N	tu->asBytes[4] = sparePtr->tagByte4;
N	tu->asBytes[5] = sparePtr->tagByte5;
N	tu->asBytes[6] = sparePtr->tagByte6;
N	tu->asBytes[7] = sparePtr->tagByte7;
N
N	result = yaffs_CheckECCOnTags(tagsPtr);
N	if (result > 0) {
N		dev->tagsEccFixed++;
N	} else if (result < 0) {
N		dev->tagsEccUnfixed++;
N	}
N}
N
Nstatic void yaffs_SpareInitialise(yaffs_Spare * spare)
N{
N	memset(spare, 0xFF, sizeof(yaffs_Spare));
N}
N
Nstatic int yaffs_WriteChunkToNAND(struct yaffs_DeviceStruct *dev,
N				  int chunkInNAND, const __u8 * data,
N				  yaffs_Spare * spare)
N{
N	if (chunkInNAND < dev->startBlock * dev->nChunksPerBlock) {
N		T(YAFFS_TRACE_ERROR,
N		  (TSTR("**>> yaffs chunk %d is not valid" TENDSTR),
N		   chunkInNAND));
X		do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N		return YAFFS_FAIL;
X		return 0;
N	}
N
N	dev->nPageWrites++;
N	return dev->writeChunkToNAND(dev, chunkInNAND, data, spare);
N}
N
Nstatic int yaffs_ReadChunkFromNAND(struct yaffs_DeviceStruct *dev,
N				   int chunkInNAND,
N				   __u8 * data,
N				   yaffs_Spare * spare,
N				   yaffs_ECCResult * eccResult,
N				   int doErrorCorrection)
N{
N	int retVal;
N	yaffs_Spare localSpare;
N
N	dev->nPageReads++;
N
N	if (!spare && data) {
N		/* If we don't have a real spare, then we use a local one. */
N		/* Need this for the calculation of the ecc */
N		spare = &localSpare;
N	}
N
N	if (!dev->useNANDECC) {
N		retVal = dev->readChunkFromNAND(dev, chunkInNAND, data, spare);
N		if (data && doErrorCorrection) {
N			/* Do ECC correction */
N			/* Todo handle any errors */
N			int eccResult1, eccResult2;
N			__u8 calcEcc[3];
N
N			yaffs_ECCCalculate(data, calcEcc);
N			eccResult1 =
N			    yaffs_ECCCorrect(data, spare->ecc1, calcEcc);
N			yaffs_ECCCalculate(&data[256], calcEcc);
N			eccResult2 =
N			    yaffs_ECCCorrect(&data[256], spare->ecc2, calcEcc);
N
N			if (eccResult1 > 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>yaffs ecc error fix performed on chunk %d:0"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				dev->eccFixed++;
N			} else if (eccResult1 < 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>yaffs ecc error unfixed on chunk %d:0"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				dev->eccUnfixed++;
N			}
N
N			if (eccResult2 > 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>yaffs ecc error fix performed on chunk %d:1"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				dev->eccFixed++;
N			} else if (eccResult2 < 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>yaffs ecc error unfixed on chunk %d:1"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N				dev->eccUnfixed++;
N			}
N
N			if (eccResult1 || eccResult2) {
N				/* We had a data problem on this page */
N				yaffs_HandleReadDataError(dev, chunkInNAND);
N			}
N
N			if (eccResult1 < 0 || eccResult2 < 0)
N				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
N			else if (eccResult1 > 0 || eccResult2 > 0)
N				*eccResult = YAFFS_ECC_RESULT_FIXED;
N			else
N				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
N		}
N	} else {
N		/* Must allocate enough memory for spare+2*sizeof(int) */
N		/* for ecc results from device. */
N		struct yaffs_NANDSpare nspare;
N		
N		memset(&nspare,0,sizeof(nspare));
N		
N		retVal =
N		    dev->readChunkFromNAND(dev, chunkInNAND, data,
N					   (yaffs_Spare *) & nspare);
N		memcpy(spare, &nspare, sizeof(yaffs_Spare));
N		if (data && doErrorCorrection) {
N			if (nspare.eccres1 > 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>mtd ecc error fix performed on chunk %d:0"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			} else if (nspare.eccres1 < 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>mtd ecc error unfixed on chunk %d:0"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			}
N
N			if (nspare.eccres2 > 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>mtd ecc error fix performed on chunk %d:1"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			} else if (nspare.eccres2 < 0) {
N				T(YAFFS_TRACE_ERROR,
N				  (TSTR
N				   ("**>>mtd ecc error unfixed on chunk %d:1"
N				    TENDSTR), chunkInNAND));
X				do{ if((0x40000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N			}
N
N			if (nspare.eccres1 || nspare.eccres2) {
N				/* We had a data problem on this page */
N				yaffs_HandleReadDataError(dev, chunkInNAND);
N			}
N
N			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
N				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
N			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
N				*eccResult = YAFFS_ECC_RESULT_FIXED;
N			else
N				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
N
N		}
N	}
N	return retVal;
N}
N
N#ifdef NOTYET
Sstatic int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
S				  int chunkInNAND)
S{
S
S	static int init = 0;
S	static __u8 cmpbuf[YAFFS_BYTES_PER_CHUNK];
S	static __u8 data[YAFFS_BYTES_PER_CHUNK];
S	/* Might as well always allocate the larger size for */
S	/* dev->useNANDECC == true; */
S	static __u8 spare[sizeof(struct yaffs_NANDSpare)];
S
S	dev->readChunkFromNAND(dev, chunkInNAND, data, (yaffs_Spare *) spare);
S
S	if (!init) {
S		memset(cmpbuf, 0xff, YAFFS_BYTES_PER_CHUNK);
S		init = 1;
S	}
S
S	if (memcmp(cmpbuf, data, YAFFS_BYTES_PER_CHUNK))
S		return YAFFS_FAIL;
S	if (memcmp(cmpbuf, spare, 16))
S		return YAFFS_FAIL;
S
S	return YAFFS_OK;
S
S}
N#endif
N
N/*
N * Functions for robustisizing
N */
N
Nstatic void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND)
N{
N	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
N
N	/* Mark the block for retirement */
N	yaffs_GetBlockInfo(dev, blockInNAND + dev->blockOffset)->needsRetiring = 1;
N	T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
N	  (TSTR("**>>Block %d marked for retirement" TENDSTR), blockInNAND));
X	do{ if((0x40000000 | 0x00000010) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N
N	/* TODO:
N	 * Just do a garbage collection on the affected block
N	 * then retire the block
N	 * NB recursion
N	 */
N}
N
N#ifdef NOTYET
Sstatic void yaffs_CheckWrittenBlock(yaffs_Device * dev, int chunkInNAND)
S{
S}
S
Sstatic void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,
S				     const __u8 * data,
S				     const yaffs_Spare * spare)
S{
S}
S
Sstatic void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,
S				    const yaffs_Spare * spare)
S{
S}
S
Sstatic void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND)
S{
S	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
S
S	/* Mark the block for retirement */
S	yaffs_GetBlockInfo(dev, blockInNAND)->needsRetiring = 1;
S	/* Delete the chunk */
S	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
S}
S
Sstatic int yaffs_VerifyCompare(const __u8 * d0, const __u8 * d1,
S			       const yaffs_Spare * s0, const yaffs_Spare * s1)
S{
S
S	if (memcmp(d0, d1, YAFFS_BYTES_PER_CHUNK) != 0 ||
S	    s0->tagByte0 != s1->tagByte0 ||
S	    s0->tagByte1 != s1->tagByte1 ||
S	    s0->tagByte2 != s1->tagByte2 ||
S	    s0->tagByte3 != s1->tagByte3 ||
S	    s0->tagByte4 != s1->tagByte4 ||
S	    s0->tagByte5 != s1->tagByte5 ||
S	    s0->tagByte6 != s1->tagByte6 ||
S	    s0->tagByte7 != s1->tagByte7 ||
S	    s0->ecc1[0] != s1->ecc1[0] ||
S	    s0->ecc1[1] != s1->ecc1[1] ||
S	    s0->ecc1[2] != s1->ecc1[2] ||
S	    s0->ecc2[0] != s1->ecc2[0] ||
S	    s0->ecc2[1] != s1->ecc2[1] || s0->ecc2[2] != s1->ecc2[2]) {
S		return 0;
S	}
S
S	return 1;
S}
N#endif				/* NOTYET */
N
Nint yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,
N						    int chunkInNAND,
N						    const __u8 * data,
N						    const yaffs_ExtendedTags *
N						    eTags)
N{
N	yaffs_Spare spare;
N	yaffs_Tags tags;
N
N	yaffs_SpareInitialise(&spare);
N
N	if (eTags->chunkDeleted) {
N		spare.pageStatus = 0;
N	} else {
N		tags.objectId = eTags->objectId;
N		tags.chunkId = eTags->chunkId;
N
N		tags.byteCountLSB = eTags->byteCount & 0x3ff;
N		
N		if(dev->nDataBytesPerChunk >= 1024){
N			tags.byteCountMSB = (eTags->byteCount >> 10) & 3;
N		} else {
N			tags.byteCountMSB = 3;
N		}
N		
N
N		tags.serialNumber = eTags->serialNumber;
N
N		if (!dev->useNANDECC && data) {
N			yaffs_CalcECC(data, &spare);
N		}
N		yaffs_LoadTagsIntoSpare(&spare, &tags);
N
N	}
N
N	return yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);
N}
N
Nint yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,
N						     int chunkInNAND,
N						     __u8 * data,
N						     yaffs_ExtendedTags * eTags)
N{
N
N	yaffs_Spare spare;
N	yaffs_Tags tags;
N	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_UNKNOWN;
N
N	static yaffs_Spare spareFF;
N	static int init = 0;
N
N	if (!init) {
N		memset(&spareFF, 0xFF, sizeof(spareFF));
N		init = 1;
N	}
N
N	if (yaffs_ReadChunkFromNAND
N	    (dev, chunkInNAND, data, &spare, &eccResult, 1)) {
N		/* eTags may be NULL */
N		if (eTags) {
N
N			int deleted =
N			    (yaffs_CountBits(spare.pageStatus) < 7) ? 1 : 0;
N
N			eTags->chunkDeleted = deleted;
N			eTags->eccResult = eccResult;
N			eTags->blockBad = 0;	/* We're reading it */
N			/* therefore it is not a bad block */
N			eTags->chunkUsed =
N			    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=
N			     0) ? 1 : 0;
N
N			if (eTags->chunkUsed) {
N				yaffs_GetTagsFromSpare(dev, &spare, &tags);
N
N				eTags->objectId = tags.objectId;
N				eTags->chunkId = tags.chunkId;
N				eTags->byteCount = tags.byteCountLSB;
N
N				if(dev->nDataBytesPerChunk >= 1024)
N					eTags->byteCount |= (((unsigned) tags.byteCountMSB) << 10);
N
N				eTags->serialNumber = tags.serialNumber;
N			}
N		}
N
N		return YAFFS_OK;
X		return 1;
N	} else {
N		return YAFFS_FAIL;
X		return 0;
N	}
N}
N
Nint yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
N					    int blockInNAND)
N{
N
N	yaffs_Spare spare;
N
N	memset(&spare, 0xff, sizeof(yaffs_Spare));
N
N	spare.blockStatus = 'Y';
N
N	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock, NULL,
X	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock, 0,
N			       &spare);
N	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock + 1,
N			       NULL, &spare);
X			       0, &spare);
N
N	return YAFFS_OK;
X	return 1;
N
N}
N
Nint yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
N					  int blockNo,
N					  yaffs_BlockState *state,
N					  __u32 *sequenceNumber)
N{
N
N	yaffs_Spare spare0, spare1;
N	static yaffs_Spare spareFF;
N	static int init;
N	yaffs_ECCResult dummy;
N
N	if (!init) {
N		memset(&spareFF, 0xFF, sizeof(spareFF));
N		init = 1;
N	}
N
N	*sequenceNumber = 0;
N
N	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock, NULL,
X	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock, 0,
N				&spare0, &dummy, 1);
N	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock + 1, NULL,
X	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock + 1, 0,
N				&spare1, &dummy, 1);
N
N	if (yaffs_CountBits(spare0.blockStatus & spare1.blockStatus) < 7)
N		*state = YAFFS_BLOCK_STATE_DEAD;
N	else if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)
N		*state = YAFFS_BLOCK_STATE_EMPTY;
N	else
N		*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
N
N	return YAFFS_OK;
X	return 1;
N}

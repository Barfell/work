; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\yaffs_tagscompat.o --asm_dir=.\ --list_dir=.\ --depend=.\flash\yaffs_tagscompat.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\app -I..\CM3_lib -I..\Drivers -I..\Startup -I.\Easy_web -I.\Lcd_Drv -I.\IIC_Test -I.\USU_Host -I.\Nand_Test -I.\FATFS_R0.08 -I..\fs -I"D:\Program Files\mdk\ARM\RV31\INC" -I"D:\Program Files\mdk\pack\ARM\CMSIS\4.1.1\CMSIS\Include" -I"D:\Program Files\mdk\ARM\Inc\NXP\LPC177x_8x" -D__MICROLIB --omf_browse=.\flash\yaffs_tagscompat.crf ..\fs\yaffs_tagscompat.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  yaffs_CountBits PROC
;;;48     
;;;49     int yaffs_CountBits(__u8 x)
000000  4601              MOV      r1,r0
;;;50     {
;;;51     	int retVal;
;;;52     	retVal = yaffs_countBitsTable[x];
000002  4afb              LDR      r2,|L1.1008|
000004  5c50              LDRB     r0,[r2,r1]
;;;53     	return retVal;
;;;54     }
000006  4770              BX       lr
;;;55     
                          ENDP

                  yaffs_CalcECC PROC
;;;57     
;;;58     void yaffs_CalcECC(const __u8 * data, yaffs_Spare * spare)
000008  b570              PUSH     {r4-r6,lr}
;;;59     {
00000a  4605              MOV      r5,r0
00000c  460c              MOV      r4,r1
;;;60     	yaffs_ECCCalculate(data, spare->ecc1);
00000e  f1040108          ADD      r1,r4,#8
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       yaffs_ECCCalculate
;;;61     	yaffs_ECCCalculate(&data[256], spare->ecc2);
000018  f104010d          ADD      r1,r4,#0xd
00001c  f5057080          ADD      r0,r5,#0x100
000020  f7fffffe          BL       yaffs_ECCCalculate
;;;62     }
000024  bd70              POP      {r4-r6,pc}
;;;63     
                          ENDP

                  yaffs_CalcTagsECC PROC
;;;64     void yaffs_CalcTagsECC(yaffs_Tags * tags)
000026  b5f0              PUSH     {r4-r7,lr}
;;;65     {
;;;66     	/* Calculate an ecc */
;;;67     
;;;68     	unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
000028  4601              MOV      r1,r0
;;;69     	unsigned i, j;
;;;70     	unsigned ecc = 0;
00002a  2400              MOVS     r4,#0
;;;71     	unsigned bit = 0;
00002c  2500              MOVS     r5,#0
;;;72     
;;;73     	tags->ecc = 0;
00002e  2700              MOVS     r7,#0
000030  6846              LDR      r6,[r0,#4]
000032  f367469d          BFI      r6,r7,#18,#12
000036  6046              STR      r6,[r0,#4]
;;;74     
;;;75     	for (i = 0; i < 8; i++) {
000038  2200              MOVS     r2,#0
00003a  e00b              B        |L1.84|
                  |L1.60|
;;;76     		for (j = 1; j & 0xff; j <<= 1) {
00003c  2301              MOVS     r3,#1
00003e  e005              B        |L1.76|
                  |L1.64|
;;;77     			bit++;
000040  1c6d              ADDS     r5,r5,#1
;;;78     			if (b[i] & j) {
000042  5c8e              LDRB     r6,[r1,r2]
000044  401e              ANDS     r6,r6,r3
000046  b106              CBZ      r6,|L1.74|
;;;79     				ecc ^= bit;
000048  406c              EORS     r4,r4,r5
                  |L1.74|
00004a  005b              LSLS     r3,r3,#1              ;76
                  |L1.76|
00004c  b2de              UXTB     r6,r3                 ;76
00004e  2e00              CMP      r6,#0                 ;76
000050  d1f6              BNE      |L1.64|
000052  1c52              ADDS     r2,r2,#1              ;75
                  |L1.84|
000054  2a08              CMP      r2,#8                 ;75
000056  d3f1              BCC      |L1.60|
;;;80     			}
;;;81     		}
;;;82     	}
;;;83     
;;;84     	tags->ecc = ecc;
000058  6846              LDR      r6,[r0,#4]
00005a  f364469d          BFI      r6,r4,#18,#12
00005e  6046              STR      r6,[r0,#4]
;;;85     
;;;86     }
000060  bdf0              POP      {r4-r7,pc}
;;;87     
                          ENDP

                  yaffs_CheckECCOnTags PROC
;;;88     int yaffs_CheckECCOnTags(yaffs_Tags * tags)
000062  b570              PUSH     {r4-r6,lr}
;;;89     {
000064  4605              MOV      r5,r0
;;;90     	unsigned ecc = tags->ecc;
000066  6868              LDR      r0,[r5,#4]
000068  f3c0448b          UBFX     r4,r0,#18,#12
;;;91     
;;;92     	yaffs_CalcTagsECC(tags);
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       yaffs_CalcTagsECC
;;;93     
;;;94     	ecc ^= tags->ecc;
000072  6868              LDR      r0,[r5,#4]
000074  f3c0408b          UBFX     r0,r0,#18,#12
000078  4044              EORS     r4,r4,r0
;;;95     
;;;96     	if (ecc && ecc <= 64) {
00007a  b19c              CBZ      r4,|L1.164|
00007c  2c40              CMP      r4,#0x40
00007e  d811              BHI      |L1.164|
;;;97     		/* TODO: Handle the failure better. Retire? */
;;;98     		unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
000080  462e              MOV      r6,r5
;;;99     
;;;100    		ecc--;
000082  1e64              SUBS     r4,r4,#1
;;;101    
;;;102    		b[ecc / 8] ^= (1 << (ecc & 7));
000084  eb0600d4          ADD      r0,r6,r4,LSR #3
000088  7800              LDRB     r0,[r0,#0]
00008a  f0040207          AND      r2,r4,#7
00008e  2101              MOVS     r1,#1
000090  4091              LSLS     r1,r1,r2
000092  4048              EORS     r0,r0,r1
000094  eb0601d4          ADD      r1,r6,r4,LSR #3
000098  7008              STRB     r0,[r1,#0]
;;;103    
;;;104    		/* Now recvalc the ecc */
;;;105    		yaffs_CalcTagsECC(tags);
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       yaffs_CalcTagsECC
;;;106    
;;;107    		return 1;	/* recovered error */
0000a0  2001              MOVS     r0,#1
                  |L1.162|
;;;108    	} else if (ecc) {
;;;109    		/* Wierd ecc failure value */
;;;110    		/* TODO Need to do somethiong here */
;;;111    		return -1;	/* unrecovered error */
;;;112    	}
;;;113    
;;;114    	return 0;
;;;115    }
0000a2  bd70              POP      {r4-r6,pc}
                  |L1.164|
0000a4  b114              CBZ      r4,|L1.172|
0000a6  f04f30ff          MOV      r0,#0xffffffff        ;111
0000aa  e7fa              B        |L1.162|
                  |L1.172|
0000ac  2000              MOVS     r0,#0                 ;114
0000ae  e7f8              B        |L1.162|
;;;116    
                          ENDP

                  yaffs_LoadTagsIntoSpare PROC
;;;118    
;;;119    static void yaffs_LoadTagsIntoSpare(yaffs_Spare * sparePtr,
0000b0  b570              PUSH     {r4-r6,lr}
;;;120    				    yaffs_Tags * tagsPtr)
;;;121    {
0000b2  4605              MOV      r5,r0
0000b4  460c              MOV      r4,r1
;;;122    	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
0000b6  4626              MOV      r6,r4
;;;123    
;;;124    	yaffs_CalcTagsECC(tagsPtr);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       yaffs_CalcTagsECC
;;;125    
;;;126    	sparePtr->tagByte0 = tu->asBytes[0];
0000be  7830              LDRB     r0,[r6,#0]
0000c0  7028              STRB     r0,[r5,#0]
;;;127    	sparePtr->tagByte1 = tu->asBytes[1];
0000c2  7870              LDRB     r0,[r6,#1]
0000c4  7068              STRB     r0,[r5,#1]
;;;128    	sparePtr->tagByte2 = tu->asBytes[2];
0000c6  78b0              LDRB     r0,[r6,#2]
0000c8  70a8              STRB     r0,[r5,#2]
;;;129    	sparePtr->tagByte3 = tu->asBytes[3];
0000ca  78f0              LDRB     r0,[r6,#3]
0000cc  70e8              STRB     r0,[r5,#3]
;;;130    	sparePtr->tagByte4 = tu->asBytes[4];
0000ce  7930              LDRB     r0,[r6,#4]
0000d0  71a8              STRB     r0,[r5,#6]
;;;131    	sparePtr->tagByte5 = tu->asBytes[5];
0000d2  7970              LDRB     r0,[r6,#5]
0000d4  71e8              STRB     r0,[r5,#7]
;;;132    	sparePtr->tagByte6 = tu->asBytes[6];
0000d6  79b0              LDRB     r0,[r6,#6]
0000d8  72e8              STRB     r0,[r5,#0xb]
;;;133    	sparePtr->tagByte7 = tu->asBytes[7];
0000da  79f0              LDRB     r0,[r6,#7]
0000dc  7328              STRB     r0,[r5,#0xc]
;;;134    }
0000de  bd70              POP      {r4-r6,pc}
;;;135    
                          ENDP

                  yaffs_GetTagsFromSpare PROC
;;;136    static void yaffs_GetTagsFromSpare(yaffs_Device * dev, yaffs_Spare * sparePtr,
0000e0  e92d41f0          PUSH     {r4-r8,lr}
;;;137    				   yaffs_Tags * tagsPtr)
;;;138    {
0000e4  4607              MOV      r7,r0
0000e6  460d              MOV      r5,r1
0000e8  4614              MOV      r4,r2
;;;139    	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
0000ea  4626              MOV      r6,r4
;;;140    	int result;
;;;141    
;;;142    	tu->asBytes[0] = sparePtr->tagByte0;
0000ec  7828              LDRB     r0,[r5,#0]
0000ee  7030              STRB     r0,[r6,#0]
;;;143    	tu->asBytes[1] = sparePtr->tagByte1;
0000f0  7868              LDRB     r0,[r5,#1]
0000f2  7070              STRB     r0,[r6,#1]
;;;144    	tu->asBytes[2] = sparePtr->tagByte2;
0000f4  78a8              LDRB     r0,[r5,#2]
0000f6  70b0              STRB     r0,[r6,#2]
;;;145    	tu->asBytes[3] = sparePtr->tagByte3;
0000f8  78e8              LDRB     r0,[r5,#3]
0000fa  70f0              STRB     r0,[r6,#3]
;;;146    	tu->asBytes[4] = sparePtr->tagByte4;
0000fc  79a8              LDRB     r0,[r5,#6]
0000fe  7130              STRB     r0,[r6,#4]
;;;147    	tu->asBytes[5] = sparePtr->tagByte5;
000100  79e8              LDRB     r0,[r5,#7]
000102  7170              STRB     r0,[r6,#5]
;;;148    	tu->asBytes[6] = sparePtr->tagByte6;
000104  7ae8              LDRB     r0,[r5,#0xb]
000106  71b0              STRB     r0,[r6,#6]
;;;149    	tu->asBytes[7] = sparePtr->tagByte7;
000108  7b28              LDRB     r0,[r5,#0xc]
00010a  71f0              STRB     r0,[r6,#7]
;;;150    
;;;151    	result = yaffs_CheckECCOnTags(tagsPtr);
00010c  4620              MOV      r0,r4
00010e  f7fffffe          BL       yaffs_CheckECCOnTags
000112  4680              MOV      r8,r0
;;;152    	if (result > 0) {
000114  f1b80f00          CMP      r8,#0
000118  dd05              BLE      |L1.294|
;;;153    		dev->tagsEccFixed++;
00011a  f8d70d70          LDR      r0,[r7,#0xd70]
00011e  1c40              ADDS     r0,r0,#1
000120  f8c70d70          STR      r0,[r7,#0xd70]
000124  e007              B        |L1.310|
                  |L1.294|
;;;154    	} else if (result < 0) {
000126  f1b80f00          CMP      r8,#0
00012a  da04              BGE      |L1.310|
;;;155    		dev->tagsEccUnfixed++;
00012c  f8d70d74          LDR      r0,[r7,#0xd74]
000130  1c40              ADDS     r0,r0,#1
000132  f8c70d74          STR      r0,[r7,#0xd74]
                  |L1.310|
;;;156    	}
;;;157    }
000136  e8bd81f0          POP      {r4-r8,pc}
;;;158    
                          ENDP

                  yaffs_SpareInitialise PROC
;;;159    static void yaffs_SpareInitialise(yaffs_Spare * spare)
00013a  b510              PUSH     {r4,lr}
;;;160    {
00013c  4604              MOV      r4,r0
;;;161    	memset(spare, 0xFF, sizeof(yaffs_Spare));
00013e  22ff              MOVS     r2,#0xff
000140  2110              MOVS     r1,#0x10
000142  4620              MOV      r0,r4
000144  f7fffffe          BL       __aeabi_memset
;;;162    }
000148  bd10              POP      {r4,pc}
;;;163    
                          ENDP

                  yaffs_WriteChunkToNAND PROC
;;;164    static int yaffs_WriteChunkToNAND(struct yaffs_DeviceStruct *dev,
00014a  e92d41f0          PUSH     {r4-r8,lr}
;;;165    				  int chunkInNAND, const __u8 * data,
;;;166    				  yaffs_Spare * spare)
;;;167    {
00014e  4604              MOV      r4,r0
000150  460d              MOV      r5,r1
000152  4616              MOV      r6,r2
000154  461f              MOV      r7,r3
;;;168    	if (chunkInNAND < dev->startBlock * dev->nChunksPerBlock) {
000156  6921              LDR      r1,[r4,#0x10]
000158  69a0              LDR      r0,[r4,#0x18]
00015a  4348              MULS     r0,r1,r0
00015c  42a8              CMP      r0,r5
00015e  dd04              BLE      |L1.362|
;;;169    		T(YAFFS_TRACE_ERROR,
000160  bf00              NOP      
000162  bf00              NOP      
;;;170    		  (TSTR("**>> yaffs chunk %d is not valid" TENDSTR),
;;;171    		   chunkInNAND));
;;;172    		return YAFFS_FAIL;
000164  2000              MOVS     r0,#0
                  |L1.358|
;;;173    	}
;;;174    
;;;175    	dev->nPageWrites++;
;;;176    	return dev->writeChunkToNAND(dev, chunkInNAND, data, spare);
;;;177    }
000166  e8bd81f0          POP      {r4-r8,pc}
                  |L1.362|
00016a  f8d40d44          LDR      r0,[r4,#0xd44]        ;175
00016e  1c40              ADDS     r0,r0,#1              ;175
000170  f8c40d44          STR      r0,[r4,#0xd44]        ;175
000174  463b              MOV      r3,r7                 ;176
000176  4632              MOV      r2,r6                 ;176
000178  4629              MOV      r1,r5                 ;176
00017a  4620              MOV      r0,r4                 ;176
00017c  f8d4c038          LDR      r12,[r4,#0x38]        ;176
000180  47e0              BLX      r12                   ;176
000182  e7f0              B        |L1.358|
;;;178    
                          ENDP

                  yaffs_HandleReadDataError PROC
;;;337    
;;;338    static void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND)
000184  b570              PUSH     {r4-r6,lr}
;;;339    {
000186  460b              MOV      r3,r1
;;;340    	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
000188  6901              LDR      r1,[r0,#0x10]
00018a  fb93f4f1          SDIV     r4,r3,r1
;;;341    
;;;342    	/* Mark the block for retirement */
;;;343    	yaffs_GetBlockInfo(dev, blockInNAND + dev->blockOffset)->needsRetiring = 1;
00018e  f8d050a4          LDR      r5,[r0,#0xa4]
000192  192a              ADDS     r2,r5,r4
000194  f8d0509c          LDR      r5,[r0,#0x9c]
000198  4295              CMP      r5,r2
00019a  dc03              BGT      |L1.420|
00019c  f8d050a0          LDR      r5,[r0,#0xa0]
0001a0  4295              CMP      r5,r2
0001a2  da01              BGE      |L1.424|
                  |L1.420|
0001a4  bf00              NOP      
0001a6  bf00              NOP      
                  |L1.424|
0001a8  f8d0609c          LDR      r6,[r0,#0x9c]
0001ac  1b96              SUBS     r6,r2,r6
0001ae  f8d050e4          LDR      r5,[r0,#0xe4]
0001b2  eb0501c6          ADD      r1,r5,r6,LSL #3
0001b6  680a              LDR      r2,[r1,#0]
0001b8  f0227280          BIC      r2,r2,#0x1000000
0001bc  f1027280          ADD      r2,r2,#0x1000000
0001c0  600a              STR      r2,[r1,#0]
;;;344    	T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
0001c2  bf00              NOP      
0001c4  bf00              NOP      
;;;345    	  (TSTR("**>>Block %d marked for retirement" TENDSTR), blockInNAND));
;;;346    
;;;347    	/* TODO:
;;;348    	 * Just do a garbage collection on the affected block
;;;349    	 * then retire the block
;;;350    	 * NB recursion
;;;351    	 */
;;;352    }
0001c6  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP

                  yaffs_ReadChunkFromNAND PROC
;;;178    
;;;179    static int yaffs_ReadChunkFromNAND(struct yaffs_DeviceStruct *dev,
0001c8  e92d4fff          PUSH     {r0-r11,lr}
;;;180    				   int chunkInNAND,
;;;181    				   __u8 * data,
;;;182    				   yaffs_Spare * spare,
;;;183    				   yaffs_ECCResult * eccResult,
;;;184    				   int doErrorCorrection)
;;;185    {
0001cc  b08b              SUB      sp,sp,#0x2c
0001ce  4604              MOV      r4,r0
0001d0  4615              MOV      r5,r2
0001d2  461f              MOV      r7,r3
0001d4  e9dd6b18          LDRD     r6,r11,[sp,#0x60]
;;;186    	int retVal;
;;;187    	yaffs_Spare localSpare;
;;;188    
;;;189    	dev->nPageReads++;
0001d8  f8d40d48          LDR      r0,[r4,#0xd48]
0001dc  1c40              ADDS     r0,r0,#1
0001de  f8c40d48          STR      r0,[r4,#0xd48]
;;;190    
;;;191    	if (!spare && data) {
0001e2  b90f              CBNZ     r7,|L1.488|
0001e4  b105              CBZ      r5,|L1.488|
;;;192    		/* If we don't have a real spare, then we use a local one. */
;;;193    		/* Need this for the calculation of the ecc */
;;;194    		spare = &localSpare;
0001e6  af07              ADD      r7,sp,#0x1c
                  |L1.488|
;;;195    	}
;;;196    
;;;197    	if (!dev->useNANDECC) {
0001e8  6ae0              LDR      r0,[r4,#0x2c]
0001ea  2800              CMP      r0,#0
0001ec  d16d              BNE      |L1.714|
;;;198    		retVal = dev->readChunkFromNAND(dev, chunkInNAND, data, spare);
0001ee  463b              MOV      r3,r7
0001f0  462a              MOV      r2,r5
0001f2  f8d4c03c          LDR      r12,[r4,#0x3c]
0001f6  4620              MOV      r0,r4
0001f8  990c              LDR      r1,[sp,#0x30]
0001fa  47e0              BLX      r12
0001fc  4682              MOV      r10,r0
;;;199    		if (data && doErrorCorrection) {
0001fe  2d00              CMP      r5,#0
                  |L1.512|
000200  d062              BEQ      |L1.712|
000202  f1bb0f00          CMP      r11,#0
000206  d0fb              BEQ      |L1.512|
;;;200    			/* Do ECC correction */
;;;201    			/* Todo handle any errors */
;;;202    			int eccResult1, eccResult2;
;;;203    			__u8 calcEcc[3];
;;;204    
;;;205    			yaffs_ECCCalculate(data, calcEcc);
000208  a906              ADD      r1,sp,#0x18
00020a  4628              MOV      r0,r5
00020c  f7fffffe          BL       yaffs_ECCCalculate
;;;206    			eccResult1 =
000210  aa06              ADD      r2,sp,#0x18
000212  f1070108          ADD      r1,r7,#8
000216  4628              MOV      r0,r5
000218  f7fffffe          BL       yaffs_ECCCorrect
00021c  4680              MOV      r8,r0
;;;207    			    yaffs_ECCCorrect(data, spare->ecc1, calcEcc);
;;;208    			yaffs_ECCCalculate(&data[256], calcEcc);
00021e  a906              ADD      r1,sp,#0x18
000220  f5057080          ADD      r0,r5,#0x100
000224  f7fffffe          BL       yaffs_ECCCalculate
;;;209    			eccResult2 =
000228  aa06              ADD      r2,sp,#0x18
00022a  f107010d          ADD      r1,r7,#0xd
00022e  f5057080          ADD      r0,r5,#0x100
000232  f7fffffe          BL       yaffs_ECCCorrect
000236  4681              MOV      r9,r0
;;;210    			    yaffs_ECCCorrect(&data[256], spare->ecc2, calcEcc);
;;;211    
;;;212    			if (eccResult1 > 0) {
000238  f1b80f00          CMP      r8,#0
00023c  dd07              BLE      |L1.590|
;;;213    				T(YAFFS_TRACE_ERROR,
00023e  bf00              NOP      
000240  bf00              NOP      
;;;214    				  (TSTR
;;;215    				   ("**>>yaffs ecc error fix performed on chunk %d:0"
;;;216    				    TENDSTR), chunkInNAND));
;;;217    				dev->eccFixed++;
000242  f8d40d68          LDR      r0,[r4,#0xd68]
000246  1c40              ADDS     r0,r0,#1
000248  f8c40d68          STR      r0,[r4,#0xd68]
00024c  e009              B        |L1.610|
                  |L1.590|
;;;218    			} else if (eccResult1 < 0) {
00024e  f1b80f00          CMP      r8,#0
000252  da06              BGE      |L1.610|
;;;219    				T(YAFFS_TRACE_ERROR,
000254  bf00              NOP      
000256  bf00              NOP      
;;;220    				  (TSTR
;;;221    				   ("**>>yaffs ecc error unfixed on chunk %d:0"
;;;222    				    TENDSTR), chunkInNAND));
;;;223    				dev->eccUnfixed++;
000258  f8d40d6c          LDR      r0,[r4,#0xd6c]
00025c  1c40              ADDS     r0,r0,#1
00025e  f8c40d6c          STR      r0,[r4,#0xd6c]
                  |L1.610|
;;;224    			}
;;;225    
;;;226    			if (eccResult2 > 0) {
000262  f1b90f00          CMP      r9,#0
000266  dd07              BLE      |L1.632|
;;;227    				T(YAFFS_TRACE_ERROR,
000268  bf00              NOP      
00026a  bf00              NOP      
;;;228    				  (TSTR
;;;229    				   ("**>>yaffs ecc error fix performed on chunk %d:1"
;;;230    				    TENDSTR), chunkInNAND));
;;;231    				dev->eccFixed++;
00026c  f8d40d68          LDR      r0,[r4,#0xd68]
000270  1c40              ADDS     r0,r0,#1
000272  f8c40d68          STR      r0,[r4,#0xd68]
000276  e009              B        |L1.652|
                  |L1.632|
;;;232    			} else if (eccResult2 < 0) {
000278  f1b90f00          CMP      r9,#0
00027c  da06              BGE      |L1.652|
;;;233    				T(YAFFS_TRACE_ERROR,
00027e  bf00              NOP      
000280  bf00              NOP      
;;;234    				  (TSTR
;;;235    				   ("**>>yaffs ecc error unfixed on chunk %d:1"
;;;236    				    TENDSTR), chunkInNAND));
;;;237    				dev->eccUnfixed++;
000282  f8d40d6c          LDR      r0,[r4,#0xd6c]
000286  1c40              ADDS     r0,r0,#1
000288  f8c40d6c          STR      r0,[r4,#0xd6c]
                  |L1.652|
;;;238    			}
;;;239    
;;;240    			if (eccResult1 || eccResult2) {
00028c  f1b80f00          CMP      r8,#0
000290  d102              BNE      |L1.664|
000292  f1b90f00          CMP      r9,#0
000296  d003              BEQ      |L1.672|
                  |L1.664|
;;;241    				/* We had a data problem on this page */
;;;242    				yaffs_HandleReadDataError(dev, chunkInNAND);
000298  4620              MOV      r0,r4
00029a  990c              LDR      r1,[sp,#0x30]
00029c  f7fffffe          BL       yaffs_HandleReadDataError
                  |L1.672|
;;;243    			}
;;;244    
;;;245    			if (eccResult1 < 0 || eccResult2 < 0)
0002a0  f1b80f00          CMP      r8,#0
0002a4  db02              BLT      |L1.684|
0002a6  f1b90f00          CMP      r9,#0
0002aa  da02              BGE      |L1.690|
                  |L1.684|
;;;246    				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
0002ac  2003              MOVS     r0,#3
0002ae  7030              STRB     r0,[r6,#0]
0002b0  e00a              B        |L1.712|
                  |L1.690|
;;;247    			else if (eccResult1 > 0 || eccResult2 > 0)
0002b2  f1b80f00          CMP      r8,#0
0002b6  dc02              BGT      |L1.702|
0002b8  f1b90f00          CMP      r9,#0
0002bc  dd02              BLE      |L1.708|
                  |L1.702|
;;;248    				*eccResult = YAFFS_ECC_RESULT_FIXED;
0002be  2002              MOVS     r0,#2
0002c0  7030              STRB     r0,[r6,#0]
0002c2  e001              B        |L1.712|
                  |L1.708|
;;;249    			else
;;;250    				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
0002c4  2001              MOVS     r0,#1
0002c6  7030              STRB     r0,[r6,#0]
                  |L1.712|
;;;251    		}
0002c8  e045              B        |L1.854|
                  |L1.714|
;;;252    	} else {
;;;253    		/* Must allocate enough memory for spare+2*sizeof(int) */
;;;254    		/* for ecc results from device. */
;;;255    		struct yaffs_NANDSpare nspare;
;;;256    		
;;;257    		memset(&nspare,0,sizeof(nspare));
0002ca  2118              MOVS     r1,#0x18
0002cc  a801              ADD      r0,sp,#4
0002ce  f7fffffe          BL       __aeabi_memclr4
;;;258    		
;;;259    		retVal =
0002d2  ab01              ADD      r3,sp,#4
0002d4  462a              MOV      r2,r5
0002d6  f8d4c03c          LDR      r12,[r4,#0x3c]
0002da  4620              MOV      r0,r4
0002dc  990c              LDR      r1,[sp,#0x30]
0002de  47e0              BLX      r12
0002e0  4682              MOV      r10,r0
;;;260    		    dev->readChunkFromNAND(dev, chunkInNAND, data,
;;;261    					   (yaffs_Spare *) & nspare);
;;;262    		memcpy(spare, &nspare, sizeof(yaffs_Spare));
0002e2  2210              MOVS     r2,#0x10
0002e4  a901              ADD      r1,sp,#4
0002e6  4638              MOV      r0,r7
0002e8  f7fffffe          BL       __aeabi_memcpy
;;;263    		if (data && doErrorCorrection) {
0002ec  b335              CBZ      r5,|L1.828|
0002ee  f1bb0f00          CMP      r11,#0
0002f2  d02f              BEQ      |L1.852|
;;;264    			if (nspare.eccres1 > 0) {
0002f4  9805              LDR      r0,[sp,#0x14]
0002f6  2800              CMP      r0,#0
0002f8  dd01              BLE      |L1.766|
;;;265    				T(YAFFS_TRACE_ERROR,
0002fa  bf00              NOP      
0002fc  e004              B        |L1.776|
                  |L1.766|
;;;266    				  (TSTR
;;;267    				   ("**>>mtd ecc error fix performed on chunk %d:0"
;;;268    				    TENDSTR), chunkInNAND));
;;;269    			} else if (nspare.eccres1 < 0) {
0002fe  9805              LDR      r0,[sp,#0x14]
000300  2800              CMP      r0,#0
000302  da01              BGE      |L1.776|
;;;270    				T(YAFFS_TRACE_ERROR,
000304  bf00              NOP      
000306  bf00              NOP      
                  |L1.776|
;;;271    				  (TSTR
;;;272    				   ("**>>mtd ecc error unfixed on chunk %d:0"
;;;273    				    TENDSTR), chunkInNAND));
;;;274    			}
;;;275    
;;;276    			if (nspare.eccres2 > 0) {
000308  9806              LDR      r0,[sp,#0x18]
00030a  2800              CMP      r0,#0
00030c  dd01              BLE      |L1.786|
;;;277    				T(YAFFS_TRACE_ERROR,
00030e  bf00              NOP      
000310  e004              B        |L1.796|
                  |L1.786|
;;;278    				  (TSTR
;;;279    				   ("**>>mtd ecc error fix performed on chunk %d:1"
;;;280    				    TENDSTR), chunkInNAND));
;;;281    			} else if (nspare.eccres2 < 0) {
000312  9806              LDR      r0,[sp,#0x18]
000314  2800              CMP      r0,#0
000316  da01              BGE      |L1.796|
;;;282    				T(YAFFS_TRACE_ERROR,
000318  bf00              NOP      
00031a  bf00              NOP      
                  |L1.796|
;;;283    				  (TSTR
;;;284    				   ("**>>mtd ecc error unfixed on chunk %d:1"
;;;285    				    TENDSTR), chunkInNAND));
;;;286    			}
;;;287    
;;;288    			if (nspare.eccres1 || nspare.eccres2) {
00031c  9805              LDR      r0,[sp,#0x14]
00031e  b908              CBNZ     r0,|L1.804|
000320  9806              LDR      r0,[sp,#0x18]
000322  b118              CBZ      r0,|L1.812|
                  |L1.804|
;;;289    				/* We had a data problem on this page */
;;;290    				yaffs_HandleReadDataError(dev, chunkInNAND);
000324  4620              MOV      r0,r4
000326  990c              LDR      r1,[sp,#0x30]
000328  f7fffffe          BL       yaffs_HandleReadDataError
                  |L1.812|
;;;291    			}
;;;292    
;;;293    			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
00032c  9805              LDR      r0,[sp,#0x14]
00032e  2800              CMP      r0,#0
000330  db02              BLT      |L1.824|
000332  9806              LDR      r0,[sp,#0x18]
000334  2800              CMP      r0,#0
000336  da02              BGE      |L1.830|
                  |L1.824|
;;;294    				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
000338  2003              MOVS     r0,#3
00033a  7030              STRB     r0,[r6,#0]
                  |L1.828|
00033c  e00a              B        |L1.852|
                  |L1.830|
;;;295    			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
00033e  9805              LDR      r0,[sp,#0x14]
000340  2800              CMP      r0,#0
000342  dc02              BGT      |L1.842|
000344  9806              LDR      r0,[sp,#0x18]
000346  2800              CMP      r0,#0
000348  dd02              BLE      |L1.848|
                  |L1.842|
;;;296    				*eccResult = YAFFS_ECC_RESULT_FIXED;
00034a  2002              MOVS     r0,#2
00034c  7030              STRB     r0,[r6,#0]
00034e  e001              B        |L1.852|
                  |L1.848|
;;;297    			else
;;;298    				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
000350  2001              MOVS     r0,#1
000352  7030              STRB     r0,[r6,#0]
                  |L1.852|
;;;299    
;;;300    		}
;;;301    	}
000354  bf00              NOP      
                  |L1.854|
;;;302    	return retVal;
000356  4650              MOV      r0,r10
;;;303    }
000358  b00f              ADD      sp,sp,#0x3c
00035a  e8bd8ff0          POP      {r4-r11,pc}
;;;304    
                          ENDP

                  yaffs_TagsCompatabilityWriteChunkWithTagsToNAND PROC
;;;404    
;;;405    int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,
00035e  b5f0              PUSH     {r4-r7,lr}
;;;406    						    int chunkInNAND,
;;;407    						    const __u8 * data,
;;;408    						    const yaffs_ExtendedTags *
;;;409    						    eTags)
;;;410    {
000360  b087              SUB      sp,sp,#0x1c
000362  4605              MOV      r5,r0
000364  460f              MOV      r7,r1
000366  4616              MOV      r6,r2
000368  461c              MOV      r4,r3
;;;411    	yaffs_Spare spare;
;;;412    	yaffs_Tags tags;
;;;413    
;;;414    	yaffs_SpareInitialise(&spare);
00036a  a803              ADD      r0,sp,#0xc
00036c  f7fffffe          BL       yaffs_SpareInitialise
;;;415    
;;;416    	if (eTags->chunkDeleted) {
000370  69e0              LDR      r0,[r4,#0x1c]
000372  b118              CBZ      r0,|L1.892|
;;;417    		spare.pageStatus = 0;
000374  2000              MOVS     r0,#0
000376  f88d0010          STRB     r0,[sp,#0x10]
00037a  e030              B        |L1.990|
                  |L1.892|
;;;418    	} else {
;;;419    		tags.objectId = eTags->objectId;
00037c  68a1              LDR      r1,[r4,#8]
00037e  9802              LDR      r0,[sp,#8]
000380  f3610011          BFI      r0,r1,#0,#18
000384  9002              STR      r0,[sp,#8]
;;;420    		tags.chunkId = eTags->chunkId;
000386  68e1              LDR      r1,[r4,#0xc]
000388  9801              LDR      r0,[sp,#4]
00038a  f3610013          BFI      r0,r1,#0,#20
00038e  9001              STR      r0,[sp,#4]
;;;421    
;;;422    		tags.byteCountLSB = eTags->byteCount & 0x3ff;
000390  8a20              LDRH     r0,[r4,#0x10]
000392  9901              LDR      r1,[sp,#4]
000394  f360519f          BFI      r1,r0,#22,#10
000398  9101              STR      r1,[sp,#4]
;;;423    		
;;;424    		if(dev->nDataBytesPerChunk >= 1024){
00039a  68e8              LDR      r0,[r5,#0xc]
00039c  f5b06f80          CMP      r0,#0x400
0003a0  db06              BLT      |L1.944|
;;;425    			tags.byteCountMSB = (eTags->byteCount >> 10) & 3;
0003a2  8a20              LDRH     r0,[r4,#0x10]
0003a4  0a81              LSRS     r1,r0,#10
0003a6  9802              LDR      r0,[sp,#8]
0003a8  f361709f          BFI      r0,r1,#30,#2
0003ac  9002              STR      r0,[sp,#8]
0003ae  e005              B        |L1.956|
                  |L1.944|
;;;426    		} else {
;;;427    			tags.byteCountMSB = 3;
0003b0  9802              LDR      r0,[sp,#8]
0003b2  f0204040          BIC      r0,r0,#0xc0000000
0003b6  f1a04080          SUB      r0,r0,#0x40000000
0003ba  9002              STR      r0,[sp,#8]
                  |L1.956|
;;;428    		}
;;;429    		
;;;430    
;;;431    		tags.serialNumber = eTags->serialNumber;
0003bc  f8941020          LDRB     r1,[r4,#0x20]
0003c0  9801              LDR      r0,[sp,#4]
0003c2  f3615015          BFI      r0,r1,#20,#2
0003c6  9001              STR      r0,[sp,#4]
;;;432    
;;;433    		if (!dev->useNANDECC && data) {
0003c8  6ae8              LDR      r0,[r5,#0x2c]
0003ca  b920              CBNZ     r0,|L1.982|
0003cc  b11e              CBZ      r6,|L1.982|
;;;434    			yaffs_CalcECC(data, &spare);
0003ce  a903              ADD      r1,sp,#0xc
0003d0  4630              MOV      r0,r6
0003d2  f7fffffe          BL       yaffs_CalcECC
                  |L1.982|
;;;435    		}
;;;436    		yaffs_LoadTagsIntoSpare(&spare, &tags);
0003d6  a901              ADD      r1,sp,#4
0003d8  a803              ADD      r0,sp,#0xc
0003da  f7fffffe          BL       yaffs_LoadTagsIntoSpare
                  |L1.990|
;;;437    
;;;438    	}
;;;439    
;;;440    	return yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);
0003de  ab03              ADD      r3,sp,#0xc
0003e0  4632              MOV      r2,r6
0003e2  4639              MOV      r1,r7
0003e4  4628              MOV      r0,r5
0003e6  f7fffffe          BL       yaffs_WriteChunkToNAND
;;;441    }
0003ea  b007              ADD      sp,sp,#0x1c
0003ec  bdf0              POP      {r4-r7,pc}
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      yaffs_countBitsTable
                          ENDP

                  yaffs_TagsCompatabilityReadChunkWithTagsFromNAND PROC
;;;442    
;;;443    int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,
0003f4  e92d41f0          PUSH     {r4-r8,lr}
;;;444    						     int chunkInNAND,
;;;445    						     __u8 * data,
;;;446    						     yaffs_ExtendedTags * eTags)
;;;447    {
0003f8  b08a              SUB      sp,sp,#0x28
0003fa  4605              MOV      r5,r0
0003fc  460e              MOV      r6,r1
0003fe  4617              MOV      r7,r2
000400  461c              MOV      r4,r3
;;;448    
;;;449    	yaffs_Spare spare;
;;;450    	yaffs_Tags tags;
;;;451    	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_UNKNOWN;
000402  2000              MOVS     r0,#0
000404  9003              STR      r0,[sp,#0xc]
;;;452    
;;;453    	static yaffs_Spare spareFF;
;;;454    	static int init = 0;
;;;455    
;;;456    	if (!init) {
000406  485f              LDR      r0,|L1.1412|
000408  6800              LDR      r0,[r0,#0]  ; init
00040a  b938              CBNZ     r0,|L1.1052|
;;;457    		memset(&spareFF, 0xFF, sizeof(spareFF));
00040c  22ff              MOVS     r2,#0xff
00040e  2110              MOVS     r1,#0x10
000410  485d              LDR      r0,|L1.1416|
000412  f7fffffe          BL       __aeabi_memset
;;;458    		init = 1;
000416  2001              MOVS     r0,#1
000418  495a              LDR      r1,|L1.1412|
00041a  6008              STR      r0,[r1,#0]  ; init
                  |L1.1052|
;;;459    	}
;;;460    
;;;461    	if (yaffs_ReadChunkFromNAND
00041c  2001              MOVS     r0,#1
00041e  a903              ADD      r1,sp,#0xc
000420  ab06              ADD      r3,sp,#0x18
000422  463a              MOV      r2,r7
000424  e9cd1000          STRD     r1,r0,[sp,#0]
000428  4631              MOV      r1,r6
00042a  4628              MOV      r0,r5
00042c  f7fffffe          BL       yaffs_ReadChunkFromNAND
000430  2800              CMP      r0,#0
000432  d041              BEQ      |L1.1208|
;;;462    	    (dev, chunkInNAND, data, &spare, &eccResult, 1)) {
;;;463    		/* eTags may be NULL */
;;;464    		if (eTags) {
000434  2c00              CMP      r4,#0
000436  d03b              BEQ      |L1.1200|
;;;465    
;;;466    			int deleted =
000438  f89d001c          LDRB     r0,[sp,#0x1c]
00043c  f7fffffe          BL       yaffs_CountBits
000440  2807              CMP      r0,#7
000442  da01              BGE      |L1.1096|
;;;467    			    (yaffs_CountBits(spare.pageStatus) < 7) ? 1 : 0;
000444  2001              MOVS     r0,#1
000446  e000              B        |L1.1098|
                  |L1.1096|
000448  2000              MOVS     r0,#0
                  |L1.1098|
00044a  4680              MOV      r8,r0
;;;468    
;;;469    			eTags->chunkDeleted = deleted;
00044c  f8c4801c          STR      r8,[r4,#0x1c]
;;;470    			eTags->eccResult = eccResult;
000450  f89d000c          LDRB     r0,[sp,#0xc]
000454  7520              STRB     r0,[r4,#0x14]
;;;471    			eTags->blockBad = 0;	/* We're reading it */
000456  2000              MOVS     r0,#0
000458  61a0              STR      r0,[r4,#0x18]
;;;472    			/* therefore it is not a bad block */
;;;473    			eTags->chunkUsed =
00045a  2210              MOVS     r2,#0x10
00045c  a906              ADD      r1,sp,#0x18
00045e  484a              LDR      r0,|L1.1416|
000460  f7fffffe          BL       memcmp
000464  b108              CBZ      r0,|L1.1130|
;;;474    			    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=
;;;475    			     0) ? 1 : 0;
000466  2001              MOVS     r0,#1
000468  e000              B        |L1.1132|
                  |L1.1130|
00046a  2000              MOVS     r0,#0
                  |L1.1132|
00046c  6060              STR      r0,[r4,#4]
;;;476    
;;;477    			if (eTags->chunkUsed) {
00046e  6860              LDR      r0,[r4,#4]
000470  b1e8              CBZ      r0,|L1.1198|
;;;478    				yaffs_GetTagsFromSpare(dev, &spare, &tags);
000472  aa04              ADD      r2,sp,#0x10
000474  a906              ADD      r1,sp,#0x18
000476  4628              MOV      r0,r5
000478  f7fffffe          BL       yaffs_GetTagsFromSpare
;;;479    
;;;480    				eTags->objectId = tags.objectId;
00047c  9805              LDR      r0,[sp,#0x14]
00047e  f3c00011          UBFX     r0,r0,#0,#18
000482  60a0              STR      r0,[r4,#8]
;;;481    				eTags->chunkId = tags.chunkId;
000484  9804              LDR      r0,[sp,#0x10]
000486  f3c00013          UBFX     r0,r0,#0,#20
00048a  60e0              STR      r0,[r4,#0xc]
;;;482    				eTags->byteCount = tags.byteCountLSB;
00048c  9804              LDR      r0,[sp,#0x10]
00048e  0d80              LSRS     r0,r0,#22
000490  6120              STR      r0,[r4,#0x10]
;;;483    
;;;484    				if(dev->nDataBytesPerChunk >= 1024)
000492  68e8              LDR      r0,[r5,#0xc]
000494  f5b06f80          CMP      r0,#0x400
000498  db05              BLT      |L1.1190|
;;;485    					eTags->byteCount |= (((unsigned) tags.byteCountMSB) << 10);
00049a  6920              LDR      r0,[r4,#0x10]
00049c  9905              LDR      r1,[sp,#0x14]
00049e  0f89              LSRS     r1,r1,#30
0004a0  ea402081          ORR      r0,r0,r1,LSL #10
0004a4  6120              STR      r0,[r4,#0x10]
                  |L1.1190|
;;;486    
;;;487    				eTags->serialNumber = tags.serialNumber;
0004a6  9804              LDR      r0,[sp,#0x10]
0004a8  f3c05001          UBFX     r0,r0,#20,#2
0004ac  6220              STR      r0,[r4,#0x20]
                  |L1.1198|
;;;488    			}
;;;489    		}
0004ae  bf00              NOP      
                  |L1.1200|
;;;490    
;;;491    		return YAFFS_OK;
0004b0  2001              MOVS     r0,#1
                  |L1.1202|
;;;492    	} else {
;;;493    		return YAFFS_FAIL;
;;;494    	}
;;;495    }
0004b2  b00a              ADD      sp,sp,#0x28
0004b4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1208|
0004b8  2000              MOVS     r0,#0                 ;493
0004ba  e7fa              B        |L1.1202|
;;;496    
                          ENDP

                  yaffs_TagsCompatabilityMarkNANDBlockBad PROC
;;;497    int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
0004bc  b57f              PUSH     {r0-r6,lr}
;;;498    					    int blockInNAND)
;;;499    {
0004be  4604              MOV      r4,r0
0004c0  460d              MOV      r5,r1
;;;500    
;;;501    	yaffs_Spare spare;
;;;502    
;;;503    	memset(&spare, 0xff, sizeof(yaffs_Spare));
0004c2  22ff              MOVS     r2,#0xff
0004c4  2110              MOVS     r1,#0x10
0004c6  4668              MOV      r0,sp
0004c8  f7fffffe          BL       __aeabi_memset
;;;504    
;;;505    	spare.blockStatus = 'Y';
0004cc  2059              MOVS     r0,#0x59
0004ce  f88d0005          STRB     r0,[sp,#5]
;;;506    
;;;507    	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock, NULL,
0004d2  6920              LDR      r0,[r4,#0x10]
0004d4  fb00f105          MUL      r1,r0,r5
0004d8  466b              MOV      r3,sp
0004da  2200              MOVS     r2,#0
0004dc  4620              MOV      r0,r4
0004de  f7fffffe          BL       yaffs_WriteChunkToNAND
;;;508    			       &spare);
;;;509    	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock + 1,
0004e2  6920              LDR      r0,[r4,#0x10]
0004e4  4368              MULS     r0,r5,r0
0004e6  1c41              ADDS     r1,r0,#1
0004e8  466b              MOV      r3,sp
0004ea  2200              MOVS     r2,#0
0004ec  4620              MOV      r0,r4
0004ee  f7fffffe          BL       yaffs_WriteChunkToNAND
;;;510    			       NULL, &spare);
;;;511    
;;;512    	return YAFFS_OK;
0004f2  2001              MOVS     r0,#1
;;;513    
;;;514    }
0004f4  b004              ADD      sp,sp,#0x10
0004f6  bd70              POP      {r4-r6,pc}
;;;515    
                          ENDP

                  yaffs_TagsCompatabilityQueryNANDBlock PROC
;;;516    int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
0004f8  b5f0              PUSH     {r4-r7,lr}
;;;517    					  int blockNo,
;;;518    					  yaffs_BlockState *state,
;;;519    					  __u32 *sequenceNumber)
;;;520    {
0004fa  b08b              SUB      sp,sp,#0x2c
0004fc  4605              MOV      r5,r0
0004fe  460e              MOV      r6,r1
000500  4614              MOV      r4,r2
000502  461f              MOV      r7,r3
;;;521    
;;;522    	yaffs_Spare spare0, spare1;
;;;523    	static yaffs_Spare spareFF;
;;;524    	static int init;
;;;525    	yaffs_ECCResult dummy;
;;;526    
;;;527    	if (!init) {
000504  4821              LDR      r0,|L1.1420|
000506  6800              LDR      r0,[r0,#0]  ; init
000508  b938              CBNZ     r0,|L1.1306|
;;;528    		memset(&spareFF, 0xFF, sizeof(spareFF));
00050a  22ff              MOVS     r2,#0xff
00050c  2110              MOVS     r1,#0x10
00050e  4820              LDR      r0,|L1.1424|
000510  f7fffffe          BL       __aeabi_memset
;;;529    		init = 1;
000514  2001              MOVS     r0,#1
000516  491d              LDR      r1,|L1.1420|
000518  6008              STR      r0,[r1,#0]  ; init
                  |L1.1306|
;;;530    	}
;;;531    
;;;532    	*sequenceNumber = 0;
00051a  2000              MOVS     r0,#0
00051c  6038              STR      r0,[r7,#0]
;;;533    
;;;534    	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock, NULL,
00051e  2001              MOVS     r0,#1
000520  a902              ADD      r1,sp,#8
000522  e9cd1000          STRD     r1,r0,[sp,#0]
000526  6928              LDR      r0,[r5,#0x10]
000528  fb00f106          MUL      r1,r0,r6
00052c  ab07              ADD      r3,sp,#0x1c
00052e  2200              MOVS     r2,#0
000530  4628              MOV      r0,r5
000532  f7fffffe          BL       yaffs_ReadChunkFromNAND
;;;535    				&spare0, &dummy, 1);
;;;536    	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock + 1, NULL,
000536  2001              MOVS     r0,#1
000538  a902              ADD      r1,sp,#8
00053a  e9cd1000          STRD     r1,r0,[sp,#0]
00053e  6928              LDR      r0,[r5,#0x10]
000540  4370              MULS     r0,r6,r0
000542  1c41              ADDS     r1,r0,#1
000544  ab03              ADD      r3,sp,#0xc
000546  2200              MOVS     r2,#0
000548  4628              MOV      r0,r5
00054a  f7fffffe          BL       yaffs_ReadChunkFromNAND
;;;537    				&spare1, &dummy, 1);
;;;538    
;;;539    	if (yaffs_CountBits(spare0.blockStatus & spare1.blockStatus) < 7)
00054e  f89d1021          LDRB     r1,[sp,#0x21]
000552  f89d2011          LDRB     r2,[sp,#0x11]
000556  ea010002          AND      r0,r1,r2
00055a  f7fffffe          BL       yaffs_CountBits
00055e  2807              CMP      r0,#7
000560  da02              BGE      |L1.1384|
;;;540    		*state = YAFFS_BLOCK_STATE_DEAD;
000562  2009              MOVS     r0,#9
000564  7020              STRB     r0,[r4,#0]
000566  e00a              B        |L1.1406|
                  |L1.1384|
;;;541    	else if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)
000568  2210              MOVS     r2,#0x10
00056a  a907              ADD      r1,sp,#0x1c
00056c  4808              LDR      r0,|L1.1424|
00056e  f7fffffe          BL       memcmp
000572  b910              CBNZ     r0,|L1.1402|
;;;542    		*state = YAFFS_BLOCK_STATE_EMPTY;
000574  2003              MOVS     r0,#3
000576  7020              STRB     r0,[r4,#0]
000578  e001              B        |L1.1406|
                  |L1.1402|
;;;543    	else
;;;544    		*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
00057a  2002              MOVS     r0,#2
00057c  7020              STRB     r0,[r4,#0]
                  |L1.1406|
;;;545    
;;;546    	return YAFFS_OK;
00057e  2001              MOVS     r0,#1
;;;547    }
000580  b00b              ADD      sp,sp,#0x2c
000582  bdf0              POP      {r4-r7,pc}
                          ENDP

                  |L1.1412|
                          DCD      init
                  |L1.1416|
                          DCD      spareFF
                  |L1.1420|
                          DCD      |symbol_number.15|
                  |L1.1424|
                          DCD      |symbol_number.12|

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  spareFF
                          %        16
                  |symbol_number.12|
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  yaffs_countBitsTable
000000  00010102          DCB      0x00,0x01,0x01,0x02
000004  01020203          DCB      0x01,0x02,0x02,0x03
000008  01020203          DCB      0x01,0x02,0x02,0x03
00000c  02030304          DCB      0x02,0x03,0x03,0x04
000010  01020203          DCB      0x01,0x02,0x02,0x03
000014  02030304          DCB      0x02,0x03,0x03,0x04
000018  02030304          DCB      0x02,0x03,0x03,0x04
00001c  03040405          DCB      0x03,0x04,0x04,0x05
000020  01020203          DCB      0x01,0x02,0x02,0x03
000024  02030304          DCB      0x02,0x03,0x03,0x04
000028  02030304          DCB      0x02,0x03,0x03,0x04
00002c  03040405          DCB      0x03,0x04,0x04,0x05
000030  02030304          DCB      0x02,0x03,0x03,0x04
000034  03040405          DCB      0x03,0x04,0x04,0x05
000038  03040405          DCB      0x03,0x04,0x04,0x05
00003c  04050506          DCB      0x04,0x05,0x05,0x06
000040  01020203          DCB      0x01,0x02,0x02,0x03
000044  02030304          DCB      0x02,0x03,0x03,0x04
000048  02030304          DCB      0x02,0x03,0x03,0x04
00004c  03040405          DCB      0x03,0x04,0x04,0x05
000050  02030304          DCB      0x02,0x03,0x03,0x04
000054  03040405          DCB      0x03,0x04,0x04,0x05
000058  03040405          DCB      0x03,0x04,0x04,0x05
00005c  04050506          DCB      0x04,0x05,0x05,0x06
000060  02030304          DCB      0x02,0x03,0x03,0x04
000064  03040405          DCB      0x03,0x04,0x04,0x05
000068  03040405          DCB      0x03,0x04,0x04,0x05
00006c  04050506          DCB      0x04,0x05,0x05,0x06
000070  03040405          DCB      0x03,0x04,0x04,0x05
000074  04050506          DCB      0x04,0x05,0x05,0x06
000078  04050506          DCB      0x04,0x05,0x05,0x06
00007c  05060607          DCB      0x05,0x06,0x06,0x07
000080  01020203          DCB      0x01,0x02,0x02,0x03
000084  02030304          DCB      0x02,0x03,0x03,0x04
000088  02030304          DCB      0x02,0x03,0x03,0x04
00008c  03040405          DCB      0x03,0x04,0x04,0x05
000090  02030304          DCB      0x02,0x03,0x03,0x04
000094  03040405          DCB      0x03,0x04,0x04,0x05
000098  03040405          DCB      0x03,0x04,0x04,0x05
00009c  04050506          DCB      0x04,0x05,0x05,0x06
0000a0  02030304          DCB      0x02,0x03,0x03,0x04
0000a4  03040405          DCB      0x03,0x04,0x04,0x05
0000a8  03040405          DCB      0x03,0x04,0x04,0x05
0000ac  04050506          DCB      0x04,0x05,0x05,0x06
0000b0  03040405          DCB      0x03,0x04,0x04,0x05
0000b4  04050506          DCB      0x04,0x05,0x05,0x06
0000b8  04050506          DCB      0x04,0x05,0x05,0x06
0000bc  05060607          DCB      0x05,0x06,0x06,0x07
0000c0  02030304          DCB      0x02,0x03,0x03,0x04
0000c4  03040405          DCB      0x03,0x04,0x04,0x05
0000c8  03040405          DCB      0x03,0x04,0x04,0x05
0000cc  04050506          DCB      0x04,0x05,0x05,0x06
0000d0  03040405          DCB      0x03,0x04,0x04,0x05
0000d4  04050506          DCB      0x04,0x05,0x05,0x06
0000d8  04050506          DCB      0x04,0x05,0x05,0x06
0000dc  05060607          DCB      0x05,0x06,0x06,0x07
0000e0  03040405          DCB      0x03,0x04,0x04,0x05
0000e4  04050506          DCB      0x04,0x05,0x05,0x06
0000e8  04050506          DCB      0x04,0x05,0x05,0x06
0000ec  05060607          DCB      0x05,0x06,0x06,0x07
0000f0  04050506          DCB      0x04,0x05,0x05,0x06
0000f4  05060607          DCB      0x05,0x06,0x06,0x07
0000f8  05060607          DCB      0x05,0x06,0x06,0x07
0000fc  06070708          DCB      0x06,0x07,0x07,0x08

                          AREA ||.data||, DATA, ALIGN=2

                  init
                          DCD      0x00000000
                  |symbol_number.15|
                          DCD      0x00000000

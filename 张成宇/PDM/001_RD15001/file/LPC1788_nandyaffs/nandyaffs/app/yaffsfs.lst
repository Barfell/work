L 1 "..\fs\yaffsfs.c"
N/*
N * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N */
N
N#include "yaffsfs.h"
L 1 "..\fs\yaffsfs.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * Header file for using yaffs in an application via
N * a direct interface.
N */
N
N
N#ifndef __YAFFSFS_H__
N#define __YAFFSFS_H__
N
N#include "yaffscfg.h"
L 1 "..\fs\yaffscfg.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * Header file for using yaffs in an application via
N * a direct interface.
N */
N
N
N#ifndef __YAFFSCFG_H__
N#define __YAFFSCFG_H__
N
N
N#include "yportenv.h"
L 1 "..\fs\yportenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N
N#ifndef __YPORTENV_H__
N#define __YPORTENV_H__
N
N//#include "2440lib.h"
N//#include <stdio.h>
N
N#define CONFIG_YAFFS_DIRECT
N/*
N * Define the MTD version in terms of Linux Kernel versions
N * This allows yaffs to be used independantly of the kernel
N * as well as with it.
N */
Ntypedef int off_t;
Ntypedef int dev_t;
Ntypedef unsigned int mode_t;
Ntypedef unsigned long loff_t;
N
N#define MTD_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
N
N#if defined CONFIG_YAFFS_WINCE
X#if 0L
S
S#include "ywinceenv.h"
S
S#elif  defined __KERNEL__
X#elif  0L
S
S#include "moduleconfig.h"
S
S/* Linux kernel */
S
S#include <linux/version.h>
S#define MTD_VERSION_CODE LINUX_VERSION_CODE
S
S#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
S#include <linux/config.h>
S#endif
S#include <linux/kernel.h>
S#include <linux/mm.h>
S#include <linux/sched.h>
S#include <linux/string.h>
S#include <linux/slab.h>
S#include <linux/vmalloc.h>
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S
S/* #define YPRINTF(x) printk x */
S#define YMALLOC(x) kmalloc(x,GFP_NOFS)
S#define YFREE(x)   kfree(x)
S#define YMALLOC_ALT(x) vmalloc(x)
S#define YFREE_ALT(x)   vfree(x)
S#define YMALLOC_DMA(x) YMALLOC(x)
S
S// KR - added for use in scan so processes aren't blocked indefinitely.
S#define YYIELD() schedule()
S
S#define YAFFS_ROOT_MODE			0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
S#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
S#define Y_TIME_CONVERT(x) (x).tv_sec
S#else
S#define Y_CURRENT_TIME CURRENT_TIME
S#define Y_TIME_CONVERT(x) (x)
S#endif
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#define TENDSTR "\n"
S#define TSTR(x) KERN_WARNING x
S#define TCONT(x) x
S#define TOUT(p) printk p
S
S#define yaffs_trace(mask, fmt, args...) \
S	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \
S		printk(KERN_WARNING "yaffs: " fmt, ## args); \
S	} while (0)
X#define yaffs_trace(mask, fmt, args...) 	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) 		printk(KERN_WARNING "yaffs: " fmt, ## args); 	} while (0)
S
S#define compile_time_assertion(assertion) \
S	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
X#define compile_time_assertion(assertion) 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
S
N#elif defined CONFIG_YAFFS_DIRECT
X#elif 1L
N
N#define MTD_VERSION_CODE MTD_VERSION(2,6,22)
N
N/* Direct interface */
N#include "ydirectenv.h"
L 1 "..\fs\ydirectenv.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * ydirectenv.h: Environment wrappers for YAFFS direct.
N */
N
N#ifndef __YDIRECTENV_H__
N#define __YDIRECTENV_H__
N
N// Direct interface
N
N#include "devextras.h"
L 1 "..\fs\devextras.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * This file is just holds extra declarations of macros that would normally
N * be providesd in the Linux kernel. These macros have been written from
N * scratch but are functionally equivalent to the Linux ones.
N *
N */
N
N
N
N#ifndef __EXTRAS_H__
N#define __EXTRAS_H__
N#define    __inline__    __inline
N
N#define  CONFIG_YAFFS_PROVIDE_DEFS
N
N#if !(defined __KERNEL__) 
X#if !(0L) 
N
N/* Definition of types */
Ntypedef unsigned char __u8;
Ntypedef unsigned short __u16;
Ntypedef unsigned __u32;
N
N#endif
N
N/*
N * This is a simple doubly linked list implementation that matches the 
N * way the Linux kernel doubly linked list implementation works.
N */
N
Nstruct ylist_head {
N	struct ylist_head *next; /* next in chain */
N	struct ylist_head *prev; /* previous in chain */
N};
N
N
N/* Initialise a static list */
N#define YLIST_HEAD(name) \
Nstruct ylist_head name = { &(name),&(name)}
X#define YLIST_HEAD(name) struct ylist_head name = { &(name),&(name)}
N
N
N
N/* Initialise a list head to an empty list */
N#define YINIT_LIST_HEAD(p) \
Ndo { \
N (p)->next = (p);\
N (p)->prev = (p); \
N} while(0)
X#define YINIT_LIST_HEAD(p) do {  (p)->next = (p); (p)->prev = (p); } while(0)
N
N
N/* Add an element to a list */
Nstatic __inline__ void ylist_add(struct ylist_head *newEntry, 
Xstatic __inline void ylist_add(struct ylist_head *newEntry, 
N                                 struct ylist_head *list)
N{
N        struct ylist_head *listNext = list->next;
N        
N        list->next = newEntry;
N        newEntry->prev = list;
N	newEntry->next = listNext;
N	listNext->prev = newEntry;
N	
N}
N
Nstatic __inline__ void ylist_add_tail(struct ylist_head *newEntry, 
Xstatic __inline void ylist_add_tail(struct ylist_head *newEntry, 
N				 struct ylist_head *list)
N{
N	struct ylist_head *listPrev = list->prev;
N	
N	list->prev = newEntry;
N	newEntry->next = list;
N	newEntry->prev = listPrev;
N	listPrev->next = newEntry;
N	
N}
N
N
N/* Take an element out of its current list, with or without
N * reinitialising the links.of the entry*/
Nstatic __inline__ void ylist_del(struct ylist_head *entry)
Xstatic __inline void ylist_del(struct ylist_head *entry)
N{
N        struct ylist_head *listNext = entry->next;
N        struct ylist_head *listPrev = entry->prev;
N        
N        listNext->prev = listPrev;
N        listPrev->next = listNext;
N        
N}
N
Nstatic __inline__ void ylist_del_init(struct ylist_head *entry)
Xstatic __inline void ylist_del_init(struct ylist_head *entry)
N{
N        ylist_del(entry);
N        entry->next = entry->prev = entry;
N}
N
N
N/* Test if the list is empty */
Nstatic __inline__ int ylist_empty(struct ylist_head *entry)
Xstatic __inline int ylist_empty(struct ylist_head *entry)
N{
N        return (entry->next == entry);
N}
N
N
N/* ylist_entry takes a pointer to a list entry and offsets it to that
N * we can find a pointer to the object it is embedded in.
N */
N 
N 
N#define ylist_entry(entry, type, member) \
N        ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
X#define ylist_entry(entry, type, member)         ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
N
N
N/* ylist_for_each and list_for_each_safe  iterate over lists.
N * ylist_for_each_safe uses temporary storage to make the list delete safe
N */
N
N#define ylist_for_each(itervar, list) \
N        for (itervar = (list)->next; itervar != (list); itervar = itervar->next )
X#define ylist_for_each(itervar, list)         for (itervar = (list)->next; itervar != (list); itervar = itervar->next )
N
N#define ylist_for_each_safe(itervar,saveVar, list) \
N        for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list); \
N         itervar = saveVar, saveVar = saveVar->next)
X#define ylist_for_each_safe(itervar,saveVar, list)         for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list);          itervar = saveVar, saveVar = saveVar->next)
N
N
N#if !(defined __KERNEL__)
X#if !(0L)
N
N
N#ifdef WIN32
S#include <sys/stat.h>
N#endif
N
N
N#ifdef CONFIG_YAFFS_PROVIDE_DEFS
N/* File types */
N
N
N#define DT_UNKNOWN      0
N#define DT_FIFO         1
N#define DT_CHR          2
N#define DT_DIR		4
N#define DT_BLK		6
N#define DT_REG          8
N#define DT_LNK          10
N#define DT_SOCK         12
N#define DT_WHT          14
N
N
N#ifdef WIN32
S#include <sys/stat.h>
N#endif
N
N/*
N * Attribute flags.  These should be or-ed together to figure out what
N * has been changed!
N */
N#define ATTR_MODE       1
N#define ATTR_UID        2
N#define ATTR_GID	4
N#define ATTR_SIZE	8
N#define ATTR_ATIME	16
N#define ATTR_MTIME	32
N#define ATTR_CTIME	64
N
Nstruct iattr {
N	unsigned int ia_valid;
N	unsigned ia_mode;
N	unsigned ia_uid;
N	unsigned ia_gid;
N	unsigned ia_size;
N	unsigned ia_atime;
N	unsigned ia_mtime;
N	unsigned ia_ctime;
N        unsigned int ia_attr_flags;
N};
N
N#endif
N
N
N#define KERN_DEBUG
N
N#else
S
S#include <linux/types.h>
S#include <linux/fs.h>
S#include <linux/stat.h>
S
N#endif
N
N
N#endif
L 26 "..\fs\ydirectenv.h" 2
N
N#include "stdlib.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 180254 $
N * Checkin $Date: 2013-06-03 17:00:28 +0100 (Mon, 03 Jun 2013) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_REALTIME_DIVIDE)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 28 "..\fs\ydirectenv.h" 2
N#include "stdio.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 29 "..\fs\ydirectenv.h" 2
N#include "string.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5040049
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "..\fs\ydirectenv.h" 2
N#include "yaffs_malloc.h"
L 1 "..\fs\yaffs_malloc.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N 
N#ifndef __YAFFS_MALLOC_H__
N#define __YAFFS_MALLOC_H__
N
N#include <stdlib.h>
N 
Nvoid *yaffs_malloc(size_t size); 
Nvoid yaffs_free(void *ptr);
N 
N#endif
N
L 31 "..\fs\ydirectenv.h" 2
N
N#include "assert.h"
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5040049
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 33 "..\fs\ydirectenv.h" 2
N#define YBUG() //assert(0)
N//#define YBUG() do { *((int *)0) =1;} while(0)
N
N
N#define YCHAR char
N#define YUCHAR unsigned char
N#define _Y(x) x
N#define yaffs_strcat(a,b)    strcat(a,b)
N#define yaffs_strcpy(a,b)    strcpy(a,b)
N#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
N#define yaffs_strncmp(a,b,c) strncmp(a,b,c)
N#define yaffs_strlen(s)	     strlen(s)
N#define yaffs_sprintf	     //sprintf
N#define yaffs_toupper(a)     toupper(a)
N
N#define YAFFS_PATH_DIVIDERS  "/"
N
N#ifdef NO_Y_INLINE
S#define Y_INLINE
N#else
N#define Y_INLINE  __inline
N#endif
N
N#define YMALLOC(x) yaffs_malloc(x)
N#define YFREE(x)   free(x)
N#define YMALLOC_ALT(x) yaffs_malloc(x)
N#define YFREE_ALT(x)   free(x)
N
N#define YMALLOC_DMA(x) yaffs_malloc(x)
N
N#define YYIELD()  do {} while(0)
N
N
N
N//#define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s))
N//#define YALERT(s) YINFO(s)
N
N
N#define TENDSTR "\n"
N#define TSTR(x) x
N#define TCONT(x) x
N#define TOUT(p) //printf p
N
N
N#define YAFFS_LOSTNFOUND_NAME		"lost+found"
N#define YAFFS_LOSTNFOUND_PREFIX		"obj"
N//#define YPRINTF(x) printf x
N
N#include "yaffscfg.h"
L 1 "..\fs\yaffscfg.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N/*
N * Header file for using yaffs in an application via
N * a direct interface.
N */
N
N
N#ifndef __YAFFSCFG_H__
S#define __YAFFSCFG_H__
S
S
S#include "yportenv.h"
S
S#define YAFFSFS_N_HANDLES 200
S
S
Stypedef struct {
S	const YCHAR *prefix;
S	struct yaffs_DeviceStruct *dev;
S} yaffsfs_DeviceConfiguration;
S
S
Svoid yaffsfs_Lock(void);
Svoid yaffsfs_Unlock(void);
S__u32 yaffsfs_CurrentTime(void);
Svoid yaffsfs_SetError(int err);
S
N#endif
N
L 82 "..\fs\ydirectenv.h" 2
N
N#define Y_CURRENT_TIME yaffsfs_CurrentTime()
N#define Y_TIME_CONVERT(x) x
N
N#define YAFFS_ROOT_MODE				0666
N#define YAFFS_LOSTNFOUND_MODE		0666
N
N#define yaffs_SumCompare(x,y) ((x) == (y))
N#define yaffs_strcmp(a,b) strcmp(a,b)
N
N#endif
N
N
L 118 "..\fs\yportenv.h" 2
N
N#elif defined CONFIG_YAFFS_UTIL
S
S/* Stuff for YAFFS utilities */
S
S#include "stdlib.h"
S#include "stdio.h"
S#include "string.h"
S
S#include "devextras.h"
S
S#define YMALLOC(x) malloc(x)
S#define YFREE(x)   free(x)
S#define YMALLOC_ALT(x) malloc(x)
S#define YFREE_ALT(x) free(x)
S
S#define YCHAR char
S#define YUCHAR unsigned char
S#define _Y(x)     x
S#define yaffs_strcat(a,b)    strcat(a,b)
S#define yaffs_strcpy(a,b)    strcpy(a,b)
S#define yaffs_strncpy(a,b,c) strncpy(a,b,c)
S#define yaffs_strlen(s)	     strlen(s)
S#define yaffs_sprintf	     sprintf
S#define yaffs_toupper(a)     toupper(a)
S
S#define Y_INLINE inline
S
S/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
S/* #define YALERT(s) YINFO(s) */
S
S#define TENDSTR "\n"
S#define TSTR(x) x
S#define TOUT(p) printf p
S
S#define YAFFS_LOSTNFOUND_NAME		"lost+found"
S#define YAFFS_LOSTNFOUND_PREFIX		"obj"
S/* #define YPRINTF(x) printf x */
S
S#define YAFFS_ROOT_MODE				0666
S#define YAFFS_LOSTNFOUND_MODE		0666
S
S#define yaffs_SumCompare(x,y) ((x) == (y))
S#define yaffs_strcmp(a,b) strcmp(a,b)
S
S#else
S/* Should have specified a configuration type */
S#error Unknown configuration
S
N#endif
N
N/* see yaffs_fs.c */
Nextern unsigned int yaffs_traceMask;
Nextern unsigned int yaffs_wr_attempts;
N
N/*
N * Tracing flags.
N * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
N */
N
N#define YAFFS_TRACE_OS			0x00000002
N#define YAFFS_TRACE_ALLOCATE		0x00000004
N#define YAFFS_TRACE_SCAN		0x00000008
N#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
N#define YAFFS_TRACE_ERASE		0x00000020
N#define YAFFS_TRACE_GC			0x00000040
N#define YAFFS_TRACE_WRITE		0x00000080
N#define YAFFS_TRACE_TRACING		0x00000100
N#define YAFFS_TRACE_DELETION		0x00000200
N#define YAFFS_TRACE_BUFFERS		0x00000400
N#define YAFFS_TRACE_NANDACCESS		0x00000800
N#define YAFFS_TRACE_GC_DETAIL		0x00001000
N#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
N#define YAFFS_TRACE_MTD			0x00004000
N#define YAFFS_TRACE_CHECKPOINT		0x00008000
N
N#define YAFFS_TRACE_VERIFY		0x00010000
N#define YAFFS_TRACE_VERIFY_NAND		0x00020000
N#define YAFFS_TRACE_VERIFY_FULL		0x00040000
N#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
N
N
N#define YAFFS_TRACE_ERROR		0x40000000
N#define YAFFS_TRACE_BUG			0x80000000
N#define YAFFS_TRACE_ALWAYS		0xF0000000
N
N
N#define T(mask,p) do{ if((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p);} while(0)
N
N#ifndef YBUG
S#define YBUG() do {T(YAFFS_TRACE_BUG,(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),__LINE__));} while(0)
N#endif
N
N#endif
L 27 "..\fs\yaffscfg.h" 2
N
N#define YAFFSFS_N_HANDLES 200
N
N
Ntypedef struct {
N	const YCHAR *prefix;
X	const char *prefix;
N	struct yaffs_DeviceStruct *dev;
N} yaffsfs_DeviceConfiguration;
N
N
Nvoid yaffsfs_Lock(void);
Nvoid yaffsfs_Unlock(void);
N__u32 yaffsfs_CurrentTime(void);
Nvoid yaffsfs_SetError(int err);
N
N#endif
N
L 26 "..\fs\yaffsfs.h" 2
N#include "yportenv.h"
N
N#define   CONFIG_YAFFSFS_PROVIDE_VALUES  1
N//typedef long off_t;
N//typedef long dev_t;
N//typedef unsigned long mode_t;
N
N
N#ifndef NAME_MAX
N#define NAME_MAX	256
N#endif
N
N
N#ifdef CONFIG_YAFFSFS_PROVIDE_VALUES
N
N#ifndef O_RDONLY
N#define O_RDONLY        00
N#endif
N
N#ifndef O_WRONLY
N#define O_WRONLY	01
N#endif
N
N#ifndef O_RDWR
N#define O_RDWR		02
N#endif
N
N#ifndef O_CREAT		
N#define O_CREAT 	0100
N#endif
N
N#ifndef O_EXCL
N#define O_EXCL		0200
N#endif
N
N#ifndef O_TRUNC
N#define O_TRUNC		01000
N#endif
N
N#ifndef O_APPEND
N#define O_APPEND	      02000
N#endif
N
N#ifndef SEEK_SET
S#define SEEK_SET	0
N#endif
N
N#ifndef SEEK_CUR
S#define SEEK_CUR	1
N#endif
N
N#ifndef SEEK_END
S#define SEEK_END	2
N#endif
N
N#ifndef EBUSY
N#define EBUSY	16
N#endif
N
N#ifndef ENODEV
N#define ENODEV	19
N#endif
N
N#ifndef EINVAL
N#define EINVAL	22
N#endif
N
N#ifndef EBADF
N#define EBADF	9
N#endif
N
N#ifndef EACCES
N#define EACCES	13
N#endif
N
N#ifndef EXDEV	
N#define EXDEV	18
N#endif
N
N#ifndef ENOENT
N#define ENOENT	2
N#endif
N
N#ifndef ENOSPC
N#define ENOSPC	28
N#endif
N
N#ifndef ENOTEMPTY
N#define ENOTEMPTY 39
N#endif
N
N#ifndef ENOMEM
N#define ENOMEM 12
N#endif
N
N#ifndef EEXIST
N#define EEXIST 17
N#endif
N
N#ifndef ENOTDIR
N#define ENOTDIR 20
N#endif
N
N#ifndef EISDIR
N#define EISDIR 21
N#endif
N
N
N// Mode flags
N
N#ifndef S_IFMT
N#define S_IFMT		0170000
N#endif
N
N#ifndef S_IFLNK
N#define S_IFLNK		0120000
N#endif
N
N#ifndef S_IFDIR
N#define S_IFDIR		0040000
N#endif
N
N#ifndef S_IFREG
N#define S_IFREG		0100000
N#endif
N
N#ifndef S_IREAD 
N#define S_IREAD		0000400
N#endif
N
N#ifndef S_IWRITE
N#define	S_IWRITE	0000200
N#endif
N
N#ifndef S_IEXEC
N#define	S_IEXEC	0000100
N#endif
N
N#ifndef R_OK
N#define R_OK	4
N#define W_OK	2
N#define X_OK	1
N#define F_OK	0
N#endif
N
N#else
S#include <errno.h>
S#include <sys/stat.h>
S#include <fcntl.h>
N#endif
N
N
Nstruct yaffs_dirent{
N    long d_ino;                 /* inode number */
N    off_t d_off;                /* offset to this dirent */
N    unsigned short d_reclen;    /* length of this d_name */
N    YUCHAR  d_type;	/* type of this record */
X    unsigned char  d_type;	 
N    YCHAR d_name [NAME_MAX+1];   /* file name (null-terminated) */
X    char d_name [256+1];    
N    unsigned d_dont_use;	/* debug pointer, not for public consumption */
N};
N
Ntypedef struct yaffs_dirent yaffs_dirent;
N
N
Ntypedef struct __opaque yaffs_DIR;
N
N
N
Nstruct yaffs_stat{
N    int		      st_dev;      /* device */
N    int           st_ino;      /* inode */
N    unsigned      st_mode;     /* protection */
N    int           st_nlink;    /* number of hard links */
N    int           st_uid;      /* user ID of owner */
N    int           st_gid;      /* group ID of owner */
N    unsigned      st_rdev;     /* device type (if inode device) */
N    off_t         st_size;     /* total size, in bytes */
N    unsigned long st_blksize;  /* blocksize for filesystem I/O */
N    unsigned long st_blocks;   /* number of blocks allocated */
N#ifdef CONFIG_YAFFS_WINCE
S	/* Special 64-bit times for WinCE */
S	unsigned long yst_wince_atime[2];
S	unsigned long yst_wince_mtime[2];
S	unsigned long yst_wince_ctime[2];
N#else
N	unsigned long yst_atime;    /* time of last access */
N    unsigned long yst_mtime;    /* time of last modification */
N    unsigned long yst_ctime;    /* time of last change */
N#endif
N};
N
Nint yaffs_open(const YCHAR *path, int oflag, int mode) ;
Xint yaffs_open(const char *path, int oflag, int mode) ;
Nint yaffs_close(int fd) ;
Nint yaffs_flush(int fd) ;
N
Nint yaffs_access(const YCHAR *path, int amode);
Xint yaffs_access(const char *path, int amode);
N
Nint yaffs_dup(int fd);
N
Nint yaffs_read(int fd, void *buf, unsigned int nbyte) ;
Nint yaffs_write(int fd, const void *buf, unsigned int nbyte) ;
N
Nint yaffs_pread(int fd, void *buf, unsigned int nbyte, unsigned int offset);
Nint yaffs_pwrite(int fd, const void *buf, unsigned int nbyte, unsigned int offset);
N
Noff_t yaffs_lseek(int fd, off_t offset, int whence) ;
N
Nint yaffs_truncate(const YCHAR *path, off_t newSize);
Xint yaffs_truncate(const char *path, off_t newSize);
Nint yaffs_ftruncate(int fd, off_t newSize);
N
Nint yaffs_unlink(const YCHAR *path) ;
Xint yaffs_unlink(const char *path) ;
Nint yaffs_rename(const YCHAR *oldPath, const YCHAR *newPath) ;
Xint yaffs_rename(const char *oldPath, const char *newPath) ;
N
Nint yaffs_stat(const YCHAR *path, struct yaffs_stat *buf) ;
Xint yaffs_stat(const char *path, struct yaffs_stat *buf) ;
Nint yaffs_lstat(const YCHAR *path, struct yaffs_stat *buf) ;
Xint yaffs_lstat(const char *path, struct yaffs_stat *buf) ;
Nint yaffs_fstat(int fd, struct yaffs_stat *buf) ;
N
N#ifdef CONFIG_YAFFS_WINCE
S
Sint yaffs_set_wince_times(int fd, const unsigned *wctime, const unsigned *watime, const unsigned *wmtime);
Sint yaffs_get_wince_times(int fd, unsigned *wctime, unsigned *watime, unsigned *wmtime);
S
N#endif
N
Nint yaffs_chmod(const YCHAR *path, mode_t mode); 
Xint yaffs_chmod(const char *path, mode_t mode); 
Nint yaffs_fchmod(int fd, mode_t mode); 
N
Nint yaffs_mkdir(const YCHAR *path, mode_t mode) ;
Xint yaffs_mkdir(const char *path, mode_t mode) ;
Nint yaffs_rmdir(const YCHAR *path) ;
Xint yaffs_rmdir(const char *path) ;
N
Nyaffs_DIR *yaffs_opendir(const YCHAR *dirname) ;
Xyaffs_DIR *yaffs_opendir(const char *dirname) ;
Nstruct yaffs_dirent *yaffs_readdir(yaffs_DIR *dirp) ;
Nvoid yaffs_rewinddir(yaffs_DIR *dirp) ;
Nint yaffs_closedir(yaffs_DIR *dirp) ;
N
Nint yaffs_mount(const YCHAR *path) ;
Xint yaffs_mount(const char *path) ;
Nint yaffs_unmount(const YCHAR *path) ;
Xint yaffs_unmount(const char *path) ;
N
Nint yaffs_sync(const YCHAR *path) ;
Xint yaffs_sync(const char *path) ;
N
Nint yaffs_symlink(const YCHAR *oldpath, const YCHAR *newpath); 
Xint yaffs_symlink(const char *oldpath, const char *newpath); 
Nint yaffs_readlink(const YCHAR *path, YCHAR *buf, int bufsiz); 
Xint yaffs_readlink(const char *path, char *buf, int bufsiz); 
N
Nint yaffs_link(const YCHAR *oldpath, const YCHAR *newpath); 
Xint yaffs_link(const char *oldpath, const char *newpath); 
Nint yaffs_mknod(const YCHAR *pathname, mode_t mode, dev_t dev);
Xint yaffs_mknod(const char *pathname, mode_t mode, dev_t dev);
N
Nloff_t yaffs_freespace(const YCHAR *path);
Xloff_t yaffs_freespace(const char *path);
Nloff_t yaffs_totalspace(const YCHAR *path);
Xloff_t yaffs_totalspace(const char *path);
N
Nint yaffs_inodecount(const YCHAR *path);
Xint yaffs_inodecount(const char *path);
N
N
Nvoid yaffs_initialise(yaffsfs_DeviceConfiguration *configList);
N
Nint yaffs_StartUp(void);
N
N#endif
N
N
L 15 "..\fs\yaffsfs.c" 2
N#include "yaffs_guts.h"
L 1 "..\fs\yaffs_guts.h" 1
N/*
N * YAFFS: Yet another Flash File System . A NAND-flash specific file system. 
N *
N * Copyright (C) 2002-2007 Aleph One Ltd.
N *   for Toby Churchill Ltd and Brightstar Engineering
N *
N * Created by Charles Manning <charles@aleph1.co.uk>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU Lesser General Public License version 2.1 as
N * published by the Free Software Foundation.
N *
N * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
N */
N
N#ifndef __YAFFS_GUTS_H__
N#define __YAFFS_GUTS_H__
N
N#include "devextras.h"
N#include "yportenv.h"
N
N#define YAFFS_OK	1
N#define YAFFS_FAIL  0
N#define CONFIG_YAFFS_YAFFS2  1
N/* Give us a  Y=0x59, 
N * Give us an A=0x41, 
N * Give us an FF=0xFF 
N * Give us an S=0x53
N * And what have we got... 
N */
N#define YAFFS_MAGIC			0x5941FF53
N
N#define YAFFS_NTNODES_LEVEL0	  	16
N#define YAFFS_TNODES_LEVEL0_BITS	4
N#define YAFFS_TNODES_LEVEL0_MASK	0xf
N
N#define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
N#define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
N#define YAFFS_TNODES_INTERNAL_MASK	0x7
N#define YAFFS_TNODES_MAX_LEVEL		6
N
N#ifndef CONFIG_YAFFS_NO_YAFFS1
N#define YAFFS_BYTES_PER_SPARE		16
N#define YAFFS_BYTES_PER_CHUNK		512
N#define YAFFS_CHUNK_SIZE_SHIFT		9
N#define YAFFS_CHUNKS_PER_BLOCK		32
N#define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
N#endif
N
N#define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
N#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
N
N#define YAFFS_MAX_CHUNK_ID		0x000FFFFF
N
N#define YAFFS_UNUSED_OBJECT_ID		0x0003FFFF
N
N#define YAFFS_ALLOCATION_NOBJECTS	100
N#define YAFFS_ALLOCATION_NTNODES	100
N#define YAFFS_ALLOCATION_NLINKS		100
N
N#define YAFFS_NOBJECT_BUCKETS		256
N
N
N#define YAFFS_OBJECT_SPACE		0x40000
N
N#define YAFFS_CHECKPOINT_VERSION 	3
N
N#ifdef CONFIG_YAFFS_UNICODE
S#define YAFFS_MAX_NAME_LENGTH		127
S#define YAFFS_MAX_ALIAS_LENGTH		79
N#else
N#define YAFFS_MAX_NAME_LENGTH		255
N#define YAFFS_MAX_ALIAS_LENGTH		159
N#endif
N
N#define YAFFS_SHORT_NAME_LENGTH		15
N
N/* Some special object ids for pseudo objects */
N#define YAFFS_OBJECTID_ROOT		1
N#define YAFFS_OBJECTID_LOSTNFOUND	2
N#define YAFFS_OBJECTID_UNLINKED		3
N#define YAFFS_OBJECTID_DELETED		4
N
N/* Sseudo object ids for checkpointing */
N#define YAFFS_OBJECTID_SB_HEADER	0x10
N#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
N#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
N
N/* */
N
N#define YAFFS_MAX_SHORT_OP_CACHES	20
N
N#define YAFFS_N_TEMP_BUFFERS		6
N
N/* We limit the number attempts at sucessfully saving a chunk of data.
N * Small-page devices have 32 pages per block; large-page devices have 64.
N * Default to something in the order of 5 to 10 blocks worth of chunks.
N */
N#define YAFFS_WR_ATTEMPTS		(5*64)
N
N/* Sequence numbers are used in YAFFS2 to determine block allocation order.
N * The range is limited slightly to help distinguish bad numbers from good.
N * This also allows us to perhaps in the future use special numbers for
N * special purposes.
N * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years, 
N * and is a larger number than the lifetime of a 2GB device.
N */
N#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
N#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
N
N/* Special sequence number for bad block that failed to be marked bad */
N#define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
N
N/* ChunkCache is used for short read/write operations.*/
Ntypedef struct {
N	struct yaffs_ObjectStruct *object;
N	int chunkId;
N	int lastUse;
N	int dirty;
N	int nBytes;		/* Only valid if the cache is dirty */
N	int locked;		/* Can't push out or flush while locked. */
N#ifdef CONFIG_YAFFS_YAFFS2
N	__u8 *data;
N#else
S	__u8 data[YAFFS_BYTES_PER_CHUNK];
N#endif
N} yaffs_ChunkCache;
N
N
N
N/* Tags structures in RAM
N * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
N * the structure size will get blown out.
N */
N
N#ifndef CONFIG_YAFFS_NO_YAFFS1
Ntypedef struct {
N        unsigned chunkId:20;
N        unsigned serialNumber:2;
N        unsigned byteCountLSB:10;
N        unsigned objectId:18;
N        unsigned ecc:12;
N        unsigned byteCountMSB:2;
N
N} yaffs_Tags;
N
Ntypedef union {
N	yaffs_Tags asTags;
N	__u8 asBytes[8];
N} yaffs_TagsUnion;
N
N#endif
N
N/* Stuff used for extended tags in YAFFS2 */
N
Ntypedef enum {
N	YAFFS_ECC_RESULT_UNKNOWN,
N	YAFFS_ECC_RESULT_NO_ERROR,
N	YAFFS_ECC_RESULT_FIXED,
N	YAFFS_ECC_RESULT_UNFIXED
N} yaffs_ECCResult;
N
Ntypedef enum {
N	YAFFS_OBJECT_TYPE_UNKNOWN,
N	YAFFS_OBJECT_TYPE_FILE,
N	YAFFS_OBJECT_TYPE_SYMLINK,
N	YAFFS_OBJECT_TYPE_DIRECTORY,
N	YAFFS_OBJECT_TYPE_HARDLINK,
N	YAFFS_OBJECT_TYPE_SPECIAL
N} yaffs_ObjectType;
N
N#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
N
Ntypedef struct {
N
N	unsigned validMarker0;
N	unsigned chunkUsed;	/*  Status of the chunk: used or unused */
N	unsigned objectId;	/* If 0 then this is not part of an object (unused) */
N	unsigned chunkId;	/* If 0 then this is a header, else a data chunk */
N	unsigned byteCount;	/* Only valid for data chunks */
N
N	/* The following stuff only has meaning when we read */
N	yaffs_ECCResult eccResult;
N	unsigned blockBad;	
N
N	/* YAFFS 1 stuff */
N	unsigned chunkDeleted;	/* The chunk is marked deleted */
N	unsigned serialNumber;	/* Yaffs1 2-bit serial number */
N
N	/* YAFFS2 stuff */
N	unsigned sequenceNumber;	/* The sequence number of this block */
N
N	/* Extra info if this is an object header (YAFFS2 only) */
N
N	unsigned extraHeaderInfoAvailable;	/* There is extra info available if this is not zero */
N	unsigned extraParentObjectId;	/* The parent object */
N	unsigned extraIsShrinkHeader;	/* Is it a shrink header? */
N	unsigned extraShadows;		/* Does this shadow another object? */
N
N	yaffs_ObjectType extraObjectType;	/* What object type? */
N
N	unsigned extraFileLength;		/* Length if it is a file */
N	unsigned extraEquivalentObjectId;	/* Equivalent object Id if it is a hard link */
N
N	unsigned validMarker1;
N
N} yaffs_ExtendedTags;
N
N/* Spare structure for YAFFS1 */
Ntypedef struct {
N	__u8 tagByte0;
N	__u8 tagByte1;
N	__u8 tagByte2;
N	__u8 tagByte3;
N	__u8 pageStatus;	/* set to 0 to delete the chunk */
N	__u8 blockStatus;
N	__u8 tagByte4;
N	__u8 tagByte5;
N	__u8 ecc1[3];
N	__u8 tagByte6;
N	__u8 tagByte7;
N	__u8 ecc2[3];
N} yaffs_Spare;
N
N/*Special structure for passing through to mtd */
Nstruct yaffs_NANDSpare {
N	yaffs_Spare spare;
N	int eccres1;
N	int eccres2;
N};
N
N/* Block data in RAM */
N
Ntypedef enum {
N	YAFFS_BLOCK_STATE_UNKNOWN = 0,
N
N	YAFFS_BLOCK_STATE_SCANNING,
N	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
N	/* The block might have something on it (ie it is allocating or full, perhaps empty)
N	 * but it needs to be scanned to determine its true state.
N	 * This state is only valid during yaffs_Scan.
N	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
N	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
N	 */
N
N	YAFFS_BLOCK_STATE_EMPTY,
N	/* This block is empty */
N
N	YAFFS_BLOCK_STATE_ALLOCATING,
N	/* This block is partially allocated. 
N	 * At least one page holds valid data.
N	 * This is the one currently being used for page
N	 * allocation. Should never be more than one of these
N	 */
N
N	YAFFS_BLOCK_STATE_FULL,	
N	/* All the pages in this block have been allocated.
N	 */
N
N	YAFFS_BLOCK_STATE_DIRTY,
N	/* All pages have been allocated and deleted. 
N	 * Erase me, reuse me.
N	 */
N
N	YAFFS_BLOCK_STATE_CHECKPOINT,	
N	/* This block is assigned to holding checkpoint data.
N	 */
N
N	YAFFS_BLOCK_STATE_COLLECTING,	
N	/* This block is being garbage collected */
N
N	YAFFS_BLOCK_STATE_DEAD	
N	/* This block has failed and is not in use */
N} yaffs_BlockState;
N
N#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
N
N
Ntypedef struct {
N
N	int softDeletions:10;	/* number of soft deleted pages */
N	int pagesInUse:10;	/* number of pages in use */
N	unsigned blockState:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
N	__u32 needsRetiring:1;	/* Data has failed on this block, need to get valid data off */
N                        	/* and retire the block. */
N	__u32 skipErasedCheck: 1; /* If this is set we can skip the erased check on this block */
N	__u32 gcPrioritise: 1; 	/* An ECC check or blank check has failed on this block. 
N				   It should be prioritised for GC */
N        __u32 chunkErrorStrikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */
N
N#ifdef CONFIG_YAFFS_YAFFS2
N	__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */
N	__u32 sequenceNumber;	 /* block sequence number for yaffs2 */
N#endif
N
N} yaffs_BlockInfo;
N
N/* -------------------------- Object structure -------------------------------*/
N/* This is the object structure as stored on NAND */
N
Ntypedef struct {
N	yaffs_ObjectType type;
N
N	/* Apply to everything  */
N	int parentObjectId;
N        __u16 sum__NoLongerUsed;        /* checksum of name. No longer used */
N        YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
X        char name[255 + 1];
N
N        /* The following apply to directories, files, symlinks - not hard links */
N        __u32 yst_mode;         /* protection */
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 notForWinCE[5];
N#else
N	__u32 yst_uid;
N	__u32 yst_gid;
N	__u32 yst_atime;
N	__u32 yst_mtime;
N	__u32 yst_ctime;
N#endif
N
N	/* File size  applies to files only */
N	int fileSize;
N
N	/* Equivalent object id applies to hard links only. */
N	int equivalentObjectId;
N
N	/* Alias is for symlinks only. */
N	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
X	char alias[159 + 1];
N
N	__u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 win_ctime[2];
S	__u32 win_atime[2];
S	__u32 win_mtime[2];
N#else
N	__u32 roomToGrow[6];
N
N#endif
N	__u32 inbandShadowsObject;
N	__u32 inbandIsShrink;
N
N	__u32 reservedSpace[2];
N	int shadowsObject;	/* This object header shadows the specified object if > 0 */
N
N	/* isShrink applies to object headers written when we shrink the file (ie resize) */
N	__u32 isShrink;
N
N} yaffs_ObjectHeader;
N
N/*--------------------------- Tnode -------------------------- */
N
Nunion yaffs_Tnode_union {
N#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
S	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];
N#else
N	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];
X	union yaffs_Tnode_union *internal[(16 / 2)];
N#endif
N/*	__u16 level0[YAFFS_NTNODES_LEVEL0]; */
N
N};
N
Ntypedef union yaffs_Tnode_union yaffs_Tnode;
N
Nstruct yaffs_TnodeList_struct {
N	struct yaffs_TnodeList_struct *next;
N	yaffs_Tnode *tnodes;
N};
N
Ntypedef struct yaffs_TnodeList_struct yaffs_TnodeList;
N
N/*------------------------  Object -----------------------------*/
N/* An object can be one of:
N * - a directory (no data, has children links
N * - a regular file (data.... not prunes :->).
N * - a symlink [symbolic link] (the alias).
N * - a hard link
N */
N
Ntypedef struct {
N	__u32 fileSize;
N	__u32 scannedFileSize;
N	__u32 shrinkSize;
N	int topLevel;
N	yaffs_Tnode *top;
N} yaffs_FileStructure;
N
Ntypedef struct {
N        struct ylist_head children;     /* list of child links */
N} yaffs_DirectoryStructure;
N
Ntypedef struct {
N	YCHAR *alias;
X	char *alias;
N} yaffs_SymLinkStructure;
N
Ntypedef struct {
N	struct yaffs_ObjectStruct *equivalentObject;
N	__u32 equivalentObjectId;
N} yaffs_HardLinkStructure;
N
Ntypedef union {
N	yaffs_FileStructure fileVariant;
N	yaffs_DirectoryStructure directoryVariant;
N	yaffs_SymLinkStructure symLinkVariant;
N	yaffs_HardLinkStructure hardLinkVariant;
N} yaffs_ObjectVariant;
N
Nstruct yaffs_ObjectStruct {
N	__u8 deleted:1;		/* This should only apply to unlinked files. */
N	__u8 softDeleted:1;	/* it has also been soft deleted */
N	__u8 unlinked:1;	/* An unlinked file. The file should be in the unlinked directory.*/
N	__u8 fake:1;		/* A fake object has no presence on NAND. */
N	__u8 renameAllowed:1;	/* Some objects are not allowed to be renamed. */
N	__u8 unlinkAllowed:1;
N	__u8 dirty:1;		/* the object needs to be written to flash */
N	__u8 valid:1;		/* When the file system is being loaded up, this 
N				 * object might be created before the data
N				 * is available (ie. file data records appear before the header).
N				 */
N	__u8 lazyLoaded:1;	/* This object has been lazy loaded and is missing some detail */
N
N	__u8 deferedFree:1;	/* For Linux kernel. Object is removed from NAND, but is
N				 * still in the inode cache. Free of object is defered.
N				 * until the inode is released.
N                                 */
N        __u8 beingCreated:1;	/* This object is still being created so skip some checks. */
N
N	__u8 serial;		/* serial number of chunk in NAND. Cached here */
N	__u16 sum;		/* sum of the name to speed searching */
N
N        struct yaffs_DeviceStruct *myDev;       /* The device I'm on */
N
N        struct ylist_head hashLink;     /* list of objects in this hash bucket */
N
N        struct ylist_head hardLinks;    /* all the equivalent hard linked objects */
N
N        /* directory structure stuff */
N        /* also used for linking up the free list */
N        struct yaffs_ObjectStruct *parent; 
N        struct ylist_head siblings;
N
N	/* Where's my object header in NAND? */
N	int hdrChunk;
N
N	int nDataChunks;	/* Number of data chunks attached to the file. */
N
N	__u32 objectId;		/* the object id value */
N
N	__u32 yst_mode;
N
N#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
S	YCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];
N#endif
N
N#ifndef __KERNEL__
N	__u32 inUse;
N#endif
N
N#ifdef CONFIG_YAFFS_WINCE
S	__u32 win_ctime[2];
S	__u32 win_mtime[2];
S	__u32 win_atime[2];
N#else
N	__u32 yst_uid;
N	__u32 yst_gid;
N	__u32 yst_atime;
N	__u32 yst_mtime;
N	__u32 yst_ctime;
N#endif
N
N	__u32 yst_rdev;
N
N#ifdef __KERNEL__
S	struct inode *myInode;
S
N#endif
N
N	yaffs_ObjectType variantType;
N
N	yaffs_ObjectVariant variant;
N
N};
N
Ntypedef struct yaffs_ObjectStruct yaffs_Object;
N
Nstruct yaffs_ObjectList_struct {
N	yaffs_Object *objects;
N	struct yaffs_ObjectList_struct *next;
N};
N
Ntypedef struct yaffs_ObjectList_struct yaffs_ObjectList;
N
Ntypedef struct {
N        struct ylist_head list;
N        int count;
N} yaffs_ObjectBucket;
N
N
N/* yaffs_CheckpointObject holds the definition of an object as dumped 
N * by checkpointing.
N */
N
Ntypedef struct {
N        int structType;
N	__u32 objectId;		
N	__u32 parentId;
N	int hdrChunk;
N	yaffs_ObjectType variantType:3;
N	__u8 deleted:1;		
N	__u8 softDeleted:1;	
N	__u8 unlinked:1;	
N	__u8 fake:1;		
N	__u8 renameAllowed:1;
N	__u8 unlinkAllowed:1;
N	__u8 serial;		
N	
N	int nDataChunks;	
N	__u32 fileSizeOrEquivalentObjectId;
N
N}yaffs_CheckpointObject;
N
N/*--------------------- Temporary buffers ----------------
N *
N * These are chunk-sized working buffers. Each device has a few
N */
N
Ntypedef struct {
N	__u8 *buffer;
N	int line;	/* track from whence this buffer was allocated */
N	int maxLine;
N} yaffs_TempBuffer;
N
N/*----------------- Device ---------------------------------*/
N
Nstruct yaffs_DeviceStruct {
N        struct ylist_head devList;
N        const char *name;
N
N        /* Entry parameters set up way early. Yaffs sets up the rest.*/
N        int nDataBytesPerChunk; /* Should be a power of 2 >= 512 */
N        int nChunksPerBlock;    /* does not need to be a power of 2 */
N        int spareBytesPerChunk;/* spare area size */
N        int startBlock;         /* Start block we're allowed to use */
N        int endBlock;           /* End block we're allowed to use */
N        int nReservedBlocks;    /* We want this tuneable so that we can reduce */
N				/* reserved blocks on NOR and RAM. */
N	
N	
N	/* Stuff used by the shared space checkpointing mechanism */
N	/* If this value is zero, then this mechanism is disabled */
N	
N//	int nCheckpointReservedBlocks; /* Blocks to reserve for checkpoint data */
N
N	
N
N
N	int nShortOpCaches;	/* If <= 0, then short op caching is disabled, else
N				 * the number of short op caches (don't use too many)
N				 */
N
N	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
N
N	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
N
N	void *genericDevice;	/* Pointer to device context
N				 * On an mtd this holds the mtd pointer.
N				 */
N        void *superBlock;
N        
N	/* NAND access functions (Must be set before calling YAFFS)*/
N
N	int (*writeChunkToNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, const __u8 * data,const yaffs_Spare * spare);
N 	int (*readChunkFromNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, __u8 * data,yaffs_Spare * spare);
N        int (*eraseBlockInNAND) (struct yaffs_DeviceStruct * dev, int blockInNAND);                               
N        int (*initialiseNAND) (struct yaffs_DeviceStruct * dev);
N        int (*deinitialiseNAND) (struct yaffs_DeviceStruct * dev);
N        int (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct * dev, int chunkInNAND, const __u8 * data,const yaffs_ExtendedTags * tags);					 
N        int (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct * dev,int chunkInNAND, __u8 * data,yaffs_ExtendedTags * tags);
N        int (*markNANDBlockBad) (struct yaffs_DeviceStruct * dev, int blockNo);
N        int (*queryNANDBlock) (struct yaffs_DeviceStruct * dev, int blockNo,yaffs_BlockState * state, __u32 *sequenceNumber);
N        //////////////////////////////////////////////
N        int isYaffs2;
N	
N	/* The removeObjectCallback function must be supplied by OS flavours that 
N	 * need it. The Linux kernel does not use this, but yaffs direct does use
N	 * it to implement the faster readdir
N	 */
N	void (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);
N	
N	/* Callback to mark the superblock dirsty */
N	void (*markSuperBlockDirty)(void * superblock);
N	
N	int wideTnodesDisabled; /* Set to disable wide tnodes */
N	
N	YCHAR *pathDividers;	/* String of legal path dividers */
X	char *pathDividers;	 
N	
N
N	/* End of stuff that must be set before initialisation. */
N	
N	/* Checkpoint control. Can be set before or after initialisation */
N	__u8 skipCheckpointRead;
N	__u8 skipCheckpointWrite;
N
N	/* Runtime parameters. Set up by YAFFS. */
N
N	__u16 chunkGroupBits;	/* 0 for devices <= 32MB. else log2(nchunks) - 16 */
N	__u16 chunkGroupSize;	/* == 2^^chunkGroupBits */
N	
N	/* Stuff to support wide tnodes */
N	__u32 tnodeWidth;
N	__u32 tnodeMask;
N	
N	/* Stuff for figuring out file offset to chunk conversions */
N	__u32 chunkShift; /* Shift value */
N	__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */
N	__u32 chunkMask;  /* Mask to use for power-of-2 case */
N
N	/* Stuff to handle inband tags */
N	int inbandTags;
N	__u32 totalBytesPerChunk;
N
N#ifdef __KERNEL__
S
S	struct semaphore sem;	/* Semaphore for waiting on erasure.*/
S	struct semaphore grossLock;	/* Gross locking semaphore */
S	__u8 *spareBuffer;	/* For mtdif2 use. Don't know the size of the buffer 
S				 * at compile time so we have to allocate it.
S				 */
S	void (*putSuperFunc) (struct super_block * sb);
N#endif
N
N	int isMounted;
N	
N	int isCheckpointed;
N
N
N	/* Stuff to support block offsetting to support start block zero */
N	int internalStartBlock;
N	int internalEndBlock;
N	int blockOffset;
N	int chunkOffset;
N	
N
N	/* Runtime checkpointing stuff */
N	int checkpointPageSequence;   /* running sequence number of checkpoint pages */
N	int checkpointByteCount;
N	int checkpointByteOffset;
N	__u8 *checkpointBuffer;
N	int checkpointOpenForWrite;
N	int blocksInCheckpoint;
N	int checkpointCurrentChunk;
N	int checkpointCurrentBlock;
N	int checkpointNextBlock;
N	int *checkpointBlockList;
N	int checkpointMaxBlocks;
N	__u32 checkpointSum;
N	__u32 checkpointXor;
N	
N	int nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */
N	
N	/* Block Info */
N	yaffs_BlockInfo *blockInfo;
N	__u8 *chunkBits;	/* bitmap of chunks in use */
N	unsigned blockInfoAlt:1;	/* was allocated using alternative strategy */
N	unsigned chunkBitsAlt:1;	/* was allocated using alternative strategy */
N	int chunkBitmapStride;	/* Number of bytes of chunkBits per block. 
N				 * Must be consistent with nChunksPerBlock.
N				 */
N
N	int nErasedBlocks;
N	int allocationBlock;	/* Current block being allocated off */
N	__u32 allocationPage;
N	int allocationBlockFinder;	/* Used to search for next allocation block */
N
N	/* Runtime state */
N	int nTnodesCreated;
N	yaffs_Tnode *freeTnodes;
N	int nFreeTnodes;
N	yaffs_TnodeList *allocatedTnodeList;
N
N	int isDoingGC;
N	int gcBlock;
N	int gcChunk;
N
N	int nObjectsCreated;
N	yaffs_Object *freeObjects;
N	int nFreeObjects;
N	
N	int nHardLinks;
N
N	yaffs_ObjectList *allocatedObjectList;
N
N	yaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];
X	yaffs_ObjectBucket objectBucket[256];
N
N	int nFreeChunks;
N
N	int currentDirtyChecker;	/* Used to find current dirtiest block */
N
N	__u32 *gcCleanupList;	/* objects to delete at the end of a GC. */
N	int nonAggressiveSkip;	/* GC state/mode */
N
N	/* Statistcs */
N	int nPageWrites;
N	int nPageReads;
N	int nBlockErasures;
N	int nErasureFailures;
N	int nGCCopies;
N	int garbageCollections;
N	int passiveGarbageCollections;
N	int nRetriedWrites;
N	int nRetiredBlocks;
N	int eccFixed;
N	int eccUnfixed;
N	int tagsEccFixed;
N	int tagsEccUnfixed;
N	int nDeletions;
N	int nUnmarkedDeletions;
N	
N	int hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */
N
N	/* Special directories */
N	yaffs_Object *rootDir;
N	yaffs_Object *lostNFoundDir;
N
N	/* Buffer areas for storing data to recover from write failures TODO
N	 *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
N	 *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];
N	 */
N	
N	int bufferedBlock;	/* Which block is buffered here? */
N	int doingBufferedBlockRewrite;
N
N	yaffs_ChunkCache *srCache;
N	int srLastUse;
N
N	int cacheHits;
N
N	/* Stuff for background deletion and unlinked files.*/
N	yaffs_Object *unlinkedDir;	/* Directory where unlinked and deleted files live. */
N	yaffs_Object *deletedDir;	/* Directory where deleted objects are sent to disappear. */
N	yaffs_Object *unlinkedDeletion;	/* Current file being background deleted.*/
N	int nDeletedFiles;		/* Count of files awaiting deletion;*/
N	int nUnlinkedFiles;		/* Count of unlinked files. */
N	int nBackgroundDeletions;	/* Count of background deletions. */
N
N	
N	/* Temporary buffer management */
N	yaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];
X	yaffs_TempBuffer tempBuffer[6];
N	int maxTemp;
N	int tempInUse;
N	int unmanagedTempAllocations;
N	int unmanagedTempDeallocations;
N
N	/* yaffs2 runtime stuff */
N	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
N	unsigned oldestDirtySequence;
N
N};
N
Ntypedef struct yaffs_DeviceStruct yaffs_Device;
N
N/* The static layout of block usage etc is stored in the super block header */
Ntypedef struct {
N        int StructType;
N        int version;
N	int checkpointStartBlock;
N	int checkpointEndBlock;
N	int startBlock;
N	int endBlock;
N	int rfu[100];
N} yaffs_SuperBlockHeader;
N	
N/* The CheckpointDevice structure holds the device information that changes at runtime and
N * must be preserved over unmount/mount cycles.
N */
Ntypedef struct {
N        int structType;
N	int nErasedBlocks;
N	int allocationBlock;	/* Current block being allocated off */
N	__u32 allocationPage;
N	int nFreeChunks;
N
N	int nDeletedFiles;		/* Count of files awaiting deletion;*/
N	int nUnlinkedFiles;		/* Count of unlinked files. */
N	int nBackgroundDeletions;	/* Count of background deletions. */
N
N	/* yaffs2 runtime stuff */
N	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
N	unsigned oldestDirtySequence;
N
N} yaffs_CheckpointDevice;
N
N
Ntypedef struct {
N    int structType;
N    __u32 magic;
N    __u32 version;
N    __u32 head;
N} yaffs_CheckpointValidity;
N
N
N/*----------------------- YAFFS Functions -----------------------*/
N
Nint yaffs_GutsInitialise(yaffs_Device * dev);
Nvoid yaffs_Deinitialise(yaffs_Device * dev);
N
Nint yaffs_GetNumberOfFreeChunks(yaffs_Device * dev);
N
Nint yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,
Xint yaffs_RenameObject(yaffs_Object * oldDir, const char * oldName,
N		       yaffs_Object * newDir, const YCHAR * newName);
X		       yaffs_Object * newDir, const char * newName);
N
Nint yaffs_Unlink(yaffs_Object * dir, const YCHAR * name);
Xint yaffs_Unlink(yaffs_Object * dir, const char * name);
Nint yaffs_DeleteFile(yaffs_Object * obj);
N
Nint yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize);
Xint yaffs_GetObjectName(yaffs_Object * obj, char * name, int buffSize);
Nint yaffs_GetObjectFileLength(yaffs_Object * obj);
Nint yaffs_GetObjectInode(yaffs_Object * obj);
Nunsigned yaffs_GetObjectType(yaffs_Object * obj);
Nint yaffs_GetObjectLinkCount(yaffs_Object * obj);
N
Nint yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr);
Nint yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr);
N
N/* File operations */
Nint yaffs_ReadDataFromFile(yaffs_Object * obj, __u8 * buffer, loff_t offset,
N                           int nBytes);
Nint yaffs_WriteDataToFile(yaffs_Object * obj, const __u8 * buffer, loff_t offset,
N                          int nBytes, int writeThrough);
Nint yaffs_ResizeFile(yaffs_Object * obj, loff_t newSize);
N
Nyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const char * name,
N                              __u32 mode, __u32 uid, __u32 gid);
Nint yaffs_FlushFile(yaffs_Object * obj, int updateTime);
N
N/* Flushing and checkpointing */
Nvoid yaffs_FlushEntireDeviceCache(yaffs_Device *dev);
N
Nint yaffs_CheckpointSave(yaffs_Device *dev);
Nint yaffs_CheckpointRestore(yaffs_Device *dev);
N
N/* Directory operations */
Nyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const char * name,
N				   __u32 mode, __u32 uid, __u32 gid);
Nyaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const YCHAR * name);
Xyaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const char * name);
Nint yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,
N				   int (*fn) (yaffs_Object *));
N
Nyaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number);
N
N/* Link operations */
Nyaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_Link(yaffs_Object * parent, const char * name,
N			 yaffs_Object * equivalentObject);
N
Nyaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj);
N
N/* Symlink operations */
Nyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid,
N				 const YCHAR * alias);
X				 const char * alias);
NYCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj);
Xchar *yaffs_GetSymlinkAlias(yaffs_Object * obj);
N
N/* Special inodes (fifos, sockets and devices) */
Nyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,
Xyaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const char * name,
N				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev);
N
N/* Special directories */
Nyaffs_Object *yaffs_Root(yaffs_Device * dev);
Nyaffs_Object *yaffs_LostNFound(yaffs_Device * dev);
N
N#ifdef CONFIG_YAFFS_WINCE
S/* CONFIG_YAFFS_WINCE special stuff */
Svoid yfsd_WinFileTimeNow(__u32 target[2]);
N#endif
N
N#ifdef __KERNEL__
S
Svoid yaffs_HandleDeferedFree(yaffs_Object * obj);
N#endif
N
N/* Debug dump  */
Nint yaffs_DumpObject(yaffs_Object * obj);
N
Nvoid yaffs_GutsTest(yaffs_Device * dev);
N
N/* A few useful functions */
Nvoid yaffs_InitialiseTags(yaffs_ExtendedTags * tags);
Nvoid yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn);
Nint yaffs_CheckFF(__u8 * buffer, int nBytes);
Nvoid yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);
N
N__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo);
Nvoid yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer, int lineNo);
N
N#endif
L 16 "..\fs\yaffsfs.c" 2
N#include "yaffscfg.h"
N#include <string.h> // for memset
N#include "yportenv.h"
N#include "debug_frmwrk.h"
L 1 "..\Drivers\debug_frmwrk.h" 1
N/***********************************************************************//**
N * @file		debug_frmwrk.h
N * @brief		Contains some utilities that used for debugging through UART
N * @version		1.0
N * @date		18. September. 2010
N * @author		NXP MCU SW Application Team
N *----------------------------------------------------------------------------
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **********************************************************************/
N
N#ifndef DEBUG_FRMWRK_H_
N#define DEBUG_FRMWRK_H_
N
N#include "lpc177x_8x_uart.h"
L 1 "..\Drivers\lpc177x_8x_uart.h" 1
N/***********************************************************************//**
N * @file		lpc177x_8x_uart.h
N * @brief		Contains all macro definitions and function prototypes
N * 				support for UART firmware library on LPC177x_8x
N * @version		1.0
N * @date		18. September. 2010
N * @author		NXP MCU SW Application Team
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N/* Peripheral group ----------------------------------------------------------- */
N#ifndef __LPC178X_UART_H
N#define __LPC178X_UART_H
N
N/* Includes ------------------------------------------------------------------- */
N#include "LPC177x_8x.h"
L 1 "..\Startup\LPC177x_8x.h" 1
N/***********************************************************************
N * $Id: LPC177x_8x.h 6698 2011-03-03 21:20:50Z nxp21346 $
N *
N * Project: LPC177x_8x CMSIS Package
N *
N * Description: Cortex-M3 Core Peripheral Access Layer Header File for
N *              NXP LPC177x_8x Series.
N *
N * Copyright(C) 2011, NXP Semiconductor
N * All rights reserved.
N *
N ***********************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **********************************************************************/
N
N
N#ifndef __LPC177x_8x_H__
N#define __LPC177x_8x_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC177x_8x Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  Reserved0_IRQn                = 13,       /*!< Reserved                                         */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  MCI_IRQn                      = 29,       /*!< SD/MMC card I/F Interrupt                        */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /*!< USB Activity interrupt                           */
N  CANActivity_IRQn              = 34,       /*!< CAN Activity interrupt                           */
N  UART4_IRQn                    = 35,       /*!< UART4 Interrupt                                  */
N  SSP2_IRQn                     = 36,       /*!< SSP2 Interrupt                                   */
N  LCD_IRQn                      = 37,       /*!< LCD Interrupt                                    */
N  GPIO_IRQn                     = 38,       /*!< GPIO Interrupt                                   */
N  PWM0_IRQn                     = 39,       /*!< PWM0 Interrupt                                   */
N  EEPROM_IRQn                   = 40,       /*!< EEPROM Interrupt                           */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
L 1 "..\CM3_lib\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N/** @addtogroup CMSIS
N * @{
N */
N
N/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - Error 10: \n
N *     register uint32_t __regBasePri         __asm("basepri"); \n
N *     Error 10: Expecting ';'
N * .
N *   - Error 530: \n
N *     return(__regBasePri); \n
N *     Warning 530: Symbol '__regBasePri' (line 264) not initialized
N * .
N *   - Error 550: \n
N *     __regBasePri = (basePri & 0x1ff); \n
N *     Warning 550: Symbol '__regBasePri' (line 271) not accessed
N * .
N *   - Error 754: \n
N *     uint32_t RESERVED0[24]; \n
N *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced
N * .
N *   - Error 750: \n
N *     #define __CM3_CORE_H__ \n
N *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced
N * .
N *   - Error 528: \n
N *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced
N * .
N *   - Error 751: \n
N *     } InterruptType_Type; \n
N *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N/** @addtogroup CMSIS_CM3_core_definitions CMSIS CM3 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
L 1 "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 95 "..\CM3_lib\core_cm3.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
N/** @brief  Nested Vectored Interrupt Controller (NVIC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM3_NVIC */
N
N
N/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
N/** @brief  System Control Block (SCB) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM3_SCB */
N
N
N/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick
N  memory mapped structure for SysTick
N  @{
N */
N/** @brief  System Tick Timer (SysTick) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RELOAD;                       /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t RELOAD;                        
N  __IO uint32_t CURR;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t CURR;                           
N  __IO uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM3_SysTick */
N
N
N/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM
N  memory mapped structure for Instrumentation Trace Macrocell (ITM)
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                          
N  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                          
N  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                          
N  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                          
N  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                          
N  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                          
N  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                          
N  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                          
N  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                          
N  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                          
N  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                          
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N/*@}*/ /* end of group CMSIS_CM3_ITM */
N
N
N/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type
N  memory mapped structure for Interrupt Type
N  @{
N */
N/** @brief   Instrumentation Trace Macrocell (ITM) register structure definition */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */
N#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */
N#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */
N
N#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */
N#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */
N
N#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */
N#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */
N/*@}*/ /* end of group CMSIS_CM3_InterruptType */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU
N  memory mapped structure for Memory Protection Unit (MPU)
N  @{
N */
N/** @brief   Memory Protection Unit (MPU) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */
N#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */
N#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */
N#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */
N#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */
N#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */
N#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@}*/ /* end of group CMSIS_CM3_MPU */
N#endif
N
N
N/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
N/** @brief   Core Debug register structure definition */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM3_CoreDebug */
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5040049 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S *
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @return BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  basePri  BasePriority
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @return FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  faultMask  faultMask value
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N *
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit values)
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @return BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  basePri  BasePriority
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @return FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  faultMask  faultMask value
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S*
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive (8 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 8 bit value
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive (16 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 16 bit values
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive (32 bit)
S *
S * @param  *addr  address pointer
S * @return        value of (*address)
S *
S * Exclusive LDR command for 32 bit values
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive (8 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 8 bit values
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive (16 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 16 bit values
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive (32 bit)
S *
S * @param  value  value to store
S * @param  *addr  address pointer
S * @return        successful / failed
S *
S * Exclusive STR command for 32 bit values
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N
N/* ##########################   NVIC functions  #################################### */
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  PriorityGroup is priority grouping field
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFul << 16) | (7ul << 8));              
N  reg_value  =  (reg_value                       |
N                (0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                (0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR =  reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @return priority grouping field
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) >> 8);    
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N *
N * @param  IRQn   The positive number of the external interrupt to disable
N *
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N *
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending,
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for read active bit
N * @return         1 = interrupt active, 0 = interrupt not active
N *
N * Read the active register in NVIC and returns 1 if its status is active,
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt
N * number can be positive to specify an external (device specific)
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  PriorityGroup    The used priority group
N * @param  PreemptPriority  The preemptive priority value (starting from 0)
N * @param  SubPriority      The sub priority value (starting from 0)
N * @return                  The encoded priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  Priority           The priority for the interrupt
N * @param  PriorityGroup      The used priority group
N * @param  pPreemptPriority   The preemptive priority value (starting from 0)
N * @param  pSubPriority       The sub priority value (starting from 0)
N *
N * Decode an interrupt priority value with the given priority group to
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N
N  SysTick->RELOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->RELOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);   
N  SysTick->CURR   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CURR   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1ul << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (7ul << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1ul << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N
N/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface
N  Core Debug Interface containing:
N  - Core Debug Receive / Transmit Functions
N  - Core Debug Defines
N  - Core Debug Variables
N*/
N/*@{*/
N
Nextern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */
N#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param  ch   character to output
N * @return      character to output
N *
N * The function outputs a character via the ITM channel 0.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1ul << 24))  &&       
N      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X      (((ITM_Type *) (0xE0000000))->TCR & (1ul << 0))                  &&       
N      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000))->TER & (1ul << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/**
N * @brief  Inputs a character via variable ITM_RxBuffer
N *
N * @return      received character, -1 = no character received
N *
N * The function inputs a character via variable ITM_RxBuffer.
N * The function returns when no debugger is connected that has booked the output.
N * It is blocking when a debugger is connected, but the previous character send is not transmitted.
N */
Nstatic __INLINE int ITM_ReceiveChar (void) {
Xstatic __inline int ITM_ReceiveChar (void) {
N  int ch = -1;                               /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/**
N * @brief  Check if a character via variable ITM_RxBuffer is available
N *
N * @return      1 = character available, 0 = no character available
N *
N * The function checks  variable ITM_RxBuffer whether a character is available or not.
N * The function returns '1' if a character is available and '0' if no character is available.
N */
Nstatic __INLINE int ITM_CheckChar (void) {
Xstatic __inline int ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM3_core_definitions */
N
N#endif /* __CM3_CORE_H__ */
N
N /**
N  * @}
N  */
N
N/*lint -restore */
L 105 "..\Startup\LPC177x_8x.h" 2
N//#include "system_LPC177x_8x.h"                 /* System Header                                      */
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;                   /*!< Offset: 0x000 (R/W)  Flash Accelerator Configuration Register */
X  volatile uint32_t FLASHCFG;                    
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                    /*!< Offset: 0x080 (R/W)  PLL0 Control Register */
X  volatile uint32_t PLL0CON;                     
N  __IO uint32_t PLL0CFG;                    /*!< Offset: 0x084 (R/W)  PLL0 Configuration Register */
X  volatile uint32_t PLL0CFG;                     
N  __I  uint32_t PLL0STAT;                   /*!< Offset: 0x088 (R/ )  PLL0 Status Register */
X  volatile const  uint32_t PLL0STAT;                    
N  __O  uint32_t PLL0FEED;                   /*!< Offset: 0x08C ( /W)  PLL0 Feed Register */
X  volatile  uint32_t PLL0FEED;                    
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;                    /*!< Offset: 0x0A0 (R/W)  PLL1 Control Register */
X  volatile uint32_t PLL1CON;                     
N  __IO uint32_t PLL1CFG;                    /*!< Offset: 0x0A4 (R/W)  PLL1 Configuration Register */
X  volatile uint32_t PLL1CFG;                     
N  __I  uint32_t PLL1STAT;                   /*!< Offset: 0x0A8 (R/ )  PLL1 Status Register */
X  volatile const  uint32_t PLL1STAT;                    
N  __O  uint32_t PLL1FEED;                   /*!< Offset: 0x0AC ( /W)  PLL1 Feed Register */
X  volatile  uint32_t PLL1FEED;                    
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;                       /*!< Offset: 0x0C0 (R/W)  Power Control Register */
X  volatile uint32_t PCON;                        
N  __IO uint32_t PCONP;                      /*!< Offset: 0x0C4 (R/W)  Power Control for Peripherals Register */
X  volatile uint32_t PCONP;                       
N       uint32_t RESERVED3[14];
N  __IO uint32_t EMCCLKSEL;                  /*!< Offset: 0x100 (R/W)  External Memory Controller Clock Selection Register */
X  volatile uint32_t EMCCLKSEL;                   
N  __IO uint32_t CCLKSEL;                    /*!< Offset: 0x104 (R/W)  CPU Clock Selection Register */
X  volatile uint32_t CCLKSEL;                     
N  __IO uint32_t USBCLKSEL;                  /*!< Offset: 0x108 (R/W)  USB Clock Selection Register */
X  volatile uint32_t USBCLKSEL;                   
N  __IO uint32_t CLKSRCSEL;                  /*!< Offset: 0x10C (R/W)  Clock Source Select Register */
X  volatile uint32_t CLKSRCSEL;                   
N  __IO uint32_t	CANSLEEPCLR;                /*!< Offset: 0x110 (R/W)  CAN Sleep Clear Register */
X  volatile uint32_t	CANSLEEPCLR;                 
N  __IO uint32_t	CANWAKEFLAGS;               /*!< Offset: 0x114 (R/W)  CAN Wake-up Flags Register */
X  volatile uint32_t	CANWAKEFLAGS;                
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                     /*!< Offset: 0x140 (R/W)  External Interrupt Flag Register */
X  volatile uint32_t EXTINT;                      
N       uint32_t RESERVED5[1];
N  __IO uint32_t EXTMODE;                    /*!< Offset: 0x148 (R/W)  External Interrupt Mode Register */
X  volatile uint32_t EXTMODE;                     
N  __IO uint32_t EXTPOLAR;                   /*!< Offset: 0x14C (R/W)  External Interrupt Polarity Register */
X  volatile uint32_t EXTPOLAR;                    
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                       /*!< Offset: 0x180 (R/W)  Reset Source Identification Register */
X  volatile uint32_t RSID;                        
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                        /*!< Offset: 0x1A0 (R/W)  System Controls and Status Register */
X  volatile uint32_t SCS;                         
N  __IO uint32_t IRCTRIM;                    /*!< Offset: 0x1A4 (R/W) Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                     
N  __IO uint32_t PCLKSEL;                    /*!< Offset: 0x1A8 (R/W)  Peripheral Clock Selection Register */
X  volatile uint32_t PCLKSEL;                     
N       uint32_t RESERVED8[3];
N  __IO uint32_t LCD_CFG;                    /*!< Offset: 0x1B8 (R/W)  LCD Configuration and clocking control Register */
X  volatile uint32_t LCD_CFG;                     
N       uint32_t RESERVED9[1];
N  __IO uint32_t USBIntSt;                   /*!< Offset: 0x1C0 (R/W)  USB Interrupt Status Register */
X  volatile uint32_t USBIntSt;                    
N  __IO uint32_t DMAREQSEL;                  /*!< Offset: 0x1C4 (R/W)  DMA Request Select Register */
X  volatile uint32_t DMAREQSEL;                   
N  __IO uint32_t CLKOUTCFG;                  /*!< Offset: 0x1C8 (R/W)  Clock Output Configuration Register */
X  volatile uint32_t CLKOUTCFG;                   
N  __IO uint32_t RSTCON0;                    /*!< Offset: 0x1CC (R/W)  RESET Control0 Register */
X  volatile uint32_t RSTCON0;                     
N  __IO uint32_t RSTCON1;                    /*!< Offset: 0x1D0 (R/W)  RESET Control1 Register */
X  volatile uint32_t RSTCON1;                     
N       uint32_t RESERVED10[2];
N  __IO uint32_t EMCDLYCTL;                  /*!< Offset: 0x1DC (R/W) SDRAM programmable delays          */
X  volatile uint32_t EMCDLYCTL;                   
N  __IO uint32_t EMCCAL;                     /*!< Offset: 0x1E0 (R/W) Calibration of programmable delays */
X  volatile uint32_t EMCCAL;                      
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t P0_0;				/* 0x000 */
X  volatile uint32_t P0_0;				 
N  __IO uint32_t P0_1;
X  volatile uint32_t P0_1;
N  __IO uint32_t P0_2;
X  volatile uint32_t P0_2;
N  __IO uint32_t P0_3;
X  volatile uint32_t P0_3;
N  __IO uint32_t P0_4;
X  volatile uint32_t P0_4;
N  __IO uint32_t P0_5;
X  volatile uint32_t P0_5;
N  __IO uint32_t P0_6;
X  volatile uint32_t P0_6;
N  __IO uint32_t P0_7;
X  volatile uint32_t P0_7;
N
N  __IO uint32_t P0_8;				/* 0x020 */
X  volatile uint32_t P0_8;				 
N  __IO uint32_t P0_9;
X  volatile uint32_t P0_9;
N  __IO uint32_t P0_10;
X  volatile uint32_t P0_10;
N  __IO uint32_t P0_11;
X  volatile uint32_t P0_11;
N  __IO uint32_t P0_12;
X  volatile uint32_t P0_12;
N  __IO uint32_t P0_13;
X  volatile uint32_t P0_13;
N  __IO uint32_t P0_14;
X  volatile uint32_t P0_14;
N  __IO uint32_t P0_15;
X  volatile uint32_t P0_15;
N
N  __IO uint32_t P0_16;				/* 0x040 */
X  volatile uint32_t P0_16;				 
N  __IO uint32_t P0_17;
X  volatile uint32_t P0_17;
N  __IO uint32_t P0_18;
X  volatile uint32_t P0_18;
N  __IO uint32_t P0_19;
X  volatile uint32_t P0_19;
N  __IO uint32_t P0_20;
X  volatile uint32_t P0_20;
N  __IO uint32_t P0_21;
X  volatile uint32_t P0_21;
N  __IO uint32_t P0_22;
X  volatile uint32_t P0_22;
N  __IO uint32_t P0_23;
X  volatile uint32_t P0_23;
N
N  __IO uint32_t P0_24;				/* 0x060 */
X  volatile uint32_t P0_24;				 
N  __IO uint32_t P0_25;
X  volatile uint32_t P0_25;
N  __IO uint32_t P0_26;
X  volatile uint32_t P0_26;
N  __IO uint32_t P0_27;
X  volatile uint32_t P0_27;
N  __IO uint32_t P0_28;
X  volatile uint32_t P0_28;
N  __IO uint32_t P0_29;
X  volatile uint32_t P0_29;
N  __IO uint32_t P0_30;
X  volatile uint32_t P0_30;
N  __IO uint32_t P0_31;
X  volatile uint32_t P0_31;
N
N  __IO uint32_t P1_0;				/* 0x080 */
X  volatile uint32_t P1_0;				 
N  __IO uint32_t P1_1;
X  volatile uint32_t P1_1;
N  __IO uint32_t P1_2;
X  volatile uint32_t P1_2;
N  __IO uint32_t P1_3;
X  volatile uint32_t P1_3;
N  __IO uint32_t P1_4;
X  volatile uint32_t P1_4;
N  __IO uint32_t P1_5;
X  volatile uint32_t P1_5;
N  __IO uint32_t P1_6;
X  volatile uint32_t P1_6;
N  __IO uint32_t P1_7;
X  volatile uint32_t P1_7;
N
N  __IO uint32_t P1_8;				/* 0x0A0 */
X  volatile uint32_t P1_8;				 
N  __IO uint32_t P1_9;
X  volatile uint32_t P1_9;
N  __IO uint32_t P1_10;
X  volatile uint32_t P1_10;
N  __IO uint32_t P1_11;
X  volatile uint32_t P1_11;
N  __IO uint32_t P1_12;
X  volatile uint32_t P1_12;
N  __IO uint32_t P1_13;
X  volatile uint32_t P1_13;
N  __IO uint32_t P1_14;
X  volatile uint32_t P1_14;
N  __IO uint32_t P1_15;
X  volatile uint32_t P1_15;
N
N  __IO uint32_t P1_16;				/* 0x0C0 */
X  volatile uint32_t P1_16;				 
N  __IO uint32_t P1_17;
X  volatile uint32_t P1_17;
N  __IO uint32_t P1_18;
X  volatile uint32_t P1_18;
N  __IO uint32_t P1_19;
X  volatile uint32_t P1_19;
N  __IO uint32_t P1_20;
X  volatile uint32_t P1_20;
N  __IO uint32_t P1_21;
X  volatile uint32_t P1_21;
N  __IO uint32_t P1_22;
X  volatile uint32_t P1_22;
N  __IO uint32_t P1_23;
X  volatile uint32_t P1_23;
N
N  __IO uint32_t P1_24;				/* 0x0E0 */
X  volatile uint32_t P1_24;				 
N  __IO uint32_t P1_25;
X  volatile uint32_t P1_25;
N  __IO uint32_t P1_26;
X  volatile uint32_t P1_26;
N  __IO uint32_t P1_27;
X  volatile uint32_t P1_27;
N  __IO uint32_t P1_28;
X  volatile uint32_t P1_28;
N  __IO uint32_t P1_29;
X  volatile uint32_t P1_29;
N  __IO uint32_t P1_30;
X  volatile uint32_t P1_30;
N  __IO uint32_t P1_31;
X  volatile uint32_t P1_31;
N
N  __IO uint32_t P2_0;				/* 0x100 */
X  volatile uint32_t P2_0;				 
N  __IO uint32_t P2_1;
X  volatile uint32_t P2_1;
N  __IO uint32_t P2_2;
X  volatile uint32_t P2_2;
N  __IO uint32_t P2_3;
X  volatile uint32_t P2_3;
N  __IO uint32_t P2_4;
X  volatile uint32_t P2_4;
N  __IO uint32_t P2_5;
X  volatile uint32_t P2_5;
N  __IO uint32_t P2_6;
X  volatile uint32_t P2_6;
N  __IO uint32_t P2_7;
X  volatile uint32_t P2_7;
N
N  __IO uint32_t P2_8;				/* 0x120 */
X  volatile uint32_t P2_8;				 
N  __IO uint32_t P2_9;
X  volatile uint32_t P2_9;
N  __IO uint32_t P2_10;
X  volatile uint32_t P2_10;
N  __IO uint32_t P2_11;
X  volatile uint32_t P2_11;
N  __IO uint32_t P2_12;
X  volatile uint32_t P2_12;
N  __IO uint32_t P2_13;
X  volatile uint32_t P2_13;
N  __IO uint32_t P2_14;
X  volatile uint32_t P2_14;
N  __IO uint32_t P2_15;
X  volatile uint32_t P2_15;
N
N  __IO uint32_t P2_16;				/* 0x140 */
X  volatile uint32_t P2_16;				 
N  __IO uint32_t P2_17;
X  volatile uint32_t P2_17;
N  __IO uint32_t P2_18;
X  volatile uint32_t P2_18;
N  __IO uint32_t P2_19;
X  volatile uint32_t P2_19;
N  __IO uint32_t P2_20;
X  volatile uint32_t P2_20;
N  __IO uint32_t P2_21;
X  volatile uint32_t P2_21;
N  __IO uint32_t P2_22;
X  volatile uint32_t P2_22;
N  __IO uint32_t P2_23;
X  volatile uint32_t P2_23;
N
N  __IO uint32_t P2_24;				/* 0x160 */
X  volatile uint32_t P2_24;				 
N  __IO uint32_t P2_25;
X  volatile uint32_t P2_25;
N  __IO uint32_t P2_26;
X  volatile uint32_t P2_26;
N  __IO uint32_t P2_27;
X  volatile uint32_t P2_27;
N  __IO uint32_t P2_28;
X  volatile uint32_t P2_28;
N  __IO uint32_t P2_29;
X  volatile uint32_t P2_29;
N  __IO uint32_t P2_30;
X  volatile uint32_t P2_30;
N  __IO uint32_t P2_31;
X  volatile uint32_t P2_31;
N
N  __IO uint32_t P3_0;				/* 0x180 */
X  volatile uint32_t P3_0;				 
N  __IO uint32_t P3_1;
X  volatile uint32_t P3_1;
N  __IO uint32_t P3_2;
X  volatile uint32_t P3_2;
N  __IO uint32_t P3_3;
X  volatile uint32_t P3_3;
N  __IO uint32_t P3_4;
X  volatile uint32_t P3_4;
N  __IO uint32_t P3_5;
X  volatile uint32_t P3_5;
N  __IO uint32_t P3_6;
X  volatile uint32_t P3_6;
N  __IO uint32_t P3_7;
X  volatile uint32_t P3_7;
N
N  __IO uint32_t P3_8;				/* 0x1A0 */
X  volatile uint32_t P3_8;				 
N  __IO uint32_t P3_9;
X  volatile uint32_t P3_9;
N  __IO uint32_t P3_10;
X  volatile uint32_t P3_10;
N  __IO uint32_t P3_11;
X  volatile uint32_t P3_11;
N  __IO uint32_t P3_12;
X  volatile uint32_t P3_12;
N  __IO uint32_t P3_13;
X  volatile uint32_t P3_13;
N  __IO uint32_t P3_14;
X  volatile uint32_t P3_14;
N  __IO uint32_t P3_15;
X  volatile uint32_t P3_15;
N
N  __IO uint32_t P3_16;				/* 0x1C0 */
X  volatile uint32_t P3_16;				 
N  __IO uint32_t P3_17;
X  volatile uint32_t P3_17;
N  __IO uint32_t P3_18;
X  volatile uint32_t P3_18;
N  __IO uint32_t P3_19;
X  volatile uint32_t P3_19;
N  __IO uint32_t P3_20;
X  volatile uint32_t P3_20;
N  __IO uint32_t P3_21;
X  volatile uint32_t P3_21;
N  __IO uint32_t P3_22;
X  volatile uint32_t P3_22;
N  __IO uint32_t P3_23;
X  volatile uint32_t P3_23;
N
N  __IO uint32_t P3_24;				/* 0x1E0 */
X  volatile uint32_t P3_24;				 
N  __IO uint32_t P3_25;
X  volatile uint32_t P3_25;
N  __IO uint32_t P3_26;
X  volatile uint32_t P3_26;
N  __IO uint32_t P3_27;
X  volatile uint32_t P3_27;
N  __IO uint32_t P3_28;
X  volatile uint32_t P3_28;
N  __IO uint32_t P3_29;
X  volatile uint32_t P3_29;
N  __IO uint32_t P3_30;
X  volatile uint32_t P3_30;
N  __IO uint32_t P3_31;
X  volatile uint32_t P3_31;
N
N  __IO uint32_t P4_0;				/* 0x200 */
X  volatile uint32_t P4_0;				 
N  __IO uint32_t P4_1;
X  volatile uint32_t P4_1;
N  __IO uint32_t P4_2;
X  volatile uint32_t P4_2;
N  __IO uint32_t P4_3;
X  volatile uint32_t P4_3;
N  __IO uint32_t P4_4;
X  volatile uint32_t P4_4;
N  __IO uint32_t P4_5;
X  volatile uint32_t P4_5;
N  __IO uint32_t P4_6;
X  volatile uint32_t P4_6;
N  __IO uint32_t P4_7;
X  volatile uint32_t P4_7;
N
N  __IO uint32_t P4_8;				/* 0x220 */
X  volatile uint32_t P4_8;				 
N  __IO uint32_t P4_9;
X  volatile uint32_t P4_9;
N  __IO uint32_t P4_10;
X  volatile uint32_t P4_10;
N  __IO uint32_t P4_11;
X  volatile uint32_t P4_11;
N  __IO uint32_t P4_12;
X  volatile uint32_t P4_12;
N  __IO uint32_t P4_13;
X  volatile uint32_t P4_13;
N  __IO uint32_t P4_14;
X  volatile uint32_t P4_14;
N  __IO uint32_t P4_15;
X  volatile uint32_t P4_15;
N
N  __IO uint32_t P4_16;				/* 0x240 */
X  volatile uint32_t P4_16;				 
N  __IO uint32_t P4_17;
X  volatile uint32_t P4_17;
N  __IO uint32_t P4_18;
X  volatile uint32_t P4_18;
N  __IO uint32_t P4_19;
X  volatile uint32_t P4_19;
N  __IO uint32_t P4_20;
X  volatile uint32_t P4_20;
N  __IO uint32_t P4_21;
X  volatile uint32_t P4_21;
N  __IO uint32_t P4_22;
X  volatile uint32_t P4_22;
N  __IO uint32_t P4_23;
X  volatile uint32_t P4_23;
N
N  __IO uint32_t P4_24;				/* 0x260 */
X  volatile uint32_t P4_24;				 
N  __IO uint32_t P4_25;
X  volatile uint32_t P4_25;
N  __IO uint32_t P4_26;
X  volatile uint32_t P4_26;
N  __IO uint32_t P4_27;
X  volatile uint32_t P4_27;
N  __IO uint32_t P4_28;
X  volatile uint32_t P4_28;
N  __IO uint32_t P4_29;
X  volatile uint32_t P4_29;
N  __IO uint32_t P4_30;
X  volatile uint32_t P4_30;
N  __IO uint32_t P4_31;
X  volatile uint32_t P4_31;
N
N  __IO uint32_t P5_0;				/* 0x280 */
X  volatile uint32_t P5_0;				 
N  __IO uint32_t P5_1;
X  volatile uint32_t P5_1;
N  __IO uint32_t P5_2;
X  volatile uint32_t P5_2;
N  __IO uint32_t P5_3;
X  volatile uint32_t P5_3;
N  __IO uint32_t P5_4;				/* 0x290 */
X  volatile uint32_t P5_4;				 
N} LPC_IOCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DIR;
X  volatile uint32_t DIR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t PIN;
X  volatile uint32_t PIN;
N  __IO uint32_t SET;
X  volatile uint32_t SET;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;                    /*!< Offset: 0x03C External Match Register (R/W) */
X  volatile uint32_t EMR;                     
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;                   /*!< Offset: 0x070 Count Control Register (R/W) */
X  volatile uint32_t CTCR;                    
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;                     /*!< Offset: 0x000 Interrupt Register (R/W) */
X  volatile uint32_t IR;                      
N  __IO uint32_t TCR;                    /*!< Offset: 0x004 Timer Control Register (R/W) */
X  volatile uint32_t TCR;                     
N  __IO uint32_t TC;                     /*!< Offset: 0x008 Timer Counter Register (R/W) */
X  volatile uint32_t TC;                      
N  __IO uint32_t PR;                     /*!< Offset: 0x00C Prescale Register (R/W) */
X  volatile uint32_t PR;                      
N  __IO uint32_t PC;                     /*!< Offset: 0x010 Prescale Counter Register (R/W) */
X  volatile uint32_t PC;                      
N  __IO uint32_t MCR;                    /*!< Offset: 0x014 Match Control Register (R/W) */
X  volatile uint32_t MCR;                     
N  __IO uint32_t MR0;                    /*!< Offset: 0x018 Match Register 0 (R/W) */
X  volatile uint32_t MR0;                     
N  __IO uint32_t MR1;                    /*!< Offset: 0x01C Match Register 1 (R/W) */
X  volatile uint32_t MR1;                     
N  __IO uint32_t MR2;                    /*!< Offset: 0x020 Match Register 2 (R/W) */
X  volatile uint32_t MR2;                     
N  __IO uint32_t MR3;                    /*!< Offset: 0x024 Match Register 3 (R/W) */
X  volatile uint32_t MR3;                     
N  __IO uint32_t CCR;                    /*!< Offset: 0x028 Capture Control Register (R/W) */
X  volatile uint32_t CCR;                     
N  __I  uint32_t CR0;                    /*!< Offset: 0x02C Capture Register 0 (R/ ) */
X  volatile const  uint32_t CR0;                     
N  __I  uint32_t CR1;					/*!< Offset: 0x030 Capture Register 1 (R/ ) */
X  volatile const  uint32_t CR1;					 
N  __I  uint32_t CR2;					/*!< Offset: 0x034 Capture Register 2 (R/ ) */
X  volatile const  uint32_t CR2;					 
N  __I  uint32_t CR3;					/*!< Offset: 0x038 Capture Register 3 (R/ ) */
X  volatile const  uint32_t CR3;					 
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;					/*!< Offset: 0x040 Match Register 4 (R/W) */
X  volatile uint32_t MR4;					 
N  __IO uint32_t MR5;					/*!< Offset: 0x044 Match Register 5 (R/W) */
X  volatile uint32_t MR5;					 
N  __IO uint32_t MR6;					/*!< Offset: 0x048 Match Register 6 (R/W) */
X  volatile uint32_t MR6;					 
N  __IO uint32_t PCR;					/*!< Offset: 0x04C PWM Control Register (R/W) */
X  volatile uint32_t PCR;					 
N  __IO uint32_t LER;					/*!< Offset: 0x050 Load Enable Register (R/W) */
X  volatile uint32_t LER;					 
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;					/*!< Offset: 0x070 Counter Control Register (R/W) */
X  volatile uint32_t CTCR;					 
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UARTx) -----------*/
N/* There are three types of UARTs on the chip:
N(1) UART0,UART2, and UART3 are the standard UART.
N(2) UART1 is the standard with modem capability.
N(3) USART(UART4) is the sync/async UART with smart card capability.
NMore details can be found on the Users Manual. */
N
N#if 0
Stypedef struct
S{
S  union {
S  __I  uint8_t  RBR;
S  __O  uint8_t  THR;
S  __IO uint8_t  DLL;
S       uint32_t RESERVED0;
S  };
S  union {
S  __IO uint8_t  DLM;
S  __IO uint32_t IER;
S  };
S  union {
S  __I  uint32_t IIR;
S  __O  uint8_t  FCR;
S  };
S  __IO uint8_t  LCR;
S       uint8_t  RESERVED1[7];
S  __I  uint8_t  LSR;
S       uint8_t  RESERVED2[7];
S  __IO uint8_t  SCR;
S       uint8_t  RESERVED3[3];
S  __IO uint32_t ACR;
S  __IO uint8_t  ICR;
S       uint8_t  RESERVED4[3];
S  __IO uint8_t  FDR;
S       uint8_t  RESERVED5[7];
S  __IO uint8_t  TER;
S       uint8_t  RESERVED6[39];
S  __I  uint8_t  FIFOLVL;
S} LPC_UART_TypeDef;
N#else
Ntypedef struct
N{
N	union
N	{
N		__I  uint8_t  RBR;
X		volatile const  uint8_t  RBR;
N		__O  uint8_t  THR;
X		volatile  uint8_t  THR;
N		__IO uint8_t  DLL;
X		volatile uint8_t  DLL;
N		uint32_t RESERVED0;
N	};
N	union
N	{
N		__IO uint8_t  DLM;
X		volatile uint8_t  DLM;
N		__IO uint32_t IER;
X		volatile uint32_t IER;
N	};
N	union
N	{
N		__I  uint32_t IIR;
X		volatile const  uint32_t IIR;
N		__O  uint8_t  FCR;
X		volatile  uint8_t  FCR;
N	};
N	__IO uint8_t  LCR;
X	volatile uint8_t  LCR;
N	uint8_t  RESERVED1[7];//Reserved
N	__I  uint8_t  LSR;
X	volatile const  uint8_t  LSR;
N	uint8_t  RESERVED2[7];//Reserved
N	__IO uint8_t  SCR;
X	volatile uint8_t  SCR;
N	uint8_t  RESERVED3[3];//Reserved
N	__IO uint32_t ACR;
X	volatile uint32_t ACR;
N	__IO uint8_t  ICR;
X	volatile uint8_t  ICR;
N	uint8_t  RESERVED4[3];//Reserved
N	__IO uint8_t  FDR;
X	volatile uint8_t  FDR;
N	uint8_t  RESERVED5[7];//Reserved
N	__IO uint8_t  TER;
X	volatile uint8_t  TER;
N	uint8_t  RESERVED8[27];//Reserved
N	__IO uint8_t  RS485CTRL;
X	volatile uint8_t  RS485CTRL;
N	uint8_t  RESERVED9[3];//Reserved
N	__IO uint8_t  ADRMATCH;
X	volatile uint8_t  ADRMATCH;
N	uint8_t  RESERVED10[3];//Reserved
N	__IO uint8_t  RS485DLY;
X	volatile uint8_t  RS485DLY;
N	uint8_t  RESERVED11[3];//Reserved
N	__I  uint8_t  FIFOLVL;
X	volatile const  uint8_t  FIFOLVL;
N}LPC_UART_TypeDef;
N#endif
N
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __I  uint8_t  FIFOLVL;
X  volatile const  uint8_t  FIFOLVL;
N} LPC_UART1_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;                   /*!< Offset: 0x000 Receiver Buffer  Register (R/ ) */
X  volatile const  uint32_t  RBR;                    
N  __O  uint32_t  THR;                   /*!< Offset: 0x000 Transmit Holding Register ( /W) */
X  volatile  uint32_t  THR;                    
N  __IO uint32_t  DLL;                   /*!< Offset: 0x000 Divisor Latch LSB (R/W) */
X  volatile uint32_t  DLL;                    
N  };
N  union {
N  __IO uint32_t  DLM;                   /*!< Offset: 0x004 Divisor Latch MSB (R/W) */
X  volatile uint32_t  DLM;                    
N  __IO uint32_t  IER;                   /*!< Offset: 0x000 Interrupt Enable Register (R/W) */
X  volatile uint32_t  IER;                    
N  };
N  union {
N  __I  uint32_t  IIR;                   /*!< Offset: 0x008 Interrupt ID Register (R/ ) */
X  volatile const  uint32_t  IIR;                    
N  __O  uint32_t  FCR;                   /*!< Offset: 0x008 FIFO Control Register ( /W) */
X  volatile  uint32_t  FCR;                    
N  };
N  __IO uint32_t  LCR;                   /*!< Offset: 0x00C Line Control Register (R/W) */
X  volatile uint32_t  LCR;                    
N  __IO uint32_t  MCR;                   /*!< Offset: 0x010 Modem control Register (R/W) */
X  volatile uint32_t  MCR;                    
N  __I  uint32_t  LSR;                   /*!< Offset: 0x014 Line Status Register (R/ ) */
X  volatile const  uint32_t  LSR;                    
N  __I  uint32_t  MSR;                   /*!< Offset: 0x018 Modem status Register (R/ ) */
X  volatile const  uint32_t  MSR;                    
N  __IO uint32_t  SCR;                   /*!< Offset: 0x01C Scratch Pad Register (R/W) */
X  volatile uint32_t  SCR;                    
N  __IO uint32_t  ACR;                   /*!< Offset: 0x020 Auto-baud Control Register (R/W) */
X  volatile uint32_t  ACR;                    
N  __IO uint32_t  ICR;                   /*!< Offset: 0x024 irDA Control Register (R/W) */
X  volatile uint32_t  ICR;                    
N  __IO uint32_t  FDR;                   /*!< Offset: 0x028 Fractional Divider Register (R/W) */
X  volatile uint32_t  FDR;                    
N  __IO uint32_t  OSR;                   /*!< Offset: 0x02C Over sampling Register (R/W) */
X  volatile uint32_t  OSR;                    
N  __O  uint32_t  POP;                   /*!< Offset: 0x030 NHP Pop Register (W) */
X  volatile  uint32_t  POP;                    
N  __IO uint32_t  MODE;                  /*!< Offset: 0x034 NHP Mode selection Register (W) */
X  volatile uint32_t  MODE;                   
N       uint32_t  RESERVED0[2];
N  __IO uint32_t  HDEN;                  /*!< Offset: 0x040 Half duplex Enable Register (R/W) */
X  volatile uint32_t  HDEN;                   
N       uint32_t  RESERVED1;
N  __IO uint32_t  SCI_CTRL;				/*!< Offset: 0x048 Smart card Interface Control Register (R/W) */
X  volatile uint32_t  SCI_CTRL;				 
N  __IO uint32_t  RS485CTRL;             /*!< Offset: 0x04C RS-485/EIA-485 Control Register (R/W) */
X  volatile uint32_t  RS485CTRL;              
N  __IO uint32_t  ADRMATCH;              /*!< Offset: 0x050 RS-485/EIA-485 address match Register (R/W) */
X  volatile uint32_t  ADRMATCH;               
N  __IO uint32_t  RS485DLY;              /*!< Offset: 0x054 RS-485/EIA-485 direction control delay Register (R/W) */
X  volatile uint32_t  RS485DLY;               
N  __IO uint32_t  SYNCCTRL;              /*!< Offset: 0x058 Synchronous Mode Control Register (R/W ) */
X  volatile uint32_t  SYNCCTRL;               
N  __IO uint32_t  TER;                   /*!< Offset: 0x05C Transmit Enable Register (R/W) */
X  volatile uint32_t  TER;                    
N       uint32_t  RESERVED2[989];
N  __I  uint32_t  CFG;                   /*!< Offset: 0xFD4 Configuration Register (R) */
X  volatile const  uint32_t  CFG;                    
N  __O  uint32_t  INTCE;                 /*!< Offset: 0xFD8 Interrupt Clear Enable Register (W) */
X  volatile  uint32_t  INTCE;                  
N  __O  uint32_t  INTSE;                 /*!< Offset: 0xFDC Interrupt Set Enable Register (W) */
X  volatile  uint32_t  INTSE;                  
N  __I  uint32_t  INTS;                  /*!< Offset: 0xFE0 Interrupt Status Register (R) */
X  volatile const  uint32_t  INTS;                   
N  __I  uint32_t  INTE;                  /*!< Offset: 0xFE4 Interrupt Enable Register (R) */
X  volatile const  uint32_t  INTE;                   
N  __O  uint32_t  INTCS;                 /*!< Offset: 0xFE8 Interrupt Clear Status Register (W) */
X  volatile  uint32_t  INTCS;                  
N  __O  uint32_t  INTSS;                 /*!< Offset: 0xFEC Interrupt Set Status Register (W) */
X  volatile  uint32_t  INTSS;                  
N       uint32_t  RESERVED3[3];
N  __I  uint32_t  MID;                   /*!< Offset: 0xFFC Module Identification Register (R) */
X  volatile const  uint32_t  MID;                    
N} LPC_UART4_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;                    /*!< Offset: 0x000 Control Register 0 (R/W) */
X  volatile uint32_t CR0;                     
N  __IO uint32_t CR1;                    /*!< Offset: 0x004 Control Register 1 (R/W) */
X  volatile uint32_t CR1;                     
N  __IO uint32_t DR;                     /*!< Offset: 0x008 Data Register (R/W) */
X  volatile uint32_t DR;                      
N  __I  uint32_t SR;                     /*!< Offset: 0x00C Status Registe (R/ ) */
X  volatile const  uint32_t SR;                      
N  __IO uint32_t CPSR;                   /*!< Offset: 0x010 Clock Prescale Register (R/W) */
X  volatile uint32_t CPSR;                    
N  __IO uint32_t IMSC;                   /*!< Offset: 0x014 Interrupt Mask Set and Clear Register (R/W) */
X  volatile uint32_t IMSC;                    
N  __IO uint32_t RIS;                    /*!< Offset: 0x018 Raw Interrupt Status Register (R/W) */
X  volatile uint32_t RIS;                     
N  __IO uint32_t MIS;                    /*!< Offset: 0x01C Masked Interrupt Status Register (R/W) */
X  volatile uint32_t MIS;                     
N  __IO uint32_t ICR;                    /*!< Offset: 0x020 SSPICR Interrupt Clear Register (R/W) */
X  volatile uint32_t ICR;                     
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CONSET;                 /*!< Offset: 0x000 I2C Control Set Register (R/W) */
X  volatile uint32_t CONSET;                  
N  __I  uint32_t STAT;                   /*!< Offset: 0x004 I2C Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t DAT;                    /*!< Offset: 0x008 I2C Data Register (R/W) */
X  volatile uint32_t DAT;                     
N  __IO uint32_t ADR0;                   /*!< Offset: 0x00C I2C Slave Address Register 0 (R/W) */
X  volatile uint32_t ADR0;                    
N  __IO uint32_t SCLH;                   /*!< Offset: 0x010 SCH Duty Cycle Register High Half Word (R/W) */
X  volatile uint32_t SCLH;                    
N  __IO uint32_t SCLL;                   /*!< Offset: 0x014 SCL Duty Cycle Register Low Half Word (R/W) */
X  volatile uint32_t SCLL;                    
N  __O  uint32_t CONCLR;                 /*!< Offset: 0x018 I2C Control Clear Register ( /W) */
X  volatile  uint32_t CONCLR;                  
N  __IO uint32_t MMCTRL;                 /*!< Offset: 0x01C Monitor mode control register (R/W) */
X  volatile uint32_t MMCTRL;                  
N  __IO uint32_t ADR1;                   /*!< Offset: 0x020 I2C Slave Address Register 1 (R/W) */
X  volatile uint32_t ADR1;                    
N  __IO uint32_t ADR2;                   /*!< Offset: 0x024 I2C Slave Address Register 2 (R/W) */
X  volatile uint32_t ADR2;                    
N  __IO uint32_t ADR3;                   /*!< Offset: 0x028 I2C Slave Address Register 3 (R/W) */
X  volatile uint32_t ADR3;                    
N  __I  uint32_t DATA_BUFFER;            /*!< Offset: 0x02C Data buffer register ( /W) */
X  volatile const  uint32_t DATA_BUFFER;             
N  __IO uint32_t MASK0;                  /*!< Offset: 0x030 I2C Slave address mask register 0 (R/W) */
X  volatile uint32_t MASK0;                   
N  __IO uint32_t MASK1;                  /*!< Offset: 0x034 I2C Slave address mask register 1 (R/W) */
X  volatile uint32_t MASK1;                   
N  __IO uint32_t MASK2;                  /*!< Offset: 0x038 I2C Slave address mask register 2 (R/W) */
X  volatile uint32_t MASK2;                   
N  __IO uint32_t MASK3;                  /*!< Offset: 0x03C I2C Slave address mask register 3 (R/W) */
X  volatile uint32_t MASK3;                   
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DAO;
X  volatile uint32_t DAO;
N  __IO uint32_t DAI;
X  volatile uint32_t DAI;
N  __O  uint32_t TXFIFO;
X  volatile  uint32_t TXFIFO;
N  __I  uint32_t RXFIFO;
X  volatile const  uint32_t RXFIFO;
N  __I  uint32_t STATE;
X  volatile const  uint32_t STATE;
N  __IO uint32_t DMA1;
X  volatile uint32_t DMA1;
N  __IO uint32_t DMA2;
X  volatile uint32_t DMA2;
N  __IO uint32_t IRQ;
X  volatile uint32_t IRQ;
N  __IO uint32_t TXRATE;
X  volatile uint32_t TXRATE;
N  __IO uint32_t RXRATE;
X  volatile uint32_t RXRATE;
N  __IO uint32_t TXBITRATE;
X  volatile uint32_t TXBITRATE;
N  __IO uint32_t RXBITRATE;
X  volatile uint32_t RXBITRATE;
N  __IO uint32_t TXMODE;
X  volatile uint32_t TXMODE;
N  __IO uint32_t RXMODE;
X  volatile uint32_t RXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N  __IO uint32_t ERSTATUS;
X  volatile uint32_t ERSTATUS;
N  __IO uint32_t ERCONTROL;
X  volatile uint32_t ERCONTROL;
N  __IO uint32_t ERCOUNTERS;
X  volatile uint32_t ERCOUNTERS;
N       uint32_t RESERVED22;
N  __IO uint32_t ERFIRSTSTAMP0;
X  volatile uint32_t ERFIRSTSTAMP0;
N  __IO uint32_t ERFIRSTSTAMP1;
X  volatile uint32_t ERFIRSTSTAMP1;
N  __IO uint32_t ERFIRSTSTAMP2;
X  volatile uint32_t ERFIRSTSTAMP2;
N       uint32_t RESERVED23;
N  __IO uint32_t ERLASTSTAMP0;
X  volatile uint32_t ERLASTSTAMP0;
N  __IO uint32_t ERLASTSTAMP1;
X  volatile uint32_t ERLASTSTAMP1;
N  __IO uint32_t ERLASTSTAMP2;
X  volatile uint32_t ERLASTSTAMP2;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  MOD;
X  volatile uint8_t  MOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __O  uint8_t  FEED;
X  volatile  uint8_t  FEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t TV;
X  volatile const  uint32_t TV;
N       uint32_t RESERVED2;
N  __IO uint32_t WARNINT;
X  volatile uint32_t WARNINT;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;                     /*!< Offset: 0x000       A/D Control Register (R/W) */
X  volatile uint32_t CR;                      
N  __IO uint32_t GDR;                    /*!< Offset: 0x004       A/D Global Data Register (R/W) */
X  volatile uint32_t GDR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t INTEN;                  /*!< Offset: 0x00C       A/D Interrupt Enable Register (R/W) */
X  volatile uint32_t INTEN;                   
N  __IO uint32_t DR[8];                  /*!< Offset: 0x010-0x02C A/D Channel 0..7 Data Register (R/W) */
X  volatile uint32_t DR[8];                   
N  __I  uint32_t STAT;                   /*!< Offset: 0x030       A/D Status Register (R/ ) */
X  volatile const  uint32_t STAT;                    
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t CNTVAL;
X  volatile uint32_t CNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t CON;
X  volatile const  uint32_t CON;
N  __O  uint32_t CON_SET;
X  volatile  uint32_t CON_SET;
N  __O  uint32_t CON_CLR;
X  volatile  uint32_t CON_CLR;
N  __I  uint32_t CAPCON;
X  volatile const  uint32_t CAPCON;
N  __O  uint32_t CAPCON_SET;
X  volatile  uint32_t CAPCON_SET;
N  __O  uint32_t CAPCON_CLR;
X  volatile  uint32_t CAPCON_CLR;
N  __IO uint32_t TC0;
X  volatile uint32_t TC0;
N  __IO uint32_t TC1;
X  volatile uint32_t TC1;
N  __IO uint32_t TC2;
X  volatile uint32_t TC2;
N  __IO uint32_t LIM0;
X  volatile uint32_t LIM0;
N  __IO uint32_t LIM1;
X  volatile uint32_t LIM1;
N  __IO uint32_t LIM2;
X  volatile uint32_t LIM2;
N  __IO uint32_t MAT0;
X  volatile uint32_t MAT0;
N  __IO uint32_t MAT1;
X  volatile uint32_t MAT1;
N  __IO uint32_t MAT2;
X  volatile uint32_t MAT2;
N  __IO uint32_t DT;
X  volatile uint32_t DT;
N  __IO uint32_t CP;
X  volatile uint32_t CP;
N  __IO uint32_t CAP0;
X  volatile uint32_t CAP0;
N  __IO uint32_t CAP1;
X  volatile uint32_t CAP1;
N  __IO uint32_t CAP2;
X  volatile uint32_t CAP2;
N  __I  uint32_t INTEN;
X  volatile const  uint32_t INTEN;
N  __O  uint32_t INTEN_SET;
X  volatile  uint32_t INTEN_SET;
N  __O  uint32_t INTEN_CLR;
X  volatile  uint32_t INTEN_CLR;
N  __I  uint32_t CNTCON;
X  volatile const  uint32_t CNTCON;
N  __O  uint32_t CNTCON_SET;
X  volatile  uint32_t CNTCON_SET;
N  __O  uint32_t CNTCON_CLR;
X  volatile  uint32_t CNTCON_CLR;
N  __I  uint32_t INTF;
X  volatile const  uint32_t INTF;
N  __O  uint32_t INTF_SET;
X  volatile  uint32_t INTF_SET;
N  __O  uint32_t INTF_CLR;
X  volatile  uint32_t INTF_CLR;
N  __O  uint32_t CAP_CLR;
X  volatile  uint32_t CAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t CON;
X  volatile  uint32_t CON;
N  __I  uint32_t STAT;
X  volatile const  uint32_t STAT;
N  __IO uint32_t CONF;
X  volatile uint32_t CONF;
N  __I  uint32_t POS;
X  volatile const  uint32_t POS;
N  __IO uint32_t MAXPOS;
X  volatile uint32_t MAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP0;
X  volatile uint32_t INXCMP0;
N  __IO uint32_t LOAD;
X  volatile uint32_t LOAD;
N  __I  uint32_t TIME;
X  volatile const  uint32_t TIME;
N  __I  uint32_t VEL;
X  volatile const  uint32_t VEL;
N  __I  uint32_t CAP;
X  volatile const  uint32_t CAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTERPHA;
X  volatile uint32_t FILTERPHA;
N  __IO uint32_t FILTERPHB;
X  volatile uint32_t FILTERPHB;
N  __IO uint32_t FILTERINX;
X  volatile uint32_t FILTERINX;
N  __IO uint32_t WINDOW;
X  volatile uint32_t WINDOW;
N  __IO uint32_t INXCMP1;
X  volatile uint32_t INXCMP1;
N  __IO uint32_t INXCMP2;
X  volatile uint32_t INXCMP2;
N       uint32_t RESERVED0[993];
N  __O  uint32_t IEC;
X  volatile  uint32_t IEC;
N  __O  uint32_t IES;
X  volatile  uint32_t IES;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __I  uint32_t IE;
X  volatile const  uint32_t IE;
N  __O  uint32_t CLR;
X  volatile  uint32_t CLR;
N  __O  uint32_t SET;
X  volatile  uint32_t SET;
N} LPC_QEI_TypeDef;
N
N/*------------- SD/MMC card Interface (MCI)-----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t POWER;
X  volatile uint32_t POWER;
N  __IO uint32_t CLOCK;
X  volatile uint32_t CLOCK;
N  __IO uint32_t ARGUMENT;
X  volatile uint32_t ARGUMENT;
N  __IO uint32_t COMMAND;
X  volatile uint32_t COMMAND;
N  __I  uint32_t RESP_CMD;
X  volatile const  uint32_t RESP_CMD;
N  __I  uint32_t RESP0;
X  volatile const  uint32_t RESP0;
N  __I  uint32_t RESP1;
X  volatile const  uint32_t RESP1;
N  __I  uint32_t RESP2;
X  volatile const  uint32_t RESP2;
N  __I  uint32_t RESP3;
X  volatile const  uint32_t RESP3;
N  __IO uint32_t DATATMR;
X  volatile uint32_t DATATMR;
N  __IO uint32_t DATALEN;
X  volatile uint32_t DATALEN;
N  __IO uint32_t DATACTRL;
X  volatile uint32_t DATACTRL;
N  __I  uint32_t DATACNT;
X  volatile const  uint32_t DATACNT;
N  __I  uint32_t STATUS;
X  volatile const  uint32_t STATUS;
N  __O  uint32_t CLEAR;
X  volatile  uint32_t CLEAR;
N  __IO uint32_t MASK0;
X  volatile uint32_t MASK0;
N       uint32_t RESERVED0[2];
N  __I  uint32_t FIFOCNT;
X  volatile const  uint32_t FIFOCNT;
N       uint32_t RESERVED1[13];
N  __IO uint32_t FIFO;
X  volatile uint32_t FIFO;
N} LPC_MCI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t TxSR;
X  volatile const  uint32_t TxSR;
N  __I  uint32_t RxSR;
X  volatile const  uint32_t RxSR;
N  __I  uint32_t MSR;
X  volatile const  uint32_t MSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t IntStat;
X  volatile const  uint32_t IntStat;
N  __I  uint32_t IntTCStat;
X  volatile const  uint32_t IntTCStat;
N  __O  uint32_t IntTCClear;
X  volatile  uint32_t IntTCClear;
N  __I  uint32_t IntErrStat;
X  volatile const  uint32_t IntErrStat;
N  __O  uint32_t IntErrClr;
X  volatile  uint32_t IntErrClr;
N  __I  uint32_t RawIntTCStat;
X  volatile const  uint32_t RawIntTCStat;
N  __I  uint32_t RawIntErrStat;
X  volatile const  uint32_t RawIntErrStat;
N  __I  uint32_t EnbldChns;
X  volatile const  uint32_t EnbldChns;
N  __IO uint32_t SoftBReq;
X  volatile uint32_t SoftBReq;
N  __IO uint32_t SoftSReq;
X  volatile uint32_t SoftSReq;
N  __IO uint32_t SoftLBReq;
X  volatile uint32_t SoftLBReq;
N  __IO uint32_t SoftLSReq;
X  volatile uint32_t SoftLSReq;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N  __IO uint32_t Sync;
X  volatile uint32_t Sync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t CSrcAddr;
X  volatile uint32_t CSrcAddr;
N  __IO uint32_t CDestAddr;
X  volatile uint32_t CDestAddr;
N  __IO uint32_t CLLI;
X  volatile uint32_t CLLI;
N  __IO uint32_t CControl;
X  volatile uint32_t CControl;
N  __IO uint32_t CConfig;
X  volatile uint32_t CConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t Revision;             /* USB Host Registers                 */
X  volatile const  uint32_t Revision;              
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __IO uint32_t CommandStatus;
X  volatile uint32_t CommandStatus;
N  __IO uint32_t InterruptStatus;
X  volatile uint32_t InterruptStatus;
N  __IO uint32_t InterruptEnable;
X  volatile uint32_t InterruptEnable;
N  __IO uint32_t InterruptDisable;
X  volatile uint32_t InterruptDisable;
N  __IO uint32_t HCCA;
X  volatile uint32_t HCCA;
N  __I  uint32_t PeriodCurrentED;
X  volatile const  uint32_t PeriodCurrentED;
N  __IO uint32_t ControlHeadED;
X  volatile uint32_t ControlHeadED;
N  __IO uint32_t ControlCurrentED;
X  volatile uint32_t ControlCurrentED;
N  __IO uint32_t BulkHeadED;
X  volatile uint32_t BulkHeadED;
N  __IO uint32_t BulkCurrentED;
X  volatile uint32_t BulkCurrentED;
N  __I  uint32_t DoneHead;
X  volatile const  uint32_t DoneHead;
N  __IO uint32_t FmInterval;
X  volatile uint32_t FmInterval;
N  __I  uint32_t FmRemaining;
X  volatile const  uint32_t FmRemaining;
N  __I  uint32_t FmNumber;
X  volatile const  uint32_t FmNumber;
N  __IO uint32_t PeriodicStart;
X  volatile uint32_t PeriodicStart;
N  __IO uint32_t LSTreshold;
X  volatile uint32_t LSTreshold;
N  __IO uint32_t RhDescriptorA;
X  volatile uint32_t RhDescriptorA;
N  __IO uint32_t RhDescriptorB;
X  volatile uint32_t RhDescriptorB;
N  __IO uint32_t RhStatus;
X  volatile uint32_t RhStatus;
N  __IO uint32_t RhPortStatus1;
X  volatile uint32_t RhPortStatus1;
N  __IO uint32_t RhPortStatus2;
X  volatile uint32_t RhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t IntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t IntSt;                
N  __IO uint32_t IntEn;
X  volatile uint32_t IntEn;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N  __O  uint32_t IntClr;
X  volatile  uint32_t IntClr;
N  __IO uint32_t StCtrl;
X  volatile uint32_t StCtrl;
N  __IO uint32_t Tmr;
X  volatile uint32_t Tmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t DevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t DevIntSt;             
N  __IO uint32_t DevIntEn;
X  volatile uint32_t DevIntEn;
N  __O  uint32_t DevIntClr;
X  volatile  uint32_t DevIntClr;
N  __O  uint32_t DevIntSet;
X  volatile  uint32_t DevIntSet;
N
N  __O  uint32_t CmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t CmdCode;              
N  __I  uint32_t CmdData;
X  volatile const  uint32_t CmdData;
N
N  __I  uint32_t RxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t RxData;               
N  __O  uint32_t TxData;
X  volatile  uint32_t TxData;
N  __I  uint32_t RxPLen;
X  volatile const  uint32_t RxPLen;
N  __O  uint32_t TxPLen;
X  volatile  uint32_t TxPLen;
N  __IO uint32_t Ctrl;
X  volatile uint32_t Ctrl;
N  __O  uint32_t DevIntPri;
X  volatile  uint32_t DevIntPri;
N
N  __I  uint32_t EpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t EpIntSt;              
N  __IO uint32_t EpIntEn;
X  volatile uint32_t EpIntEn;
N  __O  uint32_t EpIntClr;
X  volatile  uint32_t EpIntClr;
N  __O  uint32_t EpIntSet;
X  volatile  uint32_t EpIntSet;
N  __O  uint32_t EpIntPri;
X  volatile  uint32_t EpIntPri;
N
N  __IO uint32_t ReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t ReEp;                 
N  __O  uint32_t EpInd;
X  volatile  uint32_t EpInd;
N  __IO uint32_t MaxPSize;
X  volatile uint32_t MaxPSize;
N
N  __I  uint32_t DMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t DMARSt;               
N  __O  uint32_t DMARClr;
X  volatile  uint32_t DMARClr;
N  __O  uint32_t DMARSet;
X  volatile  uint32_t DMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t UDCAH;
X  volatile uint32_t UDCAH;
N  __I  uint32_t EpDMASt;
X  volatile const  uint32_t EpDMASt;
N  __O  uint32_t EpDMAEn;
X  volatile  uint32_t EpDMAEn;
N  __O  uint32_t EpDMADis;
X  volatile  uint32_t EpDMADis;
N  __I  uint32_t DMAIntSt;
X  volatile const  uint32_t DMAIntSt;
N  __IO uint32_t DMAIntEn;
X  volatile uint32_t DMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t EoTIntSt;
X  volatile const  uint32_t EoTIntSt;
N  __O  uint32_t EoTIntClr;
X  volatile  uint32_t EoTIntClr;
N  __O  uint32_t EoTIntSet;
X  volatile  uint32_t EoTIntSet;
N  __I  uint32_t NDDRIntSt;
X  volatile const  uint32_t NDDRIntSt;
N  __O  uint32_t NDDRIntClr;
X  volatile  uint32_t NDDRIntClr;
N  __O  uint32_t NDDRIntSet;
X  volatile  uint32_t NDDRIntSet;
N  __I  uint32_t SysErrIntSt;
X  volatile const  uint32_t SysErrIntSt;
N  __O  uint32_t SysErrIntClr;
X  volatile  uint32_t SysErrIntClr;
N  __O  uint32_t SysErrIntSet;
X  volatile  uint32_t SysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __IO  uint32_t I2C_STS;
X  volatile  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __I  uint32_t RxFilterWoLStatus;
X  volatile const  uint32_t RxFilterWoLStatus;
N  __O  uint32_t RxFilterWoLClear;
X  volatile  uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N/*------------- LCD controller (LCD) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t TIMH;                   /* LCD Registers                      */
X  volatile uint32_t TIMH;                    
N  __IO uint32_t TIMV;
X  volatile uint32_t TIMV;
N  __IO uint32_t POL;
X  volatile uint32_t POL;
N  __IO uint32_t LE;
X  volatile uint32_t LE;
N  __IO uint32_t UPBASE;
X  volatile uint32_t UPBASE;
N  __IO uint32_t LPBASE;
X  volatile uint32_t LPBASE;
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t INTMSK;
X  volatile uint32_t INTMSK;
N  __I  uint32_t INTRAW;
X  volatile const  uint32_t INTRAW;
N  __I  uint32_t INTSTAT;
X  volatile const  uint32_t INTSTAT;
N  __O  uint32_t INTCLR;
X  volatile  uint32_t INTCLR;
N  __I  uint32_t UPCURR;
X  volatile const  uint32_t UPCURR;
N  __I  uint32_t LPCURR;
X  volatile const  uint32_t LPCURR;
N       uint32_t RESERVED0[115];
N  __IO uint32_t PAL[128];
X  volatile uint32_t PAL[128];
N       uint32_t RESERVED1[256];
N  __IO uint32_t CRSR_IMG[256];
X  volatile uint32_t CRSR_IMG[256];
N  __IO uint32_t CRSR_CTRL;
X  volatile uint32_t CRSR_CTRL;
N  __IO uint32_t CRSR_CFG;
X  volatile uint32_t CRSR_CFG;
N  __IO uint32_t CRSR_PAL0;
X  volatile uint32_t CRSR_PAL0;
N  __IO uint32_t CRSR_PAL1;
X  volatile uint32_t CRSR_PAL1;
N  __IO uint32_t CRSR_XY;
X  volatile uint32_t CRSR_XY;
N  __IO uint32_t CRSR_CLIP;
X  volatile uint32_t CRSR_CLIP;
N       uint32_t RESERVED2[2];
N  __IO uint32_t CRSR_INTMSK;
X  volatile uint32_t CRSR_INTMSK;
N  __O  uint32_t CRSR_INTCLR;
X  volatile  uint32_t CRSR_INTCLR;
N  __I  uint32_t CRSR_INTRAW;
X  volatile const  uint32_t CRSR_INTRAW;
N  __I  uint32_t CRSR_INTSTAT;
X  volatile const  uint32_t CRSR_INTSTAT;
N} LPC_LCD_TypeDef;
N
N/*------------- External Memory Controller (EMC) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t Control;
X  volatile uint32_t Control;
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t Config;
X  volatile uint32_t Config;
N       uint32_t RESERVED0[5];
N  __IO uint32_t DynamicControl;
X  volatile uint32_t DynamicControl;
N  __IO uint32_t DynamicRefresh;
X  volatile uint32_t DynamicRefresh;
N  __IO uint32_t DynamicReadConfig;
X  volatile uint32_t DynamicReadConfig;
N       uint32_t RESERVED1[1];
N  __IO uint32_t DynamicRP;
X  volatile uint32_t DynamicRP;
N  __IO uint32_t DynamicRAS;
X  volatile uint32_t DynamicRAS;
N  __IO uint32_t DynamicSREX;
X  volatile uint32_t DynamicSREX;
N  __IO uint32_t DynamicAPR;
X  volatile uint32_t DynamicAPR;
N  __IO uint32_t DynamicDAL;
X  volatile uint32_t DynamicDAL;
N  __IO uint32_t DynamicWR;
X  volatile uint32_t DynamicWR;
N  __IO uint32_t DynamicRC;
X  volatile uint32_t DynamicRC;
N  __IO uint32_t DynamicRFC;
X  volatile uint32_t DynamicRFC;
N  __IO uint32_t DynamicXSR;
X  volatile uint32_t DynamicXSR;
N  __IO uint32_t DynamicRRD;
X  volatile uint32_t DynamicRRD;
N  __IO uint32_t DynamicMRD;
X  volatile uint32_t DynamicMRD;
N       uint32_t RESERVED2[9];
N  __IO uint32_t StaticExtendedWait;
X  volatile uint32_t StaticExtendedWait;
N       uint32_t RESERVED3[31];
N  __IO uint32_t DynamicConfig0;
X  volatile uint32_t DynamicConfig0;
N  __IO uint32_t DynamicRasCas0;
X  volatile uint32_t DynamicRasCas0;
N       uint32_t RESERVED4[6];
N  __IO uint32_t DynamicConfig1;
X  volatile uint32_t DynamicConfig1;
N  __IO uint32_t DynamicRasCas1;
X  volatile uint32_t DynamicRasCas1;
N       uint32_t RESERVED5[6];
N  __IO uint32_t DynamicConfig2;
X  volatile uint32_t DynamicConfig2;
N  __IO uint32_t DynamicRasCas2;
X  volatile uint32_t DynamicRasCas2;
N       uint32_t RESERVED6[6];
N  __IO uint32_t DynamicConfig3;
X  volatile uint32_t DynamicConfig3;
N  __IO uint32_t DynamicRasCas3;
X  volatile uint32_t DynamicRasCas3;
N       uint32_t RESERVED7[38];
N  __IO uint32_t StaticConfig0;
X  volatile uint32_t StaticConfig0;
N  __IO uint32_t StaticWaitWen0;
X  volatile uint32_t StaticWaitWen0;
N  __IO uint32_t StaticWaitOen0;
X  volatile uint32_t StaticWaitOen0;
N  __IO uint32_t StaticWaitRd0;
X  volatile uint32_t StaticWaitRd0;
N  __IO uint32_t StaticWaitPage0;
X  volatile uint32_t StaticWaitPage0;
N  __IO uint32_t StaticWaitWr0;
X  volatile uint32_t StaticWaitWr0;
N  __IO uint32_t StaticWaitTurn0;
X  volatile uint32_t StaticWaitTurn0;
N       uint32_t RESERVED8[1];
N  __IO uint32_t StaticConfig1;
X  volatile uint32_t StaticConfig1;
N  __IO uint32_t StaticWaitWen1;
X  volatile uint32_t StaticWaitWen1;
N  __IO uint32_t StaticWaitOen1;
X  volatile uint32_t StaticWaitOen1;
N  __IO uint32_t StaticWaitRd1;
X  volatile uint32_t StaticWaitRd1;
N  __IO uint32_t StaticWaitPage1;
X  volatile uint32_t StaticWaitPage1;
N  __IO uint32_t StaticWaitWr1;
X  volatile uint32_t StaticWaitWr1;
N  __IO uint32_t StaticWaitTurn1;
X  volatile uint32_t StaticWaitTurn1;
N       uint32_t RESERVED9[1];
N  __IO uint32_t StaticConfig2;
X  volatile uint32_t StaticConfig2;
N  __IO uint32_t StaticWaitWen2;
X  volatile uint32_t StaticWaitWen2;
N  __IO uint32_t StaticWaitOen2;
X  volatile uint32_t StaticWaitOen2;
N  __IO uint32_t StaticWaitRd2;
X  volatile uint32_t StaticWaitRd2;
N  __IO uint32_t StaticWaitPage2;
X  volatile uint32_t StaticWaitPage2;
N  __IO uint32_t StaticWaitWr2;
X  volatile uint32_t StaticWaitWr2;
N  __IO uint32_t StaticWaitTurn2;
X  volatile uint32_t StaticWaitTurn2;
N       uint32_t RESERVED10[1];
N  __IO uint32_t StaticConfig3;
X  volatile uint32_t StaticConfig3;
N  __IO uint32_t StaticWaitWen3;
X  volatile uint32_t StaticWaitWen3;
N  __IO uint32_t StaticWaitOen3;
X  volatile uint32_t StaticWaitOen3;
N  __IO uint32_t StaticWaitRd3;
X  volatile uint32_t StaticWaitRd3;
N  __IO uint32_t StaticWaitPage3;
X  volatile uint32_t StaticWaitPage3;
N  __IO uint32_t StaticWaitWr3;
X  volatile uint32_t StaticWaitWr3;
N  __IO uint32_t StaticWaitTurn3;
X  volatile uint32_t StaticWaitTurn3;
N} LPC_EMC_TypeDef;
N
N/*------------- CRC Engine (CRC) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t MODE;
X  volatile uint32_t MODE;
N  __IO uint32_t SEED;
X  volatile uint32_t SEED;
N  union {
N  __I  uint32_t SUM;
X  volatile const  uint32_t SUM;
N  __O  uint32_t WR_DATA_DWORD;
X  volatile  uint32_t WR_DATA_DWORD;
N  __O  uint16_t WR_DATA_WORD;
X  volatile  uint16_t WR_DATA_WORD;
N       uint16_t RESERVED_WORD;
N  __O  uint8_t WR_DATA_BYTE;
X  volatile  uint8_t WR_DATA_BYTE;
N       uint8_t RESERVED_BYTE[3];
N  };
N} LPC_CRC_TypeDef;
N
N/*------------- EEPROM Controller (EEPROM) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t CMD;			/* 0x0080 */
X  volatile uint32_t CMD;			 
N  __IO uint32_t ADDR;
X  volatile uint32_t ADDR;
N  __IO uint32_t WDATA;
X  volatile uint32_t WDATA;
N  __IO uint32_t RDATA;
X  volatile uint32_t RDATA;
N  __IO uint32_t WSTATE;			/* 0x0090 */
X  volatile uint32_t WSTATE;			 
N  __IO uint32_t CLKDIV;
X  volatile uint32_t CLKDIV;
N  __IO uint32_t PWRDWN;			/* 0x0098 */
X  volatile uint32_t PWRDWN;			 
N       uint32_t RESERVED0[975];
N  __IO uint32_t INT_CLR_ENABLE;	/* 0x0FD8 */
X  volatile uint32_t INT_CLR_ENABLE;	 
N  __IO uint32_t INT_SET_ENABLE;
X  volatile uint32_t INT_SET_ENABLE;
N  __IO uint32_t INT_STATUS;		/* 0x0FE0 */
X  volatile uint32_t INT_STATUS;		 
N  __IO uint32_t INT_ENABLE;
X  volatile uint32_t INT_ENABLE;
N  __IO uint32_t INT_CLR_STATUS;
X  volatile uint32_t INT_CLR_STATUS;
N  __IO uint32_t INT_SET_STATUS;
X  volatile uint32_t INT_SET_STATUS;
N} LPC_EEPROM_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_PERI_RAM_BASE     (0x20000000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHBRAM1_BASE      (0x20004000UL)
N#define LPC_AHB_BASE          (0x20080000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM0_BASE         (LPC_APB0_BASE + 0x14000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_IOCON_BASE        (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_UART4_BASE        (LPC_APB1_BASE + 0x24000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_SSP2_BASE         (LPC_APB1_BASE + 0x2C000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_MCI_BASE          (LPC_APB1_BASE + 0x40000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x00100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x00120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x00140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x00160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x00180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x001A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x001C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x001E0)
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x04000)
N#define LPC_LCD_BASE          (LPC_AHB_BASE  + 0x08000)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N#define LPC_CRC_BASE          (LPC_AHB_BASE  + 0x10000)
N#define LPC_GPIO0_BASE        (LPC_AHB_BASE  + 0x18000)
N#define LPC_GPIO1_BASE        (LPC_AHB_BASE  + 0x18020)
N#define LPC_GPIO2_BASE        (LPC_AHB_BASE  + 0x18040)
N#define LPC_GPIO3_BASE        (LPC_AHB_BASE  + 0x18060)
N#define LPC_GPIO4_BASE        (LPC_AHB_BASE  + 0x18080)
N#define LPC_GPIO5_BASE        (LPC_AHB_BASE  + 0x180A0)
N#define LPC_EMC_BASE          (LPC_AHB_BASE  + 0x1C000)
N
N#define LPC_EEPROM_BASE       (LPC_FLASH_BASE+ 0x200080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_UART0             ((LPC_UART_TypeDef      *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_UART4             ((LPC_UART4_TypeDef     *) LPC_UART4_BASE    )
N#define LPC_PWM0              ((LPC_PWM_TypeDef       *) LPC_PWM0_BASE     )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_IOCON             ((LPC_IOCON_TypeDef     *) LPC_IOCON_BASE    )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_SSP2              ((LPC_SSP_TypeDef       *) LPC_SSP2_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_MCI               ((LPC_MCI_TypeDef       *) LPC_MCI_BASE      )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_LCD               ((LPC_LCD_TypeDef       *) LPC_LCD_BASE      )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_GPIO5             ((LPC_GPIO_TypeDef      *) LPC_GPIO5_BASE    )
N#define LPC_EMC               ((LPC_EMC_TypeDef       *) LPC_EMC_BASE      )
N#define LPC_CRC               ((LPC_CRC_TypeDef       *) LPC_CRC_BASE      )
N#define LPC_EEPROM            ((LPC_EEPROM_TypeDef    *) LPC_EEPROM_BASE   )
N
N#endif  // __LPC177x_8x_H__
L 27 "..\Drivers\lpc177x_8x_uart.h" 2
N#include "lpc_types.h"
L 1 "..\Drivers\lpc_types.h" 1
N/***********************************************************************//**
N * @file		lpc_types.h
N * @brief		Contains the NXP ABL typedefs for C standard types.
N *     			It is intended to be used in ISO C conforming development
N *     			environments and checks for this insofar as it is possible
N *     			to do so.
N * @version		1.0
N * @date		18. September. 2010
N * @author		wellsk
N **************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N **************************************************************************/
N
N/* Type group ----------------------------------------------------------- */
N#ifndef LPC_TYPES_H
N#define LPC_TYPES_H
N
N/* Includes ------------------------------------------------------------------- */
N#include <stdint.h>
N
N
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Types LPC_Types Public Types
N * @{
N */
N
N/**
N * @brief Boolean Type definition
N */
Ntypedef enum {FALSE = 0, TRUE = !FALSE} Bool;
N
N/**
N * @brief Flag Status and Interrupt Flag Status type definition
N */
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
N#define PARAM_SETSTATE(State) ((State==RESET) || (State==SET))
N
N/**
N * @brief Functional State Definition
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define PARAM_FUNCTIONALSTATE(State) ((State==DISABLE) || (State==ENABLE))
N
N/**
N * @ Status type definition
N */
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
N
N
N/**
N * Read/Write transfer type mode (Block or non-block)
N */
Ntypedef enum
N{
N	NONE_BLOCKING = 0,		/**< None Blocking type */
N	BLOCKING,				/**< Blocking type */
N} TRANSFER_BLOCK_Type;
N
N
N/** Pointer to Function returning Void (any number of parameters) */
Ntypedef void (*PFV)();
N
N/** Pointer to Function returning int32_t (any number of parameters) */
Ntypedef int32_t(*PFI)();
N
N/**
N * @}
N */
N
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup LPC_Types_Public_Macros  LPC_Types Public Macros
N * @{
N */
N
N/* _BIT(n) sets the bit at position "n"
N * _BIT(n) is intended to be used in "OR" and "AND" expressions:
N * e.g., "(_BIT(3) | _BIT(7))".
N */
N#undef _BIT
N/* Set bit macro */
N#define _BIT(n)	(1<<n)
N
N/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
N * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
N * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
N */
N#undef _SBF
N/* Set bit field macro */
N#define _SBF(f,v) (v<<f)
N
N/* _BITMASK constructs a symbol with 'field_width' least significant
N * bits set.
N * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
N * The symbol is intended to be used to limit the bit field width
N * thusly:
N * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
N * If "any_expression" results in a value that is larger than can be
N * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
N * used with the _SBF example above, the example would be written:
N * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
N * This ensures that the value written to a_reg is no wider than
N * 16 bits, and makes the code easier to read and understand.
N */
N#undef _BITMASK
N/* Bitmask creation macro */
N#define _BITMASK(field_width) ( _BIT(field_width) - 1)
N
N/* NULL pointer */
N#ifndef NULL
S#define NULL ((void*) 0)
N#endif
N
N/* Number of elements in an array */
N#define NELEMENTS(array)  (sizeof (array) / sizeof (array[0]))
N
N/* Static data/function define */
N#define STATIC static
N/* External data/function define */
N#define EXTERN extern
N
N#define MAX(a, b) (((a) > (b)) ? (a) : (b))
N#define MIN(a, b) (((a) < (b)) ? (a) : (b))
N
N/**
N * @}
N */
N
N
N/* Old Type Definition compatibility ------------------------------------------ */
N/** @addtogroup LPC_Types_Public_Types LPC_Types Public Types
N * @{
N */
N
N/** SMA type for character type */
Ntypedef char CHAR;
N
N/** SMA type for 8 bit unsigned value */
Ntypedef uint8_t UNS_8;
N
N/** SMA type for 8 bit signed value */
Ntypedef int8_t INT_8;
N
N/** SMA type for 16 bit unsigned value */
Ntypedef	uint16_t UNS_16;
N
N/** SMA type for 16 bit signed value */
Ntypedef	int16_t INT_16;
N
N/** SMA type for 32 bit unsigned value */
Ntypedef	uint32_t UNS_32;
N
N/** SMA type for 32 bit signed value */
Ntypedef	int32_t INT_32;
N
N/** SMA type for 64 bit signed value */
Ntypedef int64_t INT_64;
N
N/** SMA type for 64 bit unsigned value */
Ntypedef uint64_t UNS_64;
N
N/** 32 bit boolean type */
Ntypedef Bool BOOL_32;
N
N/** 16 bit boolean type */
Ntypedef Bool BOOL_16;
N
N/** 8 bit boolean type */
Ntypedef Bool BOOL_8;
N
N/**
N * @}
N */
N
N
N#endif /* LPC_TYPES_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
L 28 "..\Drivers\lpc177x_8x_uart.h" 2
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Public Macros -------------------------------------------------------------- */
N/** @defgroup UART_Public_Macros  UART Public Macros
N * @{
N */
N
N/** UART time-out definitions in case of using Read() and Write function
N * with Blocking Flag mode
N */
N#define UART_BLOCKING_TIMEOUT			(0xFFFFFFUL)
N
N/**
N * @}
N */
N
N/* Private Macros ------------------------------------------------------------- */
N/** @defgroup UART_Private_Macros UART Private Macros
N * @{
N */
N
N/* Accepted Error baud rate value (in percent unit) */
N#define UART_ACCEPTED_BAUDRATE_ERROR	(3)			/*!< Acceptable UART baudrate error */
N
N
N/* --------------------- BIT DEFINITIONS -------------------------------------- */
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Receiver Buffer Register
N **********************************************************************/
N#define UART_RBR_MASKBIT   	((uint8_t)0xFF) 		/*!< UART Received Buffer mask bit (8 bits) */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Transmit Holding Register
N **********************************************************************/
N#define UART_THR_MASKBIT   	((uint8_t)0xFF) 		/*!< UART Transmit Holding mask bit (8 bits) */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Divisor Latch LSB register
N **********************************************************************/
N#define UART_LOAD_DLL(div)	((div) & 0xFF)	/**< Macro for loading least significant halfs of divisors */
N#define UART_DLL_MASKBIT	((uint8_t)0xFF)	/*!< Divisor latch LSB bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UARTn Divisor Latch MSB register
N **********************************************************************/
N#define UART_DLM_MASKBIT	((uint8_t)0xFF)			/*!< Divisor latch MSB bit mask */
N#define UART_LOAD_DLM(div)  (((div) >> 8) & 0xFF)	/**< Macro for loading most significant halfs of divisors */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART interrupt enable register
N **********************************************************************/
N#define UART_IER_RBRINT_EN		((uint32_t)(1<<0)) 	/*!< RBR Interrupt enable*/
N#define UART_IER_THREINT_EN		((uint32_t)(1<<1)) 	/*!< THR Interrupt enable*/
N#define UART_IER_RLSINT_EN		((uint32_t)(1<<2)) 	/*!< RX line status interrupt enable*/
N#define UART1_IER_MSINT_EN		((uint32_t)(1<<3))	/*!< Modem status interrupt enable */
N#define UART1_IER_CTSINT_EN		((uint32_t)(1<<7))	/*!< CTS1 signal transition interrupt enable */
N#define UART_IER_ABEOINT_EN		((uint32_t)(1<<8)) 	/*!< Enables the end of auto-baud interrupt */
N#define UART_IER_ABTOINT_EN		((uint32_t)(1<<9)) 	/*!< Enables the auto-baud time-out interrupt */
N#define UART_IER_BITMASK		((uint32_t)(0x307)) /*!< UART interrupt enable register bit mask */
N#define UART1_IER_BITMASK		((uint32_t)(0x38F)) /*!< UART1 interrupt enable register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART interrupt identification register
N **********************************************************************/
N#define UART_IIR_INTSTAT_PEND	((uint32_t)(1<<0))	/*!<Interrupt Status - Active low */
N#define UART_IIR_INTID_RLS		((uint32_t)(3<<1)) 	/*!<Interrupt identification: Receive line status*/
N#define UART_IIR_INTID_RDA		((uint32_t)(2<<1)) 	/*!<Interrupt identification: Receive data available*/
N#define UART_IIR_INTID_CTI		((uint32_t)(6<<1)) 	/*!<Interrupt identification: Character time-out indicator*/
N#define UART_IIR_INTID_THRE		((uint32_t)(1<<1)) 	/*!<Interrupt identification: THRE interrupt*/
N#define UART1_IIR_INTID_MODEM	((uint32_t)(0<<1)) 	/*!<Interrupt identification: Modem interrupt*/
N#define UART_IIR_INTID_MASK		((uint32_t)(7<<1))	/*!<Interrupt identification: Interrupt ID mask */
N#define UART_IIR_FIFO_EN		((uint32_t)(3<<6)) 	/*!<These bits are equivalent to UnFCR[0] */
N#define UART_IIR_ABEO_INT		((uint32_t)(1<<8)) 	/*!< End of auto-baud interrupt */
N#define UART_IIR_ABTO_INT		((uint32_t)(1<<9)) 	/*!< Auto-baud time-out interrupt */
N#define UART_IIR_BITMASK		((uint32_t)(0x3CF))	/*!< UART interrupt identification register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART FIFO control register
N **********************************************************************/
N#define UART_FCR_FIFO_EN		((uint8_t)(1<<0)) 	/*!< UART FIFO enable */
N#define UART_FCR_RX_RS			((uint8_t)(1<<1)) 	/*!< UART FIFO RX reset */
N#define UART_FCR_TX_RS			((uint8_t)(1<<2)) 	/*!< UART FIFO TX reset */
N#define UART_FCR_DMAMODE_SEL 	((uint8_t)(1<<3)) 	/*!< UART DMA mode selection */
N#define UART_FCR_TRG_LEV0		((uint8_t)(0)) 		/*!< UART FIFO trigger level 0: 1 character */
N#define UART_FCR_TRG_LEV1		((uint8_t)(1<<6)) 	/*!< UART FIFO trigger level 1: 4 character */
N#define UART_FCR_TRG_LEV2		((uint8_t)(2<<6)) 	/*!< UART FIFO trigger level 2: 8 character */
N#define UART_FCR_TRG_LEV3		((uint8_t)(3<<6)) 	/*!< UART FIFO trigger level 3: 14 character */
N#define UART_FCR_BITMASK		((uint8_t)(0xCF))	/*!< UART FIFO control bit mask */
N#define UART_TX_FIFO_SIZE		(16)
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART line control register
N **********************************************************************/
N#define UART_LCR_WLEN5     		((uint8_t)(0))   		/*!< UART 5 bit data mode */
N#define UART_LCR_WLEN6     		((uint8_t)(1<<0))   	/*!< UART 6 bit data mode */
N#define UART_LCR_WLEN7     		((uint8_t)(2<<0))   	/*!< UART 7 bit data mode */
N#define UART_LCR_WLEN8     		((uint8_t)(3<<0))   	/*!< UART 8 bit data mode */
N#define UART_LCR_STOPBIT_SEL	((uint8_t)(1<<2))   	/*!< UART Two Stop Bits Select */
N#define UART_LCR_PARITY_EN		((uint8_t)(1<<3))		/*!< UART Parity Enable */
N#define UART_LCR_PARITY_ODD		((uint8_t)(0))         	/*!< UART Odd Parity Select */
N#define UART_LCR_PARITY_EVEN	((uint8_t)(1<<4))		/*!< UART Even Parity Select */
N#define UART_LCR_PARITY_F_1		((uint8_t)(2<<4))		/*!< UART force 1 stick parity */
N#define UART_LCR_PARITY_F_0		((uint8_t)(3<<4))		/*!< UART force 0 stick parity */
N#define UART_LCR_BREAK_EN		((uint8_t)(1<<6))		/*!< UART Transmission Break enable */
N#define UART_LCR_DLAB_EN		((uint8_t)(1<<7))    	/*!< UART Divisor Latches Access bit enable */
N#define UART_LCR_BITMASK		((uint8_t)(0xFF))		/*!< UART line control bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 Modem Control Register
N **********************************************************************/
N#define UART1_MCR_DTR_CTRL		((uint8_t)(1<<0))		/*!< Source for modem output pin DTR */
N#define UART1_MCR_RTS_CTRL		((uint8_t)(1<<1))		/*!< Source for modem output pin RTS */
N#define UART1_MCR_LOOPB_EN		((uint8_t)(1<<4))		/*!< Loop back mode select */
N#define UART1_MCR_AUTO_RTS_EN	((uint8_t)(1<<6))		/*!< Enable Auto RTS flow-control */
N#define UART1_MCR_AUTO_CTS_EN	((uint8_t)(1<<7))		/*!< Enable Auto CTS flow-control */
N#define UART1_MCR_BITMASK		((uint8_t)(0x0F3))		/*!< UART1 bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART line status register
N **********************************************************************/
N#define UART_LSR_RDR		((uint8_t)(1<<0)) 	/*!<Line status register: Receive data ready*/
N#define UART_LSR_OE			((uint8_t)(1<<1)) 	/*!<Line status register: Overrun error*/
N#define UART_LSR_PE			((uint8_t)(1<<2)) 	/*!<Line status register: Parity error*/
N#define UART_LSR_FE			((uint8_t)(1<<3)) 	/*!<Line status register: Framing error*/
N#define UART_LSR_BI			((uint8_t)(1<<4)) 	/*!<Line status register: Break interrupt*/
N#define UART_LSR_THRE		((uint8_t)(1<<5)) 	/*!<Line status register: Transmit holding register empty*/
N#define UART_LSR_TEMT		((uint8_t)(1<<6)) 	/*!<Line status register: Transmitter empty*/
N#define UART_LSR_RXFE		((uint8_t)(1<<7)) 	/*!<Error in RX FIFO*/
N#define UART_LSR_BITMASK	((uint8_t)(0xFF)) 	/*!<UART Line status bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Modem (UART1 only) status register
N **********************************************************************/
N#define UART1_MSR_DELTA_CTS		((uint8_t)(1<<0))	/*!< Set upon state change of input CTS */
N#define UART1_MSR_DELTA_DSR		((uint8_t)(1<<1))	/*!< Set upon state change of input DSR */
N#define UART1_MSR_LO2HI_RI		((uint8_t)(1<<2))	/*!< Set upon low to high transition of input RI */
N#define UART1_MSR_DELTA_DCD		((uint8_t)(1<<3))	/*!< Set upon state change of input DCD */
N#define UART1_MSR_CTS			((uint8_t)(1<<4))	/*!< Clear To Send State */
N#define UART1_MSR_DSR			((uint8_t)(1<<5))	/*!< Data Set Ready State */
N#define UART1_MSR_RI			((uint8_t)(1<<6))	/*!< Ring Indicator State */
N#define UART1_MSR_DCD			((uint8_t)(1<<7))	/*!< Data Carrier Detect State */
N#define UART1_MSR_BITMASK		((uint8_t)(0xFF))	/*!< MSR register bit-mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Scratch Pad Register
N **********************************************************************/
N#define UART_SCR_BIMASK		((uint8_t)(0xFF))	/*!< UART Scratch Pad bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Auto baudrate control register
N **********************************************************************/
N#define UART_ACR_START				((uint32_t)(1<<0))	/**< UART Auto-baud start */
N#define UART_ACR_MODE				((uint32_t)(1<<1))	/**< UART Auto baudrate Mode 1 */
N#define UART_ACR_AUTO_RESTART		((uint32_t)(1<<2))	/**< UART Auto baudrate restart */
N#define UART_ACR_ABEOINT_CLR		((uint32_t)(1<<8))	/**< UART End of auto-baud interrupt clear */
N#define UART_ACR_ABTOINT_CLR		((uint32_t)(1<<9))	/**< UART Auto-baud time-out interrupt clear */
N#define UART_ACR_BITMASK			((uint32_t)(0x307))	/**< UART Auto Baudrate register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART IrDA control register
N **********************************************************************/
N#define UART_ICR_IRDAEN			((uint32_t)(1<<0))			/**< IrDA mode enable */
N#define UART_ICR_IRDAINV		((uint32_t)(1<<1))			/**< IrDA serial input inverted */
N#define UART_ICR_FIXPULSE_EN	((uint32_t)(1<<2))			/**< IrDA fixed pulse width mode */
N#define UART_ICR_PULSEDIV(n)	((uint32_t)((n&0x07)<<3))	/**< PulseDiv - Configures the pulse when FixPulseEn = 1 */
N#define UART_ICR_BITMASK		((uint32_t)(0x3F))			/*!< UART IRDA bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Fractional divider register
N **********************************************************************/
N#define UART_FDR_DIVADDVAL(n)	((uint32_t)(n&0x0F))		/**< Baud-rate generation pre-scaler divisor */
N#define UART_FDR_MULVAL(n)		((uint32_t)((n<<4)&0xF0))	/**< Baud-rate pre-scaler multiplier value */
N#define UART_FDR_BITMASK		((uint32_t)(0xFF))			/**< UART Fractional Divider register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART Tx Enable register
N **********************************************************************/
N#define UART_TER_TXEN			((uint8_t)(1<<7)) 		/*!< Transmit enable bit */
N#define UART_TER_BITMASK		((uint8_t)(0x80))		/**< UART Transmit Enable Register bit mask */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS485 Control register
N **********************************************************************/
N#define UART1_RS485CTRL_NMM_EN		((uint32_t)(1<<0))	/*!< RS-485/EIA-485 Normal Multi-drop Mode (NMM)
N														is disabled */
N#define UART1_RS485CTRL_RX_DIS		((uint32_t)(1<<1))	/*!< The receiver is disabled */
N#define UART1_RS485CTRL_AADEN		((uint32_t)(1<<2))	/*!< Auto Address Detect (AAD) is enabled */
N#define UART1_RS485CTRL_SEL_DTR		((uint32_t)(1<<3))	/*!< If direction control is enabled
N														(bit DCTRL = 1), pin DTR is used for direction control */
N#define UART1_RS485CTRL_DCTRL_EN	((uint32_t)(1<<4))	/*!< Enable Auto Direction Control */
N#define UART1_RS485CTRL_OINV_1		((uint32_t)(1<<5))	/*!< This bit reverses the polarity of the direction
N														control signal on the RTS (or DTR) pin. The direction control pin
N														will be driven to logic "1" when the transmitter has data to be sent */
N#define UART1_RS485CTRL_BITMASK		((uint32_t)(0x3F))	/**< RS485 control bit-mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS-485 Address Match register
N **********************************************************************/
N#define UART1_RS485ADRMATCH_BITMASK ((uint8_t)(0xFF)) 	/**< Bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART1 RS-485 Delay value register
N **********************************************************************/
N/* Macro defines for UART1 RS-485 Delay value register */
N#define UART1_RS485DLY_BITMASK		((uint8_t)(0xFF)) 	/** Bit mask value */
N
N/*********************************************************************//**
N * Macro defines for Macro defines for UART FIFO Level register
N **********************************************************************/
N#define UART_FIFOLVL_RXFIFOLVL(n)	((uint32_t)(n&0x0F))		/**< Reflects the current level of the UART receiver FIFO */
N#define UART_FIFOLVL_TXFIFOLVL(n)	((uint32_t)((n>>8)&0x0F))	/**< Reflects the current level of the UART transmitter FIFO */
N#define UART_FIFOLVL_BITMASK		((uint32_t)(0x0F0F))		/**< UART FIFO Level Register bit mask */
N
N
N/**
N * @}
N */
N
N
N/* Public Types --------------------------------------------------------------- */
N/** @defgroup UART_Public_Types UART Public Types
N * @{
N */
N
N/**
N * @brief UART Databit type definitions
N */
Ntypedef enum {
N	UART_DATABIT_5		= 0,     		/*!< UART 5 bit data mode */
N	UART_DATABIT_6,		     			/*!< UART 6 bit data mode */
N	UART_DATABIT_7,		     			/*!< UART 7 bit data mode */
N	UART_DATABIT_8		     			/*!< UART 8 bit data mode */
N} UART_DATABIT_Type;
N
N/**
N * @brief UART Stop bit type definitions
N */
Ntypedef enum {
N	UART_STOPBIT_1		= (0),   					/*!< UART 1 Stop Bits Select */
N	UART_STOPBIT_2,		 							/*!< UART Two Stop Bits Select */
N} UART_STOPBIT_Type;
N
N/**
N * @brief UART Parity type definitions
N */
Ntypedef enum {
N	UART_PARITY_NONE 	= 0,					/*!< No parity */
N	UART_PARITY_ODD,	 						/*!< Odd parity */
N	UART_PARITY_EVEN, 							/*!< Even parity */
N	UART_PARITY_SP_1, 							/*!< Forced "1" stick parity */
N	UART_PARITY_SP_0 							/*!< Forced "0" stick parity */
N} UART_PARITY_Type;
N
N/**
N * @brief FIFO Level type definitions
N */
Ntypedef enum {
N	UART_FIFO_TRGLEV0 = 0,	/*!< UART FIFO trigger level 0: 1 character */
N	UART_FIFO_TRGLEV1, 		/*!< UART FIFO trigger level 1: 4 character */
N	UART_FIFO_TRGLEV2,		/*!< UART FIFO trigger level 2: 8 character */
N	UART_FIFO_TRGLEV3		/*!< UART FIFO trigger level 3: 14 character */
N} UART_FITO_LEVEL_Type;
N
N/********************************************************************//**
N* @brief UART Interrupt Type definitions
N**********************************************************************/
Ntypedef enum {
N	UART_INTCFG_RBR = 0,	/*!< RBR Interrupt enable*/
N	UART_INTCFG_THRE,		/*!< THR Interrupt enable*/
N	UART_INTCFG_RLS,		/*!< RX line status interrupt enable*/
N	UART1_INTCFG_MS,		/*!< Modem status interrupt enable (UART1 only) */
N	UART1_INTCFG_CTS,		/*!< CTS1 signal transition interrupt enable (UART1 only) */
N	UART_INTCFG_ABEO,		/*!< Enables the end of auto-baud interrupt */
N	UART_INTCFG_ABTO		/*!< Enables the auto-baud time-out interrupt */
N} UART_INT_Type;
N
N/**
N * @brief UART Line Status Type definition
N */
Ntypedef enum {
N	UART_LINESTAT_RDR	= UART_LSR_RDR,			/*!<Line status register: Receive data ready*/
X	UART_LINESTAT_RDR	= ((uint8_t)(1<<0)),			 
N	UART_LINESTAT_OE	= UART_LSR_OE,			/*!<Line status register: Overrun error*/
X	UART_LINESTAT_OE	= ((uint8_t)(1<<1)),			 
N	UART_LINESTAT_PE	= UART_LSR_PE,			/*!<Line status register: Parity error*/
X	UART_LINESTAT_PE	= ((uint8_t)(1<<2)),			 
N	UART_LINESTAT_FE	= UART_LSR_FE,			/*!<Line status register: Framing error*/
X	UART_LINESTAT_FE	= ((uint8_t)(1<<3)),			 
N	UART_LINESTAT_BI	= UART_LSR_BI,			/*!<Line status register: Break interrupt*/
X	UART_LINESTAT_BI	= ((uint8_t)(1<<4)),			 
N	UART_LINESTAT_THRE	= UART_LSR_THRE,		/*!<Line status register: Transmit holding register empty*/
X	UART_LINESTAT_THRE	= ((uint8_t)(1<<5)),		 
N	UART_LINESTAT_TEMT	= UART_LSR_TEMT,		/*!<Line status register: Transmitter empty*/
X	UART_LINESTAT_TEMT	= ((uint8_t)(1<<6)),		 
N	UART_LINESTAT_RXFE	= UART_LSR_RXFE			/*!<Error in RX FIFO*/
X	UART_LINESTAT_RXFE	= ((uint8_t)(1<<7))			 
N} UART_LS_Type;
N
N/**
N * @brief UART Auto-baudrate mode type definition
N */
Ntypedef enum {
N	UART_AUTOBAUD_MODE0				= 0,			/**< UART Auto baudrate Mode 0 */
N	UART_AUTOBAUD_MODE1,							/**< UART Auto baudrate Mode 1 */
N} UART_AB_MODE_Type;
N
N/**
N * @brief Auto Baudrate mode configuration type definition
N */
Ntypedef struct {
N	UART_AB_MODE_Type	ABMode;			/**< Autobaudrate mode */
N	FunctionalState		AutoRestart;	/**< Auto Restart state */
N} UART_AB_CFG_Type;
N
N/**
N * @brief UART End of Auto-baudrate type definition
N */
Ntypedef enum {
N	UART_AUTOBAUD_INTSTAT_ABEO		= UART_IIR_ABEO_INT,		/**< UART End of auto-baud interrupt  */
X	UART_AUTOBAUD_INTSTAT_ABEO		= ((uint32_t)(1<<8)),		 
N	UART_AUTOBAUD_INTSTAT_ABTO		= UART_IIR_ABTO_INT			/**< UART Auto-baud time-out interrupt  */
X	UART_AUTOBAUD_INTSTAT_ABTO		= ((uint32_t)(1<<9))			 
N}UART_ABEO_Type;
N
N/**
N * UART IrDA Control type Definition
N */
Ntypedef enum {
N	UART_IrDA_PULSEDIV2		= 0,		/**< Pulse width = 2 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV4,				/**< Pulse width = 4 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV8,				/**< Pulse width = 8 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV16,				/**< Pulse width = 16 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV32,				/**< Pulse width = 32 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV64,				/**< Pulse width = 64 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV128,				/**< Pulse width = 128 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N	UART_IrDA_PULSEDIV256				/**< Pulse width = 256 * Tpclk
N										- Configures the pulse when FixPulseEn = 1 */
N} UART_IrDA_PULSE_Type;
N
N/********************************************************************//**
N* @brief UART1 Full modem -  Signal states definition
N**********************************************************************/
Ntypedef enum {
N	INACTIVE = 0,			/* In-active state */
N	ACTIVE = !INACTIVE 		/* Active state */
N}UART1_SignalState;
N
N/**
N * @brief UART modem status type definition
N */
Ntypedef enum {
N	UART1_MODEM_STAT_DELTA_CTS	= UART1_MSR_DELTA_CTS,		/*!< Set upon state change of input CTS */
X	UART1_MODEM_STAT_DELTA_CTS	= ((uint8_t)(1<<0)),		 
N	UART1_MODEM_STAT_DELTA_DSR	= UART1_MSR_DELTA_DSR,		/*!< Set upon state change of input DSR */
X	UART1_MODEM_STAT_DELTA_DSR	= ((uint8_t)(1<<1)),		 
N	UART1_MODEM_STAT_LO2HI_RI	= UART1_MSR_LO2HI_RI,		/*!< Set upon low to high transition of input RI */
X	UART1_MODEM_STAT_LO2HI_RI	= ((uint8_t)(1<<2)),		 
N	UART1_MODEM_STAT_DELTA_DCD	= UART1_MSR_DELTA_DCD,		/*!< Set upon state change of input DCD */
X	UART1_MODEM_STAT_DELTA_DCD	= ((uint8_t)(1<<3)),		 
N	UART1_MODEM_STAT_CTS		= UART1_MSR_CTS,			/*!< Clear To Send State */
X	UART1_MODEM_STAT_CTS		= ((uint8_t)(1<<4)),			 
N	UART1_MODEM_STAT_DSR		= UART1_MSR_DSR,			/*!< Data Set Ready State */
X	UART1_MODEM_STAT_DSR		= ((uint8_t)(1<<5)),			 
N	UART1_MODEM_STAT_RI			= UART1_MSR_RI,				/*!< Ring Indicator State */
X	UART1_MODEM_STAT_RI			= ((uint8_t)(1<<6)),				 
N	UART1_MODEM_STAT_DCD		= UART1_MSR_DCD				/*!< Data Carrier Detect State */
X	UART1_MODEM_STAT_DCD		= ((uint8_t)(1<<7))				 
N} UART_MODEM_STAT_type;
N
N/**
N * @brief Modem output pin type definition
N */
Ntypedef enum {
N	UART1_MODEM_PIN_DTR			= 0,		/*!< Source for modem output pin DTR */
N	UART1_MODEM_PIN_RTS						/*!< Source for modem output pin RTS */
N} UART_MODEM_PIN_Type;
N
N/**
N * @brief UART Modem mode type definition
N */
Ntypedef enum {
N	UART1_MODEM_MODE_LOOPBACK	= 0,		/*!< Loop back mode select */
N	UART1_MODEM_MODE_AUTO_RTS,				/*!< Enable Auto RTS flow-control */
N	UART1_MODEM_MODE_AUTO_CTS 				/*!< Enable Auto CTS flow-control */
N} UART_MODEM_MODE_Type;
N
N/**
N * @brief UART Direction Control Pin type definition
N */
Ntypedef enum {
N	UART1_RS485_DIRCTRL_RTS = 0,	/**< Pin RTS is used for direction control */
N	UART1_RS485_DIRCTRL_DTR			/**< Pin DTR is used for direction control */
N} UART_RS485_DIRCTRL_PIN_Type;
N
N/********************************************************************//**
N* @brief UART Configuration Structure definition
N**********************************************************************/
Ntypedef struct {
N  uint32_t Baud_rate;   		/**< UART baud rate */
N  UART_PARITY_Type Parity;    	/**< Parity selection, should be:
N							   - UART_PARITY_NONE: No parity
N							   - UART_PARITY_ODD: Odd parity
N							   - UART_PARITY_EVEN: Even parity
N							   - UART_PARITY_SP_1: Forced "1" stick parity
N							   - UART_PARITY_SP_0: Forced "0" stick parity
N							   */
N  UART_DATABIT_Type Databits;   /**< Number of data bits, should be:
N							   - UART_DATABIT_5: UART 5 bit data mode
N							   - UART_DATABIT_6: UART 6 bit data mode
N							   - UART_DATABIT_7: UART 7 bit data mode
N							   - UART_DATABIT_8: UART 8 bit data mode
N							   */
N  UART_STOPBIT_Type Stopbits;   /**< Number of stop bits, should be:
N							   - UART_STOPBIT_1: UART 1 Stop Bits Select
N							   - UART_STOPBIT_2: UART 2 Stop Bits Select
N							   */
N} UART_CFG_Type;
N
N/********************************************************************//**
N* @brief UART FIFO Configuration Structure definition
N**********************************************************************/
N
Ntypedef struct {
N	FunctionalState FIFO_ResetRxBuf;	/**< Reset Rx FIFO command state , should be:
N										 - ENABLE: Reset Rx FIFO in UART
N										 - DISABLE: Do not reset Rx FIFO  in UART
N										 */
N	FunctionalState FIFO_ResetTxBuf;	/**< Reset Tx FIFO command state , should be:
N										 - ENABLE: Reset Tx FIFO in UART
N										 - DISABLE: Do not reset Tx FIFO  in UART
N										 */
N	FunctionalState FIFO_DMAMode;		/**< DMA mode, should be:
N										 - ENABLE: Enable DMA mode in UART
N										 - DISABLE: Disable DMA mode in UART
N										 */
N	UART_FITO_LEVEL_Type FIFO_Level;	/**< Rx FIFO trigger level, should be:
N										- UART_FIFO_TRGLEV0: UART FIFO trigger level 0: 1 character
N										- UART_FIFO_TRGLEV1: UART FIFO trigger level 1: 4 character
N										- UART_FIFO_TRGLEV2: UART FIFO trigger level 2: 8 character
N										- UART_FIFO_TRGLEV3: UART FIFO trigger level 3: 14 character
N										*/
N} UART_FIFO_CFG_Type;
N
N/********************************************************************//**
N* @brief UART1 Full modem -  RS485 Control configuration type
N**********************************************************************/
Ntypedef struct {
N	FunctionalState NormalMultiDropMode_State; /*!< Normal MultiDrop mode State:
N													- ENABLE: Enable this function.
N													- DISABLE: Disable this function. */
N	FunctionalState Rx_State;					/*!< Receiver State:
N													- ENABLE: Enable Receiver.
N													- DISABLE: Disable Receiver. */
N	FunctionalState AutoAddrDetect_State;		/*!< Auto Address Detect mode state:
N												- ENABLE: ENABLE this function.
N												- DISABLE: Disable this function. */
N	FunctionalState AutoDirCtrl_State;			/*!< Auto Direction Control State:
N												- ENABLE: Enable this function.
N												- DISABLE: Disable this function. */
N	UART_RS485_DIRCTRL_PIN_Type DirCtrlPin;		/*!< If direction control is enabled, state:
N												- UART1_RS485_DIRCTRL_RTS:
N												pin RTS is used for direction control.
N												- UART1_RS485_DIRCTRL_DTR:
N												pin DTR is used for direction control. */
N	 SetState DirCtrlPol_Level;					/*!< Polarity of the direction control signal on
N												the RTS (or DTR) pin:
N												- RESET: The direction control pin will be driven
N												to logic "0" when the transmitter has data to be sent.
N												- SET: The direction control pin will be driven
N												to logic "1" when the transmitter has data to be sent. */
N	uint8_t MatchAddrValue;					/*!< address match value for RS-485/EIA-485 mode, 8-bit long */
N	uint8_t DelayValue;						/*!< delay time is in periods of the baud clock, 8-bit long */
N} UART1_RS485_CTRLCFG_Type;
N
N/**
N * @}
N */
N
N
N/* Public Functions ----------------------------------------------------------- */
N/** @defgroup UART_Public_Functions UART Public Functions
N * @{
N */
N/* UART Init/DeInit functions --------------------------------------------------*/
Nvoid UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct);
Nvoid UART_DeInit(LPC_UART_TypeDef* UARTx);
Nvoid UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct);
N
N/* UART Send/Receive functions -------------------------------------------------*/
Nvoid UART_SendByte(LPC_UART_TypeDef* UARTx, uint8_t Data);
Nuint8_t UART_ReceiveByte(LPC_UART_TypeDef* UARTx);
Nuint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
N		uint32_t buflen, TRANSFER_BLOCK_Type flag);
Nuint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
N		uint32_t buflen, TRANSFER_BLOCK_Type flag);
Xuint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, 		uint32_t buflen, TRANSFER_BLOCK_Type flag);
N
N/* UART FIFO functions ----------------------------------------------------------*/
Nvoid UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg);
Nvoid UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct);
N
N/* UART get information functions -----------------------------------------------*/
Nuint32_t UART_GetIntId(LPC_UART_TypeDef* UARTx);
Nuint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx);
N
N/* UART operate functions -------------------------------------------------------*/
Nvoid UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, \
N				FunctionalState NewState);
Xvoid UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, 				FunctionalState NewState);
Nvoid UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState);
NFlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx);
Nvoid UART_ForceBreak(LPC_UART_TypeDef* UARTx);
N
N/* UART Auto-baud functions -----------------------------------------------------*/
Nvoid UART_ABClearIntPending(LPC_UART_TypeDef *UARTx, UART_ABEO_Type ABIntType);
Nvoid UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
N				FunctionalState NewState);
Xvoid UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, 				FunctionalState NewState);
N
N/* UART1 FullModem functions ----------------------------------------------------*/
Nvoid UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
N							UART1_SignalState NewState);
Xvoid UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, 							UART1_SignalState NewState);
Nvoid UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
N							FunctionalState NewState);
Xvoid UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, 							FunctionalState NewState);
Nuint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx);
N
N/* UART RS485 functions ----------------------------------------------------------*/
Nvoid UART_RS485Config(LPC_UART_TypeDef *UARTx,
N									UART1_RS485_CTRLCFG_Type *RS485ConfigStruct);
Nvoid UART_RS485ReceiverCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState);
Nvoid UART_RS485SendSlvAddr(LPC_UART_TypeDef *UARTx, uint8_t SlvAddr);
Nuint32_t UART_RS485SendData(LPC_UART_TypeDef *UARTx, uint8_t *pData, uint32_t size);
N
N/* UART IrDA functions-------------------------------------------------------------*/
Nvoid UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
Nvoid UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState);
Nvoid UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv);
N/**
N * @}
N */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __LPC178X_UART_H */
N
N/**
N * @}
N */
N
N/* --------------------------------- End Of File ------------------------------ */
L 24 "..\Drivers\debug_frmwrk.h" 2
N
N#define USED_UART_DEBUG_PORT	0// 1
N
N#define NUM_SKIPPED_ALLOWED			(10)
N
N#define DBG_GETVAL_IN_DEC			(0)
N#define DBG_GETVAL_IN_HEX			(1)
N//#define DBG_GETVAL_IN_CHARS			(2)
N
N#if (USED_UART_DEBUG_PORT == 0)
X#if (0 == 0)
N#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART0
N#elif (USED_UART_DEBUG_PORT == 1)
S#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART1
S#elif (USED_UART_DEBUG_PORT == 2)
S#define DEBUG_UART_PORT	(LPC_UART_TypeDef *)LPC_UART2
N#endif
N
N#define put_str(x)							_db_msg(DEBUG_UART_PORT, x)
N#define put_str_(x)							_db_msg_(DEBUG_UART_PORT, x)
N
W "..\Drivers\debug_frmwrk.h" 44 10 incompatible redefinition of macro "putchar" (declared at line 681 of "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdio.h")
N#define  putchar(x)						    _db_char(DEBUG_UART_PORT, x)
N
N#define _DBD(x)								_db_dec(DEBUG_UART_PORT, x)
N#define _DBD16(x)							_db_dec_16(DEBUG_UART_PORT, x)
N#define _DBD32(x)							_db_dec_32(DEBUG_UART_PORT, x)
N
N#define _DBH(x)								_db_hex(DEBUG_UART_PORT, x)
N#define _DBH16(x)							_db_hex_16(DEBUG_UART_PORT, x)
N#define _DBH32(x)							_db_hex_32(DEBUG_UART_PORT, x)
N
N#define _DBH_(x)							_db_hex_(DEBUG_UART_PORT, x)
N#define _DBH16_(x)							_db_hex_16_(DEBUG_UART_PORT, x)
N#define _DBH32_(x)							_db_hex_32_(DEBUG_UART_PORT, x)
N
N#define getkey()							_db_get_key(DEBUG_UART_PORT)
W "..\Drivers\debug_frmwrk.h" 59 9 incompatible redefinition of macro "getchar" (declared at line 648 of "D:\Program Files\mdk\ARM\ARMCC\bin\..\include\stdio.h")
N#define getchar()							_db_get_char(DEBUG_UART_PORT)
N#define _DGV(option, numCh, val)			_db_get_val(DEBUG_UART_PORT, option, numCh, val)
N
N//void  _printf (const  char *format, ...);
N
Nextern void (*_db_msg)(LPC_UART_TypeDef *UARTx, const void *s);
Nextern void (*_db_msg_)(LPC_UART_TypeDef *UARTx, const void *s);
Nextern void (*_db_char)(LPC_UART_TypeDef *UARTx, uint8_t ch);
Nextern void (*_db_dec)(LPC_UART_TypeDef *UARTx, uint8_t decn);
Nextern void (*_db_dec_16)(LPC_UART_TypeDef *UARTx, uint16_t decn);
Nextern void (*_db_dec_32)(LPC_UART_TypeDef *UARTx, uint32_t decn);
Nextern void (*_db_hex)(LPC_UART_TypeDef *UARTx, uint8_t hexn);
Nextern void (*_db_hex_16)(LPC_UART_TypeDef *UARTx, uint16_t hexn);
Nextern void (*_db_hex_32)(LPC_UART_TypeDef *UARTx, uint32_t hexn);
Nextern void (*_db_hex_)(LPC_UART_TypeDef *UARTx, uint8_t hexn);
Nextern void (*_db_hex_16_)(LPC_UART_TypeDef *UARTx, uint16_t hexn);
Nextern void (*_db_hex_32_)(LPC_UART_TypeDef *UARTx, uint32_t hexn);
N
Nextern uint8_t (*_db_get_key)(LPC_UART_TypeDef *UARTx);
Nextern uint8_t (*_db_get_char)(LPC_UART_TypeDef *UARTx);
Nextern uint8_t (*_db_get_val)(LPC_UART_TypeDef *UARTx, uint8_t option, uint8_t numCh, uint32_t * val);
N
Nuint8_t UARTGetValue (LPC_UART_TypeDef *UARTx, uint8_t option,
N											uint8_t numCh, uint32_t* val);
Nvoid UARTPutChar (LPC_UART_TypeDef *UARTx, uint8_t ch);
Nvoid UARTPuts(LPC_UART_TypeDef *UARTx, const void *str);
Nvoid UARTPuts_(LPC_UART_TypeDef *UARTx, const void *str);
Nvoid UARTPutDec(LPC_UART_TypeDef *UARTx, uint8_t decnum);
Nvoid UARTPutDec16(LPC_UART_TypeDef *UARTx, uint16_t decnum);
Nvoid UARTPutDec32(LPC_UART_TypeDef *UARTx, uint32_t decnum);
Nvoid UARTPutHex (LPC_UART_TypeDef *UARTx, uint8_t hexnum);
Nvoid UARTPutHex16 (LPC_UART_TypeDef *UARTx, uint16_t hexnum);
Nvoid UARTPutHex32 (LPC_UART_TypeDef *UARTx, uint32_t hexnum);
Nuint8_t UARTGetChar (LPC_UART_TypeDef *UARTx);
Nuint8_t UARTGetKey (LPC_UART_TypeDef *UARTx);
Nvoid debug_frmwrk_init(void);
N
N#endif /* DEBUG_FRMWRK_H_ */
L 20 "..\fs\yaffsfs.c" 2
N
N#define YAFFSFS_MAX_SYMLINK_DEREFERENCES 5
N
N#ifndef NULL
S#define NULL ((void *)0)
N#endif
N
N
Nconst char *yaffsfs_c_version="$Id: yaffsfs.c,v 1.24 2008/11/11 01:47:46 charles Exp $";
N
N// configurationList is the list of devices that are supported
Nstatic yaffsfs_DeviceConfiguration *yaffsfs_configurationList;
N
N
N/* Some forward references */
Nstatic yaffs_Object *yaffsfs_FindObject(yaffs_Object *relativeDirectory, const YCHAR *path, int symDepth);
Xstatic yaffs_Object *yaffsfs_FindObject(yaffs_Object *relativeDirectory, const char *path, int symDepth);
Nstatic void yaffsfs_RemoveObjectCallback(yaffs_Object *obj);
N
N
N// Handle management.
N//
N
N
Nunsigned int yaffs_wr_attempts;
N
Ntypedef struct
N{
N	__u8  inUse:1;		// this handle is in use
N	__u8  readOnly:1;	// this handle is read only
N	__u8  append:1;		// append only
N	__u8  exclusive:1;	// exclusive
N	__u32 position;		// current position in file
N	yaffs_Object *obj;	// the object
N}yaffsfs_Handle;
N
N
Nstatic yaffsfs_Handle yaffsfs_handle[YAFFSFS_N_HANDLES];
Xstatic yaffsfs_Handle yaffsfs_handle[200];
N
N// yaffsfs_InitHandle
N/// Inilitalise handles on start-up.
N//
Nstatic int yaffsfs_InitHandles(void)
N{
N	int i;
N	for(i = 0; i < YAFFSFS_N_HANDLES; i++)
X	for(i = 0; i < 200; i++)
N	{
N		yaffsfs_handle[i].inUse = 0;
N		yaffsfs_handle[i].obj = NULL;
X		yaffsfs_handle[i].obj = 0;
N	}
N	return 0;
N}
N
Nyaffsfs_Handle *yaffsfs_GetHandlePointer(int h)
N{
N	if(h < 0 || h >= YAFFSFS_N_HANDLES)
X	if(h < 0 || h >= 200)
N	{
N		return NULL;
X		return 0;
N	}
N
N	return &yaffsfs_handle[h];
N}
N
Nyaffs_Object *yaffsfs_GetHandleObject(int handle)
N{
N	yaffsfs_Handle *h = yaffsfs_GetHandlePointer(handle);
N
N	if(h && h->inUse)
N	{
N		return h->obj;
N	}
N
N	return NULL;
X	return 0;
N}
N
N
N//yaffsfs_GetHandle
N// Grab a handle (when opening a file)
N//
N
Nstatic int yaffsfs_GetHandle(void)
N{
N	int i;
N	yaffsfs_Handle *h;
N
N	for(i = 0; i < YAFFSFS_N_HANDLES; i++)
X	for(i = 0; i < 200; i++)
N	{
N		h = yaffsfs_GetHandlePointer(i);
N		if(!h)
N		{
N			// todo bug: should never happen
N		}
N		if(!h->inUse)
N		{
N			memset(h,0,sizeof(yaffsfs_Handle));
N			h->inUse=1;
N			return i;
N		}
N	}
N	return -1;
N}
N
N// yaffs_PutHandle
N// Let go of a handle (when closing a file)
N//
Nstatic int yaffsfs_PutHandle(int handle)
N{
N	yaffsfs_Handle *h = yaffsfs_GetHandlePointer(handle);
N
N	if(h)
N	{
N		h->inUse = 0;
N		h->obj = NULL;
X		h->obj = 0;
N	}
N	return 0;
N}
N
N
N
N// Stuff to search for a directory from a path
N
N
Nint yaffsfs_Match(YCHAR a, YCHAR b)
Xint yaffsfs_Match(char a, char b)
N{
N	// case sensitive
N	return (a == b);
N}
N
Nint yaffsfs_IsPathDivider(YCHAR ch)
Xint yaffsfs_IsPathDivider(char ch)
N{
N	YCHAR *str = YAFFS_PATH_DIVIDERS;
X	char *str = "/";
N
N	while(*str){
N		if(*str == ch)
N			return 1;
N		str++;
N	}
N
N	return 0;
N}
N
N// yaffsfs_FindDevice
N// yaffsfs_FindRoot
N// Scan the configuration list to find the root.
N// Curveballs: Should match paths that end in '/' too
N// Curveball2 Might have "/x/ and "/x/y". Need to return the longest match
Nstatic yaffs_Device *yaffsfs_FindDevice(const YCHAR *path, YCHAR **restOfPath)
Xstatic yaffs_Device *yaffsfs_FindDevice(const char *path, char **restOfPath)
N{
N	yaffsfs_DeviceConfiguration *cfg = yaffsfs_configurationList;
N	const YCHAR *leftOver;
X	const char *leftOver;
N	const YCHAR *p;
X	const char *p;
N	yaffs_Device *retval = NULL;
X	yaffs_Device *retval = 0;
N	int thisMatchLength;
N	int longestMatch = -1;
N	int matching;
N
N	// Check all configs, choose the one that:
N	// 1) Actually matches a prefix (ie /a amd /abc will not match
N	// 2) Matches the longest.
N	while(cfg && cfg->prefix && cfg->dev)
N	{
N		leftOver = path;
N		p = cfg->prefix;
N		thisMatchLength = 0;
N		matching = 1;
N
N
N		while(matching && *p && *leftOver){
N			// Skip over any /s
N			while(yaffsfs_IsPathDivider(*p))
N			      p++;
N
N			// Skip over any /s
N			while(yaffsfs_IsPathDivider(*leftOver))
N		              leftOver++;
N
N			// Now match the text part
N		        while(matching &&
N		              *p && !yaffsfs_IsPathDivider(*p) &&
N		              *leftOver && !yaffsfs_IsPathDivider(*leftOver)){
N			      	if(yaffsfs_Match(*p,*leftOver)){
N			      		p++;
N			      		leftOver++;
N			      		thisMatchLength++;
N				} else {
N					matching = 0;
N				}
N			}
N		}
N
N		// Skip over any /s in leftOver
N		while(yaffsfs_IsPathDivider(*leftOver))
N	              leftOver++;
N		
N
N		if( matching && (thisMatchLength > longestMatch))
N		{
N			// Matched prefix
N			*restOfPath = (YCHAR *)leftOver;
X			*restOfPath = (char *)leftOver;
N			retval = cfg->dev;
N			longestMatch = thisMatchLength;
N		}
N
N		cfg++;
N	}
N	return retval;
N}
N
N#if 0
Sstatic yaffs_Device *yaffsfs_FindDevice(const YCHAR *path, YCHAR **restOfPath)
S{
S	yaffsfs_DeviceConfiguration *cfg = yaffsfs_configurationList;
S	const YCHAR *leftOver;
S	const YCHAR *p;
S	yaffs_Device *retval = NULL;
S	int thisMatchLength;
S	int longestMatch = -1;
S
S	// Check all configs, choose the one that:
S	// 1) Actually matches a prefix (ie /a amd /abc will not match
S	// 2) Matches the longest.
S	while(cfg && cfg->prefix && cfg->dev)
S	{
S		leftOver = path;
S		p = cfg->prefix;
S		thisMatchLength = 0;
S
S		while(*p &&  //unmatched part of prefix
S		      !(yaffsfs_IsPathDivider(*p) && (p[1] == 0)) && // the rest of the prefix is not / (to catch / at end)
S		      *leftOver &&
S		      yaffsfs_Match(*p,*leftOver))
S		{
S			p++;
S			leftOver++;
S			thisMatchLength++;
S		}
S
S
S		if((!*p || (yaffsfs_IsPathDivider(*p) && (p[1] == 0))) &&      // end of prefix
S		   (!*leftOver || yaffsfs_IsPathDivider(*leftOver)) && // no more in this path name part
S		   (thisMatchLength > longestMatch))
S		{
S			// Matched prefix
S			*restOfPath = (YCHAR *)leftOver;
S			retval = cfg->dev;
S			longestMatch = thisMatchLength;
S		}
S		cfg++;
S	}
S	return retval;
S}
N#endif
N
Nstatic yaffs_Object *yaffsfs_FindRoot(const YCHAR *path, YCHAR **restOfPath)
Xstatic yaffs_Object *yaffsfs_FindRoot(const char *path, char **restOfPath)
N{
N
N	yaffs_Device *dev;
N
N	dev= yaffsfs_FindDevice(path,restOfPath);
N	if(dev && dev->isMounted)
N	{
N		return dev->rootDir;
N	}
N	return NULL;
X	return 0;
N}
N
Nstatic yaffs_Object *yaffsfs_FollowLink(yaffs_Object *obj,int symDepth)
N{
N
N	while(obj && obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
N	{
N		YCHAR *alias = obj->variant.symLinkVariant.alias;
X		char *alias = obj->variant.symLinkVariant.alias;
N
N		if(yaffsfs_IsPathDivider(*alias))
N		{
N			// Starts with a /, need to scan from root up
N			obj = yaffsfs_FindObject(NULL,alias,symDepth++);
X			obj = yaffsfs_FindObject(0,alias,symDepth++);
N		}
N		else
N		{
N			// Relative to here, so use the parent of the symlink as a start
N			obj = yaffsfs_FindObject(obj->parent,alias,symDepth++);
N		}
N	}
N	return obj;
N}
N
N
N// yaffsfs_FindDirectory
N// Parse a path to determine the directory and the name within the directory.
N//
N// eg. "/data/xx/ff" --> puts name="ff" and returns the directory "/data/xx"
Nstatic yaffs_Object *yaffsfs_DoFindDirectory(yaffs_Object *startDir,const YCHAR *path,YCHAR **name,int symDepth)
Xstatic yaffs_Object *yaffsfs_DoFindDirectory(yaffs_Object *startDir,const char *path,char **name,int symDepth)
N{
N	yaffs_Object *dir;
N	YCHAR *restOfPath;
X	char *restOfPath;
N	YCHAR str[YAFFS_MAX_NAME_LENGTH+1];
X	char str[255+1];
N	int i;
N
N	if(symDepth > YAFFSFS_MAX_SYMLINK_DEREFERENCES)
X	if(symDepth > 5)
N	{
N		return NULL;
X		return 0;
N	}
N
N	if(startDir)
N	{
N		dir = startDir;
N		restOfPath = (YCHAR *)path;
X		restOfPath = (char *)path;
N	}
N	else
N	{
N		dir = yaffsfs_FindRoot(path,&restOfPath);
N	}
N
N	while(dir)
N	{
N		// parse off /.
N		// curve ball: also throw away surplus '/'
N		// eg. "/ram/x////ff" gets treated the same as "/ram/x/ff"
N		while(yaffsfs_IsPathDivider(*restOfPath))
N		{
N			restOfPath++; // get rid of '/'
N		}
N
N		*name = restOfPath;
N		i = 0;
N
N		while(*restOfPath && !yaffsfs_IsPathDivider(*restOfPath))
N		{
N			if (i < YAFFS_MAX_NAME_LENGTH)
X			if (i < 255)
N			{
N				str[i] = *restOfPath;
N				str[i+1] = '\0';
N				i++;
N			}
N			restOfPath++;
N		}
N
N		if(!*restOfPath)
N		{
N			// got to the end of the string
N			return dir;
N		}
N		else
N		{
N			if(yaffs_strcmp(str,_Y(".")) == 0)
X			if(strcmp(str,".") == 0)
N			{
N				// Do nothing
N			}
N			else if(yaffs_strcmp(str,_Y("..")) == 0)
X			else if(strcmp(str,"..") == 0)
N			{
N				dir = dir->parent;
N			}
N			else
N			{
N				dir = yaffs_FindObjectByName(dir,str);
N
N				while(dir && dir->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
N				{
N
N					dir = yaffsfs_FollowLink(dir,symDepth);
N
N				}
N
N				if(dir && dir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
N				{
N					dir = NULL;
X					dir = 0;
N				}
N			}
N		}
N	}
N	// directory did not exist.
N	return NULL;
X	return 0;
N}
N
Nstatic yaffs_Object *yaffsfs_FindDirectory(yaffs_Object *relativeDirectory,const YCHAR *path,YCHAR **name,int symDepth)
Xstatic yaffs_Object *yaffsfs_FindDirectory(yaffs_Object *relativeDirectory,const char *path,char **name,int symDepth)
N{
N	return yaffsfs_DoFindDirectory(relativeDirectory,path,name,symDepth);
N}
N
N// yaffsfs_FindObject turns a path for an existing object into the object
N//
Nstatic yaffs_Object *yaffsfs_FindObject(yaffs_Object *relativeDirectory, const YCHAR *path,int symDepth)
Xstatic yaffs_Object *yaffsfs_FindObject(yaffs_Object *relativeDirectory, const char *path,int symDepth)
N{
N	yaffs_Object *dir;
N	YCHAR *name;
X	char *name;
N
N	dir = yaffsfs_FindDirectory(relativeDirectory,path,&name,symDepth);
N
N	if(dir && *name)
N	{
N		return yaffs_FindObjectByName(dir,name);
N	}
N
N	return dir;
N}
N
N
Nint yaffs_dup(int fd)
N{
N	int newHandle = -1;
N	yaffsfs_Handle *oldPtr = NULL;
X	yaffsfs_Handle *oldPtr = 0;
N	yaffsfs_Handle *newPtr = NULL;
X	yaffsfs_Handle *newPtr = 0;
N
N	yaffsfs_Lock();
N
N	oldPtr = yaffsfs_GetHandlePointer(fd);
N	if(oldPtr && oldPtr->inUse)
N		newHandle = yaffsfs_GetHandle();
N	if(newHandle >= 0)
N		newPtr = yaffsfs_GetHandlePointer(newHandle);
N
N	if(newPtr){
N		*newPtr = *oldPtr;
N		return newHandle;
N	}
N
N	if(!oldPtr)
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	else
N		yaffsfs_SetError(-ENOMEM);
X		yaffsfs_SetError(-12);
N
N	return -1;
N
N}
N
Nint yaffs_open(const YCHAR *path, int oflag, int mode)
Xint yaffs_open(const char *path, int oflag, int mode)
N{
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	yaffs_Object *dir = NULL;
X	yaffs_Object *dir = 0;
N	YCHAR *name;
X	char *name;
N	int handle = -1;
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	int alreadyOpen = 0;
N	int alreadyExclusive = 0;
N	int openDenied = 0;
N	int symDepth = 0;
N	int errorReported = 0;
N
N	int i;
N
N
N	// todo sanity check oflag (eg. can't have O_TRUNC without WRONLY or RDWR
N
N
N	yaffsfs_Lock();
N
N	handle = yaffsfs_GetHandle();
N
N	if(handle >= 0)
N	{
N
N		h = yaffsfs_GetHandlePointer(handle);
N
N
N		// try to find the exisiting object
N		obj = yaffsfs_FindObject(NULL,path,0);
X		obj = yaffsfs_FindObject(0,path,0);
N
N		if(obj && obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
N		{
N
N			obj = yaffsfs_FollowLink(obj,symDepth++);
N		}
N
N		if(obj && obj->variantType != YAFFS_OBJECT_TYPE_FILE)
N		{
N			obj = NULL;
X			obj = 0;
N		}
N
N		if(obj)
N		{
N			// Check if the object is already in use
N			alreadyOpen = alreadyExclusive = 0;
N
N			for(i = 0; i < YAFFSFS_N_HANDLES; i++)
X			for(i = 0; i < 200; i++)
N			{
N
N				if(i != handle &&
N				   yaffsfs_handle[i].inUse &&
N				    obj == yaffsfs_handle[i].obj)
N				 {
N				 	alreadyOpen = 1;
N					if(yaffsfs_handle[i].exclusive)
N					{
N						alreadyExclusive = 1;
N					}
N				 }
N			}
N
N			if(((oflag & O_EXCL) && alreadyOpen) || alreadyExclusive)
X			if(((oflag & 0200) && alreadyOpen) || alreadyExclusive)
N			{
N				openDenied = 1;
N			}
N
N			// Open should fail if O_CREAT and O_EXCL are specified
N			if((oflag & O_EXCL) && (oflag & O_CREAT))
X			if((oflag & 0200) && (oflag & 0100))
N			{
N				openDenied = 1;
N				yaffsfs_SetError(-EEXIST);
X				yaffsfs_SetError(-17);
N				errorReported = 1;
N			}
N
N			// Check file permissions
N			if( (oflag & (O_RDWR | O_WRONLY)) == 0 &&     // ie O_RDONLY
X			if( (oflag & (02 | 01)) == 0 &&     
N			   !(obj->yst_mode & S_IREAD))
X			   !(obj->yst_mode & 0000400))
N			{
N				openDenied = 1;
N			}
N
N			if( (oflag & O_RDWR) &&
X			if( (oflag & 02) &&
N			   !(obj->yst_mode & S_IREAD))
X			   !(obj->yst_mode & 0000400))
N			{
N				openDenied = 1;
N			}
N
N			if( (oflag & (O_RDWR | O_WRONLY)) &&
X			if( (oflag & (02 | 01)) &&
N			   !(obj->yst_mode & S_IWRITE))
X			   !(obj->yst_mode & 0000200))
N			{
N				openDenied = 1;
N			}
N
N		}
N
N		else if((oflag & O_CREAT))
X		else if((oflag & 0100))
N		{
N			// Let's see if we can create this file
N			dir = yaffsfs_FindDirectory(NULL,path,&name,0);
X			dir = yaffsfs_FindDirectory(0,path,&name,0);
N			if(dir)
N			{
N 				obj = yaffs_MknodFile(dir,name,mode,0,0);
N 
N			}
N			else
N			{
N				yaffsfs_SetError(-ENOTDIR);
X				yaffsfs_SetError(-20);
N				errorReported = 1;
N			}
N		}
N                 
N
N		if(obj && !openDenied)
N		{
N			h->obj = obj;
N			h->inUse = 1;
N	    	h->readOnly = (oflag & (O_WRONLY | O_RDWR)) ? 0 : 1;
X	    	h->readOnly = (oflag & (01 | 02)) ? 0 : 1;
N			h->append =  (oflag & O_APPEND) ? 1 : 0;
X			h->append =  (oflag & 02000) ? 1 : 0;
N			h->exclusive = (oflag & O_EXCL) ? 1 : 0;
X			h->exclusive = (oflag & 0200) ? 1 : 0;
N			h->position = 0;
N
N                        obj->inUse++;
N                        if((oflag & O_TRUNC) && !h->readOnly)
X                        if((oflag & 01000) && !h->readOnly)
N                        {
N                                yaffs_ResizeFile(obj,0);
N                        }
N 
N		}
N		else
N		{
N			yaffsfs_PutHandle(handle);
N			if(!errorReported)
N			{
N				yaffsfs_SetError(-EACCES);
X				yaffsfs_SetError(-13);
N				errorReported = 1;
N			}
N			handle = -1;
N		}
N
N	}
N
N	yaffsfs_Unlock();
N
N	return handle;
N}
N
Nint yaffs_flush(int fd)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	int retVal = 0;
N
N	yaffsfs_Lock();
N
N	h = yaffsfs_GetHandlePointer(fd);
N
N	if(h && h->inUse)
N	{
N		// flush the file
N		yaffs_FlushFile(h->obj,1);
N	}
N	else
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N		retVal = -1;
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N}
N
N
Nint yaffs_close(int fd)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	int retVal = 0;
N
N	yaffsfs_Lock();
N
N	h = yaffsfs_GetHandlePointer(fd);
N
N	if(h && h->inUse)
N	{
N		// clean up
N		yaffs_FlushFile(h->obj,1);
N		h->obj->inUse--;
N		if(h->obj->inUse <= 0 && h->obj->unlinked)
N		{
N			yaffs_DeleteFile(h->obj);
N		}
N		yaffsfs_PutHandle(fd);
N		retVal = 0;
N	}
N	else
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N		retVal = -1;
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N}
N
Nint yaffs_read(int fd, void *buf, unsigned int nbyte)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int pos = 0;
N	int nRead = -1;
N	unsigned int maxRead;
N
N	yaffsfs_Lock();
N	h = yaffsfs_GetHandlePointer(fd);
N	obj = yaffsfs_GetHandleObject(fd);
N 
N	if(!h || !obj)
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N	else if( h && obj)
N	{
N		pos=  h->position;
N 		if(yaffs_GetObjectFileLength(obj) > pos)
N		{
N			maxRead = yaffs_GetObjectFileLength(obj) - pos;
N		}
N		else
N		{
N			maxRead = 0;
N            //
N		}
N
N		if(nbyte > maxRead)
N		{
N			nbyte = maxRead;
N		}
N
N        
N		if(nbyte > 0)
N		{ 
N			nRead = yaffs_ReadDataFromFile(obj,buf,pos,nbyte);
N			if(nRead >= 0)
N			{
N				h->position = pos + nRead;
N			}
N			else
N			{
N				//todo error
N			}
N		}
N		else
N		{
N			nRead = 0;
N		}
N
N	}
N
N	yaffsfs_Unlock();
N
N
N	return (nRead >= 0) ? nRead : -1;
N
N}
N
Nint yaffs_pread(int fd, void *buf, unsigned int nbyte, unsigned int offset)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int pos = 0;
N	int nRead = -1;
N	unsigned int maxRead;
N
N	yaffsfs_Lock();
N	h = yaffsfs_GetHandlePointer(fd);
N	obj = yaffsfs_GetHandleObject(fd);
N
N	if(!h || !obj)
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N	else if( h && obj)
N	{
N		pos= offset;
N		if(yaffs_GetObjectFileLength(obj) > pos)
N		{
N			maxRead = yaffs_GetObjectFileLength(obj) - pos;
N		}
N		else
N		{
N			maxRead = 0;
N		}
N
N		if(nbyte > maxRead)
N		{
N			nbyte = maxRead;
N		}
N
N
N		if(nbyte > 0)
N		{
N			nRead = yaffs_ReadDataFromFile(obj,buf,pos,nbyte);
N		}
N		else
N		{
N			nRead = 0;
N		}
N
N	}
N
N	yaffsfs_Unlock();
N
N
N	return (nRead >= 0) ? nRead : -1;
N
N}
N
Nint yaffs_write(int fd, const void *buf, unsigned int nbyte)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int pos = 0;
N	int nWritten = -1;
N	int writeThrough = 0;
N
N	yaffsfs_Lock();
N	h = yaffsfs_GetHandlePointer(fd);
N	obj = yaffsfs_GetHandleObject(fd);
N 
N	if(!h || !obj)
N	{
N 
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N	else if( h && obj && h->readOnly)
N	{
N		// todo error
N	}
N	else if( h && obj)
N	{
N		if(h->append)
N		{
N		         
N			pos =  yaffs_GetObjectFileLength(obj);
N			 
N		}
N		else
N		{
N			pos = h->position;
N		}
N
N		nWritten = yaffs_WriteDataToFile(obj,buf,pos,nbyte,writeThrough);
N
N		if(nWritten >= 0)
N		{
N			h->position = pos + nWritten;
N		}
N		else
N		{
N	 
N		}
N
N	}
N
N	yaffsfs_Unlock();
N
N
N	return (nWritten >= 0) ? nWritten : -1;
N
N}
N
Nint yaffs_pwrite(int fd, const void *buf, unsigned int nbyte, unsigned int offset)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int pos = 0;
N	int nWritten = -1;
N	int writeThrough = 0;
N
N	yaffsfs_Lock();
N	h = yaffsfs_GetHandlePointer(fd);
N	obj = yaffsfs_GetHandleObject(fd);
N
N	if(!h || !obj)
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N	else if( h && obj && h->readOnly)
N	{
N		// todo error
N	}
N	else if( h && obj)
N	{
N		pos = offset;
N
N                nWritten = yaffs_WriteDataToFile(obj,buf,pos,nbyte,writeThrough);
N
N                if(nWritten < 0 || ((unsigned int)nWritten) < nbyte)
N                        yaffsfs_SetError(-ENOSPC);
X                        yaffsfs_SetError(-28);
N
N        }
N
N	yaffsfs_Unlock();
N
N
N	return (nWritten >= 0) ? nWritten : -1;
N
N}
N
N
Nint yaffs_truncate(const YCHAR *path,off_t newSize)
Xint yaffs_truncate(const char *path,off_t newSize)
N{
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int result = YAFFS_FAIL;
X	int result = 0;
N
N	yaffsfs_Lock();
N
N	obj = yaffsfs_FindObject(NULL,path,0);
X	obj = yaffsfs_FindObject(0,path,0);
N	if(obj)
N		obj = yaffs_GetEquivalentObject(obj);
N
N	if(!obj)
N	{
N		yaffsfs_SetError(-ENOENT);
X		yaffsfs_SetError(-2);
N	}
N	else if(obj->variantType != YAFFS_OBJECT_TYPE_FILE)
N	{
N		yaffsfs_SetError(-EISDIR);
X		yaffsfs_SetError(-21);
N	}
N	else
N	{
N		result = yaffs_ResizeFile(obj,newSize);
N	}
N
N	yaffsfs_Unlock();
N
N
N	return (result) ? 0 : -1;
N}
N
Nint yaffs_ftruncate(int fd, off_t newSize)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int result = 0;
N
N	yaffsfs_Lock();
N	h = yaffsfs_GetHandlePointer(fd);
N	obj = yaffsfs_GetHandleObject(fd);
N
N	if(!h || !obj)
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N	else
N	{
N		// resize the file
N		result = yaffs_ResizeFile(obj,newSize);
N	}
N	yaffsfs_Unlock();
N
N
N	return (result) ? 0 : -1;
N
N}
N
Noff_t yaffs_lseek(int fd, off_t offset, int whence)
N{
N	yaffsfs_Handle *h = NULL;
X	yaffsfs_Handle *h = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int pos = -1;
N	int fSize = -1;
N
N	yaffsfs_Lock();
N	h = yaffsfs_GetHandlePointer(fd);
N	obj = yaffsfs_GetHandleObject(fd);
N
N	if(!h || !obj)
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N	else if(whence == SEEK_SET)
X	else if(whence == 0)
N	{
N		if(offset >= 0)
N		{
N			pos = offset;
N		}
N	}
N	else if(whence == SEEK_CUR)
X	else if(whence == 1)
N	{
W "..\fs\yaffsfs.c" 944 30 pointless comparison of unsigned integer with zero
N		if( (h->position + offset) >= 0)
N		{
N			pos = (h->position + offset);
N		}
N	}
N	else if(whence == SEEK_END)
X	else if(whence == 2)
N	{
N		fSize = yaffs_GetObjectFileLength(obj);
N		if(fSize >= 0 && (fSize + offset) >= 0)
N		{
N			pos = fSize + offset;
N		}
N	}
N
N	if(pos >= 0)
N	{
N		h->position = pos;
N	}
N	else
N	{
N		// todo error
N	}
N
N
N	yaffsfs_Unlock();
N
N	return pos;
N}
N
N
Nint yaffsfs_DoUnlink(const YCHAR *path,int isDirectory)
Xint yaffsfs_DoUnlink(const char *path,int isDirectory)
N{
N	yaffs_Object *dir = NULL;
X	yaffs_Object *dir = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	YCHAR *name;
X	char *name;
N	int result = YAFFS_FAIL;
X	int result = 0;
N
N	yaffsfs_Lock();
N
N	obj = yaffsfs_FindObject(NULL,path,0);
X	obj = yaffsfs_FindObject(0,path,0);
N	dir = yaffsfs_FindDirectory(NULL,path,&name,0);
X	dir = yaffsfs_FindDirectory(0,path,&name,0);
N	if(!dir)
N	{
N		yaffsfs_SetError(-ENOTDIR);
X		yaffsfs_SetError(-20);
N	}
N	else if(!obj)
N	{
N		yaffsfs_SetError(-ENOENT);
X		yaffsfs_SetError(-2);
N	}
N	else if(!isDirectory && obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)
N	{
N		yaffsfs_SetError(-EISDIR);
X		yaffsfs_SetError(-21);
N	}
N	else if(isDirectory && obj->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
N	{
N		yaffsfs_SetError(-ENOTDIR);
X		yaffsfs_SetError(-20);
N	}
N	else
N	{
N		result = yaffs_Unlink(dir,name);
N
N		if(result == YAFFS_FAIL && isDirectory)
X		if(result == 0 && isDirectory)
N		{
N			yaffsfs_SetError(-ENOTEMPTY);
X			yaffsfs_SetError(-39);
N		}
N	}
N
N	yaffsfs_Unlock();
N
N	// todo error
N
N	return (result == YAFFS_FAIL) ? -1 : 0;
X	return (result == 0) ? -1 : 0;
N}
N
N
Nint yaffs_rmdir(const YCHAR *path)
Xint yaffs_rmdir(const char *path)
N{
N	return yaffsfs_DoUnlink(path,1);
N}
N
Nint yaffs_unlink(const YCHAR *path)
Xint yaffs_unlink(const char *path)
N{
N	return yaffsfs_DoUnlink(path,0);
N}
N
Nint yaffs_rename(const YCHAR *oldPath, const YCHAR *newPath)
Xint yaffs_rename(const char *oldPath, const char *newPath)
N{
N	yaffs_Object *olddir = NULL;
X	yaffs_Object *olddir = 0;
N	yaffs_Object *newdir = NULL;
X	yaffs_Object *newdir = 0;
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	YCHAR *oldname;
X	char *oldname;
N	YCHAR *newname;
X	char *newname;
N	int result= YAFFS_FAIL;
X	int result= 0;
N	int renameAllowed = 1;
N
N	yaffsfs_Lock();
N
N	olddir = yaffsfs_FindDirectory(NULL,oldPath,&oldname,0);
X	olddir = yaffsfs_FindDirectory(0,oldPath,&oldname,0);
N	newdir = yaffsfs_FindDirectory(NULL,newPath,&newname,0);
X	newdir = yaffsfs_FindDirectory(0,newPath,&newname,0);
N	obj = yaffsfs_FindObject(NULL,oldPath,0);
X	obj = yaffsfs_FindObject(0,oldPath,0);
N
N	if(!olddir || !newdir || !obj)
N	{
N		// bad file
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N		renameAllowed = 0;
N	}
N	else if(olddir->myDev != newdir->myDev)
N	{
N		// oops must be on same device
N		// todo error
N		yaffsfs_SetError(-EXDEV);
X		yaffsfs_SetError(-18);
N		renameAllowed = 0;
N	}
N	else if(obj && obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)
N	{
N		// It is a directory, check that it is not being renamed to
N		// being its own decendent.
N		// Do this by tracing from the new directory back to the root, checking for obj
N
N		yaffs_Object *xx = newdir;
N
N		while( renameAllowed && xx)
N		{
N			if(xx == obj)
N			{
N				renameAllowed = 0;
N			}
N			xx = xx->parent;
N		}
N		if(!renameAllowed) yaffsfs_SetError(-EACCES);
X		if(!renameAllowed) yaffsfs_SetError(-13);
N	}
N
N	if(renameAllowed)
N	{
N		result = yaffs_RenameObject(olddir,oldname,newdir,newname);
N	}
N
N	yaffsfs_Unlock();
N
N	return (result == YAFFS_FAIL) ? -1 : 0;
X	return (result == 0) ? -1 : 0;
N}
N
N
Nstatic int yaffsfs_DoStat(yaffs_Object *obj,struct yaffs_stat *buf)
N{
N	int retVal = -1;
N
N	if(obj)
N	{
N		obj = yaffs_GetEquivalentObject(obj);
N	}
N
N	if(obj && buf)
N	{
N    	buf->st_dev = (int)obj->myDev->genericDevice;
N    	buf->st_ino = obj->objectId;
N    	buf->st_mode = obj->yst_mode & ~S_IFMT; // clear out file type bits
X    	buf->st_mode = obj->yst_mode & ~0170000; 
N
N		if(obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)
N		{
N			buf->st_mode |= S_IFDIR;
X			buf->st_mode |= 0040000;
N		}
N		else if(obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
N		{
N			buf->st_mode |= S_IFLNK;
X			buf->st_mode |= 0120000;
N		}
N		else if(obj->variantType == YAFFS_OBJECT_TYPE_FILE)
N		{
N			buf->st_mode |= S_IFREG;
X			buf->st_mode |= 0100000;
N		}
N
N    	buf->st_nlink = yaffs_GetObjectLinkCount(obj);
N    	buf->st_uid = 0;
N    	buf->st_gid = 0;;
N    	buf->st_rdev = obj->yst_rdev;
N    	buf->st_size = yaffs_GetObjectFileLength(obj);
N		buf->st_blksize = obj->myDev->nDataBytesPerChunk;
N    	buf->st_blocks = (buf->st_size + buf->st_blksize -1)/buf->st_blksize;
N#if CONFIG_YAFFS_WINCE
S		buf->yst_wince_atime[0] = obj->win_atime[0];
S		buf->yst_wince_atime[1] = obj->win_atime[1];
S		buf->yst_wince_ctime[0] = obj->win_ctime[0];
S		buf->yst_wince_ctime[1] = obj->win_ctime[1];
S		buf->yst_wince_mtime[0] = obj->win_mtime[0];
S		buf->yst_wince_mtime[1] = obj->win_mtime[1];
N#else
N    	buf->yst_atime = obj->yst_atime;
N    	buf->yst_ctime = obj->yst_ctime;
N    	buf->yst_mtime = obj->yst_mtime;
N#endif
N		retVal = 0;
N	}
N	return retVal;
N}
N
Nstatic int yaffsfs_DoStatOrLStat(const YCHAR *path, struct yaffs_stat *buf,int doLStat)
Xstatic int yaffsfs_DoStatOrLStat(const char *path, struct yaffs_stat *buf,int doLStat)
N{
N	yaffs_Object *obj;
N
N	int retVal = -1;
N
N	yaffsfs_Lock();
N	obj = yaffsfs_FindObject(NULL,path,0);
X	obj = yaffsfs_FindObject(0,path,0);
N
N	if(!doLStat && obj)
N	{
N		obj = yaffsfs_FollowLink(obj,0);
N	}
N
N	if(obj)
N	{
N		retVal = yaffsfs_DoStat(obj,buf);
N	}
N	else
N	{
N		// todo error not found
N		yaffsfs_SetError(-ENOENT);
X		yaffsfs_SetError(-2);
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N
N}
N
Nint yaffs_stat(const YCHAR *path, struct yaffs_stat *buf)
Xint yaffs_stat(const char *path, struct yaffs_stat *buf)
N{
N	return yaffsfs_DoStatOrLStat(path,buf,0);
N}
N
Nint yaffs_lstat(const YCHAR *path, struct yaffs_stat *buf)
Xint yaffs_lstat(const char *path, struct yaffs_stat *buf)
N{
N	return yaffsfs_DoStatOrLStat(path,buf,1);
N}
N
Nint yaffs_fstat(int fd, struct yaffs_stat *buf)
N{
N	yaffs_Object *obj;
N
N	int retVal = -1;
N
N	yaffsfs_Lock();
N	obj = yaffsfs_GetHandleObject(fd);
N
N	if(obj)
N	{
N		retVal = yaffsfs_DoStat(obj,buf);
N	}
N	else
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N}
N
N#ifdef CONFIG_YAFFS_WINCE
Sint yaffs_get_wince_times(int fd, unsigned *wctime, unsigned *watime, unsigned *wmtime)
S{
S	yaffs_Object *obj;
S
S	int retVal = -1;
S
S	yaffsfs_Lock();
S	obj = yaffsfs_GetHandleObject(fd);
S
S	if(obj)
S	{
S
S		if(wctime){
S			wctime[0] = obj->win_ctime[0];
S			wctime[1] = obj->win_ctime[1];
S		}
S		if(watime){
S			watime[0] = obj->win_atime[0];
S			watime[1] = obj->win_atime[1];
S		}
S		if(wmtime){
S			wmtime[0] = obj->win_mtime[0];
S			wmtime[1] = obj->win_mtime[1];
S		}
S
S
S		retVal = 0;
S	}
S	else
S	{
S		// bad handle
S		yaffsfs_SetError(-EBADF);		
S	}
S	
S	yaffsfs_Unlock();
S	
S	return retVal;
S}
S
S
Sint yaffs_set_wince_times(int fd, 
S						  const unsigned *wctime, 
S						  const unsigned *watime, 
S                                                  const unsigned *wmtime)
S{
S        yaffs_Object *obj;
S        int result;
S        int retVal = -1;
S
S        yaffsfs_Lock();
S	obj = yaffsfs_GetHandleObject(fd);
S
S	if(obj)
S	{
S
S		if(wctime){
S			obj->win_ctime[0] = wctime[0];
S			obj->win_ctime[1] = wctime[1];
S		}
S		if(watime){
S                        obj->win_atime[0] = watime[0];
S                        obj->win_atime[1] = watime[1];
S                }
S                if(wmtime){
S                        obj->win_mtime[0] = wmtime[0];
S                        obj->win_mtime[1] = wmtime[1];
S                }
S
S                obj->dirty = 1;
S                result = yaffs_FlushFile(obj,0);
S                retVal = 0;
S        }
S        else
S	{
S		// bad handle
S		yaffsfs_SetError(-EBADF);
S	}
S
S	yaffsfs_Unlock();
S
S	return retVal;
S}
S
N#endif
N
N
Nstatic int yaffsfs_DoChMod(yaffs_Object *obj,mode_t mode)
N{
N	int result = -1;
N
N	if(obj)
N	{
N		obj = yaffs_GetEquivalentObject(obj);
N	}
N
N	if(obj)
N	{
N		obj->yst_mode = mode;
N		obj->dirty = 1;
N		result = yaffs_FlushFile(obj,0);
N	}
N
N	return result == YAFFS_OK ? 0 : -1;
X	return result == 1 ? 0 : -1;
N}
N
N
Nint yaffs_access(const YCHAR *path, int amode)
Xint yaffs_access(const char *path, int amode)
N{
N	yaffs_Object *obj;
N
N	int retval = 0;
N
N	yaffsfs_Lock();
N	obj = yaffsfs_FindObject(NULL,path,0);
X	obj = yaffsfs_FindObject(0,path,0);
N
N	if(obj)
N	{
N		int access_ok = 1;
N
N		if((amode & R_OK) && !(obj->yst_mode & S_IREAD))
X		if((amode & 4) && !(obj->yst_mode & 0000400))
N			access_ok = 0;
N		if((amode & W_OK) && !(obj->yst_mode & S_IWRITE))
X		if((amode & 2) && !(obj->yst_mode & 0000200))
N			access_ok = 0;
N		if((amode & X_OK) && !(obj->yst_mode & S_IEXEC))
X		if((amode & 1) && !(obj->yst_mode & 0000100))
N			access_ok = 0;
N
N		if(!access_ok) {
N			yaffsfs_SetError(-EACCES);
X			yaffsfs_SetError(-13);
N			retval = -1;
N		}
N	}
N	else
N	{
N		// todo error not found
N		yaffsfs_SetError(-ENOENT);
X		yaffsfs_SetError(-2);
N		retval = -1;
N	}
N
N	yaffsfs_Unlock();
N
N	return retval;
N
N}
N
N
Nint yaffs_chmod(const YCHAR *path, mode_t mode)
Xint yaffs_chmod(const char *path, mode_t mode)
N{
N	yaffs_Object *obj;
N
N	int retVal = -1;
N
N	yaffsfs_Lock();
N	obj = yaffsfs_FindObject(NULL,path,0);
X	obj = yaffsfs_FindObject(0,path,0);
N
N	if(obj)
N	{
N		retVal = yaffsfs_DoChMod(obj,mode);
N	}
N	else
N	{
N		// todo error not found
N		yaffsfs_SetError(-ENOENT);
X		yaffsfs_SetError(-2);
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N
N}
N
N
Nint yaffs_fchmod(int fd, mode_t mode)
N{
N	yaffs_Object *obj;
N
N	int retVal = -1;
N
N	yaffsfs_Lock();
N	obj = yaffsfs_GetHandleObject(fd);
N
N	if(obj)
N	{
N		retVal = yaffsfs_DoChMod(obj,mode);
N	}
N	else
N	{
N		// bad handle
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N}
N
N
Nint yaffs_mkdir(const YCHAR *path, mode_t mode)
Xint yaffs_mkdir(const char *path, mode_t mode)
N{
N	yaffs_Object *parent = NULL;
X	yaffs_Object *parent = 0;
N	yaffs_Object *dir = NULL;
X	yaffs_Object *dir = 0;
N	YCHAR *name;
X	char *name;
N	int retVal= -1;
N
N	yaffsfs_Lock();
N	parent = yaffsfs_FindDirectory(NULL,path,&name,0);
X	parent = yaffsfs_FindDirectory(0,path,&name,0);
N	if(parent)
N		dir = yaffs_MknodDirectory(parent,name,mode,0,0);
N	if(dir)
N	{
N		retVal = 0;
N	}
N	else
N	{
N		if(!parent){
N			yaffsfs_SetError(-ENOENT); // missing path
X			yaffsfs_SetError(-2); 
N			put_str_("yaffs mkdir missing path");
X			_db_msg_((LPC_UART_TypeDef *)((LPC_UART_TypeDef *) ((0x40000000UL) + 0x0C000) ), "yaffs mkdir missing path");
N		}
N		else if (yaffs_FindObjectByName(parent,name)){
N			yaffsfs_SetError(-EEXIST); // the name already exists
X			yaffsfs_SetError(-17); 
N			put_str_("yaffs mkdir already exists");
X			_db_msg_((LPC_UART_TypeDef *)((LPC_UART_TypeDef *) ((0x40000000UL) + 0x0C000) ), "yaffs mkdir already exists");
N		}
N		else
N			yaffsfs_SetError(-ENOSPC); // just assume no space
X			yaffsfs_SetError(-28); 
N		put_str_("yaffs mkdir no space");
X		_db_msg_((LPC_UART_TypeDef *)((LPC_UART_TypeDef *) ((0x40000000UL) + 0x0C000) ), "yaffs mkdir no space");
N		retVal = -1;
N        
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N}
N
Nint yaffs_mount(const YCHAR *path)
Xint yaffs_mount(const char *path)
N{
N	int retVal=-1;
N	int result=YAFFS_FAIL;
X	int result=0;
N	yaffs_Device *dev=NULL;
X	yaffs_Device *dev=0;
N	YCHAR *dummy;
X	char *dummy;
N    
N	T(YAFFS_TRACE_ALWAYS,(TSTR("yaffs: Mounting %s" TENDSTR),path));
X	do{ if((0xF0000000) & (yaffs_traceMask | 0xF0000000)) ;} while(0);
N    
N	yaffsfs_Lock();
N	dev = yaffsfs_FindDevice(path,&dummy);
N	 
N	if(dev)
N	{
N	  		 
N		if(!dev->isMounted)
N		{ 
N		    
N			result = yaffs_GutsInitialise(dev);
N		 
N			if(result == YAFFS_FAIL)
X			if(result == 0)
N			{
N				// todo error - mount failed
N				yaffsfs_SetError(-ENOMEM);
X				yaffsfs_SetError(-12);
N			}
N			retVal = result ? 0 : -1;
N		}
N		else
N		{
N		 
N			//todo error - already mounted.
N			yaffsfs_SetError(-EBUSY);
X			yaffsfs_SetError(-16);
N		}
N	}
N	else
N	{
N		// todo error - no device
N 
N		yaffsfs_SetError(-ENODEV);
X		yaffsfs_SetError(-19);
N	}
N	yaffsfs_Unlock();
N	return retVal;
N
N}
N
Nint yaffs_sync(const YCHAR *path)
Xint yaffs_sync(const char *path)
N{
N        int retVal=-1;
N        yaffs_Device *dev=NULL;
X        yaffs_Device *dev=0;
N        YCHAR *dummy;
X        char *dummy;
N        
N        yaffsfs_Lock();
N        dev = yaffsfs_FindDevice(path,&dummy);
N        if(dev)
N        {
N                if(dev->isMounted)
N                {
N                        
N                        yaffs_FlushEntireDeviceCache(dev);
N                        yaffs_CheckpointSave(dev);
N                        
N                        
N                }
N                else
N                {
N                        //todo error - not mounted.
N                        yaffsfs_SetError(-EINVAL);
X                        yaffsfs_SetError(-22);
N                        
N                }
N        }
N        else
N        {
N                // todo error - no device
N                yaffsfs_SetError(-ENODEV);
X                yaffsfs_SetError(-19);
N        }       
N        yaffsfs_Unlock();
N        return retVal;  
N}
N
N
Nint yaffs_unmount(const YCHAR *path)
Xint yaffs_unmount(const char *path)
N{
N        int retVal=-1;
N	yaffs_Device *dev=NULL;
X	yaffs_Device *dev=0;
N	YCHAR *dummy;
X	char *dummy;
N
N	yaffsfs_Lock();
N	dev = yaffsfs_FindDevice(path,&dummy);
N	if(dev)
N	{
N		if(dev->isMounted)
N		{
N			int i;
N			int inUse;
N
N			yaffs_FlushEntireDeviceCache(dev);
N			yaffs_CheckpointSave(dev);
N
N			for(i = inUse = 0; i < YAFFSFS_N_HANDLES && !inUse; i++)
X			for(i = inUse = 0; i < 200 && !inUse; i++)
N			{
N				if(yaffsfs_handle[i].inUse && yaffsfs_handle[i].obj->myDev == dev)
N				{
N					inUse = 1; // the device is in use, can't unmount
N				}
N			}
N
N			if(!inUse)
N			{
N				yaffs_Deinitialise(dev);
N
N				retVal = 0;
N			}
N			else
N			{
N				// todo error can't unmount as files are open
N				yaffsfs_SetError(-EBUSY);
X				yaffsfs_SetError(-16);
N			}
N
N		}
N		else
N		{
N			//todo error - not mounted.
N			yaffsfs_SetError(-EINVAL);
X			yaffsfs_SetError(-22);
N
N		}
N	}
N	else
N	{
N		// todo error - no device
N		yaffsfs_SetError(-ENODEV);
X		yaffsfs_SetError(-19);
N	}
N	yaffsfs_Unlock();
N	return retVal;
N
N}
N
Nloff_t yaffs_freespace(const YCHAR *path)
Xloff_t yaffs_freespace(const char *path)
N{
W "..\fs\yaffsfs.c" 1576 16 integer conversion resulted in a change of sign
N	loff_t retVal=-1;
N	yaffs_Device *dev=NULL;
X	yaffs_Device *dev=0;
N	YCHAR *dummy;
X	char *dummy;
N
N	yaffsfs_Lock();
N	dev = yaffsfs_FindDevice(path,&dummy);
N	if(dev  && dev->isMounted)
N	{
N		retVal = yaffs_GetNumberOfFreeChunks(dev);
N		retVal *= dev->nDataBytesPerChunk;
N
N	}
N	else
N	{
N		yaffsfs_SetError(-EINVAL);
X		yaffsfs_SetError(-22);
N	}
N
N	yaffsfs_Unlock();
N	return retVal;
N}
N
Nloff_t yaffs_totalspace(const YCHAR *path)
Xloff_t yaffs_totalspace(const char *path)
N{
W "..\fs\yaffsfs.c" 1599 16 integer conversion resulted in a change of sign
N	loff_t retVal=-1;
N	yaffs_Device *dev=NULL;
X	yaffs_Device *dev=0;
N	YCHAR *dummy;
X	char *dummy;
N
N	yaffsfs_Lock();
N	dev = yaffsfs_FindDevice(path,&dummy);
N	if(dev  && dev->isMounted)
N	{
N		retVal = (dev->endBlock - dev->startBlock + 1) - dev->nReservedBlocks;
N		retVal *= dev->nChunksPerBlock;
N		retVal *= dev->nDataBytesPerChunk;
N
N	}
N	else
N	{
N		yaffsfs_SetError(-EINVAL);
X		yaffsfs_SetError(-22);
N	}
N
N	yaffsfs_Unlock();
N	return retVal;
N}
N
Nint yaffs_inodecount(const YCHAR *path)
Xint yaffs_inodecount(const char *path)
N{
W "..\fs\yaffsfs.c" 1623 17 integer conversion resulted in a change of sign
N	loff_t retVal= -1;
N	yaffs_Device *dev=NULL;
X	yaffs_Device *dev=0;
N	YCHAR *dummy;
X	char *dummy;
N
N	yaffsfs_Lock();
N	dev = yaffsfs_FindDevice(path,&dummy);
N	if(dev  && dev->isMounted) {
N	   int nObjects = dev->nObjectsCreated - dev->nFreeObjects;
N	   if(nObjects > dev->nHardLinks)
N		retVal = nObjects - dev->nHardLinks;
N	}
N	
W "..\fs\yaffsfs.c" 1635 12 pointless comparison of unsigned integer with zero
N	if(retVal < 0){
N		yaffsfs_SetError(-EINVAL);
X		yaffsfs_SetError(-22);
N	}
N	
N	yaffsfs_Unlock();
N	return retVal;	
N}
N
N
N
Nvoid yaffs_initialise(yaffsfs_DeviceConfiguration *cfgList)
N{
N
N	yaffsfs_DeviceConfiguration *cfg;
N
N	yaffsfs_configurationList = cfgList;
N
N	yaffsfs_InitHandles();
N
N	cfg = yaffsfs_configurationList;
N
N	while(cfg && cfg->prefix && cfg->dev)
N	{
N		cfg->dev->isMounted = 0;
N		cfg->dev->removeObjectCallback = yaffsfs_RemoveObjectCallback;
N		cfg++;
N	}
N
N
N}
N
N
N//
N// Directory search stuff.
N
N//
N// Directory search context
N//
N// NB this is an opaque structure.
N
N
Ntypedef struct
N{
N	__u32 magic;
N	yaffs_dirent de;		/* directory entry being used by this dsc */
N	YCHAR name[NAME_MAX+1];		/* name of directory being searched */
X	char name[256+1];		 
N        yaffs_Object *dirObj;           /* ptr to directory being searched */
N        yaffs_Object *nextReturn;       /* obj to be returned by next readddir */
N        int offset;
N        struct ylist_head others;       
N} yaffsfs_DirectorySearchContext;
N
N
N
Nstatic struct ylist_head search_contexts;
N
N
Nstatic void yaffsfs_SetDirRewound(yaffsfs_DirectorySearchContext *dsc)
N{
N	if(dsc &&
N	   dsc->dirObj &&
N	   dsc->dirObj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY){
N
N           dsc->offset = 0;
N
N           if( ylist_empty(&dsc->dirObj->variant.directoryVariant.children)){
N                dsc->nextReturn = NULL;
X                dsc->nextReturn = 0;
N           } else {
N                dsc->nextReturn = ylist_entry(dsc->dirObj->variant.directoryVariant.children.next,
N                                                yaffs_Object,siblings);
X                dsc->nextReturn = ((yaffs_Object *)((char *)(dsc->dirObj->variant . directoryVariant . children . next)-(unsigned long)(&((yaffs_Object *)0)->siblings)));
N           }
N        } else {
N		/* Hey someone isn't playing nice! */
N	}
N}
N
Nstatic void yaffsfs_DirAdvance(yaffsfs_DirectorySearchContext *dsc)
N{
N	if(dsc &&
N	   dsc->dirObj &&
N           dsc->dirObj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY){
N
N           if( dsc->nextReturn == NULL ||
X           if( dsc->nextReturn == 0 ||
N               ylist_empty(&dsc->dirObj->variant.directoryVariant.children)){
N                dsc->nextReturn = NULL;
X                dsc->nextReturn = 0;
N           } else {
N                   struct ylist_head *next = dsc->nextReturn->siblings.next;
N
N                   if( next == &dsc->dirObj->variant.directoryVariant.children)
N                        dsc->nextReturn = NULL; /* end of list */
X                        dsc->nextReturn = 0;  
N                   else
N                        dsc->nextReturn = ylist_entry(next,yaffs_Object,siblings);
X                        dsc->nextReturn = ((yaffs_Object *)((char *)(next)-(unsigned long)(&((yaffs_Object *)0)->siblings)));
N           }
N        } else {
N                /* Hey someone isn't playing nice! */
N	}
N}
N
Nstatic void yaffsfs_RemoveObjectCallback(yaffs_Object *obj)
N{
N
N        struct ylist_head *i;
N        yaffsfs_DirectorySearchContext *dsc;
N
N        /* if search contexts not initilised then skip */
N        if(!search_contexts.next)
N                return;
N
N        /* Iterate through the directory search contexts.
N         * If any are the one being removed, then advance the dsc to
N         * the next one to prevent a hanging ptr.
N         */
N         ylist_for_each(i, &search_contexts) {
X         for (i = (&search_contexts)->next; i != (&search_contexts); i = i->next ) {
N                if (i) {
N                        dsc = ylist_entry(i, yaffsfs_DirectorySearchContext,others);
X                        dsc = ((yaffsfs_DirectorySearchContext *)((char *)(i)-(unsigned long)(&((yaffsfs_DirectorySearchContext *)0)->others)));
N                        if(dsc->nextReturn == obj)
N                                yaffsfs_DirAdvance(dsc);
N                }
N	}
N
N}
N
Nyaffs_DIR *yaffs_opendir(const YCHAR *dirname)
Xyaffs_DIR *yaffs_opendir(const char *dirname)
N{
N	yaffs_DIR *dir = NULL;
X	yaffs_DIR *dir = 0;
N 	yaffs_Object *obj = NULL;
X 	yaffs_Object *obj = 0;
N	yaffsfs_DirectorySearchContext *dsc = NULL;
X	yaffsfs_DirectorySearchContext *dsc = 0;
N
N	yaffsfs_Lock();
N
N	obj = yaffsfs_FindObject(NULL,dirname,0);
X	obj = yaffsfs_FindObject(0,dirname,0);
N
N	if(obj && obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)
N	{
N
N		dsc = YMALLOC(sizeof(yaffsfs_DirectorySearchContext));
X		dsc = yaffs_malloc(sizeof(yaffsfs_DirectorySearchContext));
N		dir = (yaffs_DIR *)dsc;
N		if(dsc)
N		{
N			memset(dsc,0,sizeof(yaffsfs_DirectorySearchContext));
N                        dsc->magic = YAFFS_MAGIC;
X                        dsc->magic = 0x5941FF53;
N                        dsc->dirObj = obj;
N                        yaffs_strncpy(dsc->name,dirname,NAME_MAX);
X                        strncpy(dsc->name,dirname,256);
N                        YINIT_LIST_HEAD(&dsc->others);
X                        do { (&dsc->others)->next = (&dsc->others); (&dsc->others)->prev = (&dsc->others); } while(0);
N
N                        if(!search_contexts.next)
N                                YINIT_LIST_HEAD(&search_contexts);
X                                do { (&search_contexts)->next = (&search_contexts); (&search_contexts)->prev = (&search_contexts); } while(0);
N
N                        ylist_add(&dsc->others,&search_contexts);       
N                        yaffsfs_SetDirRewound(dsc);             }
N
N        }
N
N	yaffsfs_Unlock();
N
N	return dir;
N}
N
Nstruct yaffs_dirent *yaffs_readdir(yaffs_DIR *dirp)
N{
N	yaffsfs_DirectorySearchContext *dsc = (yaffsfs_DirectorySearchContext *)dirp;
N	struct yaffs_dirent *retVal = NULL;
X	struct yaffs_dirent *retVal = 0;
N
N	yaffsfs_Lock();
N
N	if(dsc && dsc->magic == YAFFS_MAGIC){
X	if(dsc && dsc->magic == 0x5941FF53){
N		yaffsfs_SetError(0);
N		if(dsc->nextReturn){
N			dsc->de.d_ino = yaffs_GetEquivalentObject(dsc->nextReturn)->objectId;
N			dsc->de.d_dont_use = (unsigned)dsc->nextReturn;
N			dsc->de.d_off = dsc->offset++;
N			yaffs_GetObjectName(dsc->nextReturn,dsc->de.d_name,NAME_MAX);
X			yaffs_GetObjectName(dsc->nextReturn,dsc->de.d_name,256);
N			if(yaffs_strlen(dsc->de.d_name) == 0)
X			if(strlen(dsc->de . d_name) == 0)
N			{
N				// this should not happen!
N				yaffs_strcpy(dsc->de.d_name,_Y("zz"));
X				strcpy(dsc->de . d_name,"zz");
N			}
N			dsc->de.d_reclen = sizeof(struct yaffs_dirent);
N			retVal = &dsc->de;
N			yaffsfs_DirAdvance(dsc);
N		} else
N			retVal = NULL;
X			retVal = 0;
N	}
N	else
N	{
N		yaffsfs_SetError(-EBADF);
X		yaffsfs_SetError(-9);
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N
N}
N
N
Nvoid yaffs_rewinddir(yaffs_DIR *dirp)
N{
N	yaffsfs_DirectorySearchContext *dsc = (yaffsfs_DirectorySearchContext *)dirp;
N
N	yaffsfs_Lock();
N
N	yaffsfs_SetDirRewound(dsc);
N
N	yaffsfs_Unlock();
N}
N
N
Nint yaffs_closedir(yaffs_DIR *dirp)
N{
N	yaffsfs_DirectorySearchContext *dsc = (yaffsfs_DirectorySearchContext *)dirp;
N
N        yaffsfs_Lock();
N        dsc->magic = 0;
N        ylist_del(&dsc->others); /* unhook from list */
N        YFREE(dsc);
X        free(dsc);
N        yaffsfs_Unlock();
N        return 0;
N}
N
N// end of directory stuff
N
N
Nint yaffs_symlink(const YCHAR *oldpath, const YCHAR *newpath)
Xint yaffs_symlink(const char *oldpath, const char *newpath)
N{
N	yaffs_Object *parent = NULL;
X	yaffs_Object *parent = 0;
N	yaffs_Object *obj;
N	YCHAR *name;
X	char *name;
N	int retVal= -1;
N	int mode = 0; // ignore for now
N
N	yaffsfs_Lock();
N	parent = yaffsfs_FindDirectory(NULL,newpath,&name,0);
X	parent = yaffsfs_FindDirectory(0,newpath,&name,0);
N	obj = yaffs_MknodSymLink(parent,name,mode,0,0,oldpath);
N	if(obj)
N	{
N		retVal = 0;
N	}
N	else
N	{
N		yaffsfs_SetError(-ENOSPC); // just assume no space for now
X		yaffsfs_SetError(-28); 
N		retVal = -1;
N	}
N
N	yaffsfs_Unlock();
N
N	return retVal;
N
N}
N
Nint yaffs_readlink(const YCHAR *path, YCHAR *buf, int bufsiz)
Xint yaffs_readlink(const char *path, char *buf, int bufsiz)
N{
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	int retVal;
N
N
N	yaffsfs_Lock();
N
N	obj = yaffsfs_FindObject(NULL,path,0);
X	obj = yaffsfs_FindObject(0,path,0);
N
N	if(!obj)
N	{
N		yaffsfs_SetError(-ENOENT);
X		yaffsfs_SetError(-2);
N		retVal = -1;
N	}
N	else if(obj->variantType != YAFFS_OBJECT_TYPE_SYMLINK)
N	{
N		yaffsfs_SetError(-EINVAL);
X		yaffsfs_SetError(-22);
N		retVal = -1;
N	}
N	else
N	{
N		YCHAR *alias = obj->variant.symLinkVariant.alias;
X		char *alias = obj->variant.symLinkVariant.alias;
N		memset(buf,0,bufsiz);
N		yaffs_strncpy(buf,alias,bufsiz - 1);
X		strncpy(buf,alias,bufsiz - 1);
N		retVal = 0;
N	}
N	yaffsfs_Unlock();
N	return retVal;
N}
N
Nint yaffs_link(const YCHAR *oldpath, const YCHAR *newpath)
Xint yaffs_link(const char *oldpath, const char *newpath)
N{
N	// Creates a link called newpath to existing oldpath
N	yaffs_Object *obj = NULL;
X	yaffs_Object *obj = 0;
N	yaffs_Object *target = NULL;
X	yaffs_Object *target = 0;
N	int retVal = 0;
N
N
N	yaffsfs_Lock();
N
N	obj = yaffsfs_FindObject(NULL,oldpath,0);
X	obj = yaffsfs_FindObject(0,oldpath,0);
N	target = yaffsfs_FindObject(NULL,newpath,0);
X	target = yaffsfs_FindObject(0,newpath,0);
N
N	if(!obj)
N	{
N		yaffsfs_SetError(-ENOENT);
X		yaffsfs_SetError(-2);
N		retVal = -1;
N	}
N	else if(target)
N	{
N		yaffsfs_SetError(-EEXIST);
X		yaffsfs_SetError(-17);
N		retVal = -1;
N	}
N	else
N	{
N		yaffs_Object *newdir = NULL;
X		yaffs_Object *newdir = 0;
N		yaffs_Object *link = NULL;
X		yaffs_Object *link = 0;
N
N		YCHAR *newname;
X		char *newname;
N
N		newdir = yaffsfs_FindDirectory(NULL,newpath,&newname,0);
X		newdir = yaffsfs_FindDirectory(0,newpath,&newname,0);
N
N		if(!newdir)
N		{
N			yaffsfs_SetError(-ENOTDIR);
X			yaffsfs_SetError(-20);
N			retVal = -1;
N		}
N		else if(newdir->myDev != obj->myDev)
N		{
N			yaffsfs_SetError(-EXDEV);
X			yaffsfs_SetError(-18);
N			retVal = -1;
N		}
N		if(newdir && yaffs_strlen(newname) > 0)
X		if(newdir && strlen(newname) > 0)
N		{
N			link = yaffs_Link(newdir,newname,obj);
N			if(link)
N				retVal = 0;
N			else
N			{
N				yaffsfs_SetError(-ENOSPC);
X				yaffsfs_SetError(-28);
N				retVal = -1;
N			}
N
N		}
N	}
N	yaffsfs_Unlock();
N
N	return retVal;
N}
N
Nint yaffs_mknod(const YCHAR *pathname, mode_t mode, dev_t dev);
Xint yaffs_mknod(const char *pathname, mode_t mode, dev_t dev);
N
Nint yaffs_DumpDevStruct(const YCHAR *path)
Xint yaffs_DumpDevStruct(const char *path)
N{
N#if 0
S	YCHAR *rest;
S
S	yaffs_Object *obj = yaffsfs_FindRoot(path,&rest);
S
S	if(obj)
S	{
S		yaffs_Device *dev = obj->myDev;
S
S		printf("\n"
S			   "nPageWrites.......... %d\n"
S			   "nPageReads........... %d\n"
S			   "nBlockErasures....... %d\n"
S			   "nGCCopies............ %d\n"
S			   "garbageCollections... %d\n"
S			   "passiveGarbageColl'ns %d\n"
S			   "\n",
S				dev->nPageWrites,
S				dev->nPageReads,
S				dev->nBlockErasures,
S				dev->nGCCopies,
S				dev->garbageCollections,
S				dev->passiveGarbageCollections
S		);
S
S	}
S
N#endif
N	return 0;
N}
N
